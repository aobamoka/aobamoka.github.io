<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>leetcode-master学习笔记-贪心算法 | aobamoka</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、前驱贪心与动态规划的使用区别： 贪心要求局部最优解能够推出全局最优解，而动态规划解决的问题一般无法通过局部最优解推出全局最优解。 简单的例子为：有一摞各种面值的钞票，要求从其中抽出10张且面值总和最大。我们通过常识就知道，只要抽出的每一张都是当前钞票堆里最大的那一张，抽出的10张面值总和肯定是最大的。这就是局部最优解推出全局最优解，所以可以用贪心算法解决这道题。 而以背包问题为例，假设背包大小">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode-master学习笔记-贪心算法">
<meta property="og:url" content="http://example.com/2021/03/19/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="aobamoka">
<meta property="og:description" content="一、前驱贪心与动态规划的使用区别： 贪心要求局部最优解能够推出全局最优解，而动态规划解决的问题一般无法通过局部最优解推出全局最优解。 简单的例子为：有一摞各种面值的钞票，要求从其中抽出10张且面值总和最大。我们通过常识就知道，只要抽出的每一张都是当前钞票堆里最大的那一张，抽出的10张面值总和肯定是最大的。这就是局部最优解推出全局最优解，所以可以用贪心算法解决这道题。 而以背包问题为例，假设背包大小">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-19T00:21:15.000Z">
<meta property="article:modified_time" content="2021-03-19T09:29:52.710Z">
<meta property="article:author" content="aoba moka">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="aobamoka" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">aobamoka</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="title-leetcode-master学习笔记-贪心算法" class="h-entry article article-type-title" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/19/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-03-19T00:21:15.000Z" itemprop="datePublished">2021-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      leetcode-master学习笔记-贪心算法
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、前驱"><a href="#一、前驱" class="headerlink" title="一、前驱"></a>一、前驱</h2><p>贪心与动态规划的使用区别：</p>
<p>贪心要求局部最优解能够推出全局最优解，而动态规划解决的问题一般无法通过局部最优解推出全局最优解。</p>
<p>简单的例子为：有一摞各种面值的钞票，要求从其中抽出10张且面值总和最大。我们通过常识就知道，只要抽出的每一张都是当前钞票堆里最大的那一张，抽出的10张面值总和肯定是最大的。这就是局部最优解推出全局最优解，所以可以用贪心算法解决这道题。</p>
<p>而以背包问题为例，假设背包大小为10，物品的体积为{8,5,4}。显然可以看出第一次取物品的局部最优解是8，但是全局最优解则是5+4=9&gt;8。这种情况就应该用动态规划。</p>
<p>由于贪心问题上述的特点，其解法一般也为，先将全局问题分解为若干子问题，选用合适的贪心策略求解子问题最优解，再综合为全局问题最优解。</p>
<p>感觉做了两三道题还是拿不准什么时候该用贪心算法，<del>大概只能多刷凭感觉了吧</del>。</p>
<h2 id="二、调用c-函数-模板类时的自定义比较函数"><a href="#二、调用c-函数-模板类时的自定义比较函数" class="headerlink" title="二、调用c++函数/模板类时的自定义比较函数"></a>二、调用c++函数/模板类时的自定义比较函数</h2><p>感觉还是挺重要的，所以单独发了一篇博客讲这个，这里就当插个眼吧。</p>
<p><a target="_blank" rel="noopener" href="https://aobamoka.github.io/2021/03/19/sort%E4%B8%8Epriority-queue%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/">sort与priority_queue中的自定义排序</a></p>
<h2 id="三、加油站"><a href="#三、加油站" class="headerlink" title="三、加油站"></a>三、加油站</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station/">leetcode 134：加油站</a></p>
<p>代码随想录给了两种方法：</p>
<ul>
<li>先计算总加油-总耗油是否大于0，并记录从0往前走的过程中最小的累加值。之后从后往前遍历，寻找到能填平这个累加值的第一个节点。</li>
<li>同样先计算总加油-总耗油大于0，之后从0开始遍历并进行累加。如果出现之前的累加值小于0，就从当前遍历到点作为起点继续往后累加。</li>
</ul>
<p>我一开始想到的是第二种方法，但是并不清楚该如何解释它的正确性。其实，由于已经计算过总加油是大于总耗油的，所以如果之前存在小于0的净加油量，则之后一定会存在大于0的净加油量，且其绝对值大于之前的绝对值，所以从当前遍历到的点开始是合理的。</p>
<h2 id="四、分糖果"><a href="#四、分糖果" class="headerlink" title="四、分糖果"></a>四、分糖果</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/">leetcode 135：分糖果</a></p>
<p>不会做。</p>
<p>大致思想是遍历两遍，从左到右只考虑右边比左边评分高，从右到左则相反。</p>
<p>官方的题解有种常数空间复杂度的算法，有时间再看看吧，学贪心为主。</p>
<h2 id="五、无重叠区间"><a href="#五、无重叠区间" class="headerlink" title="五、无重叠区间"></a>五、无重叠区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">leetcode 435：无重叠区间</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">可以认为区间的终点总是大于它的起点。</span><br><span class="line">区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure>
<p>本体难点在于遍历的方向。如果按左边界优先来进行排序且从左至右进行遍历，设想[1,4]与[2,3]这种情况，在遍历到[2,3]的时候由于2并未超过目前的局部右边界4，所以[2,3]区间会被舍弃，但是局部右边界未进行替换，而显然[2,3]才是局部最优解。</p>
<p>如果坚持从左到右进行遍历，局部右边界可取当前局部右边界与当前区间右边界的最小值。</p>
<p>所以如果按左边界优先来进行排列之后，需要从右开始向左遍历，因为越靠右的区间左边界越大，留给前面区间的空间也越大。按右边界优先来进行排列的话同理，需要从左向右开始遍历。</p>
<h2 id="六、单调递增的数字"><a href="#六、单调递增的数字" class="headerlink" title="六、单调递增的数字"></a>六、单调递增的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/monotone-increasing-digits/">leetcode 738：单调递增的数字</a></p>
<p>本体的关键在于局部最优该如何取。如果从后往前便利，遇到n[i-1]&gt;n[i]时，局部最优解应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n[i-1]--;</span><br><span class="line">n[i]&#x3D;&#39;9&#39;;</span><br></pre></td></tr></table></figure>
<p>实际实现时，可以记录最小的索引，其后面的元素都被设置为’9’。</p>
<h2 id="七、买卖股票的最佳时机（含手续费）"><a href="#七、买卖股票的最佳时机（含手续费）" class="headerlink" title="七、买卖股票的最佳时机（含手续费）"></a>七、买卖股票的最佳时机（含手续费）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">leetcode 714：买卖股票的最佳时机含手续费</a></p>
<p>比之前的买卖股票多了个手续费。解法类似，需要记录局部最小值，不过这道题有三种情况：</p>
<ul>
<li>局部最小值小于当前值，则将局部最小值设为当前值。</li>
<li>局部最小值大于当前值但小于当前值与手续费之和。此时卖出一定会亏，所以不卖。</li>
<li>局部最小值大于当前值与手续费之和。此时可以卖，也可以不卖，等后面利润更多再卖，但是我们先将利润prices[i]-minp-fee加上。关键的一步在局部最小值的变化：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minp&#x3D;prices[i]-fee;</span><br></pre></td></tr></table></figure>
  这一步保证的是即使有多次加利润，但我们保证手续费只算了一次。</li>
</ul>
<h2 id="八、监控二叉树"><a href="#八、监控二叉树" class="headerlink" title="八、监控二叉树"></a>八、监控二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-cameras/">leetcode 968：监控二叉树</a></p>
<p>本题实际上是状态转换的问题：每个节点的状态被分为三类：无摄像机覆盖、有摄像机覆盖（本身没有摄像机）与本身有摄像机。</p>
<p>另外一个需要注意的点是，由于叶节点的父节点放置的摄像头不仅能覆盖子节点，还能覆盖到其父节点，而叶节点放置的摄像头只能覆盖到其父节点，所以我们默认叶节点为已覆盖状态，而叶节点的父节点为放置摄像机状态。</p>
<p>接下来处理递归问题。父节点根据左右子节点的状态来确认自己的状态：</p>
<ul>
<li>左右子节点至少有一个为未覆盖，则父节点必须安装一个摄像机。</li>
<li>左右子节点均为已覆盖，父节点可以等着它的父节点安装摄像机，所以返回未覆盖。</li>
<li>其他情况表示左右子节点至少有一个摄像机，所以父节点返回已覆盖。<br>如果根节点的左右节点为已覆盖，根节点的状态将为未覆盖，而并没有父节点为它提供摄像机覆盖，所以最后判断根节点的状态：如果为未覆盖则需要多一个摄像机。</li>
</ul>
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>做了这么多贪心题感觉是真的无规律可循，知道思路了就能很快想出解答，否则只会一直不知道。贪心算法的总结只有：多练、多总结做过的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/19/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" data-id="ckmiiykgi0008n8vz412q36t0" data-title="leetcode-master学习笔记-贪心算法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/19/sort%E4%B8%8Epriority-queue%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          sort与priority_queue中的自定义排序
        
      </div>
    </a>
  
  
    <a href="/2021/03/18/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9E%E6%BA%AF/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">leetcode-master学习笔记-回溯</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%AD%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E6%80%9D%E6%83%B3/">动态规划中的滚动数组思想</a>
          </li>
        
          <li>
            <a href="/2021/03/20/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">leetcode-master学习笔记-动态规划</a>
          </li>
        
          <li>
            <a href="/2021/03/19/sort%E4%B8%8Epriority-queue%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/">sort与priority_queue中的自定义排序</a>
          </li>
        
          <li>
            <a href="/2021/03/19/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">leetcode-master学习笔记-贪心算法</a>
          </li>
        
          <li>
            <a href="/2021/03/18/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9E%E6%BA%AF/">leetcode-master学习笔记-回溯</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 aoba moka<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>