<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>项目学习-基于Raft的kv数据库</title>
      <link href="/2023/08/11/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8ERaft%E7%9A%84kv%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2023/08/11/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8ERaft%E7%9A%84kv%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h1><p>在Raft层上实现一个容错kv存储服务，满足线性一致性，具有以下特征：</p><ul><li>读写不是瞬间完成，而是在一个时间段内</li><li>写之前读时，读到的一定是旧值；写之后读时，读到的一定是新值</li><li>读写并发时，可能读到旧值，也可能读到新值</li><li>一旦有一个客户端读到了新值，其他的客户端也一定会读到新值</li></ul><p>整个kv由多个Server组成，每个Server包含：</p><ul><li>Raft节点</li><li>Raft的状态机（即kv数据库）</li></ul><p>运行流程为：</p><ul><li>Client发送RPC操作</li><li>kv service转发给拥有Leader Raft节点的Server</li><li>Leader Server将请求包含的command传递给Raft层</li><li>Raft层达成共识，回应Server</li><li>Server收到apply后，将command应用到状态机</li><li>成功应用后，Server对Client的RPC进行回复，返回结果和错误码</li></ul><h1 id="2、大致实现"><a href="#2、大致实现" class="headerlink" title="2、大致实现"></a>2、大致实现</h1><h2 id="1、kv数据库"><a href="#1、kv数据库" class="headerlink" title="1、kv数据库"></a>1、kv数据库</h2><p>hashmap即可。</p><p>操作数据库在后续代码中都是互斥进行，所以无需加锁。</p><h2 id="2、Client"><a href="#2、Client" class="headerlink" title="2、Client"></a>2、Client</h2><p>Raft规定，如果Client不知道Leader节点，则会随机请求一个节点。如果该节点不是Leader节点，则不会读取状态机，而是告诉Client该节点目前的Leader节点。</p><p>优化：Client找到一次Leader节点后记录Leader节点号，避免后续重复找Leader。</p><h2 id="3、Server"><a href="#3、Server" class="headerlink" title="3、Server"></a>3、Server</h2><p>Server接收Client请求后：</p><ul><li>Raft节点为Leader：调用raft方法将command传递到Raft层，达成共识。Raft层达成共识后通过apply chan通知Server。</li><li>Raft节点不为Leader：向Client返回错误，Client收到后继续向另一台Server发送请求。</li></ul><p>问题：</p><ul><li>多个Client并行请求时，无法保证apply chan的返回顺序。<ul><li>在server中维护map，index映射等待此index对应command的channel</li></ul></li><li>Raft层因为网络等问题长时间无法达成共识时，需要让Server超时返回。</li><li>容错：<ul><li>RPC丢失：Server在Raft层达成共识并应用到状态机后，回复Client出现了问题，可能导致一次Append请求多次重复提交。<ul><li>通过Seq号实现去重</li><li>可以在Append请求时附加当前数据库大小</li></ul></li></ul></li><li>Get请求为什么也要传入Raft共识：防止在网络割裂后，已经不再是Leader的原Leader返回过时的数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-Unity制作2D卡牌游戏</title>
      <link href="/2023/07/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Unity%E5%88%B6%E4%BD%9C2D%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/"/>
      <url>/2023/07/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Unity%E5%88%B6%E4%BD%9C2D%E5%8D%A1%E7%89%8C%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="1、管理物体"><a href="#1、管理物体" class="headerlink" title="1、管理物体"></a>1、管理物体</h2><p>一些物体具有同步动作时，通过创建一个空物体，将这些物体挂载在空物体下来管理他们。</p><h2 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h2><p>Unity C#单例模式可以通过如下方式实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonoSingleton</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">MonoBehaviour</span> <span class="comment">// 有类要成为单例模式时，直接继承该类即可实现</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance; <span class="comment">// 内部维护的单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance <span class="comment">// 外部获取的单例</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = FindObjectOfType&lt;T&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、事件订阅模式"><a href="#3、事件订阅模式" class="headerlink" title="3、事件订阅模式"></a>3、事件订阅模式</h2><p>某些变量更新触发事件时，如：阶段变更触发怪兽效果等。</p><p>定义事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GamePhase gamePhase = GamePhase.gameStart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> UnityEvent phaseChangeEvent = <span class="keyword">new</span> UnityEvent();</span><br></pre></td></tr></table></figure><p>将变量更新与事件发布抽象成函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changePhase</span>(<span class="params">GamePhase gamePhase</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.gamePhase = gamePhase;</span><br><span class="line">    phaseChangeEvent.Invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让函数定义事件，在事件到来时执行传入的函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BattleManager.Instance.phaseChangeEvent.AddListener(updateText);</span><br></pre></td></tr></table></figure><p>定义事件时还可以附带泛型，表示特定状态的事件，在Invoke时传入对应泛型类型的参数。</p><h2 id="4、卡牌召唤"><a href="#4、卡牌召唤" class="headerlink" title="4、卡牌召唤"></a>4、卡牌召唤</h2><p>卡牌被点击-&gt;发起召唤请求-&gt;开启场上格子等待状态</p><p>格子被点击-&gt;召唤确认-&gt;执行召唤</p><p>不直接点击召唤的原因：单机模式下，AI无法完成点击请求，导致不能复用现有逻辑，需要重新编写函数。这种模式下，AI可直接在格子上召唤。</p><h2 id="5、效果设计"><a href="#5、效果设计" class="headerlink" title="5、效果设计"></a>5、效果设计</h2><ul><li>EffectKeyWord：法术、战吼、亡语等关键字</li><li>EffectTarget：无目标、英雄、随从等</li><li>EffectType：伤害、治疗、抽卡、强化等</li><li>num：数值</li><li>time：作用次数（用于25仔的随机伤害等效果）</li></ul><p>法术设计为关键词的目的：便于复用keyword后面的效果逻辑。</p><h2 id="6、英雄设计"><a href="#6、英雄设计" class="headerlink" title="6、英雄设计"></a>6、英雄设计</h2><p>因为英雄也跟随从一样会被各种攻击、法术指到，所以直接用battlecard实例化，特殊定制一下边框啥的。</p><p>EffectType里区分一下英雄随从即可。</p><h2 id="7、牌库、卡组界面设计"><a href="#7、牌库、卡组界面设计" class="headerlink" title="7、牌库、卡组界面设计"></a>7、牌库、卡组界面设计</h2><p>创建ScrollView物体，实际存放卡的content作为子物体。</p><p>content挂载grid layout group、content size filter</p><ul><li>grid layout group：自动在单元格中排版装载卡牌。</li><li>content size filter：让带layout group组件的content大小随其的排版大小变化<ul><li>※ content只有比scrollview大，才能实现滚动效果，单纯的往里面装载卡牌是不会改变其大小的。</li></ul></li></ul><h2 id="8、全局物体"><a href="#8、全局物体" class="headerlink" title="8、全局物体"></a>8、全局物体</h2><p>玩家数据playerData、卡牌数据cardStore需要在场景变换时保持只有一个单例。</p><p>具体实现：</p><ul><li><p>创建空物体DataManger，添加组件PlayerData、CardStore脚本，并将数据csv文件挂载到组件上。</p></li><li><p>为DataManger设置标签“DataManager”。</p></li><li><p>创建脚本DataManagerGlobal，作为组件添加到DataManager，并重写Awake()</p></li><li><pre><code class="c#">    private void Awake()    &#123;        if (GameObject.FindGameObjectsWithTag(&quot;DataManager&quot;).Length &gt; 1)        &#123;            Destroy(gameObject);        &#125;        else        &#123;            DontDestroyOnLoad(gameObject);        &#125;    &#125;</code></pre></li><li><p>DontDestroyOnLoad可以在场景切换时保留DataManager，而在场景重新加载触发Awake()时，查找全局标签，如果查找到的数组长度大于1，说明又创建了新的，Destroy掉。</p></li></ul><h2 id="9、bug整理"><a href="#9、bug整理" class="headerlink" title="9、bug整理"></a>9、bug整理</h2><ul><li>读取文件速度比类初始化速度慢很多，因此如果其他类通过文件读出来的数据初始化，会得到空值，因为此时文件还没有读完。<ul><li>点击脚本右上角的“execution order”强制设定脚本执行顺序，让文件数据读取类先于其他类加载。</li></ul></li><li>保存玩家牌数据失败问题：详情见8。使用DontDestroyOnLoad的DataManager保存卡牌和玩家数据，但是DontDestroyOnLoad并不保证只存在一个，而是每次进Start界面都会再创建一个，有时候会造成PlayerData数据丢失的问题。关闭游戏时，后面的数据晚销毁，导致未保存的数据、甚至是空数据覆盖了前面已经修改的数据。<ul><li>具体解决方案见8。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-计算机图形学</title>
      <link href="/2023/06/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
      <url>/2023/06/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-渲染"><a href="#1-渲染" class="headerlink" title="1. 渲染"></a>1. 渲染</h1><p>实时渲染：要求在1/60秒内完成整个画面的绘制，一般用于游戏行业。一般使用光栅化+GPU加速。</p><p>离线渲染：不注重画面渲染的实时性和速度，但非常重视画面的质量，一般用于电影行业。一般使用更慢但更准确的路径追踪+蒙特卡洛积分。</p><h2 id="1-路径追踪"><a href="#1-路径追踪" class="headerlink" title="1. 路径追踪"></a>1. 路径追踪</h2><p>在每个像素点上发射一条光线，检测他和场景物体的碰撞，如果发生碰撞，计算反射后的出射方向，并继续追踪该方向的光线，直到光线被物体完全吸收或超出迭代次数限制。</p><p>图形学中的模型大多是三角形网络，路径追踪本质上是射线与三角形求交。</p><p>限制：</p><ul><li>对于复杂场景或高明度光源，计算量非常庞大，渲染时间非常长。</li><li>路径追踪使用蒙特卡洛算法，具有随机性，存在噪点问题，需要堆砌大量采样次数才能收敛，指数级增大了计算成本。</li></ul><h2 id="2-光栅化"><a href="#2-光栅化" class="headerlink" title="2. 光栅化"></a>2. 光栅化</h2><p>绘制每个三角形时，检测每个像素的中心点是否包含在三角形内部，如果是则填充颜色。</p><p>相较于路径追踪：高效且不需要多次采样。</p><p>限制：只能计算一次反射，在全局光照方面令人堪忧。</p><p>光栅化后是黑白二值图像，需要计算物体的光照情况，给不同位置上不同的颜色，称为着色。</p><p>着色器根据三角形每一个像素点的位置，结合物体材质反射率、颜色、该点三维坐标与光源、摄像机的角度位置关系等信息，给像素点填充符合光学规律的颜色，让图像看起来更立体。</p><h2 id="3-GPU与CPU"><a href="#3-GPU与CPU" class="headerlink" title="3. GPU与CPU"></a>3. GPU与CPU</h2><p>CPU用于执行数据管理、逻辑控制、运算等任务，处理能力以速度为主，具备高度灵活性和可编程性。</p><p>GPU专门设计用于处理图像和视频，具备高度并行计算能力和专门处理图像的硬件单元。因为路径追踪、光栅化每个光源/像素点都可独立计算，所以GPU相应要求具有高并行能力。</p><h1 id="2-OpenGL"><a href="#2-OpenGL" class="headerlink" title="2. OpenGL"></a>2. OpenGL</h1><p>一套跨平台、跨硬件的通用接口，使用这套接口的GPU能被所有的图形程序使用，使用这套接口的图形程序可以在所有支持该接口的GPU上运行。</p><p>OpenGL API的制定由专门组织发布，实现则由各大硬件厂商实现，通过更新驱动版本，在新驱动中支持新版本API。</p><h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件"></a>1. 头文件</h2><p>GL/gl.h：包含2.0以前版本的老函数。</p><p>现代OpenGL没有头文件，必须使用LoadLibraryA手动去DLL里加载，因此通过glad和glew等第三方库，在启动时加载所有函数到全局指针中。</p><p>glad/glad.h：glad API加载器，且必须在其他gl相关库前面，如GLFW/glfw3.h。</p><p>glad实际上是一个python包，根据指定版本生成加载了OpenGL全部函数的.h和.c文件</p><p>GLFW：配合OpenGL使用的轻量级工具程序库，创建并管理窗口和OpenGL上下文，同时提供处理手柄、键盘、鼠标输入的功能。</p><p>glsl：着色器语言。</p><p>glm：仿glsl语法的数学矢量库。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-docker与k8s</title>
      <link href="/2023/05/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-docker%E4%B8%8Ek8s/"/>
      <url>/2023/05/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-docker%E4%B8%8Ek8s/</url>
      
        <content type="html"><![CDATA[<h1 id="1-docker"><a href="#1-docker" class="headerlink" title="1. docker"></a>1. docker</h1><p>应用打包、分发、部署的工具。类似于轻量级虚拟机</p><ul><li>打包：把软件运行所需的依赖、第三方库、软件打包，变成一个安装包。</li><li>分发：把打包好的安装包上传到镜像仓库，其他人可以方便获取安装。</li><li>部署：拿着安装包就可以一个命令运行应用，自动模拟出一模一样的运行环境。</li></ul><h2 id="1-基本特征"><a href="#1-基本特征" class="headerlink" title="1. 基本特征"></a>1. 基本特征</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>解决不同机器运行环境差异的问题。确保不同机器上跑都是一致的运行环境。</p><p>常规应用开发部署：windows上开发测试-》linux服务器配置运行部署环境。</p><p>docker开发部署：windows上开发测试-》打包为docker镜像-》linux服务器上一个命令部署好。</p><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><ul><li>应用分发部署</li><li>快速安装测试/学习软件（用完就丢），如redis、mongodb、elasticsearch</li><li>多个版本软件共存，如python2/3</li></ul><h3 id="3-重要概念"><a href="#3-重要概念" class="headerlink" title="3. 重要概念"></a>3. 重要概念</h3><p>镜像：类似软件安装包，可以便捷传播安装。</p><p>容器：软件安装后的状态，每个软件运行环境独立隔离。</p><h2 id="2-目录挂载"><a href="#2-目录挂载" class="headerlink" title="2. 目录挂载"></a>2. 目录挂载</h2><p>docker制作自己的镜像，存在两个问题：</p><ul><li>修改项目代码不会立刻生效，必须重新制作镜像并且运行。</li><li>容器产生的log、备份等文件，容器删除后就丢失了。</li></ul><p>通过目录挂载来解决。</p><p>目录挂载方式：</p><ul><li><code>bind mount</code>直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器。</li><li><code>volume</code>由容器创建在宿主机中并管理，删除容器不会丢失。官方推荐，更高效。可挂到多个容器。</li><li><code>tmpfs mount</code>适合存储临时文件，存在宿主机内存中。不可多容器共享。</li></ul><p><img src="https://sjwx.easydoc.xyz/46901064/files/kv96dc4q.png" class="lazyload placeholder" data-srcset="https://sjwx.easydoc.xyz/46901064/files/kv96dc4q.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>挂载后，windows修改的代码在容器中也会同步，如果要生效需要重启容器。</p><h2 id="3-多容器通信"><a href="#3-多容器通信" class="headerlink" title="3. 多容器通信"></a>3. 多容器通信</h2><p>多容器互通，每个容器运行一个独立的软件，方便管理依赖软件的问题。</p><p>如，某项目依赖redis，可以先创建一个redis容器，然后在同一个网络中创建一个项目容器，从项目容器访问redis容器。</p><ul><li><code>docker network create [network name]</code>创建虚拟网络</li><li><code>--network</code>选项指定容器运行的网络</li><li><code>--network-alais</code>选项指定运行网络的别名</li></ul><h2 id="4-docker-compose"><a href="#4-docker-compose" class="headerlink" title="4. docker-compose"></a>4. docker-compose</h2><p>项目如果依赖多个第三方软件，一个个管理容器、配置运行、指定网络很麻烦。</p><p>使用docker-compose可以集合项目多个服务器。</p><h2 id="5-镜像发布和部署"><a href="#5-镜像发布和部署" class="headerlink" title="5. 镜像发布和部署"></a>5. 镜像发布和部署</h2><ul><li>创建镜像库</li><li>命令行登录</li><li>新建tag，关联本地镜像与远程仓库</li><li>将本地镜像push到远程仓库</li><li>利用远程仓库镜像直接部署容器</li></ul><p>也可以用国内镜像托管服务。</p><h2 id="6-迁移和备份数据"><a href="#6-迁移和备份数据" class="headerlink" title="6. 迁移和备份数据"></a>6. 迁移和备份数据</h2><p>如果用 <code>bind mount</code>直接挂载宿主机的目录到容器，直接复制目录即可迁移。</p><p>如果用 <code>volume</code>挂载，由于数据是由容器创建和管理，需要用特殊的方式把数据弄出来。</p><p>备份：</p><ul><li>运行一个ubuntu容器，挂载需要备份的volume到容器，并且挂载宿主机目录到容器里的备份目录。</li><li>运行tar命令将数据压缩为一个文件。</li><li>把备份文件复制到需要导入的机器。</li></ul><p>导入：</p><ul><li>运行ubuntu容器，挂载容器的volume，并且挂载宿主机备份文件所在目录到容器。</li><li>运行tar命令解压备份文件到指定目录。</li></ul><h1 id="2-kubernetes"><a href="#2-kubernetes" class="headerlink" title="2. kubernetes"></a>2. kubernetes</h1><h2 id="1-基本特征-1"><a href="#1-基本特征-1" class="headerlink" title="1. 基本特征"></a>1. 基本特征</h2><h3 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h3><ul><li>高可用，自动灾难恢复</li><li>灰度更新，不影响业务正常运转<ul><li>灰度更新：项目版本更新时，先将部分流量导引到新版本上测试，如果可以再全面推广，否则撤回上一个版本。</li><li>使用容器技术时，不需要滚动式更新，而是借助弹性资源平台，直接把原服务全部更新掉。</li></ul></li><li>一键回滚</li><li>方便的伸缩扩展、提供负载均衡</li><li>生态完善</li></ul><h3 id="2-不同的部署方案"><a href="#2-不同的部署方案" class="headerlink" title="2. 不同的部署方案"></a>2. 不同的部署方案</h3><p><img src="https://sjwx.easydoc.xyz/46901064/files/kwmxgxwp.svg" class="lazyload placeholder" data-srcset="https://sjwx.easydoc.xyz/46901064/files/kwmxgxwp.svg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>传统：应用直接在物理机上部署，机器资源分配不好控制，且无法做到应用隔离。</li><li>虚拟机：单个物理机上运行多个虚拟机，每个虚拟机都是完整系统，性能损耗大。</li><li>容器：所有容器共享主机系统，轻量级虚拟机，性能损耗小，资源隔离，CPU和资源可按需分配。</li></ul><h3 id="3-需要场合"><a href="#3-需要场合" class="headerlink" title="3. 需要场合"></a>3. 需要场合</h3><p>应用访问量大、机器数多，每次集群更新、软件更新、版本回滚十分麻烦。</p><p>k8s可以提供集中式的管理集群机器和应用，确保高可用、高性能、高扩展。</p><h2 id="2-集群架构"><a href="#2-集群架构" class="headerlink" title="2. 集群架构"></a>2. 集群架构</h2><p><img src="https://sjwx.easydoc.xyz/46901064/files/kwob90mh.png" class="lazyload placeholder" data-srcset="https://sjwx.easydoc.xyz/46901064/files/kwob90mh.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>master：主节点，控制平台。</li><li>worker：工作节点，可以是虚拟机或物理计算机，由主节点管理。</li></ul><p><img src="https://sjwx.easydoc.xyz/46901064/files/kwoccq7d" class="lazyload placeholder" data-srcset="https://sjwx.easydoc.xyz/46901064/files/kwoccq7d" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>pod/豆荚：k8s调度管理的最小单位，一个pod可包含一个或多个容器，每个pod有自己的虚拟ip。一个工作节点可以有多个pod，主节点考量负载自动调度pod到哪个节点运行。</p><p><img src="https://sjwx.easydoc.xyz/46901064/files/kwonmx7e.png" class="lazyload placeholder" data-srcset="https://sjwx.easydoc.xyz/46901064/files/kwonmx7e.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>组件：</p><ul><li><code>kube-apiserver</code> API 服务器，公开了 Kubernetes API</li><li><code>etcd</code> 键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库</li><li><code>kube-scheduler</code> 调度 Pod 到哪个节点运行</li><li><code>kube-controller</code> 集群控制器</li><li><code>cloud-controller</code> 与云服务商交互</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-Muduo库核心代码学习</title>
      <link href="/2023/05/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Muduo%E5%BA%93%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/05/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Muduo%E5%BA%93%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Multi-Reactor"><a href="#1-Multi-Reactor" class="headerlink" title="1. Multi-Reactor"></a>1. Multi-Reactor</h1><p>muduo库基于多reactor-多线程/Multi-Reactor实现。</p><p><img src="https://img-blog.csdnimg.cn/aa027fa915cc446d8301bdbd4846ba4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Zyo5Zyw6ZOB56uZ6YeM5ZCD6Ze45py6,size_14,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/aa027fa915cc446d8301bdbd4846ba4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Zyo5Zyw6ZOB56uZ6YeM5ZCD6Ze45py6,size_14,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>八股部分：</p><p>运行方式：</p><ul><li>主reactor只负责连接建立与分发fd，具体的业务逻辑由子reactor实现。</li><li>主reactor只监听client发来的连接建立事件，分配fd给该连接，并将干链接分发给某个子reactor（类似于nginx的负载均衡）。</li><li>子reactor只监听分配给它的fd的读写事件，然后在自己的循环内/调用线程池中的线程进行报文解析，然后直接发送给client。</li></ul><p>优点：</p><ul><li>主reactor只负责连接建立，子reactor只负责读写分配的连接，模块解耦。</li><li>主reactor与子reactor之间的通信只有分派fd，不会有共享内存问题。</li></ul><p>三大核心模块类为Channel、Poller/EpollPooler/EventLoop。</p><h1 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h1><p>channel类相当于对单个文件描述符fd，以及其感兴趣的事件的封装。</p><p>数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EventLoop *loop_;  <span class="comment">// 该channel所属于loop对象指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fd_;   <span class="comment">// 该channel封装的fd</span></span><br><span class="line"><span class="keyword">int</span> events_;      <span class="comment">//fd感兴趣事件</span></span><br><span class="line"><span class="keyword">int</span> real_events_; <span class="comment">//poller 具体发生的事件</span></span><br><span class="line"><span class="keyword">int</span> index_;  <span class="comment">//用于EpollPoller的update_channel()中，判断是更新事件还是删除事件</span></span><br><span class="line"></span><br><span class="line">weak_ptr&lt;<span class="keyword">void</span>&gt; tie_; <span class="comment">//观察当前channel的存在状态</span></span><br><span class="line"><span class="keyword">bool</span> tied_;          <span class="comment">//判断tie_是否绑定过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发生事件所要调用的具体事件的回调操作</span></span><br><span class="line">ReadEventCallback read_callback_;</span><br><span class="line">EventCallback write_callback_;</span><br><span class="line">EventCallback close_callback_;</span><br><span class="line">EventCallback error_callback_;</span><br></pre></td></tr></table></figure><p>channel类提供的方法包括：设置fd的感兴趣事件与发生的事件、通过loop注册或删除fd的感兴趣事件、设置fd每种感兴趣事件的处理函数。</p><p>方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">//fd得到poller通知以后，根据具体发生的事件，调用相应的回调</span></span><br><span class="line">     <span class="comment">//其实调用的handle_event_withGuard</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle_event</span><span class="params">(TimeStamp receive_time)</span></span>;</span><br><span class="line">    <span class="comment">//防止channel被remove掉，channel还在执行回调</span></span><br><span class="line">    <span class="comment">//一个tcpconnection新连接创建的时候，调用tie</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tie</span><span class="params">(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; &amp;)</span></span>;</span><br><span class="line">    <span class="comment">//得到socket套接字</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_fd</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//得到感兴趣事件</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_events</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//设置真正发生的事件,poller监听到事件然后设置real_event</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">set_revent</span><span class="params">(<span class="keyword">int</span> event)</span></span>;</span><br><span class="line">    <span class="comment">//判断该fd是否设置过感兴趣事件</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_noneEvent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回所属eventloop</span></span><br><span class="line">    <span class="function">EventLoop *<span class="title">owner_loop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//在channel所属的eventloop中删除自己</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置fd感兴趣事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enable_reading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dis_enable_reading</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enable_writing</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dis_enable_writing</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dis_enable_all</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回fd当前感兴趣事件状态</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_none_event</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_writting</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_reading</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置发生不同事件的回调操作</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//与poller更新fd所感兴趣事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//根据发生的具体事件调用相应的回调操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle_event_withGuard</span><span class="params">(TimeStamp receive_time)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="3-Poller-EpollPoller"><a href="#3-Poller-EpollPoller" class="headerlink" title="3. Poller/EpollPoller"></a>3. Poller/EpollPoller</h1><p>负责监听fd事件是否触发，返回事件发生的fd以及其具体事件。</p><p>一个reactor对应一个Poller。</p><p>muduo提供了PollPoller与EpollPoller。</p><p>数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key: fd  value:fd所属channel</span></span><br><span class="line">ChannelMap channels_;<span class="comment">//unordered_map&lt;int, Channel *&gt;;</span></span><br><span class="line">EventLoop *owner_loop_; <span class="comment">//polllers所属事件循环</span></span><br><span class="line"><span class="comment">//EpollPoller独有</span></span><br><span class="line"><span class="keyword">int</span> epollfd_;  <span class="comment">//epoll_create创建的epoll句柄</span></span><br><span class="line">EventList events_;  <span class="comment">//vector&lt;epoll_event&gt;，监听的事件集合</span></span><br></pre></td></tr></table></figure><p>方法：调用一次 <code>poll()</code>，返回事件监听的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//调用epoll_wait，先将活跃的fd存到events_成员中，之后调用fill_active_channels()将发生事件的channel填写到形参active_channel中</span></span><br><span class="line">    <span class="function">TimeStamp <span class="title">poll</span><span class="params">(<span class="keyword">int</span> timeout, ChannelList *active_channels)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">//往channel_map中添加channel</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_channel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="comment">//channel_map中删除channel</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_channel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//填写活跃的链接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill_active_channels</span><span class="params">(<span class="keyword">int</span> events_num, ChannelList *active_channels)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//更新channel，调用epoll_ctl</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> operation, Channel *channel)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="4-EventLoop"><a href="#4-EventLoop" class="headerlink" title="4. EventLoop"></a>4. EventLoop</h1><p>实现持续监听、持续获取监听结果与对对应的结果进行处理。</p><p>封装了Channel、Poller并向上提供接口。</p><p>大概过程：循环调用 <code>Poller::poll()</code>获取活跃事件的Channel集合，然后对每个Channel调用 <code>Chanlle::HandlerEvent()</code>进行事件处理。</p><p>框架：每个EventLoop绑定一个线程</p><p><img src="https://img-blog.csdnimg.cn/a9a03cef2e3948fc854a5a83441b9e5e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Zyo5Zyw6ZOB56uZ6YeM5ZCD6Ze45py6,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/a9a03cef2e3948fc854a5a83441b9e5e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Zyo5Zyw6ZOB56uZ6YeM5ZCD6Ze45py6,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread EventLoop *t_loop_in_thisTherad = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><code>__thread</code>关键字修饰的全局变量在每个线程内都有一个独立的实体。通过判断该变量是否为空，确认每个线程是否有且只有一个绑定的loop。</p><p>eventfd：专门用于事件通知的文件描述符。类似于unix本地socket，但不会经过tcp协议栈处理，性能更高。</p><p>eventfd是一个计数相关的fd，计数不为0时有可读事件发生，read后计数清零，而write递增计数器。</p><p>所以，eventfd一直可写，计数不为0时可读。</p><p>可以用于生产者消费者队列中，唤醒对方。</p><p>muduo中，如果一个eventloop一直处于epoll_wait的阻塞状态，在main reactor给它分配新的连接时，使用eventfd唤醒它。</p><p>在main reactor中通知某个sub reactor执行某个特定函数cb：</p><ul><li>如果正在运行的线程就是cb，直接执行；否则，传给 <code>queueInLoop()</code>。</li><li><code>queueInLoop()</code>中，将cb保存在 <code>pending_Functors_</code>中。</li><li><code>loop()</code>会在每次循环结束后调用 <code>pending_Functors_</code>中的函数。</li><li>如果loop在 <code>epoll_wait()</code>阻塞中，但是希望它赶紧执行注册的某个cb：<ul><li><code>wakeup()</code>随便写入一个8字节数据。</li><li>因为wakeup_fd已经注册到该loop中，<code>epoll_wait()</code>监听到写事件返回，不再阻塞。</li><li>一轮循环结束，调用 <code>pending_Functors_</code>中的函数。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">atomic_bool</span> looping_;</span><br><span class="line"><span class="keyword">atomic_bool</span> quit_; <span class="comment">//标志退出loop循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">pid_t</span> threadId_;       <span class="comment">//记录当前loop所在线程id</span></span><br><span class="line">TimeStamp poll_return_time_; <span class="comment">//poller返回的发生事件的时间点</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wakeup_fd;                       <span class="comment">//当main loop获取一个新用户的channel，通过轮询算法，选择一个sub loop，通过该成员唤醒sub loop，处理channel</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;Channel&gt; wakeup_channel_; <span class="comment">//包装wakefd</span></span><br><span class="line"></span><br><span class="line">ChannelList active_channels; <span class="comment">//eventloop 所管理的所有channel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_bool</span> calling_pending_functors_; <span class="comment">//标识当前loop是否有需要执行的回调操作</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Functor&gt; pending_Functors_;     <span class="comment">//loop所执行的所有回调操作</span></span><br><span class="line"></span><br><span class="line">mutex functor_mutex_; <span class="comment">//保护pending_functors</span></span><br></pre></td></tr></table></figure><p>方法：</p><p><code>loop()</code>中，只要quit_不为false，就一直执行循环：</p><ul><li>调用 <code>poller_()-&gt;poll()</code>取出活跃的Channel，放在 <code>active_channels</code>里。</li><li>遍历 <code>active_channels</code>，对其中每个channel，调用 <code>channel-&gt;HandlerEvent()</code>处理事件。</li><li>调用 <code>do_pending_functors()</code>执行回调函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//开启事件循环</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//退出事件循环</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TimeStamp <span class="title">get_poll_returnTime</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> poll_return_time_; &#125;</span><br><span class="line">    <span class="comment">//在当前loop中执行cb</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run_in_loop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line">    <span class="comment">//把cb放入队列中,唤醒loop所在线程执行cb（pending_functor）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queue_in_loop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line">    <span class="comment">//唤醒loop所在线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//poller的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_channel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_channel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">has_channel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line">    <span class="comment">//判断eventloop对象是否在自己的线程中</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_in_loopThread</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle_read</span><span class="params">()</span></span>;         <span class="comment">//wake up</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_pending_functors</span><span class="params">()</span></span>; <span class="comment">//执行回调</span></span><br></pre></td></tr></table></figure><h1 id="5-次要类"><a href="#5-次要类" class="headerlink" title="5. 次要类"></a>5. 次要类</h1><h2 id="1-Acceptor"><a href="#1-Acceptor" class="headerlink" title="1. Acceptor"></a>1. Acceptor</h2><p>接收新用户连接，分发给sub reactor。</p><p>封装了监听连接的套接字fd，以及相关的处理方法</p><p>数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventLoop *loop_; <span class="comment">//acceptor用的用户定义的那个baseloop，也就是mainloop</span></span><br><span class="line"></span><br><span class="line">Socket accept_socket_;  <span class="comment">//socket套接字的封装结构</span></span><br><span class="line">Channel accept_channel_;  <span class="comment">//封装accept_socket_</span></span><br><span class="line"></span><br><span class="line">NewConnectionCallback new_connetion_callback_;  <span class="comment">//TcpServer类中，将newConnection()注册给该成员，表示公平选择一个sub reactor，并将建立好的连接分发给它</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> listenning_;</span><br></pre></td></tr></table></figure><p>成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_new_connection_callback</span><span class="params">(<span class="keyword">const</span> NewConnectionCallback &amp;cb)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_listening</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> listenning_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>;  <span class="comment">//底层调用listen()，让main reactor监听accept_socket_</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle_read</span><span class="params">()</span></span>;  <span class="comment">//注册到accept_channel_上，在main reactor监听到accept_channel_发生可读事件时，调用该方法。</span></span><br><span class="line">    <span class="comment">// 完成的功能：接收新连接，以负载均衡方式选择一个sub reactor，将新连接分发到sub reactor</span></span><br></pre></td></tr></table></figure><h2 id="2-Socket"><a href="#2-Socket" class="headerlink" title="2. Socket"></a>2. Socket</h2><p>封装单个socket fd以及上面的一系列操作（bind、listen、accept等）</p><h2 id="3-Buffer"><a href="#3-Buffer" class="headerlink" title="3. Buffer"></a>3. Buffer</h2><p>封装用户缓冲区，以及其上的读写控制方法。</p><p><img src="https://img-blog.csdnimg.cn/e9a69392247249a5a1da22a49026b249.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Zyo5Zyw6ZOB56uZ6YeM5ZCD6Ze45py6,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/e9a69392247249a5a1da22a49026b249.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5Zyo5Zyw6ZOB56uZ6YeM5ZCD6Ze45py6,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="4-TcpConnection"><a href="#4-TcpConnection" class="headerlink" title="4. TcpConnection"></a>4. TcpConnection</h2><p>封装了一个已建立的tcp连接，以及控制该连接的方法（建立、关闭），与该连接发生的事件（读写/连接/错误）。</p><p>Acceptor用于main reactor中，而TcpConnection用于sub reactor中。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-CMU-15-445-课程笔记</title>
      <link href="/2023/05/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-CMU-15-445-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-CMU-15-445-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SQL语言"><a href="#1-SQL语言" class="headerlink" title="1. SQL语言"></a>1. SQL语言</h1><p>SQL分为三类命令：</p><ul><li>数据操作语言DML：SELECT、INSERT、UPDATE、DELETE。</li><li>数据定义语言DDL：定义表、索引、视图等对象。</li><li>数据控制语言：安全控制等。</li></ul><h1 id="2-磁盘管理"><a href="#2-磁盘管理" class="headerlink" title="2. 磁盘管理"></a>2. 磁盘管理</h1><p>易失性设备：</p><ul><li>断电即失去存储的数据。</li><li>支持按字节寻址随机快速访问。</li><li>一般称为内存。</li></ul><p>非易失性设备：</p><ul><li>不需要一直通电。</li><li>按块/页寻址。为了读取特定偏移量的值，需要将整块/整页加载到内存中。</li><li>一般更易于顺序访问。</li><li>一般称为磁盘。</li></ul><h2 id="1-系统设计目标"><a href="#1-系统设计目标" class="headerlink" title="1. 系统设计目标"></a>1. 系统设计目标</h2><ul><li>允许DBMS管理超出可用内存量的数据库。</li><li>读写磁盘成本很高，因此必须谨慎管理，避免出现性能大幅下降与阻塞。</li><li>磁盘随机读写一般比顺序读写慢很多，所以应该尽量顺序读写。</li></ul><h2 id="2-基于磁盘的DBMS"><a href="#2-基于磁盘的DBMS" class="headerlink" title="2. 基于磁盘的DBMS"></a>2. 基于磁盘的DBMS</h2><ul><li>数据库全部存储在磁盘上，数据库的文件组织形式为页，第一页为目录页。</li><li>对数据进行操作时需要将数据放入内存，通过缓冲池来管理磁盘与内存之间的数据交换。</li><li>执行引擎负责执行查询。</li><li>执行引擎向缓冲池请求特定页面，缓冲池负责将页面置入内存，并为执行引擎提供指向内存中该页面的指针。</li></ul><h2 id="3-堆文件"><a href="#3-堆文件" class="headerlink" title="3. 堆文件"></a>3. 堆文件</h2><p>一组无序的页集合。</p><p>通过特殊的页——目录页记录堆文件中的页的使用状况，以及其他的一些元数据，如空闲页表、每页可用的slot数目等。利用目录页找到特定页在磁盘上的位置。</p><h2 id="4-页"><a href="#4-页" class="headerlink" title="4. 页"></a>4. 页</h2><p>一块固定大小的空间，是读写数据的基本单位。</p><p>三类页：</p><ul><li>硬件页（一般4KB）</li><li>操作系统页（4KB）</li><li>数据页（1-16KB）</li></ul><p>每页包含一个页头，存储页的元数据，包括：</p><ul><li>页尺寸</li><li>校验和</li><li>DBMS版本</li><li>事务可见性</li><li>压缩信息</li></ul><h2 id="5-slotted-pages-分槽页结构"><a href="#5-slotted-pages-分槽页结构" class="headerlink" title="5. slotted pages-分槽页结构"></a>5. slotted pages-分槽页结构</h2><p>页头中存储一个slot数组，数组中每一项存储每个tuple对应的offset值（tuple在页中相对于页的首地址的偏移量）和tuple的长度。</p><p>tuple从页尾部开始存放，slot数组则从前往后递增。二者相碰代表页面已满。</p><h2 id="6-tuple-元组"><a href="#6-tuple-元组" class="headerlink" title="6. tuple-元组"></a>6. tuple-元组</h2><p>元组本质上是字节序列，由DBMS将其解释为属性类型以及值。</p><h3 id="1-元组头"><a href="#1-元组头" class="headerlink" title="1. 元组头"></a>1. 元组头</h3><p>包含元组的元数据，如可见性信息（用于并发控制）、NULL值的位图等。</p><h3 id="2-数据"><a href="#2-数据" class="headerlink" title="2. 数据"></a>2. 数据</h3><p>一般按照创建表时的顺序存储。</p><h3 id="3-独特标识符"><a href="#3-独特标识符" class="headerlink" title="3. 独特标识符"></a>3. 独特标识符</h3><p>每个元组会被分配一个独特的标识符，一般为page_id + offset/slot。</p><h3 id="4-非规范化元组数据"><a href="#4-非规范化元组数据" class="headerlink" title="4. 非规范化元组数据"></a>4. 非规范化元组数据</h3><p>如果两个表相关联，DBMS可以进行预连接，把两个表放在一页中。</p><ul><li>读取速度更快，因为只需要加载一页。</li><li>需要为每个元组提供更多空间，更新代价变大。</li></ul><h2 id="7-日志结构化存储"><a href="#7-日志结构化存储" class="headerlink" title="7. 日志结构化存储"></a>7. 日志结构化存储</h2><p>不存储元组，只存储日志记录</p><ul><li>日志分为put和delete两种类型。</li><li>读取一条记录时，从新到旧扫描日志文件并重建元组。</li><li>读慢写快。只会顺序写入磁盘，而不修改已有数据。</li><li>可通过索引、定期压缩日志等方式降低读取时间。</li><li>可将日志压缩为按id排序的表SSTtables，加快元组搜索。<ul><li>最终会出现写放大问题。</li></ul></li></ul><h1 id="3-数据表示"><a href="#3-数据表示" class="headerlink" title="3. 数据表示"></a>3. 数据表示</h1><p>数据表示方案，即DBMS如何解释元组不同位置的字节，导出属性的值。</p><h2 id="1-Integers"><a href="#1-Integers" class="headerlink" title="1. Integers"></a>1. Integers</h2><p>整型，固定长度。</p><p>如：INTEGER、BIGINT、SMALLINT、TINYINT</p><h2 id="2-Variable-Precision-Numbers"><a href="#2-Variable-Precision-Numbers" class="headerlink" title="2. Variable Precision Numbers"></a>2. Variable Precision Numbers</h2><p>不精确、可变精度的数字类型，固定长度。</p><p>计算时带有舍入误差。</p><p>如：FLOAT、REAL</p><h2 id="3-Fixed-Point-Precision-Numbers"><a href="#3-Fixed-Point-Precision-Numbers" class="headerlink" title="3. Fixed-Point Precision Numbers"></a>3. Fixed-Point Precision Numbers</h2><p>具有任意精度和比例的数字类型，通常以精确、可变长度的二进制表示存储，并带有额外元数据，指示数据长度与小数点位置。</p><p>当舍入误差不可接受时，使用该种数据类型，代价是性能。</p><p>如：NUMERIC、DEMICAL</p><h2 id="4-Variable-Length-Data"><a href="#4-Variable-Length-Data" class="headerlink" title="4. Variable-Length Data"></a>4. Variable-Length Data</h2><p>任意长度的数据类型，通常与一个跟踪字符串长度的标头一起存储，以便跳到下一个值，以及可能的数据校验和。</p><p>可以将该数据存储在其他空间，甚至是外部文件中，数据库元组中只存储指向该数据的指针。</p><p>如：VARCHAR、VARBINARY、TEXT、BLOB</p><h2 id="5-Dates-and-Times"><a href="#5-Dates-and-Times" class="headerlink" title="5. Dates and Times"></a>5. Dates and Times</h2><p>如：TIME、DATE、TIMESTAMP</p><h2 id="6-System-Catalogs"><a href="#6-System-Catalogs" class="headerlink" title="6. System Catalogs"></a>6. System Catalogs</h2><p>DBMS维护一个内部目录存储元数据，用于解码元组的内容。</p><p>该内部目录包括数据库含有的表与列，以及其类型、排列顺序。</p><h1 id="4-数据库工作方式"><a href="#4-数据库工作方式" class="headerlink" title="4. 数据库工作方式"></a>4. 数据库工作方式</h1><h2 id="1-OLTP-Online-Transaction-Processing"><a href="#1-OLTP-Online-Transaction-Processing" class="headerlink" title="1. OLTP-Online Transaction Processing"></a>1. OLTP-Online Transaction Processing</h2><p>特点：快速短时间运行的操作、单次在单个实体上操作的简单查询、重复操作。通常更多处理写入。</p><p>例子：用户将物品添加到购物车中，或进行购买。</p><h2 id="2-OLAP-Online-Analytical-Processing"><a href="#2-OLAP-Online-Analytical-Processing" class="headerlink" title="2. OLAP-Online Analytical Processing"></a>2. OLAP-Online Analytical Processing</h2><p>特点：对数据库大量数据进行长时间、复杂的查询和读取。一般从OLTP端收集的现有数据中分析和导出新数据。</p><p>例子：计算特定的一天某个城市购买量最大的商品。</p><h2 id="3-HTAP-Hybrid-Transaction-Analytical-Processing"><a href="#3-HTAP-Hybrid-Transaction-Analytical-Processing" class="headerlink" title="3. HTAP-Hybrid Transaction + Analytical Processing"></a>3. HTAP-Hybrid Transaction + Analytical Processing</h2><p>在同一个数据库上结合OLTP与OLAP</p><h1 id="5-存储模型"><a href="#5-存储模型" class="headerlink" title="5. 存储模型"></a>5. 存储模型</h1><h2 id="1-NSM-n元存储模型"><a href="#1-NSM-n元存储模型" class="headerlink" title="1. NSM-n元存储模型"></a>1. NSM-n元存储模型</h2><p>按行存储，将单个元组所有属性连续存储在单个页面中。</p><p>适合OLTP这种请求量大、事务一般只在单个实体中操作的工作场景，因为只需要一次访问就能获得单个元组所有数据。</p><ul><li>优点：快速增删改、适合需要整个元组的查询。</li><li>缺点：不适合访问一部分元组、或是扫描表的大部分。</li></ul><h2 id="2-DSM-分解存储模型"><a href="#2-DSM-分解存储模型" class="headerlink" title="2. DSM-分解存储模型"></a>2. DSM-分解存储模型</h2><p>按列存储。</p><p>适合OLAP这种对表的属性子集进行大规模扫描的工作场景。</p><ul><li>优点：减少IO浪费，只读取需要的数据；适合查询处理和数据压缩。</li><li>缺点：由于元组拆分/缝合，增删改较慢，需要在每一列中分别找到对应位置。</li></ul><p>如果想重新组合元组：</p><ul><li>固定长度偏移：不同列中相同偏移量的值来自同一元组。要求列的每个值长度相同。</li><li>嵌入式元组ID：存储一个映射，表示如何跳转到某个id的元组的每个属性。存储开销很大。</li></ul><h1 id="6-数据压缩"><a href="#6-数据压缩" class="headerlink" title="6. 数据压缩"></a>6. 数据压缩</h1><p>数据如果是完全随机，没法压缩，但是现实生活中数据的特点使得压缩成为可行：</p><ul><li>属性值往往有高度倾斜的分布。</li><li>同一元组内的不同属性往往强关联。（邮政编码与城市）</li></ul><p>数据压缩要求：</p><ul><li>必须生成固定长度的值。因为DBMS需要能使用偏移量访问数据。</li><li>允许DBMS查询期间尽可能长时间地推迟解压缩。</li><li>必须是无损压缩。</li></ul><p>压缩粒度：</p><ul><li>块级别：压缩同一个表中的元组块。</li><li>元组级别：压缩一个元组中的内容（仅限行存储）。</li><li>属性级别：将多个属性值作为一个压缩到元组中。</li><li>列级别：压缩多个元组的相同列中的值（仅限列存储）。</li></ul><h2 id="1-列压缩方案"><a href="#1-列压缩方案" class="headerlink" title="1. 列压缩方案"></a>1. 列压缩方案</h2><h3 id="1-Run-Length-Encodin-RLE"><a href="#1-Run-Length-Encodin-RLE" class="headerlink" title="1. Run-Length Encodin RLE"></a>1. Run-Length Encodin RLE</h3><p>将一列中的相同元素压缩为三元组：</p><ul><li>属性值</li><li>属性在列区间的起始位置</li><li>元素数</li></ul><p>为了最大程度压缩，应该先对列排序。</p><h3 id="2-Bit-Packing-Encoding"><a href="#2-Bit-Packing-Encoding" class="headerlink" title="2. Bit-Packing Encoding"></a>2. Bit-Packing Encoding</h3><p>属性值小于值声明的最大值时，将其存储为更小的数据类型</p><h3 id="3-Mostly-Encoding"><a href="#3-Mostly-Encoding" class="headerlink" title="3. Mostly Encoding"></a>3. Mostly Encoding</h3><p>基于2，使用一个特殊标记指示值何时超过最大值，然后维护一个查找表存储它们。</p><h3 id="4-Bitmap-Encoding"><a href="#4-Bitmap-Encoding" class="headerlink" title="4. Bitmap Encoding"></a>4. Bitmap Encoding</h3><p>为特定属性的每个唯一值设置一个单独的位图。位图第i位表示表中第i个元组。</p><p>仅适用于不同值得数目较少的属性。</p><h3 id="5-Delta-Encoding"><a href="#5-Delta-Encoding" class="headerlink" title="5. Delta Encoding"></a>5. Delta Encoding</h3><p>不存储具体值，而是存储与某个值的差。（一般用于较大值的列，转化后再使用2压缩）</p><h3 id="6-Incremental-Encoding"><a href="#6-Incremental-Encoding" class="headerlink" title="6. Incremental Encoding"></a>6. Incremental Encoding</h3><p>记录常见的前后缀与长度，再进行压缩。</p><p>对已排序的数据最有效。</p><h3 id="7-Dictionary-Compression"><a href="#7-Dictionary-Compression" class="headerlink" title="7. Dictionary Compression"></a>7. Dictionary Compression</h3><p>字典编码，最常见的数据库压缩方案。用较小的值对常见的值进行编码（类似于霍夫曼编码）。需要支持快速编码/解码以及范围查询，即编码后的值排序顺序跟原始值相同。</p><h1 id="7-缓冲池"><a href="#7-缓冲池" class="headerlink" title="7. 缓冲池"></a>7. 缓冲池</h1><p>缓冲池负责数据在内存与磁盘之间的移动，对数据进行封装，让执行引擎看起来数据全部在内存中，不必担心数据如何取到内存中。</p><h2 id="1-lock-amp-latch"><a href="#1-lock-amp-latch" class="headerlink" title="1. lock &amp; latch"></a>1. lock &amp; latch</h2><p>锁：</p><ul><li>更高级的逻辑原语。</li><li>保护数据库内容（元组、表、数据库）不受其他事务影响。</li><li>事务在其整个持续时间内持有锁。</li><li>数据库系统可以在运行时向用户公开持有的锁。</li><li>需要能回滚更改。</li></ul><p>latch：</p><ul><li>低级保护原语。</li><li>用于内部结构的关键部分（哈希表、内存区域）。</li><li>仅在进行操作期间保持。</li><li>不需要能回滚更改。</li></ul><h2 id="2-缓冲池"><a href="#2-缓冲池" class="headerlink" title="2. 缓冲池"></a>2. 缓冲池</h2><p>从磁盘读取的页面在内存中的缓存。本质上是数据库内部分配的一块内存区域，用于存储从磁盘获取的页面。</p><p>内存区域组织为固定大小页面的数组，每个数组条目称为一个帧。</p><ul><li>当请求磁盘页时，会先在缓冲池中找对应的帧。</li><li>如果缓冲池找不到磁盘页对应的帧，系统从磁盘中获取页面的副本，缓存在帧中。</li><li>如果要读入新页时缓冲池已满，会淘汰一个帧，并发生写回。</li><li>如果发生写事件，会将缓冲池的帧标记为脏页。</li></ul><h2 id="3-缓冲池的元数据"><a href="#3-缓冲池的元数据" class="headerlink" title="3. 缓冲池的元数据"></a>3. 缓冲池的元数据</h2><ul><li>页id到缓冲池帧的映射</li><li>每页的元数据：<ul><li>脏标记</li><li>引用数</li></ul></li></ul><h2 id="4-IO策略"><a href="#4-IO策略" class="headerlink" title="4. IO策略"></a>4. IO策略</h2><p>大多数DBMS使用直接IO绕过操作系统缓存，避免页面冗余副本，以及管理不同的淘汰策略。</p><h2 id="5-缓冲池页面替换策略"><a href="#5-缓冲池页面替换策略" class="headerlink" title="5. 缓冲池页面替换策略"></a>5. 缓冲池页面替换策略</h2><h3 id="1-LRU"><a href="#1-LRU" class="headerlink" title="1. LRU"></a>1. LRU</h3><p>为每页维护一个时间戳，淘汰时选择最久未使用的页面淘汰。</p><p>实际使用时可通过list实现。</p><h3 id="2-CLOCK"><a href="#2-CLOCK" class="headerlink" title="2. CLOCK"></a>2. CLOCK</h3><p>FIFO与LRU的结合版。页面放在一个环上，每页赋予一个参考位，访问时设置为1。</p><p>指针从上次位置顺时针转动，碰到页：</p><ul><li>参考位为1，设置为0。</li><li>参考位为0，选择该页淘汰。</li></ul><h3 id="3-LRU与CLOCK存在的问题"><a href="#3-LRU与CLOCK存在的问题" class="headerlink" title="3. LRU与CLOCK存在的问题"></a>3. LRU与CLOCK存在的问题</h3><p>顺序洪泛：顺序扫描大量数据一次，会导致数据在缓冲池的大量进出，无法反映我们实际想要的页面。即最近使用的页面实际上是最不需要的。</p><p>一些改进：</p><h4 id="1-LRU-K"><a href="#1-LRU-K" class="headerlink" title="1. LRU-K"></a>1. LRU-K</h4><p>页访问超过K次，才能进入LRU活跃队列，否则按照距离第一次访问的间隔淘汰。</p><h4 id="2-对每个查询特化"><a href="#2-对每个查询特化" class="headerlink" title="2. 对每个查询特化"></a>2. 对每个查询特化</h4><p>根据每个事务/查询选择需要回收的页面，从而最大限度减少每次查询对缓冲池的污染。</p><h4 id="3-优先级提示"><a href="#3-优先级提示" class="headerlink" title="3. 优先级提示"></a>3. 优先级提示</h4><p>允许事务在查询期间根据每个页面上下文，告诉缓冲池页面是否重要。</p><h3 id="4-脏页淘汰策略"><a href="#4-脏页淘汰策略" class="headerlink" title="4. 脏页淘汰策略"></a>4. 脏页淘汰策略</h3><ul><li>淘汰时写回。</li><li>尽量不淘汰脏页，转而淘汰其他页。</li><li>可通过后台写入策略尽量避免写回。DBMS后台线程定期遍历页面，将脏页写入磁盘；当脏页被写回时，可以选择收回该页或取消脏标记。</li></ul><h1 id="8-哈希表"><a href="#8-哈希表" class="headerlink" title="8. 哈希表"></a>8. 哈希表</h1><h2 id="1-组成部分"><a href="#1-组成部分" class="headerlink" title="1. 组成部分"></a>1. 组成部分</h2><ul><li>哈希函数：将大的键空间映射到一个较小的域，用于计算桶或槽数组的索引。需要考虑执行速度和碰撞几率之间的权衡。</li><li>哈希策略：在碰撞之后如何处理键冲突。需要考虑两种减少冲突方式：增大哈希表空间与发生冲突时执行额外指令处理冲突之间的权衡。</li></ul><h2 id="2-哈希函数"><a href="#2-哈希函数" class="headerlink" title="2. 哈希函数"></a>2. 哈希函数</h2><p>接受任何值作为输入（key），输出对应的整数表示（哈希值），相同的键总应该得到相同的输入。</p><p>注重速率与碰撞率。</p><h2 id="3-静态哈希策略"><a href="#3-静态哈希策略" class="headerlink" title="3. 静态哈希策略"></a>3. 静态哈希策略</h2><p>哈希表的大小固定。如果哈希表已满，只能申请新空间后，将原有数据复制过去。一般事先得知要插入的数据量，并申请双倍的空间。</p><p>为了减少多余的比较次数，需要尽量避免散列冲突。</p><h3 id="1-线性探测法"><a href="#1-线性探测法" class="headerlink" title="1. 线性探测法"></a>1. 线性探测法</h3><p>发生碰撞时，搜索下一个槽，直到找到一个能用的槽，或遍历所有槽。</p><p>通常是最快的，但是存在两个问题：</p><ul><li>存数据时必须将key也存入，因为某个位置放的数据并不一定是它的key哈希直接得到的。</li><li>删除数据可能会导致线性探测中断，进而无法探测到已有数据：<ul><li>不实际删除，而是放一个删除标记。</li><li>删除数据后移动相邻的槽。操作复杂，较少实现。</li></ul></li></ul><p>存在相同键时：</p><ul><li>开链法。</li><li>冗余键：将相同的键同样存在哈希表中，线性探测法仍然有效。</li></ul><h3 id="2-Robin-Hood-Hashing"><a href="#2-Robin-Hood-Hashing" class="headerlink" title="2. Robin Hood Hashing"></a>2. Robin Hood Hashing</h3><p>基于线性探测法的拓展。</p><p>计算待插入数据当前探测位置距离其原本哈希位置的距离，并与当前探测位置存储数据的距离比较。如果待插入数据的距离较短，则将待插入数据替换为当前探测位置的数据，继续探测。</p><h3 id="3-Cuckoo-Hashing"><a href="#3-Cuckoo-Hashing" class="headerlink" title="3. Cuckoo Hashing"></a>3. Cuckoo Hashing</h3><p>使用多个哈希函数构建多个哈希表。</p><p>插入时检查每个表，根据负载因子等选择一个有剩余空间的表，或是随机选择一个表。如果没有表有空间，一般随机取出一个旧表项，并将其散列到另一个表中。可能会陷入循环，这时候一般重新构建更大的哈希表。</p><p>查询与删除较为高效，但是插入代价可能较高。</p><h2 id="4-动态哈希策略"><a href="#4-动态哈希策略" class="headerlink" title="4. 动态哈希策略"></a>4. 动态哈希策略</h2><p>根据需要重新调整哈希表大小，而无需重构整个表。</p><h3 id="1-开链法"><a href="#1-开链法" class="headerlink" title="1. 开链法"></a>1. 开链法</h3><h3 id="2-可拓展哈希"><a href="#2-可拓展哈希" class="headerlink" title="2. 可拓展哈希"></a>2. 可拓展哈希</h3><p>详见Lab1-1实验记录</p><h3 id="3-线性哈希"><a href="#3-线性哈希" class="headerlink" title="3. 线性哈希"></a>3. 线性哈希</h3><p>实现复杂且效率不高，一般用于高响应度系统中。</p><p>具体可看：</p><p><a href="https://blog.csdn.net/jackydai987/article/details/6673063">https://blog.csdn.net/jackydai987/article/details/6673063</a></p><h1 id="9-索引"><a href="#9-索引" class="headerlink" title="9. 索引"></a>9. 索引</h1><p>索引是表的某几列，通过对这些列进行排序建立表的索引表，来访问表中的元组。一般用在对这些列需要进行频繁范围查找的场合。</p><p>建立的索引数量存在权衡。索引表的数目增加，会导致查询速度变快，但是额外消耗的空间增加，且更新表需要同步更新每个索引表，更新代价变大。</p><p>一般使用B+树实现索引表。</p><h2 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1. B+树"></a>1. B+树</h2><p>多路搜索树。一种自平衡树结构，保持数据有序且在logn时间复杂度进行增删改查，以及顺序访问。</p><ul><li>M路搜索树，即一个节点最多有M个子节点。</li><li>完全平衡，即所有叶子节点都是相同深度。</li><li>每个内部节点的key数量在[M / 2 - 1, M - 1]之间。</li><li>每个有k个key的内部节点有k + 1个非空子节点。</li><li>叶子节点之间通过链表相连。</li></ul><p>键所对应的值：</p><ul><li>内部节点的值是指向对应子节点的指针。</li><li>叶子节点的值是元组数据，或是表的元组id。</li></ul><h3 id="1-插入"><a href="#1-插入" class="headerlink" title="1. 插入"></a>1. 插入</h3><ul><li>根据搜索树性质向下遍历，找到应该插入的叶子节点L。</li><li>在L的对应位置插入新的键值对<ul><li>如果插入后满足key数量的约束，操作结束。</li><li>否则，将L分裂为两个节点L1与L2。将L的键值对均匀分配到L1、L2中，并在L的父节点中插入一条新的键值对，用于指示L1、L2。</li></ul></li><li>L的父节点的插入也可能引起分裂，通过递归向上插入。</li></ul><h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h3><ul><li><p>根据搜索树性质向下遍历，找到删除项所在的叶子节点L。</p></li><li><p>找到删除项在L中的位置</p><ul><li>如果删除后满足key数量的约束，操作结束。</li><li>否则，尝试重新分配，即把左兄弟最后一个键值对或右兄弟第一个键值对借过来，以满足ke数量约束。同时调整父节点对应位置的key。</li><li>如果重新分配失败，即左右兄弟如果借键值对后也不满足key数量约束，尝试合并L与左兄弟或右兄弟，并删除L的父节点对应的key。</li></ul></li><li><p>L的父节点的删除也可能引起再分配或合并，通过递归向上删除。</p></li></ul><h3 id="3-查找"><a href="#3-查找" class="headerlink" title="3. 查找"></a>3. 查找</h3><p>单个查找：效率略高于传统二叉树，因为key更多，导致树更扁平，平均查找次数更少。</p><p>范围查找：查找到范围内第一个值后，可以通过叶子节点间的链表，遍历所有范围内的节点。</p><h2 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2. 并发控制"></a>2. 并发控制</h2><h2 id="1-Latch的实现方式"><a href="#1-Latch的实现方式" class="headerlink" title="1. Latch的实现方式"></a>1. Latch的实现方式</h2><h3 id="1-Blocking-OS-Mutex"><a href="#1-Blocking-OS-Mutex" class="headerlink" title="1. Blocking OS Mutex"></a>1. Blocking OS Mutex</h3><p>由操作系统内置的互斥结构实现。Linux提供了futex，由：</p><ul><li>用户空间中的latch</li><li>操作系统级的mutex</li></ul><p>组成。DBMS获得latch的步骤：</p><ul><li>获取用户空间latch</li><li>如果未能获取latch，进入内核空间获取代价更高的mutex</li><li>如果未能获取mutex，线程被阻塞</li></ul><p>cpp的mutex为该种实现方式。</p><p>优点：使用简单，DBMS不需要额外编码。</p><p>缺点：代价高且不可拓展。</p><h3 id="2-Test-and-Set-Spin-Latch-TAS"><a href="#2-Test-and-Set-Spin-Latch-TAS" class="headerlink" title="2. Test-and-Set Spin Latch (TAS)"></a>2. Test-and-Set Spin Latch (TAS)</h3><p>自旋latch，本质上是内存中线程试图更新的位置。</p><p>线程执行CAS以尝试更新指定的内存位置，DBMS可控制如果未能获得latch的行为，如重试、或取消该操作。</p><p>cpp的atomic为该种实现方式</p><p>优点：加锁解锁高效。</p><p>缺点：自选浪费cpu；不支持缓存，会出现缓存一致性问题。</p><h3 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3. 读写锁"></a>3. 读写锁</h3><p>cpp的shared_mutex为该种实现方式。</p><p>优点：允许读者并发。</p><p>缺点：DBMS必须管理读写队列避免饥饿；需要额外元数据记录读写线程数，存储开销大于自旋锁。</p><h2 id="2-B-树并发控制"><a href="#2-B-树并发控制" class="headerlink" title="2. B+树并发控制"></a>2. B+树并发控制</h2><p>B+树并发面临的两个问题：</p><ul><li>多个线程同时尝试修改某个节点的内容。</li><li>一个线程遍历树，同时另一个线程改变树结构。</li></ul><p>并发控制基本思想：</p><ul><li>获得父节点的latch。</li><li>获得子节点的latch。</li><li>如果子节点是“安全的”，释放父节点的latch。安全，即为在进行对应的操作后，不会触发树结构改变操作。<ul><li>如果是插入操作，子节点key数目必须小于最大数目。即在插入一个key后不会触发分裂。</li><li>如果是删除操作，子节点key数目必须大于最小数目。即在删除一个节点后不会触发再分配、合并。</li></ul></li></ul><p>基础的并发控制：</p><ul><li>读：从根节点开始往下查找，获得子节点的S latch后，即释放父节点的S latch。</li><li>写：从根节点开始往下查找，获得X latch。子节点被锁住后，检查其是否安全，如果安全，则释放所有祖先节点上的latch。</li></ul><p>问题：内部节点使用X latch过于保守，降低并发能力。</p><p>改进的并发控制：</p><ul><li>读：相同。</li><li>写：内部节点设置S latch，叶子节点设置X latch。如果叶子节点不安全，则释放所有的latch，并按照基础并发控制的操作重新设置latch。</li></ul><p>叶节点链表扫描出现的死锁：不同线程从不同方向遍历叶节点链表，试图从不同方向对同一节点获取锁时，索引锁不支持死锁检测。</p><ul><li>B与C是两个相邻的叶节点。</li><li>t1持有B的R锁，从B遍历到C，试图获取C的R锁。除非获取到C的R锁，否则t1不会释放B的R锁。</li><li>t2持有C的R锁，从C遍历到B，试图获取B的R锁。除非获取到B的R锁，否则t2不会释放C的R锁。</li><li>t1、t2都在等待对方释放，造成死锁。</li></ul><p>latch不支持死锁检测，所以只能从编码规则层面避免死锁。</p><p>必须支持无等待获取锁，即获取失败时进行异常处理，比如重启事务并再次操作。</p><p>解决方法：一般不允许相反方向的遍历。</p><h1 id="11-排序"><a href="#11-排序" class="headerlink" title="11. 排序"></a>11. 排序</h1><p>在order by、group by、join和distinct关键字的场合，需要排序。</p><p>需要排序的数据都能装进内存中：可使用标准排序算法，如快排。</p><p>需要排序的数据不能全部装进内存：外部排序算法，一般是外部归并排序。</p><ul><li>排序：一次取出能装进内存的数量的数据，排序后写回磁盘。</li><li>归并：将排序好的子文件合并为整个大文件。</li></ul><p>二路归并排序：从磁盘读取两个排序的页面，将它们合并到第三个缓冲页面中；每当第三页被填满，就写回磁盘，并被替换为一个空页。</p><p>实际上，内存不可能只容纳3块，所以有N路归并排序。</p><p>如果排序的列有聚簇索引，可以直接用索引树排序；如果是非聚簇索引，因为存在回表，所以使用索引树的代价反而大于排序。</p><h1 id="12-聚集"><a href="#12-聚集" class="headerlink" title="12. 聚集"></a>12. 聚集</h1><p>将一个或多个元组的值折叠为单个标量值。一般有排序、散列两种方法。</p><h2 id="1-排序聚集"><a href="#1-排序聚集" class="headerlink" title="1. 排序聚集"></a>1. 排序聚集</h2><p>排序天然将重复值聚合到一起，然后按照重复值折叠即可。</p><p>如果查询需要筛选，最好先执行筛选，减少需要排序的数据量。</p><h2 id="2-哈希聚集"><a href="#2-哈希聚集" class="headerlink" title="2. 哈希聚集"></a>2. 哈希聚集</h2><p>有些聚集函数本身不需要排序。</p><ul><li>分类：根据目标哈希键将元组分类，分别分配到不同内存空间，输入到不同磁盘分区。</li><li>rehash：对每个磁盘分区，读入内存，计算聚集。</li></ul><h1 id="13-连接"><a href="#13-连接" class="headerlink" title="13. 连接"></a>13. 连接</h1><p>根据谓词条件（某些列的条件关系），将两个表中的元组组合起来形成一个表。</p><h2 id="1-输入形式"><a href="#1-输入形式" class="headerlink" title="1. 输入形式"></a>1. 输入形式</h2><p>直接输出数据：将两个表两两组合符合条件的所有新元组的所有数据全部放入中间结果表中。</p><p>输出ID：只复制连接键和匹配元组的ID到中间结果表中，要查询其他的列信息需要根据ID再去对应的表查询一次。适合列存储，因为不会查询不需要的数据。</p><h2 id="2-Nested-Loop-Join"><a href="#2-Nested-Loop-Join" class="headerlink" title="2. Nested Loop Join"></a>2. Nested Loop Join</h2><p>由两个嵌套for循环连接，分别遍历两个表中的元组，两两比较，如果匹配连接谓词，则输入。</p><p>外部for循环的表称为外表，内部for循环的表称为内表。</p><p>DBMS总是希望使用较小的表（元组数、页面数）作为外部表。</p><p>假设内表有M页、m个元组，外表有N页、n个元组。</p><h3 id="1-Simple-Nested-Loop-Join"><a href="#1-Simple-Nested-Loop-Join" class="headerlink" title="1. Simple Nested Loop Join"></a>1. Simple Nested Loop Join</h3><p>每次取内表一个元组，跟外表所有项依次匹配。</p><p>IO开销：M + m * N</p><h3 id="2-Block-Nested-Loop-Join"><a href="#2-Block-Nested-Loop-Join" class="headerlink" title="2. Block Nested Loop Join"></a>2. Block Nested Loop Join</h3><p>改进为每次从内表获取一个块，与外表中每个块比较。</p><p>IO开销：M + M * N</p><p>如果有大小为B的缓存池：M + M / (B - 2) * N</p><h3 id="3-Index-Nested-Loop-Join"><a href="#3-Index-Nested-Loop-Join" class="headerlink" title="3. Index Nested Loop Join"></a>3. Index Nested Loop Join</h3><p>数据库在join键上为其中一个表建立了索引。假设为外表建立了索引，开销为C。</p><p>IO开销：M + m * C</p><h2 id="3-Sort-Merge-Join"><a href="#3-Sort-Merge-Join" class="headerlink" title="3. Sort-Merge Join"></a>3. Sort-Merge Join</h2><p>先按照连接键对两个表分别排序，然后双指针法匹配。</p><p>适用于至少一个表已经按连接键有序（如索引）、输出需要按连接键排序。</p><p>退化：两个表连接键的值都为一个值。</p><h2 id="4-Hash-Join"><a href="#4-Hash-Join" class="headerlink" title="4. Hash Join"></a>4. Hash Join</h2><p>外表构建哈希表，内表每个元组使用连接键查找哈希表。</p><p>只能用于相等连接。</p><p>内表匹配时常出现匹配不上的情况，可以提前用外表构建布隆过滤器，提前过滤匹配不上的索引。（一般用于连接键是字符串等比较代价较高的情况）</p><h3 id="1-Grace-Hash-Join"><a href="#1-Grace-Hash-Join" class="headerlink" title="1. Grace Hash Join"></a>1. Grace Hash Join</h3><p>数据量太大无法全部装入内存时，对两个表的连接键用同样的哈希函数，将两个表中哈希值相同的元组分配到同一块空间，然后再对这块空间进行hash join。</p><h2 id="5-开销总结"><a href="#5-开销总结" class="headerlink" title="5. 开销总结"></a>5. 开销总结</h2><p>sort-merge和hash的方法开销少很多。</p><p>hash一般情况下比sort-merge好，但是在排序情况下sort-merge是必要的/效果更好的，所以两者都应使用。</p><h1 id="14-SQL查询过程"><a href="#14-SQL查询过程" class="headerlink" title="14. SQL查询过程"></a>14. SQL查询过程</h1><p>DBMS将SQL语句转换为查询计划，其中算子以树的形式排列。</p><p>数据从树的叶子节点流向根节点，根节点输出查询的结果。</p><h2 id="1-处理模型"><a href="#1-处理模型" class="headerlink" title="1. 处理模型"></a>1. 处理模型</h2><p>定义了系统如何执行查询计划，如计算查询计划的方向、在算子之间传递哪种数据。</p><h3 id="1-Iterator-Model-火山模型-管道模型"><a href="#1-Iterator-Model-火山模型-管道模型" class="headerlink" title="1. Iterator Model-火山模型/管道模型"></a>1. Iterator Model-火山模型/管道模型</h3><p>为每个算子实现 <code>Init()</code>与 <code>Next()</code>函数，类似于迭代器。</p><ul><li>查询计划中，每个节点调用其子节点的 <code>Next()</code>，直到到达叶子节点。</li><li>叶子节点取出数据，将元组发送给父节点处理。每次调用 <code>Next()</code>返回一个元组。如果没有数据要发送，返回空元组。</li><li>父节点接收到元组后，处理完该元组，向上层节点发送数据后，再调用 <code>Next()</code>。</li></ul><p>适用于基于磁盘的系统，因为允许在访问下一个元组/页面前。</p><p>某些算子会阻塞，直到子算子发送所有的元组，如join、order by以及子查询，称为pipeline breaker。</p><p>特点：</p><ul><li>最大的开销在函数调用。</li><li>允许流式处理，开发方便。</li></ul><h3 id="2-Materialization-Model-物化模型"><a href="#2-Materialization-Model-物化模型" class="headerlink" title="2. Materialization Model-物化模型"></a>2. Materialization Model-物化模型</h3><p>每个算子每次处理都返回所有元组，一个算子只调用一次，一次将结果全部输出。</p><p>特点：函数调用开销小。适用于单次查询检索数据量小的OLTP，而不适合具有大量中间结果的OLAP。</p><h3 id="3-Vectorization-Model-矢量化模型"><a href="#3-Vectorization-Model-矢量化模型" class="headerlink" title="3.Vectorization Model-矢量化模型"></a>3.Vectorization Model-矢量化模型</h3><p>结合上两种模型。</p><p>每个算子实现了 <code>Next()</code>函数，但是返回一批数据，而不是单个元组。</p><p>特点：</p><ul><li>函数调用开销较小，适合扫描大量元组的OLAP查询。</li><li>允许操作人员更容易使用矢量化指令处理成批的元组。</li></ul><h2 id="2-数据读取方法"><a href="#2-数据读取方法" class="headerlink" title="2. 数据读取方法"></a>2. 数据读取方法</h2><h3 id="1-顺序扫描"><a href="#1-顺序扫描" class="headerlink" title="1. 顺序扫描"></a>1. 顺序扫描</h3><p>算子遍历表中的元组，对每个元组使用条件谓词求值，决定是否发给父算子。</p><p>优化方式：</p><ul><li>预读：提前获取接下来将要读到的几页，减少IO阻塞次数。</li><li>加载到内存：直接将页面加载到内存，而不是缓冲池。</li><li>多线程：多线程并行扫描。</li></ul><h3 id="2-索引扫描"><a href="#2-索引扫描" class="headerlink" title="2. 索引扫描"></a>2. 索引扫描</h3><p>通过索引遍历表中的元组。</p><p>索引选择原则：走完索引后剩下的元素最少。</p><h3 id="3-多索引扫描"><a href="#3-多索引扫描" class="headerlink" title="3. 多索引扫描"></a>3. 多索引扫描</h3><p>多个条件都有索引时，使用每个索引筛选元组ID集，并使用位图、哈希表、布隆过滤器等取交集。</p><h2 id="3-数据修改方法"><a href="#3-数据修改方法" class="headerlink" title="3. 数据修改方法"></a>3. 数据修改方法</h2><p>万圣节问题：更新操作更改了其他元组的物理位置，导致多次扫描同一个元组。</p><p>解决方法：耿总每个修改的元组ID。</p><h2 id="4-表达式求值"><a href="#4-表达式求值" class="headerlink" title="4. 表达式求值"></a>4. 表达式求值</h2><p>where的条件表示为表达式树。</p><p>如果每个元组都要执行一遍表达式树计算，会导致大量重复计算。</p><p>优化：检测到重复计算后，直接调用之前的计算结果。</p><h1 id="15-并行化数据库"><a href="#15-并行化数据库" class="headerlink" title="15. 并行化数据库"></a>15. 并行化数据库</h1><p>在并行和分布式系统中，数据库分配在多个“资源”中，以提高并行性。分为计算性资源（CPU内核、GPU等）与存储性资源（磁盘、存储器等）。</p><ul><li>并行系统：资源在物理上接近，之间的通信快速且便宜可靠。</li><li>分布式系统：资源可能相距很远，在公共网络上通信较慢，成本更高，且故障出现概率更大。</li></ul><p>但是，它们对应用程序的查询应该忽略物理差异，生成相同的结果。</p><h2 id="1-进程模型"><a href="#1-进程模型" class="headerlink" title="1. 进程模型"></a>1. 进程模型</h2><p>一个worker指在数据库中执行操作的单位，并发执行即多个worker同时在数据库中运行。</p><h3 id="1-Process-per-Worker"><a href="#1-Process-per-Worker" class="headerlink" title="1. Process per Worker"></a>1. Process per Worker</h3><p>每个worker分配一个进程，依赖操作系统的协调。应用程序请求数据库时，调度器指派一个worker负责连接，直到请求完成。</p><p>优：一个进程崩溃不会影响其他进程。</p><p>劣：性能不高。</p><h3 id="2-Process-Pool"><a href="#2-Process-Pool" class="headerlink" title="2. Process Pool"></a>2. Process Pool</h3><p>基于进程池的处理模型。</p><h3 id="3-Thread-per-Worker"><a href="#3-Thread-per-Worker" class="headerlink" title="3. Thread per Worker"></a>3. Thread per Worker</h3><p>每个worker分配一个线程，每个数据库只有一个进程和多个工作线程。</p><p>此时一般让DBMS接管调度。</p><p>优：上下文切换开销更小；不用维护共享数据，因为线程之间天然共享数据。</p><h2 id="2-查询间并发"><a href="#2-查询间并发" class="headerlink" title="2. 查询间并发"></a>2. 查询间并发</h2><p>多个worker执行不同的查询。需要并发控制来防止更新数据库操作出现冲突。</p><h2 id="3-查询内并发"><a href="#3-查询内并发" class="headerlink" title="3. 查询内并发"></a>3. 查询内并发</h2><p>并行执行单个查询的操作，减少查询时间。每个算子有着对应的并发版本，主要有两大实现思路：</p><ul><li>将执行任务分配给多个worker，同时执行。</li><li>将任务数据分成多块，分给多个worker，最后合并结果。</li></ul><h3 id="1-Intra-Operator"><a href="#1-Intra-Operator" class="headerlink" title="1. Intra-Operator"></a>1. Intra-Operator</h3><p>查询计划的运算符被分成多个独立片段，这些片段对不同的数据子集执行相同操作。</p><p>即将数据集分割，相同处理后再合并。</p><h3 id="2-Inter-Operator"><a href="#2-Inter-Operator" class="headerlink" title="2. Inter-Operator"></a>2. Inter-Operator</h3><p>类似于流水线，不同算子并发执行。</p><p>如果下层的算子太慢，上层的算子需要等待，可能浪费很多时间。</p><h3 id="3-Bushy"><a href="#3-Bushy" class="headerlink" title="3. Bushy"></a>3. Bushy</h3><p>结合了前两种。</p><h2 id="4-IO并发"><a href="#4-IO并发" class="headerlink" title="4. IO并发"></a>4. IO并发</h2><p>关键在将逻辑上一起的数据分开到不同磁盘。</p><h3 id="1-多磁盘并行"><a href="#1-多磁盘并行" class="headerlink" title="1. 多磁盘并行"></a>1. 多磁盘并行</h3><p>OS/硬件自动将DBMS文件存储在不同磁盘，本质上跟DBMS关系不大。</p><h3 id="2-数据库分块"><a href="#2-数据库分块" class="headerlink" title="2. 数据库分块"></a>2. 数据库分块</h3><h4 id="1-垂直分块"><a href="#1-垂直分块" class="headerlink" title="1. 垂直分块"></a>1. 垂直分块</h4><p>将表的一部分属性分到另一个盘。一般将一些大、冷门的数据分开。</p><h4 id="2-水平分块"><a href="#2-水平分块" class="headerlink" title="2. 水平分块"></a>2. 水平分块</h4><p>一般按照某个属性的值将数据拆分成子集，该属性作为partition key，查询时根据key的值找不同的磁盘的表。</p><p>将partition key设置成网关，就能实现不同主机分表。</p><h1 id="16-查询计划优化"><a href="#16-查询计划优化" class="headerlink" title="16. 查询计划优化"></a>16. 查询计划优化</h1><p>SQL查询语句只告诉DBMS需要计算什么，不告诉怎么计算。DBMS要做的就是优化计算，让计算变得更高效。</p><p>有两种策略：</p><ul><li>静态规则/启发式：将SQL执行计划树与制定好的规则相匹配，根据规则改变树结构，进而提升效率。不需要检查数据本身。</li><li>基于成本的搜索：读取数据并估计执行等效计划的成本，选择成本最低的计划。</li></ul><h2 id="1-启发式"><a href="#1-启发式" class="headerlink" title="1. 启发式"></a>1. 启发式</h2><ul><li>逻辑查询优化：两种计划树是等价的，但是一种比另一种高效，就可以设置规则匹配低效的树结构，并在匹配到时替换为高效的树结构。<ul><li>尽早过滤（谓词下推）</li><li>重新排序谓词，先应用过滤数据最多的谓词</li><li>分解复杂谓词并下推（拆分连接谓词）</li></ul></li><li>嵌套子查询优化：提前计算子查询结果，作为常数放在总查询计划中。</li><li>表达式重写：<ul><li>删除不必要的谓词，如永真/永假。</li><li>合并谓词，如and/or连接的可合并区间。</li></ul></li></ul><h2 id="2-基于成本"><a href="#2-基于成本" class="headerlink" title="2. 基于成本"></a>2. 基于成本</h2><ul><li><p>估算代价：</p><ul><li>物理代价：CPU周期、IO时间等。极其依赖硬件，经常出现在数据库一体机上。</li><li>逻辑代价：估算算子整体开销、处理的数据。</li><li>算法代价：分析算子详细步骤与时间复杂度。</li></ul></li><li><p>磁盘开销：基于磁盘的数据库使用，磁盘IO占大部分开销。</p><ul><li>PostgreSQL：估算代价完全基于经验，如顺序IO比随机IO快4倍，这个数字完全是基于大量调参的结果。</li><li>DB2：与数据库特征、硬件环境、通信带宽等都有关。</li></ul></li><li><p>统计信息</p></li><li><p>计划枚举：在足够多可供选择的方案中选择计划执行路径。</p><ul><li>单个关系的计划：直接用启发式优化。</li><li>多个关系的计划：连表顺序、连表算法、数据访问算法等。</li><li>动态规划</li></ul></li></ul><h1 id="17-并发控制理论"><a href="#17-并发控制理论" class="headerlink" title="17. 并发控制理论"></a>17. 并发控制理论</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><p>在共享数据库上执行的一系列操作。</p><p>是DBMS的基本单元，符合ACID原则。</p><p>事务之间的并发执行可能导致不一致性问题。</p><p>事务以BEGIN命令开始，执行结果为COMMIT或ABORT。</p><ul><li>COMMIT：事务的所有修改都保存到数据库中，或DBMS重写并中止。</li><li>ABORT：事务的所有更改都被撤销。</li></ul><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>事务要么执行其所有操作，要么不执行任何操作。</p><p>通过两种方式保证</p><ul><li>日志：在内存和磁盘上维护当前执行的事务的所有操作，以便随时撤销或中止事务。</li><li>复制：只复制事务修改的page，事务提交时才被写回。数据恢复比日志快，但维护开销更大，所以几乎不用。</li></ul><h3 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2. 一致性"></a>2. 一致性</h3><p>在更高的层面上，数据库逻辑一致。事务执行前后数据库的逻辑不变，即事务执行前的状态逻辑+事务逻辑=事务执行后的状态逻辑。包含数据库一致与事务一致。</p><p>一致性应该是其他三个性保证导致的最终结果。</p><h3 id="3-隔离性"><a href="#3-隔离性" class="headerlink" title="3. 隔离性"></a>3. 隔离性</h3><p>提供事务在系统中单独运行的假象，不受并发的其他事务影响。</p><h3 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4. 持久化"></a>4. 持久化</h3><p>崩溃或重启后，提交的事务的所有更改都必须是持久的。可通过日志或影子分页确保。</p><h2 id="2-两阶段锁"><a href="#2-两阶段锁" class="headerlink" title="2. 两阶段锁"></a>2. 两阶段锁</h2><p>详情见Lab4-1。</p><h2 id="3-时间戳排序并发控制"><a href="#3-时间戳排序并发控制" class="headerlink" title="3. 时间戳排序并发控制"></a>3. 时间戳排序并发控制</h2><p>乐观并发控制协议。该协议认为事务冲突很少，不要求在读写对象前获取锁，而是使用时间戳确定事务的可序列化顺序。</p><p>即，DBMS保证两个事务的串行执行相对顺序与它们的时间戳相对大小相同。</p><p>可以使用系统时间或逻辑时钟作为时间戳。</p><h3 id="1-基础时间戳排序"><a href="#1-基础时间戳排序" class="headerlink" title="1. 基础时间戳排序"></a>1. 基础时间戳排序</h3><p>每个数据库对象标记最后一个访问它的事务的时间戳，包括读时间戳R-TS与写时间戳W-TS。DBMS为每个操作检查时间戳，如果事务试图违反时间戳顺序访问对象，事务将中止并重启。</p><p>读操作：事务的时间戳小于W-TS时，说明该事务将读到未来写入的内容，事务中止并用新的时间戳重新启动；否则，读取有效，并更新R-TS。</p><p>写操作：如果事务时间戳小于W-TS或R-TS，说明覆盖了未来的更改，中止并重新启动；否则写有效，并更新W-TS。</p><p>托马斯写优化：如果写事务时间戳小于W-TS，说明没有其他事务会读取该事务的写入，可忽略该事务并继续执行。</p><p>特点：</p><ul><li>没有死锁，因为事务从不等待。</li><li>如果短事务一直冲突，可能引起长事务饥饿。</li><li>时间戳分配与更新成为高并发系统瓶颈。</li></ul><h3 id="2-乐观并发控制OCC"><a href="#2-乐观并发控制OCC" class="headerlink" title="2. 乐观并发控制OCC"></a>2. 乐观并发控制OCC</h3><p>使用时间戳。适用冲突少的场合，如只读，或访问不相交的数据子集。</p><p>数据库很大且工作负载不倾斜时，冲突概率很低，适用OCC。</p><p>DBMS为每个事务创建一个专有工作区，事务所有修改应用到工作区中，其他任何事务都无法修改。事务提交时，比较事物的工作区是否与其他事务冲突，没有则写入。</p><p>包含三个阶段：</p><ul><li>读阶段：跟踪事务的读写操作，写入专有工作区中。</li><li>验证阶段：事务提交时，检查是否与其他事务冲突。</li><li>写阶段：如果验证成功，将专有工作区的更改应用于数据库；否则中止并重启事务。</li></ul><h1 id="18-多版本并发控制-MVCC"><a href="#18-多版本并发控制-MVCC" class="headerlink" title="18. 多版本并发控制-MVCC"></a>18. 多版本并发控制-MVCC</h1><p>DBMS在数据库中维护单个逻辑对象的多个物理版本。</p><p>优点：</p><ul><li>读写事务不会互相屏蔽，即一个事务在修改对象的同时，其他事务可以读取该对象的旧版本。</li><li>只读事务可以读取数据库快照而无需加锁。</li><li>更容易支持时间戳查询。</li></ul><h2 id="1-版本存储"><a href="#1-版本存储" class="headerlink" title="1. 版本存储"></a>1. 版本存储</h2><p>DBMS使用元组的一个指针字段，为每个元组创建一个版本链表，按时间戳从新到旧排序。事务读写时遍历版本链，直到找到正确的版本。</p><h3 id="1-只附加存储"><a href="#1-只附加存储" class="headerlink" title="1. 只附加存储"></a>1. 只附加存储</h3><p>单个元组所有版本存储在同一个表空间中，每次更新将元组的新版本附加到表中，并更新版本链。</p><h3 id="2-时间戳存储"><a href="#2-时间戳存储" class="headerlink" title="2. 时间戳存储"></a>2. 时间戳存储</h3><p>DBMS维护单独的旧版本表，存储旧版本的元组。</p><p>每次更新时，DBMS将更新前的元组复制到旧版本表，然后用新数据覆盖主表中的元组，主表中指针指向旧版本表。</p><h3 id="3-增量存储"><a href="#3-增量存储" class="headerlink" title="3. 增量存储"></a>3. 增量存储</h3><p>与时间戳存储类似，但是只将变化的部分存储在旧版本表中。</p><p>导致写入速度比时间戳存储快，因为只需要写入变化；读取速度比时间戳存储慢，因为需要根据变化的部分构建旧版本元组。</p><h2 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2. 垃圾回收"></a>2. 垃圾回收</h2><p>DBMS需要随时间推移从数据库中删除可回收的物理版本。</p><p>可回收：如果没有任何活动事务可以看到某个版本，或者该版本由中止的事务创建，则该版本是可回收的。</p><h3 id="1-元组级"><a href="#1-元组级" class="headerlink" title="1. 元组级"></a>1. 元组级</h3><h4 id="1-后台扫描"><a href="#1-后台扫描" class="headerlink" title="1. 后台扫描"></a>1. 后台扫描</h4><p>独立线程定期扫描表，寻找可回收的版本。</p><p>优化：维护一个脏页位图，跟踪自上次扫描以来哪些页面已被修改。</p><h4 id="2-协同清理"><a href="#2-协同清理" class="headerlink" title="2. 协同清理"></a>2. 协同清理</h4><p>工作线程在遍历版本链时识别可回收的版本。</p><h3 id="2-事务级"><a href="#2-事务级" class="headerlink" title="2. 事务级"></a>2. 事务级</h3><p>每个事务负责跟踪自己的旧版本，维护自己的读写操作集合。</p><p>事务完成时，垃圾回收器使用该集合标识要回收的元组。</p><h1 id="19-日志"><a href="#19-日志" class="headerlink" title="19. 日志"></a>19. 日志</h1><h2 id="1-故障恢复"><a href="#1-故障恢复" class="headerlink" title="1. 故障恢复"></a>1. 故障恢复</h2><p>数据库崩溃时，内存中所有未提交到磁盘的数据都有丢失风险。恢复算法的作用是防止崩溃后信息丢失。恢复算法分为两部分：</p><ul><li>正常事务处理期间的操作：确保DBMS能从故障恢复。</li><li>将数据库恢复到ACD状态失败后的操作。</li></ul><p>主要有REDO和UNDO两种原语。</p><h2 id="2-故障分类"><a href="#2-故障分类" class="headerlink" title="2. 故障分类"></a>2. 故障分类</h2><p>不是所有故障都能恢复。</p><h3 id="1-事务故障"><a href="#1-事务故障" class="headerlink" title="1. 事务故障"></a>1. 事务故障</h3><p>事务出现错误并且必须中止。</p><ul><li>逻辑错误：由于完整性、违反约束等内部条件，事务无法完成。</li><li>内部状态错误：由于死锁等错误情况，DBMS必须中止活动事务。</li></ul><h3 id="2-系统故障"><a href="#2-系统故障" class="headerlink" title="2. 系统故障"></a>2. 系统故障</h3><p>承载DBMS的底层软硬件故障。</p><ul><li>软件故障：DBMS实现出现问题，如未捕获的除以0异常等，系统不得不中止。</li><li>硬件故障：托管DBMS的计算机崩溃。故障停止假设：假设非易失性存储内容不会因为系统崩溃而损坏。</li></ul><h3 id="3-存储介质故障"><a href="#3-存储介质故障" class="headerlink" title="3. 存储介质故障"></a>3. 存储介质故障</h3><p>物理存储设备损坏时发生的不可修复的故障。</p><p>此时必须从存档版本恢复DBMS，需要人工干预恢复。</p><ul><li>不可修复的硬件故障：磁头崩溃之类的磁盘故障会破坏非易失性存储器的部分。破坏是可以检测到的。</li></ul><h2 id="3-缓冲池管理策略"><a href="#3-缓冲池管理策略" class="headerlink" title="3. 缓冲池管理策略"></a>3. 缓冲池管理策略</h2><p>DBMS有以下保证：</p><ul><li>一旦DBMS告诉某人某事务已提交，它做的任何更改都是持久的。</li><li>如果事务中止，它做的所有更改都是非持久的。</li></ul><p>窃取策略：是否可以将属于不同事务的未提交更改写入磁盘。</p><p>强制策略：DBMS是否要求事务在被允许提交前，其更新反映在非易失性存储上。</p><p>最容易实现的策略：NO-STEAL+FORCE。</p><ul><li>DBMS不需要撤销中止事务的更改，因为没有写入磁盘。</li><li>BMDS不需要重做已提交事务的更改，因为所有更改都在提交时写入磁盘。</li><li>限制：事务修改的所有数据都必须能装进内存。否则，事务无法执行，因为不允许DBMS在事务提交前将脏页写入磁盘。</li></ul><h2 id="4-影子分页"><a href="#4-影子分页" class="headerlink" title="4. 影子分页"></a>4. 影子分页</h2><p>之前的方案中，DBMS写入时复制页面，维护两个版本：</p><ul><li>master：仅包含提交的事务的更改。</li><li>shadow：包含未提交事务的更改。</li></ul><p>更新只在shadow中进行，在事务提交时shadow切换为新的master，旧master被垃圾回收。</p><p>缺陷：复制页面成本很高；shadow提交开销高，需要刷新所有更新的页面、页表，导致数据碎片化、垃圾回收；一次只支持一个写事务。</p><h2 id="5-预写日志-WAL"><a href="#5-预写日志-WAL" class="headerlink" title="5. 预写日志-WAL"></a>5. 预写日志-WAL</h2><p>在更新磁盘前，将操作先记录在日志文件中，用于执行撤销、重做操作，以便在崩溃后恢复数据库。</p><p>允许DBMS将随机写入转换为顺序写入，提高了性能；但是恢复比影子分页慢，因为需要重放日志。</p><p>实现：</p><ul><li>首先将事务日志记录在内存中。</li><li>允许在外存中重写页面之前，将该页面更新相关的日志记录先写入外存。</li><li>在事务日志写入外存前，事务不被视为已提交。</li><li>事务开始时写入BEGIN记录，标志事务开始点。</li><li>事务完成后写入COMMIT记录，确保在向应用程序返回确认前清空所有日志记录。</li></ul><p>每条日志包含：</p><ul><li>事务id</li><li>操作对象id</li><li>旧值</li><li>新值</li></ul><p>事务只有在其日志刷新到外存，才会告诉外部世界已提交。</p><p>可使用组提交优化，批量处理多个日志刷新，以分摊开销。</p><p>刷新时机：日志缓冲区满；每隔一定时间。</p><h2 id="6-日志分类"><a href="#6-日志分类" class="headerlink" title="6. 日志分类"></a>6. 日志分类</h2><ul><li>物理日志：记录对数据库中特定位置的字节级更改。<ul><li>git diff</li></ul></li><li>逻辑日志：记录事务执行的高级操作，如sql语句。<ul><li>写入日志的数据相比于物理日志更少，因为一条语句可能引起多个更改。</li><li>update、delete、insert语句。</li></ul></li><li>物理逻辑日志：<ul><li>混合物理日志与逻辑日志。指定具体的页，而不指定页中具体位置。</li><li>类似于，指定sql语句用在了哪些页？</li><li>DBMS最常用的日志。</li></ul></li></ul><h2 id="7-检查点"><a href="#7-检查点" class="headerlink" title="7. 检查点"></a>7. 检查点</h2><p>WAL技术的一个缺点是，日志文件会不断变大，每次崩溃后重放日志的时间也会变长。</p><p>因此，DBMS需要定期检查，将所有缓冲区刷新到磁盘。</p><p>检查点的设置需要权衡：太少会导致系统重启后恢复时间太长；太多会导致运行性能下降。</p><p>实现：</p><ul><li>停止接受新事务，并等待所有活动事务完成。</li><li>将当前内存中所有日志记录和脏页刷新到磁盘。</li><li>写入CHECKPOINT条目到日志，并刷新到磁盘。</li></ul><h1 id="20-故障恢复"><a href="#20-故障恢复" class="headerlink" title="20. 故障恢复"></a>20. 故障恢复</h1><p>ARIES恢复算法：</p><ul><li>WAL：在将数据库更改写入磁盘之前，先将更改日志写入磁盘。</li><li>redo：在重启时，回溯操作，并恢复数据库到崩溃前的状态。</li><li>undo：在日志中记录undo，确保在重复失败的请款下不会重复操作。</li></ul><h2 id="1-WAL"><a href="#1-WAL" class="headerlink" title="1. WAL"></a>1. WAL</h2><p>每条日志分配一个全局唯一的日志序列号LSN。</p><ul><li>每次事务修改页面，更新pageLSN，表示该页最近更新的LSN。</li><li>每次DBMS将WAL缓冲区写入磁盘，更新内存的flushedLSN，表示目前为止刷新的最大LSN。</li><li>DBMS将第i页写入磁盘前，必须至少刷新日志到pageLSNi &lt;= flushedLSN的点。</li></ul><h2 id="2-正常运行"><a href="#2-正常运行" class="headerlink" title="2. 正常运行"></a>2. 正常运行</h2><h3 id="1-事务提交"><a href="#1-事务提交" class="headerlink" title="1. 事务提交"></a>1. 事务提交</h3><ul><li>DBMS将commit记录写入内存日志缓冲区。</li><li>DBMS将所有日志记录刷新到磁盘。</li><li>DBMS向应用程序返回事务已提交的确认信息。</li><li>DBMS写一条特殊的TXN-END日志记录，表示该事务已全部完成，今后不会再出现该事务的日志记录。</li></ul><h3 id="2-事务中止"><a href="#2-事务中止" class="headerlink" title="2. 事务中止"></a>2. 事务中止</h3><p>日志中有prevLSN附加字段，表示事务的前一个LSN。</p><p>CLR补偿日志记录：记录为了撤销之前的更新记录需要采取的操作。包含更新日志记录的所有字段，以及undoNext指针（下一个要撤销的LSN）。DBMS将CLR添加到日志当中，这些日志永远不需要撤销。</p><p>中止事务：</p><ul><li>DBMS向内存日志缓冲区追加一条abort记录。</li><li>以相反的顺序撤销事物的更新，从数据库中删除更改。<ul><li>对于每个未提交的更新，DBMS在日志中创建CLR，并将对应的记录恢复到旧值。</li></ul></li><li>所有被中止的事务都被undo后，DBMS写一条TXN-END记录。</li></ul><h2 id="3-检查点"><a href="#3-检查点" class="headerlink" title="3. 检查点"></a>3. 检查点</h2><p>DBMS定期设置检查点，将缓冲池的脏页写到磁盘上。这样如果需要故障恢复，只需要从上一次写磁盘的日志位置开始，减少重放日志量。</p><h3 id="1-阻塞检查点"><a href="#1-阻塞检查点" class="headerlink" title="1. 阻塞检查点"></a>1. 阻塞检查点</h3><p>当DBMS需要设置检查点时，停止事务和查询的运行。</p><ul><li>阻止新事务启动。</li><li>等待活动事务执行完毕。</li><li>刷新脏页到磁盘。</li></ul><h3 id="2-阻塞检查点优化"><a href="#2-阻塞检查点优化" class="headerlink" title="2. 阻塞检查点优化"></a>2. 阻塞检查点优化</h3><p>DBMS不必等待活动事务完成，而是保存检查点开始时各个事务的状态，在刷盘完毕后恢复执行。类似于线程切换。</p><ul><li>阻止新事务启动。</li><li>在DBMS执行检查点时暂停所有活动事务。</li></ul><h3 id="3-活动事务表ATT"><a href="#3-活动事务表ATT" class="headerlink" title="3. 活动事务表ATT"></a>3. 活动事务表ATT</h3><p>ATT表示DBMS的活动事务的状态，包含：</p><ul><li>事务id</li><li>事务状态：运行、提交、undo</li><li>lastLSN：事务最近写的LSN</li></ul><h3 id="4-脏页表DPT"><a href="#4-脏页表DPT" class="headerlink" title="4. 脏页表DPT"></a>4. 脏页表DPT</h3><p>DPT包含缓冲池中未被提交的事务修改的页面信息。每个脏页包含一个recLSN（第一条修改了该页的日志LSN）</p><p>ATT和DPT用于帮助DBMS恢复数据库在崩溃前的状态。</p><h3 id="5-模糊检查点"><a href="#5-模糊检查点" class="headerlink" title="5. 模糊检查点"></a>5. 模糊检查点</h3><p>额外为检查点设置两个状态：</p><ul><li>begin：此时DBMS获取当前ATT、DPT。</li><li>end：包含begin时获取的ATT、DPT。</li></ul><h2 id="4-ARIES恢复算法"><a href="#4-ARIES恢复算法" class="headerlink" title="4. ARIES恢复算法"></a>4. ARIES恢复算法</h2><p>用于DBMS在崩溃后恢复，由三个阶段组成：</p><ul><li>Analysis：读取WAL，识别崩溃时缓冲池中的脏页和活动事务。ATT提供崩溃时的活动事务信息，DPT提供可能没有保存的脏页信息。</li><li>Redo：从日志的适当位置开始，重复所有操作。</li><li>Undo：撤销崩溃前未提交的事务操作。</li></ul><h3 id="1-Analysis"><a href="#1-Analysis" class="headerlink" title="1. Analysis"></a>1. Analysis</h3><p>从数据库的最后一条LSN开始：</p><ul><li>从检查点向前扫描日志。</li><li>如果发现某事务的TXN-END记录，从ATT中删除该事务。</li><li>所有其他事务标记为UNDO状态，添加到ATT。</li><li>对于update日志，如果修改的页不再DPT中，将其添加到DPT，并将P的recLSN设置为日志的LSN。</li></ul><h3 id="2-Redo"><a href="#2-Redo" class="headerlink" title="2. Redo"></a>2. Redo</h3><p>DBMS从DPT中包含最小recLSN的日志向前扫描，如果下列条件都不满足，则重放该日志：</p><ul><li>受影响的页不在DPT。</li><li>受影响的页在DPT，但日志的LSN小于DPT中该页的recLSN。</li><li>磁盘上受影响的pageLSN &gt;= LSN</li></ul><p>重放时，DBMS重新应用日志中的更改，然后将被更改页面的pageLSN设置为该日志的LSN。</p><p>redo结束时，为状态为COMMIT的所有事务写入TXN-END日志记录，将其从ATT中删除。</p><h3 id="3-Undo"><a href="#3-Undo" class="headerlink" title="3. Undo"></a>3. Undo</h3><p>处理崩溃时的活动事务，即在Analysis阶段标记于UNDO状态的事务。</p><p>反向遍历日志记录，并依次反转更新，每次反转写入一条CLR日志。</p><p>最后一个事务成功中止时，DBMS将日志刷盘，准备开始处理新事务。</p><h1 id="21-分布式数据库"><a href="#21-分布式数据库" class="headerlink" title="21. 分布式数据库"></a>21. 分布式数据库</h1><p>相较于多线程数据库的特点：</p><ul><li>节点之间可以相距很远。</li><li>节点可能通过公共网络连接，缓慢、不可靠。</li><li>存在不可忽视的通信成本和连接问题，如节点崩溃、数据包丢失。</li></ul><h2 id="1-系统结构"><a href="#1-系统结构" class="headerlink" title="1. 系统结构"></a>1. 系统结构</h2><p>关于CPU可以直接访问哪些共享资源。</p><ul><li>共享内存：一般不使用，因为由内核级别提供，导致多进程同步问题。</li><li>共享磁盘：每个CPU有自己的内存充当缓存。更新数据后，如果该数据在其他CPU中也有副本，必须将更新告知其他CPU。</li><li>不共享：节点之间只通过网络进行通信。<ul><li>很难扩容、确保数据一致性。</li><li>性能、效率更高。</li></ul></li></ul><h2 id="2-设计思路"><a href="#2-设计思路" class="headerlink" title="2. 设计思路"></a>2. 设计思路</h2><p>目的：保持数据透明性。即用户不需要知道数据的物理位置、表的分区与复制方式，像使用单节点数据库一样使用分布式数据库。</p><p>节点如何在集群中交互的设计：</p><ul><li>同构节点：每个节点可执行的任务相同。</li><li>异构节点：每个节点被分配特定的任务。</li></ul><h2 id="3-分片策略"><a href="#3-分片策略" class="headerlink" title="3. 分片策略"></a>3. 分片策略</h2><p>DBMS接收到查询后，首先分析查询需要访问的数据，将不同的查询片段发送到不同的节点，最后组合不同节点的查询结果，产生答案。</p><p>分片目的：最大化单节点事务，即只访问一个分片上包含的数据的事务。</p><p>实现：</p><ul><li>数据分区：不同区存不同表。如果有经常查询的表，可能会造成负载不均衡。</li><li>垂直分区：表不同属性差分为不同区。</li><li>水平分区：表的元组按某列的值拆分为不相交的子集。</li></ul><h2 id="4-分布式并发控制"><a href="#4-分布式并发控制" class="headerlink" title="4. 分布式并发控制"></a>4. 分布式并发控制</h2><ul><li>集中式协调：集中式协调器负责协调。</li><li>中间件：集中式协调器充当中间件，负责接受查询请求，并将查询路由到正确的分区。</li><li>去中心化协调：客户端直接向其中一个分区发送查询，该分区与其他分区通信，并将查询结果返回客户端。</li></ul><h1 id="22-分布式OLTP"><a href="#22-分布式OLTP" class="headerlink" title="22. 分布式OLTP"></a>22. 分布式OLTP</h1><h2 id="1-提交协议"><a href="#1-提交协议" class="headerlink" title="1. 提交协议"></a>1. 提交协议</h2><p>多节点事务完成时，DBMS需要询问所有涉及的节点，该提交是否安全。有不同协议，规定需要提交的节点：</p><ul><li>两阶段提交</li><li>三阶段提交</li><li>Paxos</li><li>Raft</li><li>ZAB：Zookeeper原子广播协议</li><li>Viewstamped复制</li></ul><h3 id="1-两阶段提交"><a href="#1-两阶段提交" class="headerlink" title="1. 两阶段提交"></a>1. 两阶段提交</h3><ul><li>客户端向协调者发送提交请求</li><li>第一阶段：提交请求/投票<ul><li>协调者发送prepare消息与事务内容，询问参与者是否提交当前事务。</li><li>参与者向协调者发送是否可以提交。</li></ul></li><li>第二阶段：提交/执行<ul><li>如果所有参与者返回yes，说明事务可以提交：<ul><li>协调者发送commit请求。</li><li>参与者将事务真正提交，释放占用的事务资源，返回ack。</li><li>协调者收到所有参与者的ack时，事务完成。</li></ul></li><li>有参与者返回no或超时：<ul><li>协调者发送rollback请求。</li><li>参与者根据undo日志回滚到事务执行前的状态，释放占用的事务资源，返回ack。</li><li>协调者收到所有参与者的ack时，事务回滚完成。</li></ul></li></ul></li><li>要么所有人提交，要么无人提交。</li><li>崩溃：<ul><li>在确定下一个操作前，节点阻塞。</li><li>协调者崩溃：参与者选择中止；或相互通信，协调是否可以提交。</li><li>参与者崩溃：协调者假设该参与者返回no。</li></ul></li><li>缺点：<ul><li>协调者存在单点故障问题。</li><li>执行过程同步，各参与者等待其他参与者响应时阻塞，存在性能问题。</li><li>存在不一致风险，如果只有部分参与者收到commit请求，会导致部分提交。</li></ul></li></ul><h3 id="2-Paxos-Raft"><a href="#2-Paxos-Raft" class="headerlink" title="2. Paxos/Raft"></a>2. Paxos/Raft</h3><p>共识协议：提议者提出一个结果（提交/中止），接受者投票决定该结果是否应该成功。</p><ul><li>客户端向提议者发送提交请求。</li><li>提议者向其他节点发送提议。</li><li>如果某个接受者没有向其他更新时间戳的提议者发送过同意，则同意该提议；否则，拒绝该提议。</li><li>只要大多数接受者同意，提议者响应客户端已提交。</li></ul><p>2PC是paxos的退化情况。</p><p>改进：Multi-Paxos：系统选举出一个领导，在一段时间内监视提议变更，从而跳过提议阶段。</p><h2 id="2-数据复制"><a href="#2-数据复制" class="headerlink" title="2. 数据复制"></a>2. 数据复制</h2><p>通过冗余数据提高可用性。</p><ul><li><p>主节点：</p><ul><li>必须选出一个主节点，同步所有其他节点的更新，并将更新同步到其他节点。</li><li>没有主节点，每个节点更新后都需要同步到所有节点中。</li></ul></li><li><p>K-Safety：如果某个数据可用副本数小于K，则DBMS停止提供服务。</p></li><li><p>传播方案：</p><ul><li>同步方案：主节点确保所有副本应用更改后，才通知客户端更新成功。</li><li>异步方案：主节点不等待副本应用，直接通知客户端更新成功。</li></ul></li><li><p>传播时机：</p><ul><li>连续：生成日志消息时立即发送。</li><li>提交：仅在事务提交后向副本发送该事务的日志消息。</li></ul></li></ul><h2 id="3-CAP"><a href="#3-CAP" class="headerlink" title="3. CAP"></a>3. CAP</h2><p>分布式系统不能同时满足三个属性：</p><ul><li>一致性：一旦写入完成，所有将来的读取都应该返回最近一次写入的值。</li><li>可用性：所有已启动的节点都能满足所有请求。</li><li>分区容忍：尽管节点之间存在了一些消息丢失，系统仍然可以正常运行。</li></ul><p>PACELC理论：考虑了一致性与延迟的权衡。在分布式系统网络分区（P）的情况下，必须在A与C之间选择；否则（E），即使系统在没有网络分区的情况下正常运行，也必须在延迟（L）与C之间选择。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab4-3</title>
      <link href="/2023/05/07/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab4-3/"/>
      <url>/2023/05/07/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab4-3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-并发SQL查询"><a href="#1-并发SQL查询" class="headerlink" title="1. 并发SQL查询"></a>1. 并发SQL查询</h2><p>将事务锁应用于Lab3实现的算子中。</p><p>实际实现中，事务只在最底层的算子中与数据库的数据打交道，所以只需要修改底层算子，实现加解锁即可。</p><p>底层算子有查/增/删三种，分别对应SeqScan、Insert、Delete三种算子。</p><h2 id="2-SeqScan"><a href="#2-SeqScan" class="headerlink" title="2. SeqScan"></a>2. SeqScan</h2><p>按照隔离级别有不同的行为</p><ul><li>读未提交：无需加锁。</li><li>读提交：该隔离级别规定，只要事务提交，其他事务就能立即看到提交的结果。<ul><li><code>Next()</code>返回false，即一次读完毕时，释放锁。</li><li><code>Init()</code>给表加IS锁，<code>Next()</code>遍历时给行加S锁。</li><li>只需要给符合predicate的行加S锁。</li><li>如果没有predicate，可以直接给表上S锁。</li><li>加锁失败抛出异常。</li></ul></li><li>可重复读：与读提交行为类似，但是最后不主动释放锁，等到事务Commit/Abort时统一释放，保证事务多次读到的结果一致。</li></ul><h2 id="3-Insert-amp-Delete"><a href="#3-Insert-amp-Delete" class="headerlink" title="3. Insert &amp; Delete"></a>3. Insert &amp; Delete</h2><p>各个隔离级别行为相同。</p><ul><li><code>Init()</code>中为表加IX锁。</li><li><code>Next()</code>遍历时为行加X锁。</li><li>加锁失败抛出异常。</li></ul><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-SeqScan"><a href="#1-SeqScan" class="headerlink" title="1. SeqScan"></a>1. SeqScan</h2><p><code>Init()</code>：</p><ul><li>如果隔离级别不是读未提交，加IS表锁。<ul><li>读未提交不需要加锁。</li></ul></li><li>捕获各种异常。</li></ul><p><code>Next()</code>：</p><ul><li>如果迭代到表末尾，且隔离级别为读提交，需要先释放行锁，后释放表锁，最后返回false。</li><li>如果不是末尾，取出tuple和rid，迭代器前进一步。</li><li>如果predicate不为空，且当前行不符合predicate条件，循环一次上面。</li><li>获得了符合predicate条件的行时，若隔离级别不为读未提交，需要尝试加锁，加锁成功后返回true。</li></ul><h2 id="2-Insert-Delete"><a href="#2-Insert-Delete" class="headerlink" title="2. Insert/Delete"></a>2. Insert/Delete</h2><p><code>Init()</code>：</p><ul><li>尝试加IX表锁。</li></ul><p><code>Next()</code>：</p><ul><li>child获得数据后，先尝试加X行锁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab4-2</title>
      <link href="/2023/05/06/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab4-2/"/>
      <url>/2023/05/06/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab4-2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-死锁检测"><a href="#1-死锁检测" class="headerlink" title="1. 死锁检测"></a>1. 死锁检测</h2><p>用等待关系图来表示事物之间的等待关系。</p><p>等待关系图是一个二维矩阵，二维的下标分别代表等待的事务、占用资源的事务的id。t1-&gt;t2表示事务t1等待事务t2释放资源。</p><p>等待关系图中如果存在环，即代表出现死锁，需要挑选事务终止，来打破死锁。</p><p>检测算法：DFS、拓扑排序。这里用DFS。</p><p>检测到环后，需要ABORT环中的一个事务来破坏环。这里的规则是，ABORT最年轻的事务，即txn id最大的事务。</p><ul><li>原因大概是，年轻的事务执行的操作较少，破坏代价较小？</li></ul><p>每次破坏一个环后，ABORT事务的资源即得到释放，需要通过条件变量唤醒阻塞在这些资源上的其他线程。</p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>同样是基于LockManager</p><h3 id="1-死锁检测线程"><a href="#1-死锁检测线程" class="headerlink" title="1. 死锁检测线程"></a>1. 死锁检测线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; enable_cycle_detection_;</span><br><span class="line"><span class="built_in">std</span>::thread *cycle_detection_thread_;</span><br></pre></td></tr></table></figure><p>专门创建一个死锁检测线程用于检测。</p><ul><li>enable_cycle_detection表示检测是否开启。</li><li>while循环判断条件为enable_cycle_detection。</li><li>每次循环开始时，死锁检测线程睡眠一段时间（50ms），即每50ms检测一次死锁。</li></ul><h3 id="2-waits-for"><a href="#2-waits-for" class="headerlink" title="2. waits_for_"></a>2. waits_for_</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">txn_id_t</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">txn_id_t</span>&gt;&gt; waits_for_;</span><br><span class="line"><span class="built_in">std</span>::mutex waits_for_latch_;</span><br></pre></td></tr></table></figure><p>等待关系图。</p><h3 id="3-txn-set"><a href="#3-txn-set" class="headerlink" title="3. txn_set_"></a>3. txn_set_</h3><p>新增的数据结构，表示目前waits_for_中的所有事务id。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-AddEdge"><a href="#1-AddEdge" class="headerlink" title="1. AddEdge"></a>1. AddEdge</h2><p>功能：向等待关系图中增加一条边。</p><p>输入：txn_id_t t1、t2。增加一条t1-&gt;t2的边。</p><p>具体逻辑：</p><ul><li>waits_for_[t1]添加t2。</li><li>txn_set_添加t1、t2。</li></ul><h2 id="2-RemoveEdge"><a href="#2-RemoveEdge" class="headerlink" title="2. RemoveEdge"></a>2. RemoveEdge</h2><p>功能：在等待关系图中删除一条边</p><p>输入：txn_id_t t1、t2。删除t1-&gt;t2的边。</p><p>具体逻辑：</p><ul><li>waits_for_[t1]中找到t2。</li><li>如果能找到，则在waits_for_[t1]中删除。</li><li>否则直接返回。</li></ul><h2 id="3-HasCycle"><a href="#3-HasCycle" class="headerlink" title="3. HasCycle"></a>3. HasCycle</h2><p>功能：判断是否有环</p><p>输入：txn_id_t *txn_id，当有环时通过指针返回最年轻的事务id。</p><p>输出：bool，表示是否有环。</p><p>具体逻辑：</p><ul><li>两个哈希表safe_set、active_set。<ul><li>safe_set表示已经遍历过且不在当前路径中的事务id。</li><li>active_set表示已经遍历过且在当前路径中的事务id。</li></ul></li><li>子函数dfs：输入id表示当前遍历的事务id，输出bool表示是否有环。<ul><li>正常的dfs检测环逻辑。</li></ul></li><li>遍历txn_set，如果当前的id不在safe_set里，即没有被访问，则调用dfs访问。<ul><li>如果dfs返回true，说明有环，取active_set里最大的id返回。</li></ul></li><li>遍历完毕没有提前返回，说明无环，返回false。</li></ul><h2 id="4-GetEdgeList"><a href="#4-GetEdgeList" class="headerlink" title="4. GetEdgeList"></a>4. GetEdgeList</h2><p>功能：返回所有边。</p><p>具体逻辑：遍历waits_for，将边加入数组即可。</p><h2 id="5-RunCycleDetection"><a href="#5-RunCycleDetection" class="headerlink" title="5. RunCycleDetection"></a>5. RunCycleDetection</h2><p>功能：循环检测死锁，并在死锁出现时破坏环。</p><p>具体逻辑：</p><ul><li>当enable_cycle_detection_时，循环检测：<ul><li>调用 <code>this_thread::sleep_for()</code>睡眠50ms，代表每50ms检测一次。</li><li>两个哈希表txn_table_map、txn_row_map。<ul><li>txn_table_map表示所有事务id与其锁住的表的映射。</li><li>txn_row_map表示所有事务id与其锁住的行的映射。</li></ul></li><li>对table_lock_map与row_lock_map上锁，遍历，填充两个哈希表与waits_for_等待关系图。</li><li>循环调用 <code>HasCycle()</code>判断是否有环，如果有，获得其id：<ul><li><code>TransactionManager::GetTransaction()</code>获得被释放的事务指针，设置状态为ABORTED。</li><li>遍历txn_set，调用 <code>RemoveEdge()</code>删除id为起点的所有边。</li><li>通过两个哈希表找到其占有的资源，通过条件变量唤醒阻塞在这些资源上的所有其他线程。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab4-1</title>
      <link href="/2023/05/03/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab4-1/"/>
      <url>/2023/05/03/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab4-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1. 锁"></a>1. 锁</h2><h3 id="1-SX锁"><a href="#1-SX锁" class="headerlink" title="1. SX锁"></a>1. SX锁</h3><p>S锁：共享锁：加了S锁的记录，允许其他事务加S锁，不允许其他事务加X锁。</p><p>X锁：排他锁：加了X锁的记录，不允许其他事务加S锁或X锁。</p><h3 id="2-意向锁"><a href="#2-意向锁" class="headerlink" title="2. 意向锁"></a>2. 意向锁</h3><p>意向锁是表锁，可相互兼容，表明”某个事物持有锁，或准备持有“</p><p>IS锁：意向共享锁：事务请求S锁前，要先对表请求并获得IS锁。</p><p>IX锁：意向排他锁：事务请求X锁前，要先对表请求并获得IX锁。</p><p>好处：可以方便地判断某张表有没有数据被锁定。</p><h3 id="3-兼容关系"><a href="#3-兼容关系" class="headerlink" title="3. 兼容关系"></a>3. 兼容关系</h3><ul><li>意向锁相互兼容。因为只是表明申请了更低层次的锁。</li><li>表级S锁与X、IX锁不兼容。S锁表示已有事务访问表，加X、IX锁的事务没法独占该表。</li><li>表级X锁与其他锁都不兼容。X锁表示独占，其他事务不能再加锁。</li></ul><p><img src="https://img-blog.csdnimg.cn/20190224230234331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20190224230234331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDEyOTY=,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h3 id="4-共享意向排他锁"><a href="#4-共享意向排他锁" class="headerlink" title="4. 共享意向排他锁"></a>4. 共享意向排他锁</h3><p>SIX锁。用于读取了表中的数据，但是只更新其中一部分的场景。</p><h2 id="2-两阶段锁-2PL"><a href="#2-两阶段锁-2PL" class="headerlink" title="2. 两阶段锁-2PL"></a>2. 两阶段锁-2PL</h2><p>解决的问题：假设事务A执行从a转账50到b的操作，事务B执行查询a、b金额总和的操作。按以下顺序执行会导致事务B的查询结果违反一致性。</p><ul><li>事务A对a上X锁，-50，然后释放a的X锁。</li><li>事务B查询总和，发现比预期少了50。</li><li>事务A对b上X锁，+50，然后释放b的X锁。</li></ul><p>2PL将每个事务获取与释放锁分为两个阶段：Growing与Shrinking。</p><ul><li>Growing阶段，事务只能获取锁。</li><li>Shrinking阶段，事务只能释放锁。</li></ul><p>即，如果事务释放了任意一个它持有的锁，那么就再也不能获取锁。</p><p>变种：</p><p>保守两阶段锁：</p><ul><li>每个事务都知道自己会进行哪些操作，开始执行前先获取所有锁。</li><li>可以保证事务不会被abort。</li></ul><p>严格两阶段锁：</p><ul><li>事务执行结束再统一释放锁。</li><li>可以避免事务的连锁abort。</li></ul><h2 id="3-数据结构理解"><a href="#3-数据结构理解" class="headerlink" title="3. 数据结构理解"></a>3. 数据结构理解</h2><p>本次需要实现LockManager类中加解表锁、行锁四个方法。</p><h3 id="1-LockManager"><a href="#1-LockManager" class="headerlink" title="1. LockManager"></a>1. LockManager</h3><p>本次需要实现方法的类。</p><p>有一个全局的LockManager，负责管理目前所有已经被事务持有的锁与申请的锁。</p><p>负责处理申请锁的事务请求，将锁给事务、阻塞事务或者abort事务。</p><p>成员变量：</p><ul><li>table_lock_map：table的oid与其相关锁请求的映射。</li><li>row_lock_map：row的rid与其相关锁请求的映射。<ul><li>两者的值都是锁请求队列LockRequestQueue，其成员为：<ul><li>request_queue：实际存放锁请求的list。</li><li>cv、latch：条件变量和锁。</li><li>upgrading：正在此资源上尝试锁升级的事务id。同一时刻只能有一个锁升级。</li></ul></li><li>request_queue里存放的单个锁请求为LockRequest，其成员为：<ul><li>txn_id：发起请求的事务transaction的id。</li><li>lock_mode：请求的锁类型。</li><li>oid：代表所在的table的oid。</li><li>rid：只在行锁请求有效，代表请求行对应的rid。</li><li>granted：是否已经授予了锁。</li></ul></li></ul></li></ul><p>需要注意的是，request_queue中，已授予的锁与未授予的锁是放在一个队列中的，已授予的锁排在前面。</p><h3 id="2-Lock-Note"><a href="#2-Lock-Note" class="headerlink" title="2. Lock Note"></a>2. Lock Note</h3><p>一般行为： <code>LockTable()</code>和 <code>LockRow()</code>都是阻塞方法，直到获得锁才return。但是如果事务被abort了，则直接返回false。</p><p>多事务：table_lock_map与row_lock_map为每一个表/行维护一个锁队列，锁请求遵循FIFO原则。</p><p>支持的锁类型：加表锁支持所有类型的锁；加行锁不支持意向锁，否则应该给事务设置ABORTED。</p><p>隔离级别：不应该出现的状态都应该将事务设置为ABORTED，并抛出异常。</p><ul><li>REPEATABLE_READ可重复读：GROWING状态下允许获得所有类型的锁；SHRINKING状态下不允许获得锁。</li><li>READ_COMMITTED读提交：GROWING状态下允许获得所有类型的锁；SHRINKING状态下只允许获得IS/S锁。</li><li>READ_UNCOMMITTED读未提交：GROWING状态下只允许获得X/IX锁；SHRINKING状态下不允许获得锁。</li></ul><p>多层级锁：在对行加锁时，必须确保该事务已经持有了行所在的表的相应类型锁。</p><ul><li>对行加S锁，必须确保持有该表的S/IS/SIX锁。</li><li>对行加X锁，必须确保持有该表的X/IX/SIX锁。</li></ul><p>锁升级：对某资源加锁时发现，该事务已经持有了该资源的一个锁。</p><ul><li>如果本次加的锁类型与已持有的相同，则无事发生直接返回。</li><li>如果不同，必须遵守规范：（只能升级锁，而不能降级锁）<ul><li>IS -&gt; S/X/IX/SIX</li><li>S -&gt; X/SIX</li><li>IX -&gt; X/SIX</li><li>SIX -&gt; X</li></ul></li><li>同一个资源在同一时刻只能有一个事务升级锁。（该设置只是为了降低lab难度，事实上可以通过一个升级队列实现同步升级）</li></ul><p>记录：在将锁授予某个事务后，事务内部和LockManager都应该记录。</p><h3 id="3-Unlock-Note"><a href="#3-Unlock-Note" class="headerlink" title="3. Unlock Note"></a>3. Unlock Note</h3><p>一般行为：释放指定的锁</p><ul><li>必须确认事务持有需要释放的锁。</li><li>释放表锁时，事务不能持有该表上的行锁。</li><li>释放锁后，需要唤醒该资源上阻塞的加锁线程。</li></ul><p>事务状态更新：由于2PL算法，释放锁时需要变换事务状态。</p><ul><li>REPEATABLE_READ可重复读：释放任意锁使得状态变为SHRINKING。</li><li>READ_COMMITTED读提交：释放X锁使得状态变为SHRINKING。</li><li>READ_UNCOMMITED读不提交：释放X锁使得状态变为SHRINKING；该隔离级别下没有S锁，因此行为未定义。</li></ul><p>记录：在释放锁后，事物内部和LockManager都应该记录。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-LockTable"><a href="#1-LockTable" class="headerlink" title="1. LockTable"></a>1. LockTable</h2><p>功能：授予某个事务某张表指定类型的锁。</p><p>输入：</p><ul><li>Transaction *txn：事务指针。</li><li>LockMode lock_mode：要加的锁类型。</li><li>table_oid_t oid：表的oid。</li></ul><p>输出：bool，表示是否上锁成功。</p><p>具体逻辑：</p><ul><li>检查锁类型、隔离级别与事务状态，确保符合2PL。</li><li>给table_lock_map加锁，取出对应表的LockRequestQueue后解锁map，并给queue加锁。</li><li>检查是否是锁更新请求：遍历队列，找是否有该事务在该表上获得的锁，如果找到：<ul><li>如果锁类型相同，说明是冗余请求，直接返回true。</li><li>如果LockRequestQueue的upgrading不为INVALID，代表此时有其他事务在升级锁，设置ABORTED并抛出异常。</li><li>检查是否符合锁升级规范，如果不符合，设置ABORTED并抛出异常。</li><li>在LockRequestQueue与事务中移除该请求，准备插入升级后的请求。</li><li>找到list中已授予的锁的末尾，插入升级后的请求，并同步更新事务。设置LockRequestQueue的upgrading，准备升级锁。</li><li>通过cv与unique_lock，尝试获得LockRequestQueue的锁，并判断要插入的锁能否与当前表的锁兼容。<ul><li>如果获得LockRequestQueue的锁后，事务已经是ABORTED了，则设置LockRequestQueue的upgrading，删除锁请求，并抛出异常。</li></ul></li><li>升级成功，设置LockRequestQueue的upgrading，请求的granted设置为true，并更新事务状态。</li><li>如果加的锁不是独占锁，通过 <code>notify_all()</code>唤醒其他阻塞中的线程，返回true。</li></ul></li><li>否则，是申请新锁的请求。与锁更新请求类似，只不过不需要设置LockRequestQueue的upgrading。</li></ul><h2 id="2-UnlockTable"><a href="#2-UnlockTable" class="headerlink" title="2. UnlockTable"></a>2. UnlockTable</h2><p>功能：释放某个事务持有的某个表的锁。</p><p>输入：</p><ul><li>Transaction *txn：事务指针。</li><li>table_oid_t oid：表的oid。</li></ul><p>输出：bool，表示是否释放成功。</p><p>具体逻辑：</p><ul><li>如果table_lock_map找不到该table，设置ABORTED，抛出异常。</li><li>如果该table中还有未释放的行锁，设置ABORTED，抛出异常。</li><li>遍历LockRequestQueue，找到对应的已授予的锁请求。<ul><li>释放锁并变更事务状态。</li><li><code>notify_all()</code>通知其他阻塞的线程。</li><li>返回true。</li></ul></li><li>如果没找到锁请求，设置ABORTED，抛出异常。</li></ul><h2 id="3-LockRow"><a href="#3-LockRow" class="headerlink" title="3. LockRow"></a>3. LockRow</h2><p>功能：授予某个事务某张表某行指定类型的锁。</p><p>输入：</p><ul><li>Transaction *txn：事务指针。</li><li>LockMode lock_mode：要加的锁类型。</li><li>table_oid_t oid：表的oid。</li><li>RID rid：行的rid。</li></ul><p>输出：bool，表示是否上锁成功。</p><p>具体逻辑：与LockTable基本一致。</p><ul><li>收到请求后，需要检查row所在的table是否有对应的锁。</li></ul><h2 id="4-UnlockRow"><a href="#4-UnlockRow" class="headerlink" title="4. UnlockRow"></a>4. UnlockRow</h2><p>功能：释放某个事务持有的某个表某行的锁。</p><p>输入：</p><ul><li>Transaction *txn：事务指针。</li><li>table_oid_t oid：表的oid。</li><li>RID rid：行的rid。</li></ul><p>输出：bool，表示是否释放成功。</p><p>具体逻辑：与UnlockRow基本一致。</p><ul><li>不需要再判断是否有未释放的行锁。</li></ul><h1 id="3-debug经历"><a href="#3-debug经历" class="headerlink" title="3. debug经历"></a>3. debug经历</h1><p>heap_use_after_free：表示使用了野指针。<br>因此bug一定是跟指针或者引用相关，并且在其作用域内有erase、remove等操作。<br>通过搜索erase/remove发现，锁更新时，查找已有的锁是通过foreach遍历的，在找到并且检查无误后需要删掉原来的锁，但是foreach是const auto&amp;常引用的锁，所以删掉锁后再使用该常引用会导致报错。</p>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab3-Extra</title>
      <link href="/2023/05/02/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab3-Extra/"/>
      <url>/2023/05/02/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab3-Extra/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Optimizer"><a href="#1-Optimizer" class="headerlink" title="1. Optimizer"></a>1. Optimizer</h1><p>sql语句执行步骤中，Planner与Executor中间存在一个Optimizer的过程。</p><p>优化的目的，就是使得Executor执行时更具有效率。</p><p>Optimizer执行方式：</p><ul><li>每个Optimizer输入为PlanNode，输出为PlanNode。</li><li>Optimizer内对PlanNode进行后续遍历：<ul><li>先递归对PlanNode的所有子节点调用Optimizer。</li><li>然后根据特定规则处理PlanNode。</li><li>返回处理完毕的PlanNode。</li></ul></li><li>总的Optimizer按特定顺序依次调用所有实现的Optimizer，最终得到优化完毕的PlanNode。</li></ul><p>下面是Bustub已经实现的几个Optimizer的源码阅读。</p><h2 id="1-OptimizeEliminateTrueFilter"><a href="#1-OptimizeEliminateTrueFilter" class="headerlink" title="1. OptimizeEliminateTrueFilter"></a>1. OptimizeEliminateTrueFilter</h2><p>适用节点：FilterPlanNode。</p><p>如果筛选的条件恒定为true，那么该FilterPlanNode可以去掉。</p><h2 id="2-OptimizeMergeFilterNLJ"><a href="#2-OptimizeMergeFilterNLJ" class="headerlink" title="2. OptimizeMergeFilterNLJ"></a>2. OptimizeMergeFilterNLJ</h2><p>适用节点：FilterPlanNode，且子节点为NestedLoopJoinNode。</p><p>如果子节点的谓词恒为true，即两个join列都只有一个值，那么会将FilterPlanNode直接去掉，用NestedLoopJoinNode替代，且新的Node谓词改为原FilterPlanNode的判断条件。</p><p>以sql语句为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">where</span> t1.a <span class="operator">=</span><span class="operator">=</span> t2.b <span class="keyword">and</span> t1.c <span class="operator">&gt;</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>本来应该join t1与t2后，将t1.c &gt; 3应用在新表中。</p><p>如果t1.a == t2.b始终成立，则可以在join时就用t1.c &gt; 3代替t1.a == t2.b进行判断，从而减少join次数。</p><h2 id="3-OptimizeMergeFilterScan"><a href="#3-OptimizeMergeFilterScan" class="headerlink" title="3. OptimizeMergeFilterScan"></a>3. OptimizeMergeFilterScan</h2><p>适用节点：FilterPlanNode，且子节点为SeqScanNode。</p><p>优化前的行为为，先SeqScan全表扫描一遍，然后再对全表扫描结果过滤。</p><p>优化为在SeqScan的时候直接应用Filter规则过滤，相当于少遍历了一次。</p><h2 id="4-OptimizeMergeProjection"><a href="#4-OptimizeMergeProjection" class="headerlink" title="4. OptimizeMergeProjection"></a>4. OptimizeMergeProjection</h2><p>适用节点：ProjectionPlanNode。</p><p>优化前的行为为，子节点先进行操作，然后再对子节点操作的结果进行投影。</p><p>优化为，子节点操作时，只返回需要投影的几列，相当于少遍历了一次。</p><h2 id="5-OptimizeNLJAsHashJoin"><a href="#5-OptimizeNLJAsHashJoin" class="headerlink" title="5. OptimizeNLJAsHashJoin"></a>5. OptimizeNLJAsHashJoin</h2><p>适用节点：谓词为相等的NestedLoopJoinPlanNode。</p><p>优化前的行为为，双层循环遍历左子节点与右子节点的数据，然后逐个判断是否能join。</p><p>优化为，直接将右子节点数据存到哈希表中，以join的列为key，然后循环遍历左子节点，判断是否能join。把所有join上的value都存起来，<code>Next()</code>遍历逐个返回。</p><h2 id="6-OptimizeNLJAsIndexJoin"><a href="#6-OptimizeNLJAsIndexJoin" class="headerlink" title="6. OptimizeNLJAsIndexJoin"></a>6. OptimizeNLJAsIndexJoin</h2><p>适用节点：NestedLoopJoinPlanNode，且右子节点join的列是索引。</p><p>优化前的行为为，双层循环遍历左子节点与右子节点的数据，然后逐个判断是否能join。</p><p>优化为，右子节点的数据通过索引查找获得，不需要再遍历。</p><h2 id="7-OptimizeOrderByAsIndexScan"><a href="#7-OptimizeOrderByAsIndexScan" class="headerlink" title="7. OptimizeOrderByAsIndexScan"></a>7. OptimizeOrderByAsIndexScan</h2><p>适用节点：只需要以一列数据排序的SortPlanNode，且为升序排序，且该列为索引列；子节点为SeqScan。</p><p>优化前的行为为，先SeqScan全表扫描一遍，然后再对全表扫描结果排序。</p><p>优化为，直接按照IndexScan遍历结果返回。（因为索引表已经顺序排序好了）</p><h2 id="8-OptimizeSortLimitAsTopN"><a href="#8-OptimizeSortLimitAsTopN" class="headerlink" title="8. OptimizeSortLimitAsTopN"></a>8. OptimizeSortLimitAsTopN</h2><p>适用节点：LimitPlanNode，子节点为SortPlanNode。</p><p>优化前的行为为，先全表排序，再取出前N个。</p><p>优化为，直接获得top N个数据（通过快速选择法）。</p><h1 id="2-理论优化方法"><a href="#2-理论优化方法" class="headerlink" title="2. 理论优化方法"></a>2. 理论优化方法</h1><h2 id="1-Hash-Join"><a href="#1-Hash-Join" class="headerlink" title="1. Hash Join"></a>1. Hash Join</h2><p>join的判断条件如果为相等，可以直接用哈希表处理。</p><h2 id="2-小表驱动大表"><a href="#2-小表驱动大表" class="headerlink" title="2. 小表驱动大表"></a>2. 小表驱动大表</h2><p>join时，如果为loop join，保证外循环的表是小表。</p><p>因为内循环的表存在内存中，所以数据库驱动次数等于外循环的表取数据次数，即外循环次数。外循环为小表，数据库驱动次数少，代价小。</p><h2 id="3-谓词下推"><a href="#3-谓词下推" class="headerlink" title="3. 谓词下推"></a>3. 谓词下推</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1, t2 <span class="keyword">where</span> t1.a <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">and</span> t2.b <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>先用 <code>t1.a &gt; 3</code>与 <code>t2.b &gt; 5</code>两个条件过滤t1、t2，再进行join。</p><p>尽量把过滤条件，推到靠近叶子节点，从而减少join时产生的数据，节省计算开销。</p><p>步骤：</p><ul><li>将左外连接和右外连接转化为内连接：如果谓词条件一定会把包含NULL的行全部过滤掉，可以直接改为内连接。</li><li>区分所有条件：join的等值条件、全部来源于左孩子的条件、全部来源于右孩子的条件。</li><li>把左条件和右条件分别往左右孩子吓退，其他的保留在当前join算子。</li><li>不能推过max、limit等节点。</li></ul><h2 id="4-列裁剪"><a href="#4-列裁剪" class="headerlink" title="4. 列裁剪"></a>4. 列裁剪</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> t <span class="keyword">where</span> b <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>t有abcd四列，但显然只需要a、b两列。列裁剪在从t中读取数据时，就只读取a、b两列的数据。</p><p>步骤：</p><ul><li>自顶向下递归执行。某个节点需要用到的列，等于它自己用到的列，加上其父亲节点用到的列。</li><li>裁剪列的算子：projection、seqscan、indexscan。</li><li>添加用到的列的算子：aggregation、filter、sort、join等。</li></ul><p>具体实现：</p><ul><li>连续projection，合并为一个，只取父节点所需要的列。</li><li>projection + aggregation，改写aggregation，只截取projection需要的列。</li></ul><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><h2 id="1-sql1"><a href="#1-sql1" class="headerlink" title="1. sql1"></a>1. sql1</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.x <span class="operator">=</span> t2.x) <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t3 <span class="keyword">ON</span> t2.y <span class="operator">=</span> t3.y;</span><br></pre></td></tr></table></figure><p>优化思路：</p><ul><li>t1表有索引，但是bustub只能识别右子节点的索引，所以如果左子节点有索引，需要交换位置。</li><li>join条件为两列相等时，可以优化为hashjoin。</li><li>NestedLoopJoinPlanNode一般左子节点为小表，右子节点为大表，小表驱动大表。<ul><li>因为右子节点数据放在内存中，所以数据库驱动次数即为左子节点数据个数，左子节点为小表，数据库驱动次数少，代价低。</li></ul></li></ul><p>大致优化流程如图：</p><p><img src="https://pic3.zhimg.com/80/v2-d35326c195a74d1d71f965273e9157d6_720w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-d35326c195a74d1d71f965273e9157d6_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"><img src="https://pic3.zhimg.com/80/v2-d653683e7e4108982b71280c34fc2506_720w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-d653683e7e4108982b71280c34fc2506_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h3 id="1-OptimizePickIndex"><a href="#1-OptimizePickIndex" class="headerlink" title="1. OptimizePickIndex"></a>1. OptimizePickIndex</h3><p>适用节点：NestedLoopJoinPlanNode，且左子节点为SeqScan，且join的列是索引列。</p><p>具体逻辑：</p><ul><li>改写NestedLoopJoinPlanNode的predicate，交换等号两边。</li><li>改写NestedLoopJoinPlanNode的schema，交换两边列的顺序。</li><li>用改写后的predicate与schema建立新的NestedLoopJoinPlanNode并返回。</li></ul><h3 id="2-OptimizeNLJAsIndexJoin"><a href="#2-OptimizeNLJAsIndexJoin" class="headerlink" title="2. OptimizeNLJAsIndexJoin"></a>2. OptimizeNLJAsIndexJoin</h3><p>1里说过，将NLJ优化为NIJ</p><h3 id="3-OptimizeNLJAndNIJ"><a href="#3-OptimizeNLJAndNIJ" class="headerlink" title="3. OptimizeNLJAndNIJ"></a>3. OptimizeNLJAndNIJ</h3><p>适用节点：NestedLoopJoinPlanNode，且左子节点为NIJ，右子节点与左子节点的子节点均为SeqScan或MockScan。（也可以是右子节点为NIJ，懒得实现了）</p><p>具体逻辑：</p><ul><li>用t2与t3生成新的NLJ的predicate。</li><li>用t2与t3的columns生成新的NLJ的schema。</li><li>在上一步的基础上加上t1的columns，得到新的NIJ的schema。</li><li>构造如图所示的NIJ节点。</li></ul><h3 id="4-OptimizeJoinReorder"><a href="#4-OptimizeJoinReorder" class="headerlink" title="4. OptimizeJoinReorder"></a>4. OptimizeJoinReorder</h3><p>适用节点：NestedLoopJoinPlanNode，且左右子节点均为SeqScan或MockScan。</p><p>具体逻辑：</p><ul><li>调用 <code>EstimatedCardinality()</code>估算左右子节点的数据量级。</li><li>如果左子节点数据量级较大，需要交换两个节点来使小表驱动大表。<ul><li>改写predicate。</li><li>改写schema。</li><li>构造新的NestedLoopJoinPlanNode节点。</li></ul></li></ul><h3 id="5-HashJoin"><a href="#5-HashJoin" class="headerlink" title="5. HashJoin"></a>5. HashJoin</h3><p>后续，最后一步的NLJ节点会被优化为HashJoin节点。</p><h2 id="2-sql2"><a href="#2-sql2" class="headerlink" title="2. sql2"></a>2. sql2</h2><p>待填坑</p>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab3-3</title>
      <link href="/2023/05/01/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab3-3/"/>
      <url>/2023/05/01/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab3-3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h1><h2 id="1-order-bys"><a href="#1-order-bys" class="headerlink" title="1. order_bys_"></a>1. order_bys_</h2><p>存在于SortPlanNode等相关的PlanNode中，表示排序规则。</p><p>是pair数组，pair的两个元素类型为OrderByType与AbstractExpressionRef。</p><p>OrderByType：分为INVALID、DEFAULT、ASC与DESC，即升序还是降序排序。（INVALID与DEFAULT都当作升序处理）</p><p>AbstractExpressionRef：排序依据的字段。</p><p>对于语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> t1.x <span class="keyword">asc</span>, t1.y <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>order_bys_数组即类似为：其中t1.x与t1.y应为ColumnValueExpression，即取表中特定的某列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;ASC, t1.x&#125;, &#123;DESC, t1.y&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-Sort"><a href="#1-Sort" class="headerlink" title="1. Sort"></a>1. Sort</h2><p>功能：支持order by，包括default（默认为升序，即asc）、asc、desc三种排序方式。</p><p>因为 <code>Next()</code>是按排序后的结果返回的，所以需要先在 <code>Init()</code>里存储并排序子节点的所有数据。</p><p>添加的数据结构：</p><ul><li>child_：子节点。</li><li>child_tuples_：子节点传上来的tuple数组。</li><li>child_iter_：tuple数组的迭代器。</li></ul><p><code>Init()</code>：存储子节点传上来的所有tuple，并排序。</p><ul><li>初始化子节点。</li><li>调用子节点的 <code>Next()</code>，将所有tuple存入child_tuples_。</li><li>调用 <code>sort()</code>方法排序，传入自定义排序规则：<ul><li>plan取出order_by数组，遍历其中用于排序的所有key。</li><li>根据排序规则（正序还是逆序），通过AbstractExpression的 <code>Evaluate()</code>方法计算出两个元组用于排序的值，然后进行比较。</li><li>如果能比较出结果，就直接返回比较结果。否则如果相等，就继续比较order_by的下一个key。</li><li>如果遍历完了order_by还没有比较完毕，返回false。（一般不可能）</li></ul></li><li>迭代器调整为排序后的数组起点。</li></ul><p><code>Next(Tuple *tuple, RID *rid)</code>：<code>Init()</code>已经处理好，只需要遍历即可。</p><ul><li>如果迭代器已到达终点，返回false。</li><li>tuple、rid传入迭代器当前的值。</li><li>迭代器向前一步。</li><li>返回true。</li></ul><h2 id="2-Limit"><a href="#2-Limit" class="headerlink" title="2. Limit"></a>2. Limit</h2><p>功能：支持limit，即选出前n个元素。</p><p>只是带个limit数目限制的SeqScan，跟SeqScan类似构造。</p><p>添加的数据结构：</p><ul><li>child_executor_：子节点。</li><li>count_：当前已经选出的元素个数。</li></ul><p><code>Init()</code>：</p><ul><li>初始化子节点。</li></ul><p><code>Next(Tuple *tuple, RID *rid)</code>：</p><ul><li>如果count_大于limit，返回false。</li><li>调用子节点的 <code>Next()</code>，返回获取到的结果。</li></ul><h2 id="3-TopN"><a href="#3-TopN" class="headerlink" title="3. TopN"></a>3. TopN</h2><p>功能：order by和limit连用时，优化为一个topn节点。</p><p>添加的数据结构：</p><ul><li>child_executor_：子节点。</li><li>topn_：N的数值。</li><li>tuples_：子节点的数据。</li><li>count_：<code>Next()</code>下一个应该取的位置。</li></ul><p><code>Init()</code>：与sort类似，需要先在TopN中取出子节点所有数据，并处理完毕。</p><ul><li>初始化子节点。</li><li>子节点调用 <code>Next()</code>取出所有数据，存入tuples_中。</li><li>自定义排序规则cmp（用的sort里的）</li><li>topn_取与tuples_.size()的最小值。</li><li>快速选择法，挑出tuples_中的前topn_个元素，放在前topn_个位置。</li><li>对前topn_个位置sort。</li></ul><p><code>Next(Tuple *tuple, RID *rid)</code>：tuples_的前topn_个元素是有序的，所以遍历即可。</p><ul><li>如果count_不小于topn_，返回false。</li><li>tuple、rid传入当前遍历位置的元素。</li><li>返回true。</li></ul><h2 id="4-优化：TopN替代Sort-Limit"><a href="#4-优化：TopN替代Sort-Limit" class="headerlink" title="4. 优化：TopN替代Sort+Limit"></a>4. 优化：TopN替代Sort+Limit</h2><p>实现TopN后，还需要实现对应的优化规则，才能生效。</p><p>需要实现sort_limit_as_topn.cpp中的OptimizeSortLimitAsTopN函数。</p><p>输入：AbstractPlanNodeRef &amp;plan：待优化的plan节点。</p><p>输出：AbstractPlanNodeRef：优化后的plan节点。</p><p>具体逻辑：</p><ul><li>先取出plan的所有子节点，后序遍历：对其递归调用OptimizeSortLimitAsTopN，优化所有子节点。</li><li>调用plan的 <code>CloneWithChildren()</code>，通过优化后的子节点拷贝出新的optimized_plan。</li><li>优化条件为：plan节点为limit，且plan的唯一子节点为sort，且plan的唯一子节点也有唯一子节点。<ul><li>满足优化条件时，通过plan的schema、plan的孙子节点、order_by排序规则与limit数目，构造指向topn节点的指针，并返回。</li><li>否则，返回optimized_plan。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab3-2</title>
      <link href="/2023/04/27/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab3-2/"/>
      <url>/2023/04/27/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab3-2/</url>
      
        <content type="html"><![CDATA[<p>因为整个lab3都是实现算子，所以也没啥其他好说的了。</p><h1 id="1-理解与额外的数据结构"><a href="#1-理解与额外的数据结构" class="headerlink" title="1. 理解与额外的数据结构"></a>1. 理解与额外的数据结构</h1><h2 id="1-Aggregation"><a href="#1-Aggregation" class="headerlink" title="1. Aggregation"></a>1. Aggregation</h2><p>支持GROUP BY，将每组数据聚合起来。即为，对于每一组数据，通过传入的函数（count、sum、max、min等）计算出该组数据的结果。</p><p>课程网站称其为pipline breaker，意思是打破了火山模型“通过Next逐条获取结果”的规则。</p><p>因为调用一次 <code>Next()</code>返回的是一组的结果，而不是单个tuple，所以需要在 <code>Init()</code>里就将所有组的结果计算出来存起来，调用 <code>Next()</code>再一条条返回结果。</p><h3 id="1-SimpleAggregationHashTable"><a href="#1-SimpleAggregationHashTable" class="headerlink" title="1. SimpleAggregationHashTable"></a>1. SimpleAggregationHashTable</h3><p>哈希表，用于计算并保存Aggregation的结果。</p><p>key为AggregateKey，value为AggregateValue，底层类型均为vector&lt;Value&gt;。</p><ul><li>key代表作为group by依据的字段。</li><li>value代表需要aggregate的字段。</li><li>此外，维护一个exprs，大小与value大小相等，代表aggregate的类型，如count、sum等。</li></ul><p>具体的来说，对于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">min</span>(t.z), <span class="built_in">max</span>(t.z), <span class="built_in">sum</span>(t.z) <span class="keyword">FROM</span> t <span class="keyword">GROUP</span> <span class="keyword">BY</span> t.x, t.y;</span><br></pre></td></tr></table></figure><ul><li>key为{t.x, t.y}</li><li>value为{t.z, t.z, t.z}</li><li>exprs为{min, max, sum}</li></ul><h2 id="2-AbstractExpression"><a href="#2-AbstractExpression" class="headerlink" title="2. AbstractExpression"></a>2. AbstractExpression</h2><p>抽象表达式，作为所有表达式的父类。</p><p>对于sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> t1.x <span class="operator">=</span> t1.y <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AND</span> t1.y <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>有这样的抽象语法树</p><p><img src="https://blog.eleven.wiki/imgs/15-445-3-5.png" class="lazyload placeholder" data-srcset="https://blog.eleven.wiki/imgs/15-445-3-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>AbstractExpression即为抽象语法树的每个节点，维护了：</p><ul><li>vector&lt;AbstractExpressionRef&gt; children_：共享指针指向其子节点。</li><li>TypeId ret_type_：表达式的返回值类型。</li></ul><p>同时提供了接口 <code>Evaluate()</code>、<code>EvaluateJoin()</code>供子类实现，计算返回值。</p><p>子类包括：</p><ul><li>ArithmeticExpression：算术表达式，支持加减运算。有左右子节点，且要求左右子节点求值为int型。<ul><li><code>Evaluate()</code>：先调用左右子节点的 <code>Evaluate()</code>得到Value，然后在PerformComputation()中，通过模拟整数加减进行运算。</li><li><code>EvaluateJoin()</code>：与 <code>Evaluate()</code>类似，只不过左右子树同样调用 <code>EvaluateJoin()</code>。</li></ul></li><li>ColumnValueExpression：表示表中的某一列，类似table.member。接受一个tuple，返回其中特定列的值。本身便是值，所以没有子节点。<ul><li><code>Evaluate()</code>：直接调用传入的tuple的 <code>GetValue()</code>。</li><li><code>EvaluateJoin()</code>：成员tuple_idx_表示是left join还是right join，0表示left，调用left_tuple的 <code>GetValue()</code>，否则表示right，调用right_tuple的 <code>GetValue()</code>。</li></ul></li><li>ConstantValueExpression：表示常量值，两个方法都永远返回常数成员val。</li><li>ComparisonExpression/LogicExpression：都是二元操作符，跟ArithmeticExpression类似。</li></ul><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-Aggregation-1"><a href="#1-Aggregation-1" class="headerlink" title="1. Aggregation"></a>1. Aggregation</h2><p>功能：支持GROUP BY，将每组数据聚合起来。</p><p>添加的数据结构：</p><ul><li>child_：指向子节点的unique指针，需要根据子节点传过来的数据聚合。</li><li>SimpleAggregationHashTable aht_：存储group by的结果。</li><li>SimpleAggregationHashTable::Iterator aht_iterator_：哈希表的迭代器。</li></ul><p>需要先实现SimpleAggregationHashTable的某个函数：</p><p><code>GenerateInitialAggregateValue()</code>：生成初始值。</p><ul><li>对于countstar类型，应该生成整型0值作为初始值。</li><li>对于其他类型，应该生成整型null值作为初始值。</li></ul><p><code>CombineAggregateValues(AggregateValue *result, const AggregateValue &amp;input)</code>：把input的结果聚合到result中。</p><ul><li>遍历每个聚合字段，按聚合类型分类：<ul><li>对于countstar类型，因为是计数，所以result对应位置自增1。</li><li>对于count类型，与countstar的区别是，初始化为空值。<ul><li>result值为空时，初始化为0。</li><li>input值不为空时，result对应位置自增1。</li></ul></li><li>对于sum、min、max类型<ul><li>result值为空时，初始化为input对应位置的值。</li><li>input值不为空时，result对应位置与input对应位置进行相应运算。</li></ul></li></ul></li></ul><p><code>InsertCombine(const AggregateKey &amp;agg_key, const AggregateValue &amp;agg_val)</code>：向哈希表中插入一条记录。</p><ul><li>如果哈希表中不存在agg_key，插入初始记录。</li><li>调用 <code>CombineAggregateValues()</code>聚合该条记录。</li></ul><p>executor的函数：</p><p><code>Init()</code>：需要先在 <code>Init()</code>中完成所有聚合的逻辑。</p><ul><li>先调用child_的 <code>Init()</code></li><li>循环调用child_的 <code>Next()</code>函数，把获取的tuple通过aht_的 <code>InsertCombine()</code>插入到哈希表中，并在哈希表中聚合。</li><li>如果在循环结束后，aht_的大小仍为0，需要插入一个空值。</li><li>把迭代器调整为哈希表开头。</li></ul><p><code>Next(Tuple *tuple, RID *rid)</code>：</p><ul><li>如果迭代器到达哈希表末端，返回false。</li><li>把迭代器当前指向的k-v都装入vector中。</li><li>用vector创建tuple，传入指针参数。</li><li>迭代器自增。</li><li>返回true。</li></ul><h2 id="2-NestedLoopJoin"><a href="#2-NestedLoopJoin" class="headerlink" title="2. NestedLoopJoin"></a>2. NestedLoopJoin</h2><p>功能：支持left join与inner join。join操作就是，根据两个表中相同的字段，将这两个表中对应的元组都提取出来。</p><p>NestedLoopJoin，顾名思义，就是双重循环遍历左表与右表，逐个匹配。</p><p>细节踩坑点：</p><ul><li>右表Next只能获取右表中每个元组各一次，而双重循环思想需要对左表的每个元组都遍历右表。<ul><li>提前获取右表的所有元素并存起来。</li></ul></li><li>右表中可能有多个元组与左表匹配。<ul><li>额外存储当前遍历到的右表的位置，下一次调用next时从该位置出发遍历。</li></ul></li></ul><p>添加的数据结构：</p><ul><li>left_executor_：join的操作数是两张表，所以有两个子节点。</li><li>right_excutor_：右子节点。</li><li>left_tuple_：当前遍历到的左元组。</li><li>right_tuples_：提前把所有右元组提取出来。</li><li>right_tuple_index_：当前遍历到的右元组位置。</li></ul><p><code>Init()</code>：</p><ul><li>左右子节点初始化。</li><li>调用右子节点的 <code>Next()</code>将右子节点的数据全部读出来，存在right_tuples中。</li></ul><p><code>Next(Tuple *tuple, RID *rid)</code>：</p><ul><li>right_tuple_index_不小于0，或左子节点 <code>Next()</code>为true时，表示还有数据可以取，进入循环，否则直接返回false，表示已经没有数据了。</li><li>从right_tuple_index_开始遍历right_tuples_，找到下一条能Join的数据。<ul><li>通过plan_的 <code>Predicate()</code>获取join的表达式，然后通过表达式的 <code>EvaluateJoin()</code>方法返回值是否不为空且为true，判断是否找到Join的数据。</li></ul></li><li>找到数据，则遍历左右tuple的所有列，将值都传入vals数组中，再根据vals构造tuple，传入参数；更新right_tuple_index_的位置；返回true。</li><li>如果遍历了完整的right_tuples_都没有找到，且为left join，需要将vals右节点对应的列全部设置为空，传入tuple，再返回true。</li><li>如果在上面两个条件中都没有返回，说明需要重新获取左节点的tuple，将right_tuple_index_设置为-1，继续循环。</li></ul><h2 id="3-NestedIndexJoin"><a href="#3-NestedIndexJoin" class="headerlink" title="3. NestedIndexJoin"></a>3. NestedIndexJoin</h2><p>功能：NestLoopJoin的另一种版本，其中的一列是索引时，会被优化为NestedIndexJoin。</p><p>添加的数据结构：</p><ul><li>child_executor_：只需要一个子节点，另一个是索引。</li><li>IndexInfo *index_info_：索引元信息。</li><li>TableInof *table_info_：索引所在的表信息，因为非聚簇索引需要回表。</li><li>BPlusTreeIndexForOneIntegerColumn *tree_index_：索引。</li></ul><p><code>Init()</code>：</p><ul><li>子节点初始化。因为另一列的数据已经在索引表中了，所以不需要在 <code>Init()</code>中查找到并存储。</li></ul><p><code>Next(Tuple *tuple, RID *rid)</code>：</p><ul><li>如果子节点的 <code>Next()</code>返回true，说明还有没处理的数据，进入循环。否则返回false，表示已经没有数据了。</li><li>通过plan_的 <code>Predicate()</code>获取join的表达式，然后通过表达式的 <code>Evaluate()</code>方法获取子节点需要join的列。</li><li>通过tree_index_的 <code>ScanKey()</code>方法，在索引中搜索是否有等于该列值的元组。<ul><li>如果在索引中找到，先回表查找到完整数据tuple，然后与NestedLoopJoin类似，将左右元组中所有列的值都都传入vals数组中，再根据vals构造tuple，传入参数，返回true。</li><li>如果在索引中没找到，且为left join，需要将vals右节点对应的列全部设置为空，传入tuple，再返回true。</li></ul></li><li>否则，代表 <code>Next()</code>获取的左tuple在索引中没有对应的数据，且为inner join不需要返回空，继续循环，取下一个左tuple。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab3-1</title>
      <link href="/2023/04/24/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab3-1/"/>
      <url>/2023/04/24/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab3-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Bustub架构"><a href="#1-Bustub架构" class="headerlink" title="1. Bustub架构"></a>1. Bustub架构</h1><p>Lab1写的是实现缓存池替换的buffer_pool_manager，Lab2写的是B+树的底层实现，都是整个数据库的一个局部。</p><p>Lab3需要实现具体的数据库语句逻辑，所以需要先了解数据库整体的架构。</p><p><img src="https://pic4.zhimg.com/80/v2-59c2d164f467b9a3de77546a61dcd6bf_1440w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-59c2d164f467b9a3de77546a61dcd6bf_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="1-Parser"><a href="#1-Parser" class="headerlink" title="1. Parser"></a>1. Parser</h2><p>sql语句通过Parser生成一棵AST抽象语法树。</p><p>一般不会成为性能瓶颈，所以采用第三方库生成。</p><p>bustub采用了libpg_query库生成AST。</p><h2 id="2-Binder"><a href="#2-Binder" class="headerlink" title="2. Binder"></a>2. Binder</h2><p>Binder将AST中的词语绑定到数据库实体上。</p><p>比如，对于sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> colA <span class="keyword">from</span> table1;</span><br></pre></td></tr></table></figure><p>select与from是关键字，colA与table1是标识符。Binder遍历AST，将这些词语绑定到相应的实体，在bustub中属于各种类。</p><p>最终得到一棵bustub能理解的树，称为bustub AST。</p><h2 id="3-Planner"><a href="#3-Planner" class="headerlink" title="3. Planner"></a>3. Planner</h2><p>Planner遍历bustub AST，得到初步的查询计划。查询计划规定了数据的流向，数据从树叶流向树根，在根节点输出结果。</p><p>对于sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b <span class="keyword">from</span> t1, t2 <span class="keyword">where</span> t1.c <span class="operator">=</span> t2.c <span class="keyword">and</span> t1.a <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>生成的未经优化的查询计划为：</p><ul><li>需要查t1、t2两个表，对应的DataSrouce（在bustub里为Scan）负责将数据捞上来。</li><li>Join算子，将两个表按 <code>t1.c = t2.c</code>连接。</li><li>Selection过滤出 <code>t1.a &gt; 5</code>的数据。</li><li>Projection将b列投影出来。</li></ul><p><img src="https://img1.www.pingcap.com/prod/1_5d26a18dc3.png" class="lazyload placeholder" data-srcset="https://img1.www.pingcap.com/prod/1_5d26a18dc3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>本项目中，不同的Plan对应着不同的PlanNode类，构造Executor时传入PlanNode作为参数，提供必要的信息。</p><h2 id="4-Optimizer"><a href="#4-Optimizer" class="headerlink" title="4. Optimizer"></a>4. Optimizer</h2><p>初步的查询计划由Optimizer修改优化。主要有两种实现方式：</p><ul><li>（bustub实现）Rule-based：遍历查询计划，根据已定义好的一系列规则对PlanNode进行修改、聚合等操作。Optimizer不需要知道数据的具体内容，只根据预定义规则修改。<ul><li>即：每一条优化规则对应一个函数，对查询计划按一定顺序依次应用所有优化规则函数。</li></ul></li><li>Cost-based：先读取树，利用统计学模型预测不同形式但结果等价的查询计划的cost，最后选取cost最小的查询计划。</li></ul><p>一般来说，Planner生成Logical Plan Node，代表抽象的计划；而Optimizer生成Physical Plan Node，代表具体的计划。</p><p>抽象计划中，只有Join；具体计划中，会被优化成具体的HashJoin或NestedIndexJoin。</p><p>而在bustub中，不区分抽象与具体的Node，Planner直接生成具体计划。</p><h2 id="5-Executor"><a href="#5-Executor" class="headerlink" title="5. Executor"></a>5. Executor</h2><p>本lab主要实现的内容，即为一系列算子。</p><p>遍历查询计划树，将树上的PlanNode替换成Executor。</p><p>算子的执行模型大致分为三种：</p><ul><li>Iterator Model/火山模型：每个算子都有 <code>Init()</code>与 <code>Next()</code>两个方法。<code>Init()</code>初始化算子，<code>Next()</code>向下层算子请求下一条数据。当 <code>Next()</code>返回false时，表示下层算子没有剩余数据，迭代结束。<ul><li>一次调用请求一条数据，占用内存少，但函数调用开销大，特别是虚函数调用，容易造成cache miss问题。</li></ul></li><li>Materialization Model：所有算子立即计算出所有结果并返回。<ul><li>与Iterator相反，数据量大时内存占用很高，但减少了函数调用开销。</li></ul></li><li>Vectorization Model：上面两种模型的中和，一次调用返回一批数据。</li></ul><p>bustub采用火山模型。</p><p>算子执行方向也有两种：</p><ul><li>Top-to-Bottom：从根节点算子开始，不断pull下层算子数据。</li><li>Bottom-to-Top：从叶子节点算子开始，向上层算子push自己的数据。</li></ul><p>bustub采用Top-to-Bottom。</p><h2 id="6-获得结果"><a href="#6-获得结果" class="headerlink" title="6. 获得结果"></a>6. 获得结果</h2><p>最终，在根节点获得想要查询的数据，一次sql查询结束。</p><h2 id="7-与前两个lab的关联"><a href="#7-与前两个lab的关联" class="headerlink" title="7. 与前两个lab的关联"></a>7. 与前两个lab的关联</h2><p>某些算子执行时，需要遍历table或索引（根据Lab 2的B+树实现），一个table由许多page组成，访问page时用到了Lab 1实现的Buffer Pool。</p><h2 id="8-一些不需要实现的辅助数据结构"><a href="#8-一些不需要实现的辅助数据结构" class="headerlink" title="8. 一些不需要实现的辅助数据结构"></a>8. 一些不需要实现的辅助数据结构</h2><h3 id="1-ExecutorContext"><a href="#1-ExecutorContext" class="headerlink" title="1. ExecutorContext"></a>1. ExecutorContext</h3><p>初始化算子时传入，提供算子执行时的上下文。</p><p>作用为提供一系列数据结构，如Transaction、Catalog、BufferPoolManager等。</p><h3 id="2-Catalog"><a href="#2-Catalog" class="headerlink" title="2. Catalog"></a>2. Catalog</h3><p>通过ExecutorContext的GetCatalog()获得。</p><p>作用为存储一个数据库的元数据，包括表名、索引、视图、用户权限等信息。</p><h3 id="3-TableInfo"><a href="#3-TableInfo" class="headerlink" title="3. TableInfo"></a>3. TableInfo</h3><p>通过Catalog的GetTable()获得。</p><p>作用为存储一张表的元数据，包括schema、name、table_heap与OID。</p><h3 id="4-Schema"><a href="#4-Schema" class="headerlink" title="4. Schema"></a>4. Schema</h3><p>规定一张表存储数据的格式，即表头的元数据，包括每一列的名字、存储的数据类型等。</p><h3 id="4-TableHeap"><a href="#4-TableHeap" class="headerlink" title="4. TableHeap"></a>4. TableHeap</h3><p>记录在TableInfo结构中。</p><p>作用为表的增删改查以及回滚删除。</p><p>可能由多个table page组成，但只保存第一个table page的id，访问某个page时通过page id经由buffer pool访问。</p><h3 id="5-TablePage"><a href="#5-TablePage" class="headerlink" title="5. TablePage"></a>5. TablePage</h3><p>继承自父类Page，实际存储table的数据。</p><p>在data开头存放next page id与prev page id，将多个table page连成双向链表，便于整表遍历。</p><h3 id="6-TableIterator"><a href="#6-TableIterator" class="headerlink" title="6. TableIterator"></a>6. TableIterator</h3><p>TableHeap的迭代器。对table按行遍历。</p><p>值为Tuple。</p><h3 id="7-Tuple"><a href="#7-Tuple" class="headerlink" title="7. Tuple"></a>7. Tuple</h3><p>table中的一行数据，由RID唯一标识。</p><p>由value构成，value个数和类型由table info中的schema指定。</p><h3 id="8-IndexInfo"><a href="#8-IndexInfo" class="headerlink" title="8. IndexInfo"></a>8. IndexInfo</h3><p>维护一个索引表的所有元数据，如该索引所在表的名称、索引名称等。</p><h1 id="2-已经实现的Executor"><a href="#2-已经实现的Executor" class="headerlink" title="2. 已经实现的Executor"></a>2. 已经实现的Executor</h1><p>executor自己不保存查询计划信息，而应该通过其成员plan获得如何进行本次计算。</p><h2 id="1-AbstractExecutor"><a href="#1-AbstractExecutor" class="headerlink" title="1. AbstractExecutor"></a>1. AbstractExecutor</h2><p>所有Executor的父类</p><h2 id="2-FilterExecutor"><a href="#2-FilterExecutor" class="headerlink" title="2. FilterExecutor"></a>2. FilterExecutor</h2><p>根据表达式筛选数据，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> t1.x <span class="operator">=</span><span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>循环通过child executor的next()获得一条数据。</p><ul><li>如果child executor的next()返回false，代表已经没有数据了，返回false。</li><li>否则即为有数据，通过自己的predicate（谓词，在本executor中即为过滤条件）进行计算<ul><li>如果计算结果为true，表示符合筛选条件，返回true。</li><li>否则，继续循环。</li></ul></li></ul><h2 id="3-MockScanExecutor"><a href="#3-MockScanExecutor" class="headerlink" title="3. MockScanExecutor"></a>3. MockScanExecutor</h2><p>似乎与SeqScan差别不大</p><h2 id="4-ProjectionExecutor"><a href="#4-ProjectionExecutor" class="headerlink" title="4. ProjectionExecutor"></a>4. ProjectionExecutor</h2><p>投影，即从表中选出特定的列，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> x, y <span class="keyword">from</span> t1</span><br></pre></td></tr></table></figure><p>过程：</p><ul><li>获得child executor的一条数据tuple</li><li>获取当前节点应该输出的所有表达式，如对于上面的语句，表达式分别为x、y</li><li>将tuple传入每条表达式，计算输出</li><li>将所有输出作为一条tuple，传给父节点</li></ul><h2 id="5-ValuesExecutor"><a href="#5-ValuesExecutor" class="headerlink" title="5. ValuesExecutor"></a>5. ValuesExecutor</h2><p>创建一行新tuple。</p><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>bustub使用的是火山模型：</p><ul><li>每个算子都有 <code>Init()</code>与 <code>Next()</code>两个方法。<ul><li><code>Init()</code>初始化算子。</li><li><code>Next(Tuple *tuple, RID *rid)</code>向下层算子请求下一条数据。当 <code>Next()</code>返回false时，表示下层算子没有剩余数据，迭代结束。</li></ul></li><li>一次调用请求一条数据，占用内存少，但函数调用开销大，特别是虚函数调用，容易造成cache miss问题。</li></ul><p>所以，以下每个算子的实现都分为 <code>Init()</code>与 <code>Next()</code>两个方法。</p><h2 id="1-SeqScan"><a href="#1-SeqScan" class="headerlink" title="1. SeqScan"></a>1. SeqScan</h2><p>功能：顺序扫描数据表。</p><p>添加的数据结构：</p><ul><li>TableInfo *table_info_：通过exec_ctx_获得catalog，然后通过plannode获得要查找的表id，接着根据表id在catalog中查找到表的元数据。</li><li>TableIterator table_iter：要查找的表的迭代器。</li></ul><p><code>Init()</code>：</p><ul><li>空。因为数据结构都在构造函数中初始化了。</li></ul><p><code>Next(Tuple *tuple, RID *rid)</code>：SeqScan是最底层的算子，所以只需要向指针参数提供数据。</p><ul><li>判断迭代器是否已经到达终点，如果是则返回false。</li><li>取出迭代器当前指向的元组tuple与rid，传给参数。</li><li>迭代器自增。</li><li>返回true。</li></ul><h2 id="2-Insert"><a href="#2-Insert" class="headerlink" title="2. Insert"></a>2. Insert</h2><p>功能：向数据表中插入一条元组。</p><p>添加的数据结构：</p><ul><li>TableInfo *table_info_</li><li>std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;child_executor_：子节点的指针。因为需要插入的是子节点传过来的数据。</li><li>std::vector&lt;IndexInfo *&gt; table_indexes_：保存当前表的所有索引。因为插入一条元组需要同时向该表的所有索引表都插入。通过catalog获得。</li><li>bool is_end_：标识插入是否结束。</li></ul><p><code>Init()</code>：</p><ul><li>调用子节点的 <code>Init()</code>函数。</li></ul><p><code>Next(Tuple *tuple, RID *rid)</code>：需要接收子节点传来的数据，然后插入。tuple中装的是此次成功插入的tuple数目。</p><ul><li>如果结束标识为true，返回false。</li><li>调用子节点的Next()获取下层传入的tuple、rid，如果返回true表示有数据，进入循环：<ul><li>在table_info_里找到table_heap结构，通过InsertTuple()插入获取的tuple。</li><li>如果插入成功，根据table_indexes_对所有索引表插入tuple。<ul><li>tuple需要根据KeyFromTuple()方法调整结构。</li></ul></li><li>增加count。</li></ul></li><li>用count构造一个tuple，传入指针参数，is_end_置为true，返回true。</li></ul><h2 id="3-delete"><a href="#3-delete" class="headerlink" title="3. delete"></a>3. delete</h2><p>功能：在数据表中删除一条元组。删除并不是真的删除，而只是标记该数据已删除。</p><p>添加的数据结构：</p><ul><li>TableInfo *table_info_</li><li>std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;child_executor_：子节点的指针。因为需要删除的是子节点传过来的数据。</li><li>std::vector&lt;IndexInfo *&gt; table_indexes_：保存当前表的所有索引。因为删除一条元组需要同时在该表的所有索引表都删除。通过catalog获得。</li><li>bool is_end_：标识删除是否结束。</li></ul><p><code>Init()</code>：</p><ul><li>调用子节点的 <code>Init()</code>函数。</li></ul><p><code>Next(Tuple *tuple, RID *rid)</code>：需要接收子节点传来的数据，然后删除。tuple中装的是此次成功删除的tuple数目。</p><ul><li>如果结束标识为true，返回false。</li><li>调用子节点的Next()获取下层传入的tuple、rid，如果返回true表示有数据，进入循环：<ul><li>在table_info_里找到table_heap结构，通过MarkDelete()删除获取的tuple。</li><li>如果删除成功，根据table_indexes_对所有索引表删除tuple。<ul><li>tuple需要根据KeyFromTuple()方法调整结构。</li></ul></li><li>增加count。</li></ul></li><li>用count构造一个tuple，传入指针参数，is_end_置为true，返回true。</li></ul><h2 id="4-IndexScan"><a href="#4-IndexScan" class="headerlink" title="4. IndexScan"></a>4. IndexScan</h2><p>功能：根据索引扫描。底层需要用到Lab2实现的B+树。</p><p>添加的数据结构：</p><ul><li>IndexInfo *index_info_：索引信息</li><li>TableInfo *table_info_：表信息</li><li>BPlusTreeIndexForOneIntegerColumn *tree_index_：索引类型</li><li>BPlusTreeIndexIteratorForOneIntegerColumn tree_index_iter_：索引的迭代器</li></ul><p><code>Init()</code>：空。因为数据结构都在构造函数中初始化了。</p><p><code>Next(Tuple *tuple, RID *rid)</code>：IndexScan是最底层的算子，所以只需要向指针参数提供数据。</p><ul><li>如果tree_index_iter_迭代结束，返回false。</li><li>通过tree_index_iter_取出当前迭代索引项的rid。</li><li>在表中通过GetTuple()查找到tuple信息。<ul><li>因为Lab2实现的都是非聚簇索引，叶子节点只存储tuple的rid，所以需要“回表”，即在原表中根据rid找到tuple具体数据。</li></ul></li><li>tree_index_iter_前进一步。</li><li>返回GetTuple()的结果，代表是否查找成功。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-golang</title>
      <link href="/2023/04/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-golang/"/>
      <url>/2023/04/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-golang/</url>
      
        <content type="html"><![CDATA[<p>鹅实习要转golang，先学着。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>go是一门编译型语言，与cpp类似，先静态编译，然后链接形成可执行文件。</p><p>go通过包（package）组织，类似于库、模块。</p><p>一个包由位于单个目录下的一个或多个.go源代码文件组成。</p><ul><li>每个源文件以一条package声明语句开始，表示该文件属于哪个包。</li><li>紧接着一系列import导入以来的包。</li><li>之后是程序语句。</li></ul><p>main包定义一个独立可执行程序，里面的main函数是整个程序执行的入口。</p><p>特性：</p><ul><li>只允许导入需要的包，否则无法编译通过。</li><li>编译过程没有警告信息。</li><li>编译器会主动将特定符号后的换行符转换为分号，所以：<ul><li>不需要显示添加分号，除非一行多个语句。</li><li>不能随意换行，因为以特定字符结尾可能导致添加分号。</li></ul></li><li>gofmt工具将代码格式化为标准格式，所以go语言在代码格式上很标准。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-命令行"><a href="#2-命令行" class="headerlink" title="2. 命令行"></a>2. 命令行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run helloworld.go  // 编译并运行</span><br><span class="line">go build helloworld.go  // 编译生成二进制文件，还需要通过./helloworld运行</span><br><span class="line">go get golang.org/x/tools/cmd/goimports  // 安装工具</span><br></pre></td></tr></table></figure><h1 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h1><h2 id="1-命名"><a href="#1-命名" class="headerlink" title="1. 命名"></a>1. 命名</h2><p>规则：</p><ul><li>以字母或下划线开头，后面跟字母、数字或下划线。</li><li>不能用关键字。</li><li>可以用预定义名字，如内建常量、内建类型和内建函数。</li></ul><p>命名风格：</p><ul><li>开头字母大写，代表它将是导出的，即可以被外部包访问。</li><li>包本身一般用小写字母。</li><li>尽量使用短小名字。</li><li>尽量用驼峰式命名。</li></ul><h2 id="2-声明"><a href="#2-声明" class="headerlink" title="2. 声明"></a>2. 声明</h2><p>四种类型：</p><ul><li>var：变量</li><li>const：常量</li><li>type：类型</li><li>func：函数</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varname <span class="keyword">type</span> = expression  <span class="comment">// 一般语法</span></span><br><span class="line">varname := expression  <span class="comment">// 简短声明</span></span><br></pre></td></tr></table></figure><h3 id="1-一般语法"><a href="#1-一般语法" class="headerlink" title="1. 一般语法"></a>1. 一般语法</h3><p>“type”或“= expression”可以省略其中之一。</p><ul><li>省略类型信息：根据初始化表达式来推导类型。</li><li>省略初始化表达式：用该类型的零值初始化该变量。<ul><li>数值类型：0</li><li>布尔类型：false</li><li>字符串类型：空字符串</li><li>接口或引用类型：nil</li><li>数组或结构体等聚合类型：每个元素或字段对应的零值</li></ul></li></ul><p>有初始化机制的存在，保证go语言中<strong>不存在未初始化的变量</strong>。</p><p>可以在一行初始化多个不同类型的值，类型由初始化表达式推导。</p><p>初始化时机：</p><ul><li>包级别的变量：main执行前。</li><li>局部变量：声明语句被执行到时。</li></ul><h3 id="2-简短变量声明"><a href="#2-简短变量声明" class="headerlink" title="2. 简短变量声明"></a>2. 简短变量声明</h3><p>变量类型根据表达式自动推导。</p><ul><li>简短变量声明中必须至少要声明一个新变量，否则无法编译通过。</li><li>如果左边有已经在同级词法域内声明过的变量，则只会赋值。</li><li>如果变量是在外部词法域声明，那么简短声明会重新声明一个新变量。</li></ul><h3 id="3-指针"><a href="#3-指针" class="headerlink" title="3. 指针"></a>3. 指针</h3><p><code>*type</code>表示type类型的指针。普通变量通过&amp;取地址操作获取其指针。</p><p>★ 返回局部变量的地址也是安全的。</p><p>原因：</p><ul><li><p>编译器会做逃逸分析，分析变量作用域是否跑出了函数范围。</p><ul><li>如果没有跑出，就分配在栈上</li><li>否则分配在堆上。</li></ul></li><li><p>不必担心内存泄漏，因为go语言自带垃圾回收机制。</p></li><li><p>除此之外，new的局部变量也会根据逃逸分析决定分配在栈或堆上。</p></li></ul><h3 id="4-new"><a href="#4-new" class="headerlink" title="4. new"></a>4. new</h3><p><code>new(T)</code>创建一个T类型的匿名变量，初始化为T类型零值，并返回变量地址。</p><p>类大小都是0时，可能有相同的地址。谨慎使用大小为0的类型，可能导致go的自动垃圾回收器有不同行为。</p><p>new只是预定义函数，所以可以定义成别的类型。</p><h3 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h3><p>包一级：与整个程序的运行周期一致。</p><p>局部变量：从创建的声明语句开始，直到该变量不再被引用。</p><p>如何知道一个变量可以被回收：</p><ul><li>从每个包级的变量和每个当前运行函数的每一个局部变量开始。</li><li>通过指针或引用的访问路径遍历，是否可以找到该变量。<ul><li>如果不存在这样的访问路径，说明该变量不可达，也就是说它是否存在不会影响程序后续。</li></ul></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    *y = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以x为例，f()运行结束后，依然可以通过global访问到x，所以必须分配在堆上。即，局部变量x从函数f中逃逸了。</p><p>以y为例，g()运行结束后，*y不可达，即可以马上被回收。编译器可以选择在栈上或堆上分配。</p><p>逃逸变量需要额外分配内存，同时可能影响性能优化。</p><h1 id="4-赋值"><a href="#4-赋值" class="headerlink" title="4. 赋值"></a>4. 赋值</h1><p>数值变量支持自增/自减。但与C++不同的是，自增自减<strong>是语句而不是表达式，没有返回值，所以不能将结果赋给其他值</strong>。</p><p>支持元组赋值，即类似Python的，等号两边多个变量/表达式。会先将等号右边的表达式都求出值后，统一赋值给左边的变量。</p><p>表达式/函数可能产生多个值，出现在等号右边时，左边变量的数目必须相同。</p><p>与C++类似，可以用_空白标识符占位，丢弃该位置的值。</p><h3 id="1-可赋值性"><a href="#1-可赋值性" class="headerlink" title="1. 可赋值性"></a>1. 可赋值性</h3><p>赋值语句左边的变量和右边最终求到的值必须有相同的数据类型。即右边的值对左边的变量是可赋值的。</p><p>规则：</p><ul><li>类型必须完全匹配。</li><li>nil可赋值给任何指针/引用类型的变量。</li><li>常量规则更为灵活，为了避免不必要的显式类型转换。</li></ul><p>对于值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的。</p><h1 id="5-类型"><a href="#5-类型" class="headerlink" title="5. 类型"></a>5. 类型</h1><h2 id="1-类型声明"><a href="#1-类型声明" class="headerlink" title="1. 类型声明"></a>1. 类型声明</h2><p><code>type 类型名字 底层类型</code></p><p>一般出现在包一级，在本包中用类型名字来使用底层类型。</p><p>类似于using与typedef。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span>    <span class="comment">// 摄氏温度</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="keyword">float64</span> <span class="comment">// 华氏温度</span></span><br></pre></td></tr></table></figure><p>它们有相同的底层类型float64，但是是不同的数据类型，因此不可相互比较，或混在一个表达式中计算/比较。</p><p>但是，它们各自可以与底层类型float64比较。</p><h1 id="6-包和文件"><a href="#6-包和文件" class="headerlink" title="6. 包和文件"></a>6. 包和文件</h1><p>一个包包含一个或多个go源文件。</p><p>每个包对应一个独立的名字空间。</p><p>名字是大写字母开头，则该名字导出（汉字不区分大小写，所以汉字开头的名字都不导出）。</p><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><p>包级别声明的变量，有初始化表达式，则用初始化表达式初始化。</p><p>否则，可以用特殊的init初始化函数初始化。每个文件可包含多个init初始化函数。</p><p>init函数不能被调用或引用，程序开始时每个文件中的init函数按照其声明的顺序被自动调用。</p><p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只初始化一次。</p><h1 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7. 作用域"></a>7. 作用域</h1><p>一个声明语句将程序中的实体和一个名字关联。</p><p>声明语句的作用域指源代码中可以有效使用这个名字的范围。</p><p>作用域≠生命周期。</p><ul><li>作用域：对应一个源代码的文本区域，是编译时属性。</li><li>生命周期：程序运行时变量存在的有效时间段，该时间区域内可以被程序的其他部分引用，是运行时概念。</li></ul><p>★ import导入的包只能在当前文件中访问，也就是说import当前文件的其他文件要访问当前文件import的包，必须自己import。</p><p>与C++的include展开不一样。</p><h2 id="1-句法块-词法块"><a href="#1-句法块-词法块" class="headerlink" title="1. 句法块/词法块"></a>1. 句法块/词法块</h2><p>句法块：花括弧包含的一系列语句。</p><p>句法块内部声明的名字无法被外部块访问，该块决定了内部声明的名字的作用域范围。</p><p>把块的概念推广到包括其他声明的群组，有一些声明在代码中并未显式用花括号包裹，称为词法块。</p><p>（词法块的概念包括句法块）</p><ul><li>对全局源代码，存在一个整体词法块，称为全局词法块。</li><li>对于每个包、每个for、if和switch语句，也有对应的词法块。</li><li>显示书写的词法块（花括号包裹）</li></ul><p>编译器遇到名字引用时，会从当前词法域从内层往外查找。</p><p>如果该名字在多个词法域都声明过，内部的声明首先被找到，因此屏蔽了外部同名的声明，让外部声明的名字无法被找到。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> x &#123;</span><br><span class="line">        x := x + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c&quot;</span>, x) <span class="comment">// &quot;HELLO&quot; (one letter per iteration)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个x变量生命在不同的词法域：</p><ul><li>函数体词法域</li><li>for隐式的初始化词法域</li><li>for循环体词法域</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, err := os.Open(fname); err != <span class="literal">nil</span> &#123; <span class="comment">// compile error: unused: f</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.ReadByte() <span class="comment">// compile error: undefined f</span></span><br><span class="line">f.Close()    <span class="comment">// compile error: undefined f</span></span><br></pre></td></tr></table></figure><p>f的作用域只在if语句内，所以后面的语句无法引入。</p><h1 id="8-基础类型"><a href="#8-基础类型" class="headerlink" title="8. 基础类型"></a>8. 基础类型</h1><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1. 整型"></a>1. 整型</h2><p>int8、int16、int32、int64：对应bit大小的有符号整数</p><p>uint8、uint16、uint32、uint64：对应bit大小的无符号整数</p><p>rune：Unicode字符类型，表示一个Unicode码点。与int32等价。</p><p>byte：强调数值是一个原始的数据。与int8等价。</p><p>uintpr：没有指定具体bit大小，足以容纳指针。</p><p>int/uint：默认为32bit，但是与int/uint32是不同类型，需要显式转换。</p><p>超出整型范围的浮点数转换为整型，可能发生截断，截断行为依赖于具体实现（菜鸟go在线的工具是取int64的最小值），所以应该避免。</p><h2 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2. 浮点数"></a>2. 浮点数</h2><p>float32、float64：对应bit精度的浮点数。</p><p>math.MaxFloat32：约3.4e38</p><p>math.MinFloat32：约1.4e-45</p><p>math.MaxFloat64：约1.8e308</p><p>math.MinFloat64：约4.9e-324</p><h2 id="3-复数"><a href="#3-复数" class="headerlink" title="3. 复数"></a>3. 复数</h2><p>complex64、complex128：分别对应float32、float64。</p><p>real(complex)、imag(complex)返回实部和虚部。</p><p>math/cmplx包提供了许多处理复数的函数，如求平方根、求幂。</p><h2 id="4-布尔型"><a href="#4-布尔型" class="headerlink" title="4. 布尔型"></a>4. 布尔型</h2><p>true、false。</p><p>不能隐式转换为0、1.</p><h2 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h2><p>不可修改。该特性意味着多个字符串共享相同的底层数据是安全地，因此复制、切片等操作的代价很低（只需要记录起始位置与长度）。</p><h3 id="1-字符串面值"><a href="#1-字符串面值" class="headerlink" title="1. 字符串面值"></a>1. 字符串面值</h3><p><code>&quot;hello, world&quot;</code></p><p>用双引号包含：可以插入以反斜杠\开头的转义字符。</p><p>用反引号包含：原生的字符串面值，没有转义操作，内容就是字面意思。会删除回车。</p><h3 id="2-Unicode"><a href="#2-Unicode" class="headerlink" title="2. Unicode"></a>2. Unicode</h3><p>用一个int32表示一个Unicode码点。</p><p>简单统一，能表示世界上所有符号系统，但是浪费空间。</p><h3 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3. UTF-8"></a>3. UTF-8</h3><p>将Unicode码点编码为字节序列的变长编码。用1到4个字节表示每个Unicode码点，ASCII部分字符只用1字节，常用字符2或3字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xxxxxxx                             runes 0-127    (ASCII)</span><br><span class="line">110xxxxx 10xxxxxx                    128-2047       (values &lt;128 unused)</span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx           2048-65535     (values &lt;2048 unused)</span><br><span class="line">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  65536-0x10ffff (other values unused)</span><br></pre></td></tr></table></figure><p>第一个字节的前几位表示该编码占几个字节。</p><p>Go语言源文件采用UTF-8编码。</p><p>通过unicode包或unicode/utf8包处理rune字符、UTF8编码解码。</p><p>因为Unicode字符可能占多个字节，len()返回的是字节数，并不一定与Unicode字符数相等。</p><p>range循环处理字符串时会自动隐式解码UTF8字符串。</p><h3 id="4-常用处理包"><a href="#4-常用处理包" class="headerlink" title="4. 常用处理包"></a>4. 常用处理包</h3><p>bytes：针对[]byte类型。字符串只读，因此一步步增加字符构建字符串会导致很多复制操作。这种情况下使用bytes.Buffer类型更为有效。</p><p>strings：提供字符串查询、替换、比较、拆分、合并等操作。</p><p>strconv：字符串转其他基本类型、双引号转移相关转换。</p><p>unicode：给字符分类。</p><h2 id="6-常量"><a href="#6-常量" class="headerlink" title="6. 常量"></a>6. 常量</h2><p>常量表达式的值在编译器计算，潜在类型为bool、string或数字。</p><p>常量的值不可修改。</p><h3 id="1-iota"><a href="#1-iota" class="headerlink" title="1. iota"></a>1. iota</h3><p>批量声明常量时，除了第一个外其他常量右边的初始化表达式可省略，默认用前面的初始化表达式。</p><p>在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</p><h3 id="2-无类型常量"><a href="#2-无类型常量" class="headerlink" title="2. 无类型常量"></a>2. 无类型常量</h3><p>编译期为没有明确基础类型的数字常量提供至少256bit的运算精度。</p><p>如：</p><p><code>fmt.Println(YiB/ZiB)</code></p><p>YiB和ZiB都是超出int范围的编译期常量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x float32 &#x3D; math.Pi</span><br><span class="line">var y float64 &#x3D; math.Pi</span><br><span class="line">var z complex128 &#x3D; math.Pi</span><br></pre></td></tr></table></figure><p>math.Pi如果被确定为特定类型，结果精度可能不一样。</p><p>只有常量可以是无类型，在被赋值给变量时隐式转换为对应的类型。</p><p>无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。</p><h1 id="9-复合类型"><a href="#9-复合类型" class="headerlink" title="9. 复合类型"></a>9. 复合类型</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p>数组长度是固定的，所以一般使用切片代替。</p><p>初始化方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 没指定初始值的元素就被初始化为0</span></span><br><span class="line"></span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// 数组长度根据初始化值的个数计算</span></span><br><span class="line"></span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;  <span class="comment">// 指定特定下标的初始值。该语句定义了一个长度为100，最后一个元素为-1的数组</span></span><br></pre></td></tr></table></figure><p>go中相同长度与类型的数组可以比较。</p><h2 id="2-slice"><a href="#2-slice" class="headerlink" title="2. slice"></a>2. slice</h2><p>语法与python类似。</p><p>由指针（起始地址）、长度和容量构成，与cpp的vector类似。</p><p>多个slice可以共享底层的数据，引用区间可能重叠。</p><p>切片操作[]：</p><ul><li>如果超出容量cap，会导致panic异常</li><li>如果超出长度len，则会扩展slice</li></ul><p>向函数传递slice允许在函数内部修改数组元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。</p><p>与数组不同，slice只能与nil比较，不能互相之间比较。因为slice的元素是间接引用的：</p><ul><li>一个slice甚至可以包含自身。</li><li>一个固定的slice值在不同时刻可能包含不同元素，因为底层数组元素可能被修改。</li></ul><h3 id="1-make"><a href="#1-make" class="headerlink" title="1. make"></a>1. make</h3><p>创建一个匿名数组变量，返回一个slice，只能通过返回的slice引用底层的匿名数组变量。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure><h3 id="2-append"><a href="#2-append" class="headerlink" title="2. append"></a>2. append</h3><p>向slice追加一个或多个元素。</p><p>与vector的扩容类似，如果cap不够，就再分配一个足够大的slice，然后拷贝到新slice中。</p><p>改进：内置的copy可以使dst与src的slice共享一个底层数组，降低拷贝开销。</p><p>因为append操作可能创建新的slice，不能确认新slice与原始slice是否引用相同空间，所以一般把append返回的结果赋值给输入的slice。</p><h2 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h2><p>哈希表，无序k-v对。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建方式</span></span><br><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;alice&quot;</span>: <span class="number">31</span>,</span><br><span class="line"><span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="built_in">delete</span>(ages, <span class="string">&quot;alice&quot;</span>)</span><br></pre></td></tr></table></figure><p>与cpp中的unordered_map相似，删除不存在的元素、取不存在的key的值都是安全的。</p><p>不能对map元素取址。map可能随元素数量增长分配更大空间，导致之前的地址无效。</p><p>可通过ranges遍历。</p><p><code>var ages map[string]int</code></p><p>map类型的零值是nil，即没有引用任何哈希表，可安全查找、删除、len、ranges，但不能添加元素。</p><p>添加元素前必须先创建map。</p><p><code>ages := map[string]int&#123;&#125;</code>不等于nil，因为它是一个新创建的空map的引用。</p><p>map也只能与nil比较，不能互相比较。</p><h2 id="4-结构体"><a href="#4-结构体" class="headerlink" title="4. 结构体"></a>4. 结构体</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="keyword">int</span></span><br><span class="line">    Name      <span class="keyword">string</span></span><br><span class="line">    Address   <span class="keyword">string</span></span><br><span class="line">    DoB       time.Time</span><br><span class="line">    Position  <span class="keyword">string</span></span><br><span class="line">    Salary    <span class="keyword">int</span></span><br><span class="line">    ManagerID <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmployeeByID</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">Employee</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(EmployeeByID(dilbert.ManagerID).Position) <span class="comment">// &quot;Pointy-haired boss&quot;</span></span><br><span class="line"></span><br><span class="line">id := dilbert.ID</span><br><span class="line">EmployeeByID(id).Salary = <span class="number">0</span> <span class="comment">// fired for... no real reason</span></span><br></pre></td></tr></table></figure><p>如果将EmployeeByID()的返回值改为Employee，第6行无法编译通过，因为等号左边可能是一个值而不是变量。</p><p>如果结构体成员名字以大写字母开头，该成员就是导出的。</p><p>初始化：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">int</span> &#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p := Point&#123;X: <span class="number">1</span>, Y: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>两种方法不能混用，并且不能在外部初始化结构体中未导出的成员。</p><p>结构体的比较：全部成员都需要是可比较的。</p><h3 id="1-嵌入"><a href="#1-嵌入" class="headerlink" title="1. 嵌入"></a>1. 嵌入</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle</span><br><span class="line">    Spokes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span>  <span class="comment">// w.Circle.Point.X = 8</span></span><br><span class="line">w.Radius = <span class="number">5</span>  <span class="comment">// w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>在结构体中只声明成员对应的数据类型而不指名成员的名字，这类成员叫匿名成员。不能包含两个类型相同的匿名成员。</p><p>匿名成员的数据类型必须是命名类型或指向一个命名类型的指针。</p><p>访问的时候可以忽略匿名成员的点操作符部分，直接取到匿名成员包含的成员。</p><p>嵌入类似于cpp的继承机制。</p><p>即使改成circle与wheel，包内部依然能用简短形式访问，但是包外部不行，因为没有导出。</p><p>但是，初始化无法简短。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;Circle&#123;Point&#123;<span class="number">8</span>, <span class="number">8</span>&#125;, <span class="number">5</span>&#125;, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;</span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>, <span class="comment">// <span class="doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-JSON"><a href="#5-JSON" class="headerlink" title="5. JSON"></a>5. JSON</h2><p>编码：json.Marshal将结构体转为JSON，返回一个字节slice。</p><p>可以在结构体成员的后面加Tag，表示在编译阶段关联到该成员的元信息字符串。一般形式为：`key: “value”`</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Year  <span class="keyword">int</span>  <span class="string">`json:&quot;released&quot;`</span>  <span class="comment">// 转JSON时key变为released</span></span><br><span class="line">Color <span class="keyword">bool</span> <span class="string">`json:&quot;color,omitempty&quot;`</span>  <span class="comment">// 转JSON时key变为color，并且如果结构体为空或零值，不生成该JSON对象。</span></span><br></pre></td></tr></table></figure><p>解码：json.Unmarshal。可以选择性解码感兴趣的结构。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> titles []<span class="keyword">struct</span>&#123; Title <span class="keyword">string</span> &#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;JSON unmarshaling failed: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(titles) <span class="comment">// &quot;[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-文本和HTML模板"><a href="#6-文本和HTML模板" class="headerlink" title="6. 文本和HTML模板"></a>6. 文本和HTML模板</h2><p>text/template与html/template提供将变量值填充到文本或HTML格式模板的机制。</p><h1 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h1><h2 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1. 函数声明"></a>1. 函数声明</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span> <span class="params">(result-list)</span></span> &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>return-list可以省略，只有一个可以省略括号。</li><li>parameter-list可以用下划线代替参数名，表示该参数未使用。</li><li>go语言没有默认参数值，因此也无法通过指定形参名来按名字传参。</li><li>实参是值传递，但可以通过指针、切片等间接引用修改。</li><li>可能有没有函数体的函数声明，表示该函数不是以Go实现的。</li></ul><h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h2><h2 id="3-多返回值"><a href="#3-多返回值" class="headerlink" title="3. 多返回值"></a>3. 多返回值</h2><p>一般用error接口类型作为第二个返回值，来进行错误处理。</p><p>bare return：返回值可以加显式的变量名，return可以省略操作数。</p><h2 id="4-错误"><a href="#4-错误" class="headerlink" title="4. 错误"></a>4. 错误</h2><p>函数运行失败返回的错误信息一般被认为是一种预期的值，而非异常。</p><p>这样设计的原因是，对于某个应该在控制流中处理的错误，以异常形式抛出会混乱对错误的描述。</p><p>所以使用控制流处理错误，使得编码人员更多关注错误处理。</p><h3 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1. 错误处理"></a>1. 错误处理</h3><h4 id="1-传播错误"><a href="#1-传播错误" class="headerlink" title="1. 传播错误"></a>1. 传播错误</h4><p>函数中某个子程序的失败会变成函数的失败。</p><p>一般场景：对某个函数调用失败，则直接在错误信息上添加一些当前函数相关信息，作为错误信息返回给调用者。</p><h4 id="2-重试"><a href="#2-重试" class="headerlink" title="2. 重试"></a>2. 重试</h4><p>用于偶发性错误或不可预知的问题导致的错误。</p><p>限制重试次数，通过for循环重试。</p><h4 id="3-结束"><a href="#3-结束" class="headerlink" title="3. 结束"></a>3. 结束</h4><p>输出程序信息并结束程序。</p><p>只应用在main中。在库函数中，除非该错误意味着程序内部不一致性，即出现bug，才能结束。</p><p>可通过log.Fatalf()实现。</p><h4 id="4-输出"><a href="#4-输出" class="headerlink" title="4. 输出"></a>4. 输出</h4><p>只输出错误信息，不需要中断程序运行。</p><h4 id="5-忽略"><a href="#5-忽略" class="headerlink" title="5. 忽略"></a>5. 忽略</h4><p>错误并不影响程序的逻辑。</p><p>比如手动清理临时目录失败，但是系统会定期自动清理。</p><h3 id="2-文件结尾错误EOF"><a href="#2-文件结尾错误EOF" class="headerlink" title="2. 文件结尾错误EOF"></a>2. 文件结尾错误EOF</h3><p>io包保证任何由文件结束引起的读取失败都返回io.EOF错误。</p><h2 id="5-函数值"><a href="#5-函数值" class="headerlink" title="5. 函数值"></a>5. 函数值</h2><p>函数类型有零值nil，调用值为nil的函数会引起panic。</p><p>函数值属于引用类型，之间不可比较。</p><p>可以传入函数作为参数。</p><h2 id="6-匿名函数"><a href="#6-匿名函数" class="headerlink" title="6. 匿名函数"></a>6. 匿名函数</h2><p>函数字面量：可以绕过“函数只能在包级语法块中被声明”的限制，在任何表达式中表示一个没有名字的函数值，函数值被称为匿名函数。</p><p>在函数中定义的内部函数可以引用该函数的变量。这意味着函数值记录了状态，这就是其属于引用类型、不可比较的原因。</p><p>同时，x的生命周期也不由其作用域决定，因为squares返回后，x隐式存在于f中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;1&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;4&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;9&quot;</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// &quot;16&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-问题：捕获迭代变量"><a href="#1-问题：捕获迭代变量" class="headerlink" title="1. 问题：捕获迭代变量"></a>1. 问题：捕获迭代变量</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir) <span class="comment">// <span class="doctag">NOTE:</span> incorrect!</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...do some work…</span></span><br><span class="line"><span class="keyword">for</span> _, rmdir := <span class="keyword">range</span> rmdirs &#123;</span><br><span class="line">    rmdir() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环变量dir在for循环的词法块中声明，在该循环中生成的所有函数值都共享相同的循环变量。</p><p>而内部函数是引用该词法块中的变量，记录的是dir的内存地址，而不是某一时刻的值。</p><p>dir随着迭代不断更新值，直到最后一个值，所以所有内部函数最终记录的都是dir最后一次的值。</p><p>通常在第3行前加入 <code>dir := dir</code>解决该问题。</p><h2 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7. 可变参数"></a>7. 可变参数</h2><p>在函数参数列表的最后一个参数类型前加上省略符号…，表示接收任意数量该类型的参数。</p><p>最后一个参数在函数体中被看作该类型的切片。</p><p>如果要传入切片类型中所有的值，可以在变量名后加入…。</p><h2 id="8-Deferred函数"><a href="#8-Deferred函数" class="headerlink" title="8. Deferred函数"></a>8. Deferred函数</h2><p>在调用普通函数/方法前加上defer。</p><p>在执行该语句时，函数和参数表达式得到计算，但是直到包含该defer语句的函数执行完毕时，defer函数才被执行。</p><p>经常用于处理成对的操作，如打开/关闭连接、加锁/释放锁。释放资源的defer应该紧跟在请求资源之后。</p><h2 id="9-Panic异常"><a href="#9-Panic异常" class="headerlink" title="9. Panic异常"></a>9. Panic异常</h2><p>运行时错误会引起panic异常。</p><p>出现panic异常时，程序会：</p><ul><li>终止运行</li><li>立即执行该goroutine中被延迟的defer函数</li><li>崩溃并输出日志</li></ul><p>一般用于严重错误，一般应该尽量少用，并多用控制流error处理错误。</p><h2 id="10-Recover捕获异常"><a href="#10-Recover捕获异常" class="headerlink" title="10. Recover捕获异常"></a>10. Recover捕获异常</h2><p>在deferred函数中调用recover，且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。</p><p>导致panic异常的函数不会继续运行，但能正常返回。</p><p>未发生panic时调用recover，recover会返回nil。</p><p>有些情况无法恢复，如内存不足，所以应该有选择性地recover。</p><h1 id="11-方法"><a href="#11-方法" class="headerlink" title="11. 方法"></a>11. 方法</h1><h2 id="1-声明"><a href="#1-声明" class="headerlink" title="1. 声明"></a>1. 声明</h2><p>函数声明时，在其名字前放一个变量，即是一个方法。该附加参数会将该函数附加到这种类型上。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traditional function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// same thing, but as a method of the Point type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Distance</span><span class="params">(q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附加的参数p称为方法的接收器。</p><p>Go语言中，可以同一个包内的非指针、interface的任意命名类型定义方法，包括数值、字符串等类型。</p><p>好处：在包外可以直接通过变量.方法的形式调用，方法名可以很简短。</p><h2 id="2-基于指针对象的方法"><a href="#2-基于指针对象的方法" class="headerlink" title="2. 基于指针对象的方法"></a>2. 基于指针对象的方法</h2><p>如果接收器类型太大，也需要用指针声明方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span> <span class="title">ScaleBy</span><span class="params">(factor <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般约定如果Point类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器。</p><p>只有类型和该类型指针，才能出现在接收器声明中。为了避免歧义，如果一个类型名本身是一个指针，不允许出现在接收器中。</p><p>如果接收器与方法声明一个是指针，一个不是指针，可以</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.ScaleBy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>编译期会隐式用&amp;p或*p调用方法。只适用于能取到地址的变量，临时值是无法使用的。</p><p>如果一个方法用指针作为接收器，需要避免进行拷贝，因为可能引起多个别名，进而某些别名意外修改了方法内的状态。</p><p>★ 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。</p><h2 id="3-嵌入结构体"><a href="#3-嵌入结构体" class="headerlink" title="3. 嵌入结构体"></a>3. 嵌入结构体</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;image/color&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColoredPoint <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将ColoredPoint类型当作接收器调用Point里的方法。</p><p>类似于cpp的子类调用父类方法。</p><p>但是，只有接收器可以这样用。其他参数还是得显式指出内嵌的类型。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(p.Distance(q.Point))</span><br></pre></td></tr></table></figure><h2 id="4-方法值和方法表达式"><a href="#4-方法值和方法表达式" class="headerlink" title="4. 方法值和方法表达式"></a>4. 方法值和方法表达式</h2><p>方法的执行可以分为两步：</p><ul><li>选择器：返回一个方法值，即一个将方法绑定到特定接收器变量的函数，如 <code>m := p.ScaleBy</code>。</li><li>向选择器传入需要的参数。<code>m(2)</code>。</li></ul><p>方法表达式：当T是一个类型时，方法表达式可能会写作 <code>T.f</code>或者 <code>(*T).f</code>，会返回一个函数“值”，这种函数会将其第一个参数用作接收器，所以可以用普通函数的形式调用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">distance := Point.Distance   <span class="comment">// method expression</span></span><br><span class="line">fmt.Println(distance(p, q))  <span class="comment">// &quot;5&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, distance) <span class="comment">// &quot;func(Point, Point) float64&quot;</span></span><br><span class="line"></span><br><span class="line">scale := (*Point).ScaleBy</span><br><span class="line">scale(&amp;p, <span class="number">2</span>)</span><br><span class="line">fmt.Println(p)            <span class="comment">// &quot;&#123;2 4&#125;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, scale) <span class="comment">// &quot;func(*Point, float64)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="5-封装"><a href="#5-封装" class="headerlink" title="5. 封装"></a>5. 封装</h2><p>Go语言只有基于名字的封装手段，即：</p><ul><li>大写首字母的标识符会从定义它们的包中被导出，同样适用于struct或类型方法。</li></ul><p>这使得Go语言最小封装单元为package，而不是其它语言的类型。</p><p>封装的优点：</p><ul><li>调用方只需要关注API即可使用。</li><li>隐藏实现细节。</li><li>阻止外部调用方修改对象内部值。</li></ul><h1 id="12-接口"><a href="#12-接口" class="headerlink" title="12. 接口"></a>12. 接口</h1><h2 id="1-接口类型"><a href="#1-接口类型" class="headerlink" title="1. 接口类型"></a>1. 接口类型</h2><p>抽象类型。不会暴露其代表的对象的内部值的结构、对象支持的基础操作集合，只会表现出自己的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, args...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    Fprintf(&amp;buf, format, args...)</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Printf与Sprintf都是调用Fprintf完成：</p><ul><li>Printf第一个参数os.Stdout是*os.File类型。</li><li>Sprintf第一个参数是*bytes.Buffer类型。</li></ul><p>但是，Fprintf第一个参数要求的是io.Writer类型，是一个接口类型</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Write writes len(p) bytes from p to the underlying data stream.</span></span><br><span class="line">    <span class="comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span></span><br><span class="line">    <span class="comment">// and any error encountered that caused the write to stop early.</span></span><br><span class="line">    <span class="comment">// Write must return a non-nil error if it returns n &lt; len(p).</span></span><br><span class="line">    <span class="comment">// Write must not modify the slice data, even temporarily.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Implementations must not retain p.</span></span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io.Writer类型定义了Fprintf与其调用者的约定，即：</p><ul><li>要求传入的类型都有一个特定签名和行为的Write函数。</li><li>保证Fprintf接受任何满足io.Writer接口的值都能工作。</li></ul><p>一个类型可以自由被另一个满足相同接口的类型替换，被称作可替换性（LSP里氏替换）。</p><p>据此，可以自定义Write方法后，传入这些函数中。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c ByteCounter</span><br><span class="line">c.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">fmt.Println(c) <span class="comment">// &quot;5&quot;, = len(&quot;hello&quot;)</span></span><br><span class="line">c = <span class="number">0</span>          <span class="comment">// reset the counter</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Dolly&quot;</span></span><br><span class="line">fmt.Fprintf(&amp;c, <span class="string">&quot;hello, %s&quot;</span>, name)</span><br><span class="line">fmt.Println(c) <span class="comment">// &quot;12&quot;, = len(&quot;hello, Dolly&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-实现接口的条件"><a href="#2-实现接口的条件" class="headerlink" title="2. 实现接口的条件"></a>2. 实现接口的条件</h2><p>一个类型如果拥有一个接口需要的所有方法，这个类型就实现了这个接口。</p><p>尽管某类型的指针可以直接通过点操作符调用方法，但是这只是一个语法糖，本质上该方法的接收器还是该类型的指针变量，所以该类型的变量赋值给接口类型也必须取地址。</p><h2 id="3-接口值"><a href="#3-接口值" class="headerlink" title="3. 接口值"></a>3. 接口值</h2><p>接口的零值：类型和值都是nil。</p><p>接口具有动态类型，所以接口上的调用必须动态分配。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">    &#125;</span><br><span class="line">    f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        <span class="comment">// ...use buf...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...do something...</span></span><br><span class="line">    <span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">        out.Write([]<span class="keyword">byte</span>(<span class="string">&quot;done!\n&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当debug设置为false时，18行会发生panic，因为out的动态类型是*bytes.Buffer，只是其值为nil，所以判断不为nil。</p><p>改进：一开始只给buf *io.Writer类型，只有debug为true时才设置*bytes.Buffer类型。</p><h1 id="13-协程"><a href="#13-协程" class="headerlink" title="13. 协程"></a>13. 协程</h1><p>位于用户态，类似于轻量级线程，占用内存KB级别。</p><p>可以充分利用多核CPU优势。</p><p>Go通过通信共享内存，而不是通过共享内存实现通信。</p><h2 id="1-channel"><a href="#1-channel" class="headerlink" title="1. channel"></a>1. channel</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, [size])</span><br></pre></td></tr></table></figure><p>不加size表示无缓冲通道，加了表示有缓冲通道。</p><h2 id="2-lock"><a href="#2-lock" class="headerlink" title="2. lock"></a>2. lock</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br></pre></td></tr></table></figure><p>互斥锁，拥有加解锁方法。</p><h2 id="3-waitgroup"><a href="#3-waitgroup" class="headerlink" title="3. waitgroup"></a>3. waitgroup</h2><p>维护计数器，开启协程+1，子协程执行结束-1；主协程阻塞直到计数器为0。</p><p>用于多协程多任务同步。</p><h1 id="14-项目依赖管理"><a href="#14-项目依赖管理" class="headerlink" title="14. 项目依赖管理"></a>14. 项目依赖管理</h1><p>演变：GOPATH-》Go Vendor-》Go Module</p><p>GOPATH弊端：</p><ul><li>无法依赖同一包的不同版本。</li></ul><p>Go Vendor弊端：</p><ul><li>无法控制依赖版本。</li><li>更新版本可能出现依赖冲突，导致编译出错。</li></ul><p>Go Module依赖管理三要素：</p><ul><li>配置文件，描述依赖：go.mod</li><li>中心仓库，管理依赖库：Proxy</li><li>本地工具：go get/mod</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab2-4</title>
      <link href="/2023/04/10/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-4/"/>
      <url>/2023/04/10/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-并发控制"><a href="#1-并发控制" class="headerlink" title="1. 并发控制"></a>1. 并发控制</h1><h2 id="1-lock-amp-latch"><a href="#1-lock-amp-latch" class="headerlink" title="1. lock &amp; latch"></a>1. lock &amp; latch</h2><p>lock级别比latch更高</p><ul><li>对象：<ul><li>lock：事务</li><li>latch：线程</li></ul></li><li>保护的东西：<ul><li>lock：数据库内容</li><li>latch：内存数据结构</li></ul></li><li>持续时间：<ul><li>lock：整个事务过程</li><li>latch：访问持有该latch的临界资源时</li></ul></li><li>模式：<ul><li>lock：行锁、表锁、意向锁</li><li>latch：读写锁、互斥量</li></ul></li><li>死锁：<ul><li>lock：waits-for graph、time out等机制检测与处理</li><li>latch：无检测与处理机制，仅通过应用程序加锁顺序保证无死锁发生</li></ul></li><li>存在位置：<ul><li>lock：lock manager的哈希表中</li><li>latch：每个数据结构对象中</li></ul></li></ul><h2 id="2-控制逻辑"><a href="#2-控制逻辑" class="headerlink" title="2. 控制逻辑"></a>2. 控制逻辑</h2><h3 id="1-transaction"><a href="#1-transaction" class="headerlink" title="1. transaction"></a>1. transaction</h3><p>主要用到这两个结构与其方法：</p><p>page_set：保存加了锁的page</p><ul><li>GetPageSet()</li><li>AddIntoPageSet()</li></ul><p>deleted_page_set：保存已被删除的page</p><ul><li>GetDeletedPageSet()</li><li>AddIntoDeletedPageSet()</li></ul><h3 id="2-root并发控制"><a href="#2-root并发控制" class="headerlink" title="2. root并发控制"></a>2. root并发控制</h3><p>可能有多个进程访问root_page_id_，所以需要在b_plus_tree类中加一个root_page_id_latch_读写锁，来控制对root_page_id的访问。</p><p>在transaction中，用nullptr表示id写锁，pop出nullptr时即写释放id锁。</p><h3 id="3-FindLeaf"><a href="#3-FindLeaf" class="headerlink" title="3. FindLeaf"></a>3. FindLeaf</h3><p>需要区分当前的操作是search、insert或remove。</p><p>对于search：</p><ul><li>不会改变树，所以只需要加写锁。</li><li>不会递归改变树结构，所以遍历到子页，即可释放父页上加的写锁。</li></ul><p>对于insert/remove：</p><ul><li>可能会改变树，所以需要加写锁。</li><li>可能会改变根节点、树结构，所以可能暂时不能释放Leaf的祖先节点的锁。</li><li>对于insert操作，到Leaf路径上的所有节点可能会因为子节点溢出而需要插入一个新的元素。所以，如果子节点在插入元素后不会溢出，判断该insert操作为安全操作，就可以将子节点的所有祖先节点上的写锁全部释放。</li><li>对于remove操作，到Leaf路径上的所有节点可能会因为子节点移除后不满足min_size合并，而需要修改键值对。所以，如果子节点在移除元素后不需要调整，即size大于minsize，判断该remove操作为安全操作，就可以将子节点的所有祖先节点上的写锁全部释放。<ul><li>需要调整兄弟节点时，因为调整的节点不安全，调整节点的父节点（也即兄弟节点的父节点）一定是被锁住的，所以可以安全调整。</li></ul></li><li>即使在释放时，有被锁上的不安全的祖先节点，因为当前节点是安全的，所以不会再回溯。所以即使祖先节点不安全，也不会受到波及。</li></ul><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-ReleaseLatch"><a href="#1-ReleaseLatch" class="headerlink" title="1. ReleaseLatch"></a>1. ReleaseLatch</h2><p>作用：释放当前持有的所有锁。</p><p>输入：Transaction *transaction</p><p>具体逻辑：</p><ul><li>GetPageSet()遍历page_set，每次pop出一个page然后判断：<ul><li>为nullptr，表示是id锁，写释放。</li><li>不为nullptr，表示是页锁。<ul><li>写释放后还需要UnpinPage()。</li></ul></li></ul></li></ul><h2 id="2-FindLeafRW"><a href="#2-FindLeafRW" class="headerlink" title="2. FindLeafRW"></a>2. FindLeafRW</h2><p>作用：带读写锁控制的找到key对应的叶子页。</p><p>输入：</p><ul><li>key：要找的key。</li><li>op：调用FindLeafRW的操作类型，如SEARCH、INSERT和REMOVE。</li><li>transaction：并发控制。</li><li>bool leftmost：最左查找，用于迭代器中的begin()。</li><li>bool rightmost：最右查找。</li></ul><p>输出：Page *，表示找到的key对应的叶子页。</p><p>判断操作是否安全：</p><ul><li>插入：插入后不需要溢出处理。<ul><li>internal：size小于maxsize。</li><li>leaf：size小于maxsize-1。</li></ul></li><li>删除：删除后不需要合并处理。<ul><li>size大于minsize。</li><li>对根节点，internal要求size大于2，leaf要求size大于1。</li></ul></li></ul><p>具体逻辑：</p><ul><li>FetchPage()取到根页，转换成BPlusTreePage的节点为当前页。（一般在FindLeafRW()调用前就已经加了id锁）</li><li>判断是否可以释放id锁：<ul><li>如果op为SEARCH，释放id锁，并为根页上读锁。</li><li>否则，先为根页上写锁，然后判断操作是否安全（是否会改变根页号），安全才释放id锁</li></ul></li><li>如果当前页不是Leaf页，循环向下，根据key/leftmost/rightmost查找对应的子页：<ul><li>FetchPage()取到子页，转换成BPlusTreePage的节点。</li><li>判断是否可以释放父页的锁：<ul><li>如果op为SEARCH，释放父页读锁并UnpinPage()，为子页上读锁。</li><li>如果op为INSERT/REMOVE，为子页上写锁，AddIntoPageSet()添加父页，然后判断子页操作是否安全，安全则ReleaseLatch()释放到该页路径上的所有锁。</li></ul></li><li>当前页赋值为子页。</li></ul></li><li>返回当前页。</li></ul><h2 id="3-Insert"><a href="#3-Insert" class="headerlink" title="3. Insert"></a>3. Insert</h2><p>修改点：</p><ul><li><p>一开始需要先对id锁加写锁，并向page_set插入nullptr表示id锁已上锁。</p></li><li><p>StartNewTree()结束后，ReleaseLatch()。</p></li><li><p>InsertToLeaf()中：</p><ul><li>没有InsertToParent()提前退出时（key重复插入失败，或插入后没有溢出），先ReleaseLatch()、当前页解写锁后再UnpinPage()。</li><li>★ Split()<strong>不需要为分裂的新页加锁</strong>。因为分裂操作是线程不安全的，代表着新页的父节点一定上了写锁，从而其他线程无法通过父节点访问到新页。</li><li>InsertToParent()后，当前页解写锁后再UnpinPage()。</li></ul></li><li><p>InsertToParent()中：</p><ul><li>UnpinPage()前ReleaseLatch()。</li></ul></li></ul><h2 id="4-Remove"><a href="#4-Remove" class="headerlink" title="4. Remove"></a>4. Remove</h2><p>修改点：</p><ul><li>一开始需要先对id锁加写锁，并向page_set插入nullptr表示id锁已上锁。</li><li>树为空、key没找到返回前，需要ReleaseLatch()。如果树不为空，ReleaseLatch()后需要写解锁当前的叶子页。</li><li>返回前，需要遍历deleted_page_set，调用DeletePage()删除这些页。</li><li>RedistributeOrMerge()中：增加bool型返回值，表示传入的节点是否需要删除。<ul><li>如果当前节点为根节点、或不需要调整，返回前需要ReleaseLatch()。</li><li>parent节点已经在FindLeafRW()时加过写锁，所以再次获取不需要加锁。</li><li>如果可以从左右兄弟借元素，需要先给左右兄弟加写锁，借完元素后，ReleaseLatch()、写解锁当前页、UnpinPage()，返回false。（借节点成功，节点数目没有减少，不需要删除）</li><li>如果需要与左右兄弟合并，根据Merge()返回值决定是否将父节点加入deleted_page_set中，然后UnpinPage()前写解锁访问到的左右兄弟。（不需要写解锁当前节点，因为会在函数退出后解锁）</li><li>如果是与左兄弟合并，当前节点会合并到左兄弟，所以需要删除当前节点，返回false；否则右兄弟合并到当前节点，当前节点不需要删除，返回true，右兄弟需要删除，将右兄弟加入delete_page_set中。</li></ul></li><li>Merge()中：增加bool型返回值，表示传入的parent节点是否需要删除。</li></ul><h2 id="5-Iterator"><a href="#5-Iterator" class="headerlink" title="5. Iterator"></a>5. Iterator</h2><p>修改点：</p><ul><li>将初始化的BPlusTreePage *类型改为Page *类型，因为需要上锁。内部添加一个LeafPage *类型查询值。</li><li>Begin()时id锁加读锁，然后改用FindLeafRW()找到最左叶子页。</li><li>End()时id锁加读锁，然后改用FindLeafRW()找到最左叶子页。</li><li>++操作换页时加解锁。</li><li>析构时解锁。</li></ul><h1 id="3-debug经历"><a href="#3-debug经历" class="headerlink" title="3. debug经历"></a>3. debug经历</h1><h2 id="1-concurrency-delete-bug"><a href="#1-concurrency-delete-bug" class="headerlink" title="1. concurrency delete bug"></a>1. concurrency delete bug</h2><p>原理：</p><p>leaf叶节点的Remove()方法中，没有考虑到查找的key大于leaf节点所有key（找不到删除的元素），从而KeyIndex返回Size的情况。</p><p>因为柔性数组，即使返回越界的Size，编译器也不会报数组越界错误。</p><p>而如果Size处的key（可能是之前remove时残留下来的）恰好与传入的key相等，就会触发Remove成功的操作，<strong>错误减少当前Size</strong>。</p><p>场景：</p><p>Size减多了，导致页提前删除，查找原本在该页中的key时找不到。如果该页为根节点，会抛出异常，因为根节点被异常删除，id变为INVALID。</p><p>解决：</p><ul><li>根据报错信息定位到错误为多线程删除时，错误访问了空树。</li><li>查看用例得知，插入5个值后多线程删除4个值，应该还剩一个值。在访问该值时报错。</li><li>分析问题成因：<ul><li>多线程逻辑出错导致多个线程删除页。（如果是这样，应该在删除时就报错，而不是访问剩下的值时报错）</li><li>页的删除逻辑出错。</li></ul></li><li>因为多线程bug不好处理，对照完加解锁实现逻辑与insert用例无误后，猜想可能是size大小的问题。</li><li>查看页的删除逻辑，发现了找不到删除的元素时，没有判断查找的key大于当前节点中所有key的情况。</li><li>导致如果Size处的key（可能是之前remove时残留下来的）恰好与传入的key相等，就会触发Remove成功的操作，<strong>错误减少当前Size</strong>。</li></ul><h2 id="2-死锁分析"><a href="#2-死锁分析" class="headerlink" title="2. 死锁分析"></a>2. 死锁分析</h2><p>一般情况：获取多个锁时，都是从父节点到子节点，从上到下获取，因此不可能存在一个线程先持有子节点锁再申请父节点锁的情况，不会出现死锁．</p><p>一般遍历＋迭代器遍历：删除操作需要获取左兄弟时，是从右往左，而迭代器遍历是从左往右，会出现两个线程同时各持一个兄弟节点的锁，获取另一个兄弟节点的锁的死锁情况。</p><ul><li>因此，需要让一方在获取不到锁时放弃获取，这里设置为让迭代器放弃获取，因为读操作影响比写操作小。</li></ul><h2 id="3、优化"><a href="#3、优化" class="headerlink" title="3、优化"></a>3、优化</h2><p>在增删操作获取锁时，可以乐观认为不会有不安全的操作，像查找一样上读锁并及时释放。</p><ul><li>如果操作确实安全，则直接完成。</li><li>如果发现操作不安全，则放弃持有的所有锁，从根页开始像未优化一样悲观操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab2-3</title>
      <link href="/2023/04/09/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-3/"/>
      <url>/2023/04/09/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Iterator"><a href="#1-Iterator" class="headerlink" title="1. Iterator"></a>1. Iterator</h1><p>BPlusTree的所有叶子节点相连构成了一条链表，需要实现该链表的迭代器。</p><p>这个应该没什么好说的。。。实现迭代器，重载isEnd()、++、*、!=、==方法。</p><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><ul><li>BufferPoolManager *bpm：访问Leaf页时需要通过bpm的FetchPage()取出。</li><li>LeafPage *leaf：当前所在Leaf页指针。</li><li>int index：当前所在Leaf页内索引下标。</li></ul><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h2><p>传入三个数据结构初始化即可。</p><h2 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2. 析构函数"></a>2. 析构函数</h2><p>具体逻辑：</p><ul><li>UnpinPage()释放Leaf页指针。</li></ul><h2 id="3-IsEnd"><a href="#3-IsEnd" class="headerlink" title="3. IsEnd"></a>3. IsEnd</h2><p>输出：bool，表示当前迭代器是否为链表尾。（iterator的end表示最后一个节点的后面一个位置）</p><p>具体逻辑：</p><ul><li>Leaf页的GetNextPageId() == INVALID_PAGE_ID，表示Leaf页为链表最后一页。</li><li>index == leaf_-&gt;GetSize()，表示当前索引下标为Leaf页最后一个下标的后一个位置。</li></ul><h2 id="4-operator"><a href="#4-operator" class="headerlink" title="4. operator++"></a>4. operator++</h2><p>前置自增操作符。</p><p>具体逻辑：</p><ul><li>如果index为当前Leaf页最后一个下标，且当前Leaf页不为链表尾页。<ul><li>通过GetNextPageId()获取下一个链表页的page_id。</li><li>UnpinPage()当前页。</li><li>FetchPage()下一个链表页。</li><li>leaf指针指向下一个链表页。</li><li>index重置为0。</li></ul></li><li>否则，有两种情况，但两种情况都只需自增index。<ul><li>index不为当前Leaf页最后一个下标</li><li>index为当前Leaf页最后一个下标，且当前Leaf页为链表尾页：自增后index == leaf_-&gt;GetSize()，表示到达迭代器的End()位置。</li></ul></li><li>返回this指针指向的值。</li></ul><h2 id="5-operator"><a href="#5-operator" class="headerlink" title="5. operator*"></a>5. operator*</h2><p>取值操作符。</p><p>具体逻辑：</p><ul><li>GetItem()获取当前Leaf页在index处的k-v键值对。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab2-2</title>
      <link href="/2023/04/03/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-2/"/>
      <url>/2023/04/03/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-BPlusTree"><a href="#1-BPlusTree" class="headerlink" title="1. BPlusTree"></a>1. BPlusTree</h1><h2 id="1-基本特征"><a href="#1-基本特征" class="headerlink" title="1. 基本特征"></a>1. 基本特征</h2><p>B+树，多路平衡搜索树。</p><p>特点：</p><ul><li>非叶子节点只存储索引，叶子节点存储数据。<ul><li>非叶子节点存储n个key与n+1个指针，指针指向的页面中所有key都存在于指针左右的两key形成的左开右闭区间之中。</li><li>叶子节点存储n个k-v对，表示key以及对应的数据。</li></ul></li><li>每个节点存储的数据有最小/最大限制。<ul><li>最小值为最大值的一半（因为在lab设计中，非叶子节点多了一个没有key的k-v对，所以非叶子节点最小数据个数为(max + 1) / 2）</li><li>根节点最小数据个数为1。</li></ul></li><li>根节点到所有叶子节点路程相同。</li><li>叶子节点之间通过链表相连，形成有序链表。<ul><li>方便范围查询。</li></ul></li></ul><h2 id="2-变形"><a href="#2-变形" class="headerlink" title="2. 变形"></a>2. 变形</h2><p>增删时，为了维持节点存储数据个数的限制，需要进行变形。</p><h3 id="1-插入"><a href="#1-插入" class="headerlink" title="1. 插入"></a>1. 插入</h3><p>如果插入导致叶子节点的size大于max_size，需要进行分裂：</p><ul><li>将叶子节点分裂为两个大小差不多的节点（一般为左小右大）</li><li>将新节点连入链表中。</li><li>以新节点第一个key为索引，将该key插入父节点中。</li><li>父节点插入key后，可能也会导致size溢出，因此可能需要递归分裂。</li></ul><h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h3><p>如果删除导致叶子结点的size小于min_size，需要：</p><ul><li>如果左边/右边兄弟节点的size大于min_size，就借一个节点过来。</li><li>如果两边都不能借节点，就把当前节点与左边/右边的兄弟节点合并，然后删除父节点中对应的k-v。</li><li>如果删除父节点的k-v导致父节点的size小于min_size，需要递归操作。</li></ul><p>InternalPage在移动的时候，需要注意重设子节点的parent。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-FindLeaf"><a href="#1-FindLeaf" class="headerlink" title="1. FindLeaf"></a>1. FindLeaf</h2><p>作用：根据key找到该key可能存在的leaf。</p><p>输入：key</p><p>输出：Page *，表示找到key对应的leaf页。</p><p>具体逻辑：</p><ul><li>assert根页号不能为空。</li><li>先从bpm中FetchPage()根页号对应的页，作为当前页。</li><li>当前页是leaf时，退出循环，否则：<ul><li>将当前页reinterpret_cast为internal。</li><li>Lookup()找到key存在的子树的根页号。</li><li>UnpinPage()当前页。</li><li>根据子树的根页号获取新的页。</li></ul></li><li>返回当前页。</li></ul><h2 id="2-★-GetValue"><a href="#2-★-GetValue" class="headerlink" title="2. ★ GetValue"></a>2. ★ GetValue</h2><p>输入：</p><ul><li>key</li><li>result：vector数组指针，第一个元素存储查找到的值</li><li>transaction：用于2-4的读写控制，现在用不到</li></ul><p>输出：bool，表示是否查找成功。</p><p>具体逻辑：</p><ul><li>通过FindLeaf()找到key对应的leaf。</li><li>在leaf中Lookup()当前key。</li><li>UnpinPage()当前leaf。</li><li>如果Lookup()找到，在result中装入value，返回true。</li><li>否则返回false。</li></ul><h2 id="3-Split"><a href="#3-Split" class="headerlink" title="3. Split"></a>3. Split</h2><p>作用：Insert()时如果页大小超过最大，则进行分裂。</p><p>输入：BPlusTreePage *，表示待分裂的页面。</p><p>输出：BPlusTreePage *，表示分裂出来的新页。</p><p>具体逻辑：</p><ul><li>从bpm中NewPage()申请一块新页。</li><li>判断待分裂页是leaf还是internal，并根据情况分别reinterpret_cast为不同类型，并调用MoveHalfTo()分裂。</li><li>返回新页。</li></ul><h2 id="4-InsertToParent"><a href="#4-InsertToParent" class="headerlink" title="4. InsertToParent"></a>4. InsertToParent</h2><p>作用：Insert()时，Split()后需要向父节点插入索引。</p><p>输入：</p><ul><li>BPlusTreePage *old_page，表示被Split()的页面。</li><li>BPlusTreePage *split_page，表示Split()出来的页面。</li><li>key，表示待插入父节点的key。为split_page的第一个key。</li></ul><p>输出：void。</p><p>具体逻辑：</p><ul><li>先判断old_page是否为根页，是则特殊处理。<ul><li>根页没有父页，需要NewPage()申请一块新页，并更新root_page_id_。</li><li>将old_page、split_page的id与split_key插入新根页，设置新根页的size。</li><li>重设old_page、split_page父节点为新根页。</li><li>UnpinPage()新根页后<strong>返回</strong>。</li></ul></li><li>FetchPage()获取父页。</li><li>如果父页size小于最大size，说明可以直接插入而无需分裂。<ul><li>InserNodeAfter()插入。</li><li>UnpinPage()父页后<strong>返回</strong>。</li></ul></li><li>InserNodeAfter()插入。</li><li>Split()分裂父页。</li><li>递归InsertToParent()向父页的父页插入。</li><li>UnpinPage()分裂的两个父页后<strong>返回</strong>。</li></ul><h2 id="5-★-Insert"><a href="#5-★-Insert" class="headerlink" title="5. ★ Insert"></a>5. ★ Insert</h2><p>细节区分：</p><ul><li>Leaf页设计存在一个空间，可以容许先插入再判断是否溢出。</li><li>Internal页不存在这个空间，所以必须先判断是否可能溢出。</li></ul><p>输入：</p><ul><li>key</li><li>value</li><li>transaction：用于2-4的读写控制，现在用不到</li></ul><p>输出：bool，表示是否插入成功</p><p>具体逻辑：</p><ul><li>先判断是否为空树，如果为空：<ul><li>用bpm NewPage()一个新页，作为根页。</li><li>初始化新页。</li><li>将k-v插入新页中。</li><li>unpin新页。</li><li>更新root_page_id。</li><li>返回true。</li></ul></li><li>通过FindLeaf()找到key对应的leaf页。</li><li>通过leaf的Insert()方法尝试插入，根据插入前后leaf的size：<ul><li>如果size没有变化，说明已有该key，返回false。</li><li>如果size不大于max_size，说明插入成功且不需要分裂，返回true。</li><li>否则，说明当前leaf需要分裂，继续后面的逻辑。</li></ul></li><li>通过leaf的Split()分裂该leaf为leaf与new_leaf。</li><li>将两个新leaf连接在原来的链表上。</li><li>通过InsertToParent()向parent插入新索引。</li><li>UnpinPage()两个新页。</li><li>返回true。</li></ul><h2 id="6-RedistributeLeft"><a href="#6-RedistributeLeft" class="headerlink" title="6. RedistributeLeft"></a>6. RedistributeLeft</h2><p>作用：将当前页左兄弟页的最后一个子节点借过来，作为当前页第一个子节点插入。</p><p>输入：</p><ul><li>Node *sibling_node：左兄弟页。</li><li>Node *target_node：当前页。</li><li>InternalPage *parent：父页。</li><li>int index：父页中当前页的索引下标，用于调整父页索引。</li></ul><p>具体逻辑：</p><ul><li>Internal页与Leaf页需要分别讨论，因为方法不同。</li><li>获取sibling页最后一个子节点，插入target页第一个位置。</li><li>移动的子节点索引为key，移动后target页中的节点索引全都大于等于key，所以将父页index位置的索引设置为key。</li></ul><h2 id="7-RedistributeRight"><a href="#7-RedistributeRight" class="headerlink" title="7. RedistributeRight"></a>7. RedistributeRight</h2><p>作用：将当前页右兄弟页的第一个子节点借过来，作为当前页最后一个子节点插入。</p><p>输入：</p><ul><li>Node *sibling_node：右兄弟页。</li><li>Node *target_node：当前页。</li><li>InternalPage *parent：父页。</li><li>int index：父页中当前页的索引下标，用于调整父页索引。</li></ul><p>具体逻辑：</p><ul><li>Internal页与Leaf页需要分别讨论，因为方法不同。</li><li>获取sibling页第一个子节点，插入target页最后一个位置。</li><li>移动后sibling页中的节点索引全都大于等于sibling页第一个索引key，所以将父页index + 1位置的索引设置为key。</li></ul><h2 id="8-Merge"><a href="#8-Merge" class="headerlink" title="8. Merge"></a>8. Merge</h2><p>作用：合并页。</p><p>输入：</p><ul><li>Node *dst_node：目标页。</li><li>Node *src_node：被合并页。</li><li>InternalPage *parent：父页。</li><li>int index：父页中被合并页的索引下标。</li></ul><p>具体逻辑：目标页一定是被合并页左边的页。</p><ul><li>因为Leaf页与Internal页的MoveAllTo()参数不同，需要分开讨论。</li><li>调用src_node的MoveAllTo()将其所有子节点移动到dst_node。</li><li>parent Remove() index位置的元素。</li><li>如果parent的Remove()导致其Size小于min_size，对parent递归调用RedistributeOrMerge()。</li></ul><h2 id="9-RedistributeOrMerge"><a href="#9-RedistributeOrMerge" class="headerlink" title="9. RedistributeOrMerge"></a>9. RedistributeOrMerge</h2><p>作用：Remove后如果页的size小于min_size，需要重新分配。</p><p>输入：BPlusTreePage *，待重新分配的页。</p><p>输出：void。</p><p>具体逻辑：</p><ul><li><p>如果当前页是根页，且页为空，需要重新设置根页：</p><ul><li>Internal页的Size为1（空）：<ul><li>将根页的第一个子页取出，作为新的根页。</li><li>重设root_page_id_。</li><li><strong>返回</strong>。</li></ul></li><li>Leaf页的Size为0（空）：<ul><li>重设root_page_id_。</li><li><strong>返回</strong>。</li></ul></li></ul></li><li><p>如果当前页size大于minsize，不需要再分配，直接返回。</p></li><li><p>否则，需要调整使得页大小不小于min_size，依次尝试以下操作：</p><ul><li><p>如果左兄弟页的Size大于min_size</p><ul><li>RedistributeLeft()把左兄弟页的最后一个子节点借过来。</li><li><strong>返回。</strong></li></ul></li><li><p>如果右兄弟页的Size大于min_size</p><ul><li>RedistributeRight()把右兄弟页的第一个子节点借过来。</li><li><strong>返回。</strong></li></ul></li><li><p>如果有左兄弟页（左兄弟页的Size等于min_size，即不能借子节点）</p><ul><li>Merge()合并左兄弟页和当前页。</li><li><strong>返回。</strong></li></ul></li><li><p>如果有右兄弟页（右兄弟页的Size等于min_size，即不能借子节点）</p><ul><li>Merge()合并右兄弟页和当前页。</li><li><strong>返回。</strong></li></ul></li></ul></li></ul><h2 id="10-★-Remove"><a href="#10-★-Remove" class="headerlink" title="10. ★ Remove"></a>10. ★ Remove</h2><p>输入：</p><ul><li>key</li><li>transaction：用于2-4的读写控制，现在用不到</li></ul><p>输出：void</p><p>具体逻辑：</p><ul><li><p>如果树为空：</p><ul><li>无需删除直接<strong>返回</strong>。</li></ul></li><li><p>通过FindLeaf()找到key对应的leaf页。</p></li><li><p>在leaf页中Remove()对应的key。</p></li><li><p>如果Remove()返回false：</p><ul><li>说明没有该key，直接<strong>返回</strong>。</li></ul></li><li><p>调用RedistributeOrMerge()重新分配。</p></li><li><p>UnpinPage()后返回。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-跳表</title>
      <link href="/2023/03/27/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E8%B7%B3%E8%A1%A8/"/>
      <url>/2023/03/27/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>用在WebServer里了</p><p>维护一个多层的链表，高层链表是底层链表的子集，且层次越高，一次跨越的节点数越多，用于Ologn时间的增删改查。</p><p>实现与红黑树、AVL树相似。用于Redis的Zset实现。</p><p>每个节点由key、value与level大小的指针数组组成。</p><h2 id="1-层数"><a href="#1-层数" class="headerlink" title="1. 层数"></a>1. 层数</h2><p>每个节点都会随机到一个不同的层数x，该节点0~X所有层都是同一数据。</p><p>计算方式：</p><ul><li>节点初始为第0层。</li><li>在有第i层的情况下，第i+1层出现概率为p。</li><li>最大为MaxLevel层。</li></ul><p>每层的指针连接到相同层下一个节点（相当于每一层构成一个链表）。</p><p>Redis中p=1/4，MaxLevel=64，这种情况下一个节点平均有1.33个指针，低于二叉树</p><p>计算方式：第0层n个，第一层平均n/4个，第二层平均n/16个，等比数列求和得到大约4n/3个。</p><h2 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h2><ul><li>从dummyhead的最高层level出发。</li><li>比较当前层下一个节点的key与待查key<ul><li>小于待查key<ul><li>当前层next节点为空，向下一层。</li><li>否则移动到当前层forward节点。</li></ul></li><li>大于待查key<ul><li>当前层不为第0层，向下一层。</li><li>当前层为第0层，查找失败。</li></ul></li><li>等于待查key，查找成功。</li></ul></li></ul><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h2><p><img src="https://pic4.zhimg.com/80/v2-6a28162637f7ec3496470aa8c2d73f6b_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-6a28162637f7ec3496470aa8c2d73f6b_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>先查询合适的插入位置。在查询的过程中记录每层最后一个遍历到的节点作为update数组。</li><li>创建新节点，随机生成待插入节点的level。如果level大于跳表当前最大层数，则将level设为跳表最大层数+1，update[level]更新为dummyhead。</li><li>用update连接上新节点，更新新节点各层的指针。</li></ul><h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><p><img src="https://pic4.zhimg.com/80/v2-41ed3ff71b11abc2e6aa79de40f6f95f_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-41ed3ff71b11abc2e6aa79de40f6f95f_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>与插入类似，记录update，移除时调整update中各节点指针指向。</p><p>删除后，跳表当前最大层数可能发生变化，需要调整。具体为dummyhead节点最高level向下查，看next指针是否为空，为空则将level-1。</p><h2 id="5-比较"><a href="#5-比较" class="headerlink" title="5. 比较"></a>5. 比较</h2><p>与哈希表：范围查找。</p><p>与平衡树：</p><ul><li>范围查找。</li><li>平衡树增删触发染色、旋转操作<ul><li>实现复杂</li><li>可能需要回溯，涉及节点多，并发时锁范围大，导致效率低。</li></ul></li><li>内存占用，平衡树每个节点至少需要两个指针，跳表p=1/4时平均每个节点只要1.33个指针。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab2-1</title>
      <link href="/2023/03/23/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-1/"/>
      <url>/2023/03/23/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-BPlusTreePage"><a href="#1-BPlusTreePage" class="headerlink" title="1. BPlusTreePage"></a>1. BPlusTreePage</h1><h2 id="1-BPlusTreePage-1"><a href="#1-BPlusTreePage-1" class="headerlink" title="1. BPlusTreePage"></a>1. BPlusTreePage</h2><p>根据Lab1-3，Page有这些metadata：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data_[BUSTUB_PAGE_SIZE]&#123;&#125;;  <span class="comment">// 存储数据，大小为4096即4K</span></span><br><span class="line"><span class="keyword">page_id_t</span> page_id_ = INVALID_PAGE_ID;  <span class="comment">// 映射的物理页号</span></span><br><span class="line"><span class="keyword">int</span> pin_count_ = <span class="number">0</span>;  <span class="comment">// 引用计数</span></span><br><span class="line"><span class="keyword">bool</span> is_dirty_ = <span class="literal">false</span>;  <span class="comment">// 脏页标志</span></span><br><span class="line">ReaderWriterLatch rwlatch_;  <span class="comment">// 读写锁，后面的lab才用到</span></span><br></pre></td></tr></table></figure><p>data_就是我们存放B+树节点的位置，总大小为4K。</p><p>BPlusTreePage实际上是抽象类，分为BPlusTreeInternalPage与BPlusTreeLeafPage两个子类，分别表示非叶子几点与叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IndexPageType page_type_;  <span class="comment">// 该页存储非叶子节点还是叶子节点</span></span><br><span class="line"><span class="keyword">lsn_t</span> lsn_;  <span class="comment">// 日志序列号，Lab4才用</span></span><br><span class="line"><span class="keyword">int</span> size_;  <span class="comment">// 页中的键值对数目（对应叶子节点，是k-v；对于非叶子节点，是键-子节点指针数，因为子节点指针数会比键数多1，约定第一个键为空）</span></span><br><span class="line"><span class="keyword">int</span> max_size_;  <span class="comment">// 页最大储存的键值对数目</span></span><br><span class="line"><span class="keyword">page_id_t</span> parent_page_id_;  <span class="comment">// 父节点的物理页号</span></span><br><span class="line"><span class="keyword">page_id_t</span> page_id_;  <span class="comment">// 物理页号</span></span><br></pre></td></tr></table></figure><p>我们知道，B+树的特点：</p><ul><li>非叶子节点不存储数据。</li><li>叶子节点由双向链表相连。（本Lab中为单向链表）</li></ul><p>所以两者实现存在差别。</p><h2 id="2-BPlusTreeInternalPage"><a href="#2-BPlusTreeInternalPage" class="headerlink" title="2. BPlusTreeInternalPage"></a>2. BPlusTreeInternalPage</h2><h3 id="1-弹性数组"><a href="#1-弹性数组" class="headerlink" title="1. 弹性数组"></a>1. 弹性数组</h3><p>BPlusTreeInternalPage只多了个这个，放在最后。</p><p>为什么大小为1？使用了弹性数组思想。</p><p>我们不能确定这个数组大小（键值对数目）应该如何设置，但知道整张页的大小，就可以使用弹性数组。</p><p>该数组必须是类最后一个成员，且大小只能为1。为对象分配内存时，它会自动填充，占用未被其他变量使用的内存，来确定自己的长度。</p><p>本Lab中，其所占空间为4KB-24bytes（BPlusTreePage类中放的那些）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MappingType array_[<span class="number">1</span>];  <span class="comment">// MappingType为pair&lt;K, V&gt;</span></span><br><span class="line"><span class="comment">// InternalPage中，K为索引，V为page_id，指向下一层节点。之前约定了第一个K为空</span></span><br><span class="line"><span class="comment">// K对应的page_id即为大于等于当前K，但小于下一个K的索引所在的page</span></span><br></pre></td></tr></table></figure><h3 id="2-size的问题"><a href="#2-size的问题" class="headerlink" title="2. size的问题"></a>2. size的问题</h3><p>B+树的索引节点有n个键与n+1个值，数量不相等。</p><p>InternalPage对此的设置是：</p><ul><li>键值对数组的第一个键为空，表示小于第二个键所在的Page编号。</li><li>其他每个键对应的值存储的是大于等于该键、小于下一个键的键所在的Page编号。</li></ul><p>那么问题来了，size到底包不包含第一个键值对呢？设置的是<strong>包含</strong>。</p><p>如果设置不包含，Internal与Leaf的Size会出现歧义，写查找等代码容易把自己绕进去。</p><h3 id="3-min-size"><a href="#3-min-size" class="headerlink" title="3. min_size"></a>3. min_size</h3><p>n为max_size</p><p>Leaf页n/2向下取整。</p><p>Internal页n/2向上取整。（因为在设计时，内部节点天生少一个key）</p><h2 id="3-BPlusTreeLeafPage"><a href="#3-BPlusTreeLeafPage" class="headerlink" title="3. BPlusTreeLeafPage"></a>3. BPlusTreeLeafPage</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">page_id_t</span> next_page_id_;  <span class="comment">// 链表的next指针</span></span><br><span class="line">MappingType array_[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这里就会发现一个问题：Bustub的所有索引都是非聚簇索引。因为此处设计的V只有一个，且大小固定，意思应该是指向实际数据的recorid_id（RID里是这么写的，暂且不知道要怎么用）。</p><h2 id="4-额外提示"><a href="#4-额外提示" class="headerlink" title="4. 额外提示"></a>4. 额外提示</h2><p>官方给了些额外提示：</p><ul><li>两种Page的value是不一样的，Internal的value是子页节点的物理页号，而Leaf的value是指向实际数据的指针。</li><li>B+树页在读取时势必会加载到缓冲区中，所以：<ul><li>在读之前，先要fetch对应的页。</li><li>然后将页reinterpret_cast为对应类型的B+树页。</li><li>读写完毕之后再减少引用计数。</li></ul></li></ul><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><p>基本都是后面写着写着再来加的。</p><p>因为key是自定义类型，编译器不一定实现了比较方法，所以传入KeyComparator类型的用于key比较的伪函数。</p><h2 id="1-InternalPage"><a href="#1-InternalPage" class="headerlink" title="1. InternalPage"></a>1. InternalPage</h2><p>设计问题：</p><ul><li>size是否包含第一个空键，之前说过了，是<strong>包含</strong>的。</li></ul><p>实现的一些方法：</p><h3 id="1-根据索引查key-value，或者反过来"><a href="#1-根据索引查key-value，或者反过来" class="headerlink" title="1. 根据索引查key/value，或者反过来"></a>1. 根据索引查key/value，或者反过来</h3><h3 id="2-Lookup"><a href="#2-Lookup" class="headerlink" title="2. Lookup"></a>2. Lookup</h3><p>输入：</p><ul><li>key</li><li>comparator</li></ul><p>输出：key对应的value。因为是InternalPage，含义即为，通过key找到应该跳转到的子页面编号。</p><p>具体逻辑：</p><ul><li>通过lower_bound找到大于等于当前key的第一个位置k。</li><li>如果越界，直接返回最后一个子页面编号。</li><li>否则<ul><li>如果k等于当前key，返回k对应的子页面编号。（因为每个k存储的是所有&gt;=k且&lt;下一个key的索引与数据所在的页面）</li><li>否则，返回k的上一个子页面编号。</li></ul></li></ul><p>有点抽象，感觉应该举个例子？</p><p>比如两个key分别为3和5</p><ul><li>3存储了key在 [3, 5) 之间的索引与数据所在的页面</li><li>5存储了 [5, +∞) 的索引与数据所在的页面</li><li>如果传入的key为4：<ul><li>大于等于4的第一个位置为5，4与5不相等，返回5的上一个3对应的子页面编号，因为4在 [3, 5)</li></ul></li><li>如果传入的key为5：<ul><li>大于等于5的第一个位置为5，5与5相等，返回5对应的子页面编号，因为5在 [5, +∞)</li></ul></li></ul><h3 id="3-MoveHalf-CopyData"><a href="#3-MoveHalf-CopyData" class="headerlink" title="3. MoveHalf/CopyData"></a>3. MoveHalf/CopyData</h3><p>用在Insert的节点分裂中，这里只需要完成分裂逻辑即可，不需要关心如何分裂。</p><p>输入：</p><ul><li>dst_page：src_page就是本页面。</li><li>bpm：缓存池对象，因为需要取出子页面重设parent。</li></ul><p>具体逻辑：</p><ul><li>通过GetMinSize算出本页面留下的键值对数，将剩下的通过CopyData拷贝到新页面。</li><li>CopyData<ul><li>先拷贝键值对，重设新页面的size。</li><li>通过bpm取出新页面的所有子页面，重设其parent，然后unpin。</li></ul></li><li>重设本页面的size。</li></ul><h3 id="4-Insert系列函数"><a href="#4-Insert系列函数" class="headerlink" title="4. Insert系列函数"></a>4. Insert系列函数</h3><p>InternalPage设计比较特殊，所以还要分出头部插入、尾部插入、中间插入这些情况。</p><p>插入后记得把插入的value（子页面编号）拿出来设置一下parent。</p><h2 id="2-LeafPage"><a href="#2-LeafPage" class="headerlink" title="2. LeafPage"></a>2. LeafPage</h2><h3 id="1-根据索引查key-value，或者反过来-1"><a href="#1-根据索引查key-value，或者反过来-1" class="headerlink" title="1. 根据索引查key/value，或者反过来"></a>1. 根据索引查key/value，或者反过来</h3><h3 id="2-Lookup-1"><a href="#2-Lookup-1" class="headerlink" title="2. Lookup"></a>2. Lookup</h3><p>为什么跟InternalPage的不一样？</p><ul><li>InternalPage的key代表的是范围，是一定能找到的，而LeafPage却不一定。</li></ul><p>输入：</p><ul><li>key</li><li>value指针，用来返回查找的value</li><li>comparator</li></ul><p>输出：bool，是否找到</p><p>具体逻辑：</p><ul><li>通过key找到对应的idx<ul><li>如果idx越界，或者idx对应的key不等于key，返回false。</li></ul></li><li>将idx对应的value存入参数value指针中，返回true。</li></ul><h3 id="3-MoveHalf-CopyData-1"><a href="#3-MoveHalf-CopyData-1" class="headerlink" title="3. MoveHalf/CopyData"></a>3. MoveHalf/CopyData</h3><p>为什么跟InternalPage的不一样？</p><ul><li>LeafPage存的是具体数据的位置，不需要设置parent。</li></ul><h3 id="4-Insert"><a href="#4-Insert" class="headerlink" title="4. Insert"></a>4. Insert</h3><p>输入：</p><ul><li>key</li><li>value</li><li>comparator</li></ul><p>输出：插入后本页的size</p><p>具体逻辑：</p><ul><li>先找到key对应的idx。<ul><li>如果越界，说明应该在尾部插入，插入后返回。</li></ul></li><li>否则如果idx对应的key与key相等，说明已经有了该key，插入失败，直接返回。</li><li>否则，将idx及后面位置的元素向后移动一位，然后将k-v插入idx位置。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab1-3</title>
      <link href="/2023/03/23/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-3/"/>
      <url>/2023/03/23/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-BufferPoolManagerInstance"><a href="#1-BufferPoolManagerInstance" class="headerlink" title="1. BufferPoolManagerInstance"></a>1. BufferPoolManagerInstance</h1><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1. 理论"></a>1. 理论</h2><p>1-3要实现的是基于1-1的哈希表与1-2的lru-k cache的内存页面置换算法。</p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>Page：表示缓存页</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data_[BUSTUB_PAGE_SIZE]&#123;&#125;;  <span class="comment">// 存储数据，大小为4096即4K</span></span><br><span class="line"><span class="keyword">page_id_t</span> page_id_ = INVALID_PAGE_ID;  <span class="comment">// 映射的物理页号</span></span><br><span class="line"><span class="keyword">int</span> pin_count_ = <span class="number">0</span>;  <span class="comment">// 引用计数</span></span><br><span class="line"><span class="keyword">bool</span> is_dirty_ = <span class="literal">false</span>;  <span class="comment">// 脏页标志</span></span><br><span class="line">ReaderWriterLatch rwlatch_;  <span class="comment">// 读写锁，后面的lab才用到</span></span><br></pre></td></tr></table></figure><p>page代表物理页号，frame代表缓存页号。</p><p>pin_count类似于引用计数？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> pool_size_;  <span class="comment">// pages_数组大小，代表缓存页数目</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">page_id_t</span>&gt; next_page_id_ = <span class="number">0</span>;  <span class="comment">// 下一个分配的物理页号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> bucket_size_ = <span class="number">4</span>;  <span class="comment">// ExtendibleHashTable的桶大小</span></span><br><span class="line"></span><br><span class="line">Page *pages_;  <span class="comment">// 具体的缓存页，可通过frame_id访问</span></span><br><span class="line">DiskManager *disk_manager_;  <span class="comment">// 具体读写磁盘的对象。在页面将要被换出或强制刷盘时，通过该指针的WritePage方法写磁盘；在从磁盘加载已存在的页时，通过该指针的ReadPage方法读磁盘</span></span><br><span class="line">ExtendibleHashTable&lt;<span class="keyword">page_id_t</span>, <span class="keyword">frame_id_t</span>&gt; *page_table_;  <span class="comment">// 物理页号-缓存页号的映射关系</span></span><br><span class="line">LRUKReplacer *replacer_;  <span class="comment">// 非空闲的缓存页lru-k淘汰策略</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">frame_id_t</span>&gt; free_list_;  <span class="comment">// 空闲缓存页链表</span></span><br><span class="line"><span class="built_in">std</span>::mutex latch_;  <span class="comment">// 互斥锁</span></span><br></pre></td></tr></table></figure><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-GetFrame"><a href="#1-GetFrame" class="headerlink" title="1. GetFrame"></a>1. GetFrame</h2><p>因为NewPgImp和FetchPgImp都是要找一个闲置或能被换出的缓存页号，所以将这部分抽象为GetFrame方法。</p><p>输入：frame_it_t* 通过指针传递找到的缓存页号。</p><p>输出：bool 代表是否找到。</p><p>具体逻辑：</p><ul><li>优先找free_list，如果不为空就取出一个闲置的缓存页号，赋给参数，返回true。</li><li>然后找lru-k，通过Evict方法尝试能否取出一个evictable=true的缓存页号。如果能取出：<ul><li>该页可能为脏页，需要先写回磁盘。</li><li>在哈希表中移除映射关系。</li><li>将该缓存页号赋给参数。</li><li>重置该缓存页。</li><li>返回true。</li></ul></li><li>如果都找不到，说明缓存页都被占用，且都不可被换出，返回false。</li></ul><h2 id="2-NewPgImp"><a href="#2-NewPgImp" class="headerlink" title="2. NewPgImp"></a>2. NewPgImp</h2><p>申请一块新的物理页，并尝试换入缓存。</p><p>输入：page_id_t* 通过指针传递成功创建的物理页号。</p><p>输出：如果成功创建，返回对应的缓存页指针；否则返回nullptr。</p><p>具体逻辑：</p><ul><li>加锁。</li><li>通过GetFrame尝试找能用的缓存页，如果找到：<ul><li>AllocatePage分配新的物理页号，传给参数。</li><li>重置该缓存页信息，物理页号为上一步新创建的，pin_count置为1。<ul><li>因为是新建的页，所以不需要ReadPage。</li></ul></li><li>在哈希表中加入映射关系。</li><li>lru-k记录一次访问，并设置不可移除<ul><li>因为新建页一般会马上访问。</li></ul></li><li>返回缓存页指针。</li></ul></li><li>找不到，返回nullptr。</li></ul><h2 id="3-FetchPgImp"><a href="#3-FetchPgImp" class="headerlink" title="3. FetchPgImp"></a>3. FetchPgImp</h2><p>为一块已有的物理找一块缓存页。</p><p>输入：page_id_t 物理页号</p><p>输出：如果成功找到，返回对应的缓存页指针；否则返回nullptr。</p><p>具体逻辑：</p><ul><li>加锁</li><li>如果该页已有了映射的缓存页：<ul><li>lru-k记录一次访问，并设置不可移除。</li><li>自增对应缓存页的pin_count。</li><li>返回缓存页指针。</li></ul></li><li>如果该页没有映射的缓存页，通过GetFrame尝试找能用的缓存页，如果找到：<ul><li>重置该缓存页信息，虚拟页框号为上一步新创建的，pin_count置为1。<ul><li>因为是已有的页，所以需要ReadPage。</li></ul></li><li>在哈希表中加入映射关系。</li><li>lru-k记录一次访问，并设置不可移除<ul><li>因为一般会马上访问。</li></ul></li><li>返回缓存页指针。</li></ul></li></ul><h2 id="4-UnpinPgImp"><a href="#4-UnpinPgImp" class="headerlink" title="4. UnpinPgImp"></a>4. UnpinPgImp</h2><p>一般是进程对该物理页访问结束了，减少一次引用计数。</p><p>输入：page_id_t 待操作的物理页号，bool 是否修改过该页（是否设置脏页）</p><p>输出：</p><ul><li>true：找到该页并且成功减少pin_count。</li><li>false：找不到该页；该页的pin_count不能再被减少。</li></ul><p>具体逻辑：</p><ul><li>加锁</li><li>找到该页，如果找不到返回false。</li><li>如果该页对应的缓存页pin_count已经为0，返回false。</li><li>如果is_dirty，设置脏页标记。</li><li>减少pin_count.</li><li>如果该页pin_count降到0，则设置为可移出。</li><li>返回true。</li></ul><h2 id="5-FlushPgImp"><a href="#5-FlushPgImp" class="headerlink" title="5. FlushPgImp"></a>5. FlushPgImp</h2><p>输入：page_id_t 待刷盘的物理页号。</p><p>输出：如果该页有对应的缓存页，返回true，否则false。</p><p>具体逻辑：</p><ul><li>加锁</li><li>找到对应的缓存页，不管dirty位直接刷盘。</li><li>将dirty位置为false。</li></ul><h2 id="6-FlushAllPgsImp"><a href="#6-FlushAllPgsImp" class="headerlink" title="6. FlushAllPgsImp"></a>6. FlushAllPgsImp</h2><p>具体逻辑：</p><ul><li>加锁</li><li>遍历pages，只要不为无效页，都刷盘。</li></ul><h2 id="7-DeletePgImp"><a href="#7-DeletePgImp" class="headerlink" title="7. DeletePgImp"></a>7. DeletePgImp</h2><p>输入：page_id_t 待删除的物理页号</p><p>输出：如果无法删除（对应的缓存页还有pin_count，即还有其他进程访问），返回false，否则都返回true。（踩坑点：找不到也返回true）</p><p>具体逻辑：</p><ul><li>加锁</li><li>找对应的缓存页</li><li>如果删不掉，返回false。</li><li>如果为脏页，先刷盘。</li><li>从lru中移除，加入free_list。</li><li>重置页面信息。</li><li>DeallocatePage（实际上没用，就是做个样子）</li></ul><h1 id="3-框架理解"><a href="#3-框架理解" class="headerlink" title="3. 框架理解"></a>3. 框架理解</h1><p>disk_manager</p><p>使用到了ReadPage与WritePage两个方法。</p><p>具体实现：使用一个文件表示内存，文件流fstream类进行读写操作。</p><h2 id="1-WritePage"><a href="#1-WritePage" class="headerlink" title="1. WritePage"></a>1. WritePage</h2><p>具体逻辑：</p><ul><li>加锁</li><li>根据物理页号*物理页大小（4K）获得offset偏移量。</li><li>根据偏移量移动文件流指针到对应页开头，写数据。</li><li>将文件流刷盘。</li></ul><h2 id="2-ReadPage"><a href="#2-ReadPage" class="headerlink" title="2. ReadPage"></a>2. ReadPage</h2><p>具体逻辑：</p><ul><li>加锁</li><li>根据物理页号*物理页大小（4K）获得offset偏移量。<ul><li>偏移量不能大于文件大小。</li></ul></li><li>根据偏移量移动文件流指针到对应页开头，读数据。<ul><li>如果读出来的数据比一页要少，可能存在bug，将当前页读出来的数据后面的数据置为0。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-Raft一致性协议</title>
      <link href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Raft%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Raft%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h1><p><a href="https://www.jianshu.com/p/7a313173b56a">讲的挺清楚的</a></p><p>一个共识算法，即多个节点对某事达成一致的看法。</p><p>Raft算法首要目标是易理解，对Paxos算法做了问题分解、状态简化。</p><p>两个核心属性：</p><ul><li>可靠性：已提交的日志不会再修改。由已提交的日志存在于大多数节点上、日志最新的节点才能获得大多数投票保证。</li><li>一致性：所有节点数据一致。</li></ul><p>要达成的目标：</p><ul><li>安全性保证：非拜占庭错误下，网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。</li><li>可用性：集群中只要有大多数机器可运行且能相互通信、和客户端通信，就能保证可用。</li><li>不依赖时序保证一致性：物理时钟错误或极端消息延迟只有在最坏情况下才会导致可用性问题。</li><li>通常情况下，一条指令可以尽可能快的在进群中大多数节点响应一轮远程过程调用时完成，小部分较慢的节点不影响整体性能。</li></ul><p>大致流程：选举出leader，leader完全负责replicated log的管理。leader负责接收所有客户端更新请求，然后复制到follower节点，并在安全的时候执行这些请求。如果leader故障，会在follower中选出新leader。</p><p><strong>非leader接收到客户端的请求会转交给leader。</strong></p><h1 id="2-状态"><a href="#2-状态" class="headerlink" title="2. 状态"></a>2. 状态</h1><p>一个节点有三种状态：</p><ul><li>leader：最多只有一个。接收到更新的term的心跳包时变成follower。</li><li>follower：启动时的初始状态。心跳包超时时变为candidate。</li><li>candidate：发现其他更新的节点时变为follower；选举超时（一段时间没收到多数票）时开始新一轮选举；收到多数票时变为leader。</li></ul><p>term：每个term从新一轮选举开始，到开始下一轮选举结束（有follower心跳包超时变为candidate）。每个节点各自维护term计数，当自己变为candidate时就自增term，否则等到更高term的包到来时同步自己的term。term递增，可以充当逻辑时钟的作用。</p><h1 id="3-选举"><a href="#3-选举" class="headerlink" title="3. 选举"></a>3. 选举</h1><p>系统刚开启时，所有节点都是follower；follower心跳包超时（leader挂了、没选出leader、网络故障）后，主动发起选举：</p><ul><li>增加本地term，切换到candidate。</li><li>投自己一票。</li><li>向其他所有节点请求投票。</li><li>等待回复。</li></ul><p>结果有三种：</p><ul><li>发现总票数大于节点数的一半，成为leader并发送心跳包。</li><li>收到心跳包（其他人当选），成为follower。</li><li>一段时间内没收到多数票，保持candidate状态并重新发起选举。平票会导致系统不可用，需要避免，因此设置每个节点随机选举超时时间、节点数目为奇数来避免平票。</li></ul><p>投票约束：</p><ul><li>1个term内只能投一票。</li><li>候选人日志不能比该节点旧（有不同term时，term越新日志越新；term相同时，日志越长越新）。<ul><li>不能以长度为第一选择项：可能有节点连续当选，然后都在收到日志之后复制日志之前崩溃，这样其本地日志会一直变长，而其他节点没有。</li><li>不要求commit。</li></ul></li><li>先到先得。</li></ul><p>超时时间一般设置150ms~300ms：</p><ul><li>不能太短：新的leader节点心跳包还来不及到达，就已经超时发起选举推翻leader了。</li><li>不能太长：如果选不出leader，所有节点都在等待超时，系统不可用时间会较长。</li></ul><h2 id="Go实现"><a href="#Go实现" class="headerlink" title="Go实现"></a>Go实现</h2><p>监控选举超时的goroutine：</p><p>将startElection()也作为一个goroutine：如果electionTimer超时时，候选者还未当选，则需要放弃选举，开启新一轮选举。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">ticker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-rf.electionTimer.C:</span><br><span class="line">            rf.mu.Lock()</span><br><span class="line">            <span class="keyword">if</span> rf.state == LEADER &#123;</span><br><span class="line">                rf.mu.Unlock()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            rf.state = CANDIDATE</span><br><span class="line">            rf.mu.Unlock()</span><br><span class="line">            <span class="keyword">go</span> rf.startElection()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startElection()</p><ul><li>使用n-1个协程并行发送RequestVote请求。</li><li>使用n-1大小的chan接收投票结果。</li><li>统计投票结果<ul><li>如果统计过程中失去了Candidate身份，则停止统计</li><li>如果获得票数过半，则当选leader，启动HeartBeat携程</li><li>如果所有成员已投票且未当选leader，则退出统计</li></ul></li></ul><p>HeartBeat()</p><ul><li>为每个节点分配一个replicator协程，接收两种类型的chan消息<ul><li>wake：唤醒协程发送AppendEntries RPC</li><li>done：中断协程</li></ul></li><li>先进行初始broadcast()，对应Leader刚当选的心跳，通过wake chan唤醒所有replicator协程发送心跳包</li><li>初始化heartbeatTimer，到期时broadcast()<ul><li>如果节点被kill或不再是leader，需要中断heartbeatTimer且释放所有replicator协程</li></ul></li></ul><p>注意点：发送心跳包需要另起一个协程运行，避免在发送过程中，Leader又发送了新的broadcast，或者不再是Leader。</p><h1 id="4-log复制"><a href="#4-log复制" class="headerlink" title="4. log复制"></a>4. log复制</h1><p>客户端不知道leader：如果非leader的节点发送到客户端请求，就会拒绝请求，并提供该节点知道的关于最新leader的信息。如果leader崩溃，客户端请求超时，会选择随机节点重试。</p><p>约束：</p><ul><li>leader不能删改自己的日志，也不能从follower处更新自己的日志，只能从客户端处追加。</li><li>leader强制要求follower的日志与自己相同。</li><li>超过半数的follower收到该条日志后，leader就更新commitIndex并将日志应用到状态机，保证该条日志生效。</li></ul><p>选举完成后进入工作期。客户端请求发给leader，leader调度请求并保证与follower的一致性。</p><p><strong>基于复制状态机：相同的初始状态+相同输入=相同的结束状态。</strong></p><p>leader将客户端请求与term等信息封装成log entry，复制到所有follower节点，大家按相同顺序应用log entry中的请求，能保证状态一致。</p><p>保证：</p><ul><li>不同日志中两个条目有相同的term与index，则它们存储相同指令，且它们之前的所有日志全部相同。</li></ul><p>维护状态：</p><ul><li><p>leader维护所有节点的NextIndex、MatchIndex，每个节点维护自身的CommitIndex。</p></li><li><p>NextIndex表示待发往该节点的Entry Index，初始化为leader的log长度，表示从最后一天开始往前试探</p><ul><li>NextIndex是对追加位置的一种猜测，是乐观估计</li></ul></li><li><p>MatchIndex表示已匹配的Entry Index，初始化为0，表示还不知道匹配进度</p><ul><li>MatchIndex是对同步情况的保守确认，为了保证安全性</li><li>MatchIndex与NextIndex在一次次心跳中不断靠近，直到MatchIndex=NextIndex-1，表示Follower已经与Leader同步成功</li></ul></li><li><p>CommitIndex表示当前已提交的EntryIndex</p></li><li><p>转为Leader后，MatchIndex、CommitIndex置0，NextIndex为自己最后一条日志Index+1。</p></li></ul><p>leader行动：</p><ul><li>添加log entry。</li><li>在心跳包中附带上log entry与前一条entry信息。Follower收到后校验该entry前一条日志是否匹配（比较自己prevLogIndex位置上的日志的term是否为prevLogTerm），是则直接写入entry，否则删除不匹配的日志，返回失败。</li><li>等待多数响应。每有一条成功的返回消息，更新对应节点的NextIndex和MatchIndex，继续发送后续的Entry。每有一条失败的返回消息，回退NextIndex继续发送（可优化为回退一个term），直到其返回成功。follower更新nextindex及之后的所有log entry。</li><li>如果大多数节点的MatchIndex大于CommitIndex，就更新CommitIndex。对自己的状态机应用log entry。CommitIndex更新条件：<ul><li>存在index值N &gt; CommitIndex</li><li>过半数matchIndex &gt;= N</li><li>log[N].term == currentTerm<ul><li>特性：Leader仅会直接提交其任期内的entry，不在其任期内的则会通过提交之后的entry来间接提交。简化了Leader当选初始化工作、避免了已提交entry被覆盖的问题。</li></ul></li></ul></li><li>回复客户端ACK。</li><li>心跳包中附带上Leader最新的CommitIndex。Follower发现心跳包的CommitIndex大于自身，则应用状态，将自身的CommitIndex更新为自身最新的LogIndex与leader的CommitIndex的最小值。（应设定为<strong>只在没有log同步时才同步commit</strong>）</li><li>等待多数响应。</li></ul><p><strong>只要log entry复制到多数节点，就能保证不会被回滚</strong>。</p><h2 id="go实现"><a href="#go实现" class="headerlink" title="go实现"></a>go实现</h2><p>每个Follower节点具有的后台goroutine：</p><ul><li>alerter：1个。监听electionTimer的超时时间、重置事件。<ul><li>超时事件：转变为Candidate，发起选举。</li></ul></li><li>applier：1个。监听applier chan。节点认为需要apply时，向applier chan发送一次信号。applier接收信号后，将当前lastApplied和commitIndex间所有entry提交。</li><li>heartbeat：1个。监听heartbeatTimer的超时事件，仅在Leader状态工作。<ul><li>超时事件：广播心跳命令。</li></ul></li><li>replicator：n-1个，每一个对应一个peer，监听心跳广播命令，仅在节点为Leader时工作。接收到命令后，向对应的peer发送心跳。</li></ul><p>注意点：</p><ul><li>请求投票和广播是并行异步，各个routine发送RPC的args要完全一致，所以必须在启动routine前准备好。</li><li>reply由于log冲突返回false，可直接告诉leader发生冲突的位置，而不必每次将nextIndex-1多次重试。</li></ul><h1 id="5-集群变更"><a href="#5-集群变更" class="headerlink" title="5. 集群变更"></a>5. 集群变更</h1><p>在系统运行时动态增删节点。</p><p><strong>约定一次只能变更一个节点。</strong></p><p>问题：假设一开始三个节点，假设增加两个节点后触发选举，1、2节点保存的配置只有3个节点，所以节点1获得1、2的选票当选；新节点5获得3、4、5的选票当选，出现两个节点。</p><p>Raft在新旧配置之间添加过渡阶段处理，称为联合共识阶段。该阶段约束：（这里的新配置指新节点+老节点）</p><ul><li>日志条目被复制给集群中新、老配置的所有节点。</li><li>新加入节点和原有节点都能成为leader。</li><li>达成一致需要分别在两种配置上超过半数。</li></ul><p><strong>C-old-new日志与C-new日志都是在follower收到后立马apply</strong>，而不必等leader的commit。</p><h2 id="1-添加节点"><a href="#1-添加节点" class="headerlink" title="1. 添加节点"></a>1. 添加节点</h2><p>两阶段变更。</p><p>通过发送日志来发送配置变更日志指令。假设向三个节点的集群添加两个节点。</p><p>阶段一：客户端发送新配置给leader，leader将新老配置取并集，包装为C-old-new日志。</p><ul><li>leader apply并发送C-old-new，复制给follower节点，但提交后不对状态机数据有任何变动。</li><li>follower收到C-old-new后立即apply，进入联合共识阶段。1为leader，复制给4、5，而2、3在旧配置。老的1、2、3集群中日志未超过半数，所以不能提交。</li><li>假设2收到C-old-new，这样老集群超过半数处在联合共识阶段，即使leader崩溃，新leader也会处于该阶段。</li></ul><p>阶段二：</p><ul><li>leader apply并发送C-new，告知follower可以切换到新集群。在这段时间，客户端的指令可以正常提交，但是得满足联合共识约束。</li><li>follower收到C-new后立即apply，如果发现自己不在C-new，立即退出集群。</li><li>leader确认C-new大部分节点切换成功后，响应客户端成功。</li></ul><h2 id="2-删除节点-特例：删除leader"><a href="#2-删除节点-特例：删除leader" class="headerlink" title="2. 删除节点-特例：删除leader"></a>2. 删除节点-特例：删除leader</h2><p>可能要删除leader节点。假设删除1、5.</p><ul><li>leader发送C-old-new，超过半数收到后提交。</li><li>leader发送C-new。因为其还没生效，所以1仍然行使leader职责，只是超过半数时不计算他自己。</li><li>leader提交C-new之后，退位。</li><li>新集群中的节点重新选取leader。</li></ul><h1 id="6-安全性"><a href="#6-安全性" class="headerlink" title="6. 安全性"></a>6. 安全性</h1><p>任何系统模型都要满足安全性，即任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误内容。</p><h2 id="1-选举安全"><a href="#1-选举安全" class="headerlink" title="1. 选举安全"></a>1. 选举安全</h2><p>保证任意一次选举最多只有一个leader</p><ul><li>一个节点1个term只能投一票。</li><li>只有获得多数票才会当选。</li><li>只能响应term大于等于自己term的请求。</li></ul><p>决定是否投票给candidate</p><ul><li>candidate term不小于自身term</li><li>自身还没有投票</li><li>candidate日志比自己新</li></ul><p>保证不进入超时-选举循环</p><ul><li>所有follower投给自己：设置随机超时时间。</li><li>平票：奇数节点；设置随机超时时间。</li></ul><p>保证leader出现后其他节点迅速达成一致：可能会出现情况：leader刚被选举出来，但是另一个节点B选举超时发起新的选举，term更高，A收到请求后被迫变成follower。</p><ul><li>leader产生后迅速发出心跳。</li><li>合理设置超时时间，应该远大于广播时间。</li></ul><h2 id="2-leader完整性"><a href="#2-leader完整性" class="headerlink" title="2. leader完整性"></a>2. leader完整性</h2><p>如果一个log entry在某个term内被提交，这条log entry一定会出现在所有更高term的leader的日志中。</p><ul><li>一个log entry被复制到多数节点才算提交。</li><li>一个节点得到多数投票才能成为leader。</li><li>一个节点给其他节点投票的前提是，其他节点日志不能比该节点旧（有不同term时，term越新日志越新；term相同时，日志越长越新）。</li></ul><h2 id="3-复制安全性"><a href="#3-复制安全性" class="headerlink" title="3. 复制安全性"></a>3. 复制安全性</h2><p>两个约定：</p><ul><li>Leader节点只追加log数据，不修改与删除已有数据。</li><li>Follower在指定index上的log条目与Leader term不一致，则用Leader的log覆盖。</li></ul><p>相同index处follower term号比leader大：follower原来是leader，日志没同步半数后崩溃。</p><ul><li>follower删除自己的。</li></ul><p>新leader没有最新的数据</p><ul><li>给它投票的前提就是其log比自己更新，所以不可能有不是最新数据的leader。</li></ul><p>follower应用日志到状态机的时间</p><ul><li>后续leader发送心跳包或日志时，follower发现自己的commitindex小于leader，就更新并应用。</li></ul><p>leader提交并返回客户端后自己挂了</p><ul><li>新的leader一定是有最新日志的，也包括了原leader挂了前提交的日志，所以新leader会继续复制该日志。</li></ul><p>日志复制超过半数节点，leader还没提交就崩溃</p><ul><li>Raft核心：只要Leader把某个日志应用到状态机，最终所有节点都能把该日志应用到状态机。</li><li>日志只是复制到半数节点，Leader还没应用，所以不保证该条日志后续一定提交。（客户端没有收到肯定答复，所以无法确认最终是否生效）</li><li>日志被提交生效的充分必要条件是，日志被复制到超过半数节点，且日志是当前Leader任期内从客户端收到。（不是当前任期内收到，会在提交后续日志的同时顺带提交）</li></ul><h2 id="4-扩容安全性"><a href="#4-扩容安全性" class="headerlink" title="4. 扩容安全性"></a>4. 扩容安全性</h2><p>leader发送C-old-new时崩溃，会不会有多个leader</p><ul><li>C-old-new收到就按新配置运行，不要等提交。假设旧配置集群选出了leader，因为它们都投了票，所以联合共识阶段的节点无法在旧配置集群中获得多数选票，无法产生第二个leader。</li></ul><p>新当选的leader会继续提交C-old-new吗？</p><ul><li>不一定。旧配置集群中的节点当选时，联合共识阶段节点的C-old-new会被删除。此时客户端没有收到leader的确认信息，所以系统不保证节点一定添加成功，客户端需要重新发出指令添加节点。</li></ul><p>老集群超过半数处于联合共识阶段时leader崩溃。</p><ul><li>投票约束保证老集群当选的leader也一定有C-old-new。</li></ul><h2 id="5-缩容安全性"><a href="#5-缩容安全性" class="headerlink" title="5. 缩容安全性"></a>5. 缩容安全性</h2><p>leader提交C-new之前，客户端发来新的日志</p><ul><li>leader工作在C-new下，会将日志复制到新集群节点上，收到新集群半数以上确认后提交日志。</li></ul><h2 id="6-可用性"><a href="#6-可用性" class="headerlink" title="6. 可用性"></a>6. 可用性</h2><p>新节点同步数据期间无法提交新日志，造成集群短时间不可用：</p><ul><li>新节点同步数据期间可以以<strong>没有投票权</strong>的方式加入。</li></ul><p>被删除的节点在leader进入新配置后不再收到心跳，触发选举使leader失效：</p><ul><li>节点确认当前leader存在时，忽略请求投票。</li><li>确认存在：收到请求投票时间距离上次收到心跳或日志的时间不超过超时时间。</li></ul><h1 id="7-快速恢复-由逐个变为逐term"><a href="#7-快速恢复-由逐个变为逐term" class="headerlink" title="7. 快速恢复-由逐个变为逐term"></a>7. 快速恢复-由逐个变为逐term</h1><p>由于follower下线太久或脑裂，导致有大量log需要同步。</p><p>解决方法：一次同步一个term的log。</p><p>如果不匹配，follower回复时携带：</p><ul><li>XTerm：自己的冲突log对应的任期号。</li><li>XIndex：自己任期号为XTerm的第一条Log的Index。</li><li>XLen：如果follower在冲突处没有log，XTerm会返回-1，XLen表示空白的Log槽位数。</li></ul><p><strong>场景1</strong>：S1 45 Leader S2 466。此时S1没有最新Term的任何Log。</p><p>S1返回XTerm=5，XIndex=2。S2发现自己没有term=5的日志，就将S1的nextIndex设置为XIndex。</p><p><strong>场景2</strong>：S1 444 Leader S2 466.</p><p>S1返回XTerm=4，XIndex=1。S2发现自己有term=4的日志，将S1的nextIndex设置到本地在XTerm位置的Log条目后面，即2。</p><p><strong>场景3</strong>：S1 4 Leader S2 466。</p><p>S1返回XTerm=-1，XLen=2。S2根据XLen回退S1的nextIndex到其最后一条条目的下一条，即2。</p><p>因为是线性查找，可使用二分提速。</p><h1 id="8-持久化-日志快照"><a href="#8-持久化-日志快照" class="headerlink" title="8. 持久化/日志快照"></a>8. 持久化/日志快照</h1><p>需要持久化的数据：</p><ul><li>Log</li><li>currentTerm</li><li>votedFor</li></ul><p>后两者为了确保一个任期内只有一个leader。</p><p>写入频率问题：将数据写入磁盘大概花费10ms，但相对于Raft中的操作太长了，代价很大；运行较久的Raft系统中，Log累积过多，如果持久化需要大量磁盘空间，且恢复需要很长时间。</p><p>解决：快照：当Log大于一定限制时，要求应用程序在Log特定位置对其状态快照（k-v表单与位置，即LogIndex）。然后Raft丢弃该位置之前的所有Log记录。快照在应用程序生成，且Raft需要通过某种方式调用到应用程序，通知其生成与获取快照。</p><p>Raft持久化问题转化为持久化最后一次快照，以及之后的所有Log。</p><p>有Follower的Log没有同步到快照位置</p><ul><li>有follower落后则不丢弃：Leader通过nextIndex发现有Follower的Log落后于快照点，就不丢弃快照前的Log。<ul><li>如果Follower落后过多，比如一直断网、断电，这种方法无效。</li></ul></li><li>引入InstallSnapshot RPC：在日志复制Leader尝试回退的过程中，如果Leader不能再回退（到达了快照点），就直接发送快照，再发送后面的Log。</li></ul><h1 id="9-特殊情况"><a href="#9-特殊情况" class="headerlink" title="9. 特殊情况"></a>9. 特殊情况</h1><h2 id="1-网络分割（脑裂）"><a href="#1-网络分割（脑裂）" class="headerlink" title="1. 网络分割（脑裂）"></a>1. 网络分割（脑裂）</h2><p>网络分割时，如果原leader被划分在少数节点集群中，可能出现多个leader，但是它们term不同（原leader和多数节点集群选举出的新leader）。</p><p>如果网络一直分割，那么多个leader可能一直存在。但是客户端只会给原leader发送指令，而原leader也会一直认为自己是leader，它无法同步给大多数节点，所以返回给客户端失败。通过牺牲一定的服务可用性保证数据一致性。</p><p>如果网络恢复，老leader发现有更新term的节点后就会自动降级为follower，并通过日志匹配机制同步。客户端在脑裂阶段发给原leader的指令回应都是失败，因此客户端需要一直发送，等到原leader恢复成follower，再将客户端的指令转发给新leader，之后客户端就能与新leader正常通信。</p><p>问题：老leader在少数派时，客户端读取可能读到旧值。</p><p>解决：引入region leader（可以是raft leader），其作为raft leader代理与客户端交互，将请求转发给raft leader。任期内每隔t时间间隔在集群内部更新region leader的lease。（感觉region leader还是有问题，不如让leader主动降级简单）</p><p>网络分区时：</p><ul><li>region在多数派，raft在多数派。无影响。</li><li>region在多数派，raft在少数派。多数派会选出新的raft leader。因为客户端请求要走region leader，region leader就转发给新的raft leader，不会读到旧值。</li><li>region在少数派，raft在多数派。客户端请求找到region，无法联系到raft，请求失败，直到lease过期。新region leader在多数派产生。因为老region没法成功写入，所以不会读到旧值，代价是这期间系统不可用。</li><li>region在少数派，raft在少数派。与上一种情况类似。</li></ul><h2 id="2-重启"><a href="#2-重启" class="headerlink" title="2. 重启"></a>2. 重启</h2><p>可以通过创建快照恢复。</p><p>优点：</p><ul><li>降低重启耗时，不需要从第一条entry开始逐条应用。</li><li>节省空间：快照做完后或产生新快照即可删除。</li></ul><h2 id="3-特殊情况下新leader如何告知客户端"><a href="#3-特殊情况下新leader如何告知客户端" class="headerlink" title="3. 特殊情况下新leader如何告知客户端"></a>3. 特殊情况下新leader如何告知客户端</h2><p>脑裂：旧leader位于少数派</p><p>可以设置主动降级条件，leader在得不到大多数回应几次后主动降级成为follower，客户端询问时该follower不知道leader信息，因此客户端会随机挑选节点发送命令，只要挑选的节点位于多数派，就能连接上多数派选举出来的新leader。</p><p><a href="https://www.cnblogs.com/mindwind/p/5231986.html">可以一看</a></p><p><a href="https://zhuanlan.zhihu.com/p/28882896">可以一看2</a></p><h1 id="10-与Paxos"><a href="#10-与Paxos" class="headerlink" title="10. 与Paxos"></a>10. 与Paxos</h1><p>basic paxos复杂且效率相对更低，目前的项目都是基于multi-paxos实现。</p><p>主要区别：</p><ul><li>multi-paxos的leader任意节点都能当选，而raft必须满足term与log的约束。</li><li>multi-paxos允许日志出现空洞，而raft不允许。</li></ul><h1 id="11-读"><a href="#11-读" class="headerlink" title="11. 读"></a>11. 读</h1><p>一般方案：</p><ul><li>写主读从：容易读到过时的数据。</li><li>写主读主：状态机落后commit、网络分区导致脏读。</li><li>raft log read：将读操作同样作为一条log操作，当该log可以被应用到到状态机时，返回读结果。</li></ul><p>后两种都是读主，主容易过载。</p><p>读性能优化：</p><ul><li>read index：<ul><li>leader收到读请求，记录当前的commitindex，称为read index。</li><li>leader发送一次心跳包，确保领导权，避免网络分区。</li><li>等待状态机至少应用到read index。</li><li>执行读请求，返回状态机的结果。</li></ul></li><li>lease read：<ul><li>leader设置一个比选举超时更短的时间作为租期，在这段期间内可以相信其他节点一定没有发起选举，也就不会存在脑裂。</li><li>租期内直接读主。</li><li>非租期内走read index。</li></ul></li><li>follower read：<ul><li>follower收到读请求后主动向leader询问commit index，等到自己的commit index更新到这个位置并应用到状态机后，返回客户端。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab1-2</title>
      <link href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-2/"/>
      <url>/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-LRU-K"><a href="#1-LRU-K" class="headerlink" title="1. LRU-K"></a>1. LRU-K</h1><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1. 理论"></a>1. 理论</h2><p>K不是指大小，是指访问次数！</p><p>根据每个页面的K-距离判断该弹出哪个页面。</p><p>K-距离定义：</p><ul><li>页面访问次数大于等于K，则为其最后一次出现的位置。</li><li>页面访问次数小于K，则为正无穷<ul><li>都为正无穷时，第一次访问越早的页面K-距离越大。</li></ul></li></ul><p>具体换出时，页面还会被标记是否可被换出，应该找到可被换出页面离K-距离最大的。</p><p>为什么不用LRU？</p><ul><li>关联访问：一个页可能因为同一个原因被访问多次，但它可能在之后很长一段时间不再被访问。<ul><li>内部事务：读取时访问，提交时再访问。</li><li>事务重试：访问终止，然后重试事务再次访问。</li><li>内部流程：多个同样流程的事务依次访问同一个页面。</li></ul></li><li>关联访问会让人误解该页面很常用，但实际上可能接下来很长一段时间不会用到。</li><li>LRU-K的作用主要是降低缓存污染，但K设置过高可能让历史缓存清除不掉，综合各种因素后选用LRU-2。</li></ul><p>2Q：即LRU-2，为LRU-K特例。</p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>结构设计：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameInfo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">frame_id_t</span> frame_id_;  <span class="comment">// 物理页号</span></span><br><span class="line">  <span class="keyword">size_t</span> access_times_;  <span class="comment">// 访问次数</span></span><br><span class="line">  <span class="keyword">bool</span> evictable_;  <span class="comment">// 是否可被换出</span></span><br><span class="line">  explicit FrameInfo(frame_id_t f, size_t at = 1, bool evi = false): frame_id_(f), access_times_(at), evictable_(evi) &#123;&#125;</span><br><span class="line">  <span class="comment">// 这里怎么设置evi都可以，因为FrameInfo只在RecordAccess中新建，而lab1-3中，RecordAccess后一般会马上调用SetEvitable置为false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[[maybe_unused]] <span class="keyword">size_t</span> replacer_size_;  <span class="comment">// 物理页总数，页框号不应大于等于这个数</span></span><br><span class="line"><span class="keyword">size_t</span> k_; <span class="comment">// k</span></span><br><span class="line"><span class="keyword">size_t</span> evictable_num_; <span class="comment">// 可被换出的页面数目</span></span><br><span class="line"><span class="built_in">std</span>::mutex latch_; <span class="comment">// 互斥锁</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;FrameInfo&gt; lt_k_list_; <span class="comment">// 历史队列，保存小于k次访问的页面</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;FrameInfo&gt; ge_k_list_; <span class="comment">// 缓存队列，保存大于等于k次访问的页面</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">frame_id_t</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;FrameInfo&gt;::iterator&gt; hash_; <span class="comment">// 哈希表，在常数时间内查找链表项</span></span><br></pre></td></tr></table></figure><p>踩坑点：</p><ul><li>页面访问次数小于k时，访问页面并不会改变位置，因为K-距离只由第一次访问时间决定，所以此时不需要移动list。</li><li>寻找被弹出的界面时，因为找到的页面可能是不能被弹出的，所以只能从后往前遍历寻找，有没有更快的方法？</li><li>锁粒度能细化吗？</li></ul><h1 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h1><h2 id="1-Evict"><a href="#1-Evict" class="headerlink" title="1. Evict"></a>1. Evict</h2><p>作用：找到一个换出到磁盘的物理页。</p><p>输入：</p><ul><li>frame_id_t *frame_id：如果有页面被弹出，用该参数存储弹出页面id。</li></ul><p>输出：</p><ul><li>bool：表示是否找到了能弹出的页面。</li></ul><p>具体逻辑：</p><ul><li>加锁</li><li>先在历史队列逆序遍历，看能否找到可弹出的，如果找到则弹出后返回。</li><li>再在缓存队列逆序遍历，看能否找到可弹出的，如果找到则弹出后返回。</li><li>返回false。</li></ul><h2 id="2-RecordAccess"><a href="#2-RecordAccess" class="headerlink" title="2. RecordAccess"></a>2. RecordAccess</h2><p>作用：访问对应物理页。如果其在缓存中，就增加访问次数并调整位置；否则插入一条。</p><p>输入：</p><ul><li>frame_id_t frame_id：访问的页面</li></ul><p>具体逻辑：</p><ul><li>如果物理页框号无效（大于等于物理页数），则抛出异常。</li><li>如果对应物理页在lru中，则增加其访问次数。<ul><li>如果增加后次数等于k，则应该移动队列。</li><li>如果增加后次数大于k，则应该将其移到队列首部。</li></ul></li><li>如果对应物理页不再lru中，则将其加入lru。</li></ul><h2 id="3-SetEvitable"><a href="#3-SetEvitable" class="headerlink" title="3. SetEvitable"></a>3. SetEvitable</h2><p>输入：frame_id_t 要设置的物理页号，set_evitable 设置其是否可被换出，一般是false。</p><p>具体逻辑：</p><ul><li>判断物理页号是否有效。</li><li>如果找不到物理页号，直接返回。</li><li>如果找到，根据set_evitable设置，并改变evictable_num。</li></ul><h2 id="4-Remove"><a href="#4-Remove" class="headerlink" title="4. Remove"></a>4. Remove</h2><p>输入：frame_id_t 要移除的物理页号。</p><p>具体逻辑：</p><ul><li>判断物理页号是否有效。</li><li>如果找不到物理页号，直接返回。</li><li>如果找到但其不可被移除，抛出异常。</li><li>减少evctable_num，并在哈希表与链表中移除。</li></ul><h2 id="5-Size"><a href="#5-Size" class="headerlink" title="5. Size"></a>5. Size</h2><p>返回evictable_num即可。</p>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab1-1</title>
      <link href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-1/"/>
      <url>/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ExtendibleHashTable"><a href="#1-ExtendibleHashTable" class="headerlink" title="1. ExtendibleHashTable"></a>1. ExtendibleHashTable</h1><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1. 理论"></a>1. 理论</h2><p><a href="https://cloud.tencent.com/developer/article/1020586">详细阅读</a></p><p>作用：能动态扩容的哈希表。</p><p>特点：哈希表大小必定为2^D，D为全局位深度，初始为0。每个哈希项（桶）的大小也必定为2^L，L为局部位深度。</p><p>插入元素时，元素根据key哈希值的末D位分配到对应桶中。如果桶溢出，则发生分裂。</p><ul><li>哈希表扩容为2倍。</li><li>++D。</li><li>溢出桶的元素重新分配，局部位深度变为全局位深度；其他新建的未分裂桶暂时指向原桶，局部位深度不变。</li></ul><p>（这里d桶里的10应该是打错了）</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1008345/wjz044kc5l.jpeg?imageView2/2/w/2560/h/7000" class="lazyload placeholder" data-srcset="https://ask.qcloudimg.com/http-save/yehe-1008345/wjz044kc5l.jpeg?imageView2/2/w/2560/h/7000" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>插入13、20时，</p><ul><li>13二进制为1101，插入到b桶，不发生分裂。</li><li>20二进制为10100，插入到a桶，a桶溢出。<ul><li>散列表扩容为2倍。</li><li>D从2变为3。</li><li>原a桶中所有元素根据末3位重新分配到a1桶或a2桶，a1、a2桶局部位深度变为3。</li></ul></li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-1008345/5vehpsfyh3.jpeg?imageView2/2/w/2560/h/7000" class="lazyload placeholder" data-srcset="https://ask.qcloudimg.com/http-save/yehe-1008345/5vehpsfyh3.jpeg?imageView2/2/w/2560/h/7000" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>查询：根据全局位深度D计算散列值，然后去对应桶查。</p><p>删除：查询到后删除。</p><ul><li>未实现：如果删除后桶元素为空，可与其兄弟桶合并，并减少局部位深度。如果所有局部位深度都小于全局位深度，可以收缩散列表。</li></ul><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>Bucket：用开散列法解决散列冲突问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> size_;  <span class="comment">// 桶大小</span></span><br><span class="line"><span class="keyword">int</span> depth_;  <span class="comment">// 局部位深度</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;K, V&gt;&gt; list_;  <span class="comment">// 开散列法的开链表</span></span><br></pre></td></tr></table></figure><p>ExtendibleHashTable</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_depth_;    <span class="comment">// 全局位深度</span></span><br><span class="line"><span class="keyword">size_t</span> bucket_size_;  <span class="comment">// 单个桶大小，等于Bucket::size_</span></span><br><span class="line"><span class="keyword">int</span> num_buckets_;     <span class="comment">// 当前桶数目，初始为1</span></span><br><span class="line"><span class="keyword">mutable</span> <span class="built_in">std</span>::mutex latch_;  <span class="comment">// 互斥锁</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Bucket&gt;&gt; dir_;   <span class="comment">// 散列表</span></span><br></pre></td></tr></table></figure><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-Bucket"><a href="#1-Bucket" class="headerlink" title="1. Bucket"></a>1. Bucket</h2><p>单个桶，里面封装了list，存储桶中所有元素。</p><p>通过list的API实现查、增、删即可。</p><h2 id="2-ExtendibleHashTable"><a href="#2-ExtendibleHashTable" class="headerlink" title="2. ExtendibleHashTable"></a>2. ExtendibleHashTable</h2><p>Find、Remove都是找到桶，然后调用对应桶的API就行了。Insert可能出现桶溢出，较为复杂。</p><h3 id="1-Insert"><a href="#1-Insert" class="headerlink" title="1. Insert"></a>1. Insert</h3><p>输入：key、value</p><p>具体步骤：</p><ul><li>找到桶。</li><li>先尝试在桶中插入，如果成功就结束了。</li><li>如果局部位深度=全局位深度，需要扩容。<ul><li>复制散列表，添加在原散列表后面，实现扩容。且未溢出的新建桶指向原桶。</li><li>增加全局位深度。</li></ul></li><li>重新定位桶，因为全局位深度增加，导致增加的散列位可能为1。</li><li>新建两个桶，深度为全局位深度，将原桶的元素按新散列值分配到两个桶中。</li><li>替换散列表中对应的桶。</li><li>递归调用，再次尝试插入。（在这之前需要先释放锁）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-CMU-15-445-Lab0</title>
      <link href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab0/"/>
      <url>/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-字典树"><a href="#1-字典树" class="headerlink" title="1. 字典树"></a>1. 字典树</h1><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1. 理论"></a>1. 理论</h2><p>字典树，树形结构， 每个节点保存单个字符，从根遍历到叶子节点的字符组成string，即为key值。</p><p>叶子节点保存key值对应的value。</p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>整个lab分为三个数据结构</p><ul><li>TrieNode：保存非结束（is_end = false）的Trie节点。<ul><li>char key_char_：当前Trie节点的key值。</li><li>bool is_end_：当前Trie节点是否为结束节点。TrieNode一定为false。</li><li>unordered_map&lt;char, unique_ptr&lt;TrieNode&gt;&gt; children_：保存子节点。</li></ul></li><li>TrieNodeWithValue：继承TrieNode，保存结束Trie节点。<ul><li>添加了成员T value，用于存储数据。</li></ul></li><li>Trie：保存TrieNode的根节点，实现插入、删除与查询k-v值。<ul><li>unique_ptr&lt;TrieNode&gt; root_：保存根节点。</li><li>ReaderWriterLatchlatch_：封装的C++11 mutex。用来实现线程安全</li></ul></li></ul><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="1-TrieNode"><a href="#1-TrieNode" class="headerlink" title="1. TrieNode"></a>1. TrieNode</h2><p>都是简单的赋值，注意参数的右值引用实际上已经是左值了，所以赋值时需要用move变成右值。</p><h2 id="2-TrieNodeWithValue"><a href="#2-TrieNodeWithValue" class="headerlink" title="2. TrieNodeWithValue"></a>2. TrieNodeWithValue</h2><p>同上，额外注意一下value即可。</p><p>注意把is_end_设置为true，因为该类型一定有value。</p><h2 id="3-Trie"><a href="#3-Trie" class="headerlink" title="3. Trie"></a>3. Trie</h2><h3 id="1-Insert"><a href="#1-Insert" class="headerlink" title="1. Insert"></a>1. Insert</h3><p>输入：string key， T value。</p><p>输出：bool，表示是否插入成功。</p><p>具体逻辑：</p><ul><li>首先判断key是否为空，为空则直接返回false。</li><li>用latch上锁。（因为封装了，所以不能用unique_lock，记得在返回前解锁）</li><li>最后一个字符需要创建TrieNodeWithValue类型，所以遍历前面的字符，常规字典树建树方法。</li><li>对最后一个字符的情况分类讨论<ul><li>最后一个字符处已经有TrieNodeWithValue节点存在：插入失败。</li><li>最后一个字符处有TrieNode节点存在：通过unique_ptr的reset方法转换为TrieNodeWithValue，插入成功。</li><li>最后一个字符处节点不存在：直接新建TrieNodeWithValue节点插入。</li></ul></li></ul><h3 id="2-Remove"><a href="#2-Remove" class="headerlink" title="2. Remove"></a>2. Remove</h3><p>输入：string key。</p><p>输出：bool，表示是否删除成功。</p><p>具体逻辑：</p><ul><li>首先判断key是否为空，为空则直接返回false。</li><li>用latch上锁。</li><li>遍历，用stack&lt;tuple&lt;char, std::unique_ptr &lt;TrieNode&gt;*&gt;&gt;存储访问的路径，如果遍历到空节点，说明要删除的key不存在，直接返回false。<ul><li>stack中tuple两个元素的含义：第二个元素需要删除key为第一个元素的child。</li></ul></li><li>用stack回溯路径。当回溯到的key的节点还有子节点时，不再回溯。</li></ul><h3 id="3-GetValue"><a href="#3-GetValue" class="headerlink" title="3. GetValue"></a>3. GetValue</h3><p>输入：string key，bool *success，表示是否成功。</p><p>输出：T value。</p><p>具体逻辑：</p><ul><li>遍历，如果中途到达空节点，说明要找的值不存在，返回空值。</li><li>用dynamic_cast尝试将遍历到的最后一个节点转为TrieNodeWithValue。<ul><li>如果不为空，说明key存在，返回对应的value。</li><li>否则返回空值。</li></ul></li><li>注意设置success。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-Shell编程</title>
      <link href="/2023/03/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/03/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-运行原理"><a href="#1-运行原理" class="headerlink" title="1. 运行原理"></a>1. 运行原理</h1><ul><li>terminal终端：字符输入输出设备的抽象，在linux下是一种<strong>特殊的文件</strong>，键盘输入写入这个文件，对应的终端驱动程序会执行回显等工作。</li><li>shell：本质是命令解释软件。</li><li><strong>运行shell时，shell的stdin、stdout、stderr会打开并指向一个特定的terminal文件，使得我们的键盘输入实际上写到terminal里，但shell通过stdin从terminal文件得到。</strong></li></ul><p>执行方式：</p><ul><li>ubuntu中默认的shell是bash，打开终端时就会启动bash。接下来输入的字符通过terminal传递给bash运行。bash执行指令的方式有三种<ul><li>绝对路径执行，指定执行的命令脚本的路径+命令文件</li><li>sh执行，用脚本对应的sh或bash接脚本执行</li><li>shell环境执行，在当前的shell环境中执行，使用.接脚本或source接脚本</li><li>前两种方式会使用一个新的bash子进程执行命令，父进程睡眠。子进程执行完后回到父进程。</li></ul></li></ul><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h1><p>三种类型：</p><ul><li>局部变量：在脚本或命令中定义。</li><li>环境变量：所有的程序都能访问。</li><li>shell变量：由shell设置的特殊变量，一部分是局部变量，一部分是环境变量。</li></ul><p>定义</p><ul><li>变量名和等号间不能有空格。</li><li>命名只能用英文字母、数字和下划线，首个字符不能是数字。</li></ul><p>使用</p><ul><li>在等号右边用，变量名前加$。</li><li><strong>可以不加花括号</strong>，但是为了帮助解释器识别变量边界，推荐加上。</li></ul><p>只读：readonly</p><p>删除：unset</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;hyw&quot;</span><br><span class="line">echo $&#123;your_name&#125;</span><br><span class="line">readonly your_name</span><br><span class="line">unset your_name</span><br></pre></td></tr></table></figure><h1 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h1><p>单引号：</p><ul><li>单引号里的变量无效，会原样输出。</li><li>单引号中不能出现单独的单引号，但可成对出现。</li></ul><p>双引号：</p><ul><li>双引号里可以有变量。</li><li>双引号里可以有转义字符。</li></ul><p>反引号：执行命令。一般用在等号右边，将命令的标准输出赋给变量。</p><p>拼接：字符串拼接只需要写在一起即可。</p><p>长度：<code>#string</code></p><p>查找：e或o第一个出现的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;hello, world!&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; eo`</span><br></pre></td></tr></table></figure><p>截取：</p><ul><li><p><code>$&#123;string:start:length&#125;</code>：从左边第start个字符开始向右截取</p><ul><li>length可省略</li></ul></li><li><p><code>$&#123;string: 0-start :length&#125;</code>：从右边第start个字符开始向右截取。</p><ul><li>length可省略</li></ul></li><li><p><code>$&#123;string#*chars&#125;</code>：截取从<strong>左边起</strong>的<strong>第一个</strong>chars字符<strong>右边</strong>的字符串。</p><ul><li>翻译：*可替代任意个任意字符，换成特定字符也可以。</li></ul></li><li><p><code>$&#123;string##*chars&#125;</code>：截取从<strong>右边起</strong>的第<strong>一个</strong>chars字符<strong>右边</strong>的字符串。</p></li><li><p>#换成%就是截取左边的，同时*和chars交换位置。</p></li></ul><h1 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h1><p>支持一维数组，可用下标单独赋值，读取下标要加上$。</p><p>所有元素：[@]或[*]。在前面加!可获取数组所有的键。</p><p>长度：与字符串相同。</p><p><code>arr=(v1 v2 v3 ... vn)</code></p><p>关联数组：用任意字符串、整数作为下标访问数组元素。</p><p><code>declare -A arr=([&quot;A&quot;]=&quot;a&quot; [&quot;B&quot;]=&quot;b&quot; [&quot;C&quot;]=&quot;c&quot;)</code></p><h1 id="5-注释"><a href="#5-注释" class="headerlink" title="5. 注释"></a>5. 注释</h1><p>一行：#开头。</p><p>多行：第一行 <code>:&lt;&lt;[endsig]</code>，最后一行 <code>[endsig]</code>。endsig可为任意符号。</p><h1 id="6-参数"><a href="#6-参数" class="headerlink" title="6. 参数"></a>6. 参数</h1><p>通过$n表示传入的第n个参数。</p><p>$*与$@：</p><ul><li>相同：引用所有参数</li><li>不同：只在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li></ul><h1 id="7-运算"><a href="#7-运算" class="headerlink" title="7. 运算"></a>7. 运算</h1><p>原生bash不支持运算，通过``引入awk或expr命令来进行计算。或者可以 <code>result=$[a + b]</code></p><p>基本：+ - * / % =</p><p>条件表达式要放在方括号之间，并且要有空格，如 <code>[ $a == $b ]</code></p><p>条件：== != -eq -ne -gt -lt -ge -le。或者用(())双括号括起来后直接用运算符。</p><p>布尔：! -o -a</p><p>逻辑：&amp;&amp; ||</p><p>字符串：</p><ul><li>=：字符串是否相等</li><li>!=：字符串是否不相等</li><li>-z ：字符串长度是否为0，放在变量前面。</li><li>-n：字符串长度是否不为0。</li><li>$str：字符串是否不为空。</li></ul><p>文件测试：放在字符串前面，字符串存储的是文件路径</p><ul><li>-r：可读</li><li>-w：可写</li><li>-x：可执行</li><li>-f：是文件</li><li>-d：是目录</li><li>-s：不为空</li><li>-e：存在</li><li>-p：是有名管道</li></ul><h1 id="8-printf"><a href="#8-printf" class="headerlink" title="8. printf"></a>8. printf</h1><p>语法：<code>printf format-string [arguments]</code></p><p>类似于C的printf。</p><p>加-表示左对齐，否则表示右对齐。</p><p>10、8表示将显示字符控制在该数字以内，不足会填充，多了会截取。</p><p>参数：</p><ul><li>%s：输出字符串</li><li>%d：输出整型</li><li>%c：输出字符</li><li>%f：输出小数，默认支持6位。</li><li>%b：输出字符串，但是会转义参数字符串中的转义字符。</li></ul><p>转义字符：</p><ul><li>\c：抑制输出结果中任何结尾的换行字符（只在%b格式的参数字符串中有效）。</li><li>\f：换页</li><li>\n：换行</li><li>\r：回车</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234</span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543</span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</span><br></pre></td></tr></table></figure><h1 id="9-流程控制"><a href="#9-流程控制" class="headerlink" title="9. 流程控制"></a>9. 流程控制</h1><p>if-else：写成一行时需要在换行的地方加；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if cond</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">[elif] cond2</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">[else]</span><br><span class="line">...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>for：写成一行时需要在换行的地方加；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in i1 i2 ... in</span><br><span class="line">do</span><br><span class="line">cmd</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>while：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while cond</span><br><span class="line">do</span><br><span class="line">cmd</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>until：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until cond</span><br><span class="line">do</span><br><span class="line">cmd</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>case .. esac：*表示default</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case val in</span><br><span class="line">v1)</span><br><span class="line">cmd</span><br><span class="line">;;</span><br><span class="line">v2)</span><br><span class="line">cmd</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">cmd</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>continue</p><p>break</p><h1 id="10-函数"><a href="#10-函数" class="headerlink" title="10. 函数"></a>10. 函数</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()] &#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function可以不加。</p><p>返回值如果不加，将以最后一条命令的结果作为返回值。</p><p>调用时可不带括号。</p><p>函数返回值在调用后的下一条指令通过$?获得。（再下一条就不能获得了）</p><p>函数参数与shell参数类似获得。</p><h1 id="11-重定向"><a href="#11-重定向" class="headerlink" title="11. 重定向"></a>11. 重定向</h1><p>重定向实际上是指定从哪里读取输入/输出/输出错误。</p><p>这里的command不用加反引号</p><p>command &gt; file：重定向输出</p><p>command &lt; file：重定向输入</p><p>command &gt;&gt; file：以追加方式重定向输出</p><p>n &gt; file：将文件描述符为n的文件重定向到file</p><p>n &lt; file</p><p>n &gt;&gt; file</p><p>n &gt;&amp; m：将输出文件m和n合并</p><p>n &lt;&amp; m：将输入文件m和n合并</p><p>&lt;&lt; tag：将开始标记tag和结束标记tag之间的内容作为输出</p><p>标准输入/输出/错误分别为0/1/2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command 2&gt;file #重定向stderr</span><br><span class="line">command &gt; file 2&gt;&amp;1 #将stdout与stderr合并后重定向到file</span><br><span class="line">command &lt; file1 &gt; file2 #command将stdin重定向到file1，将stdout重定向到file2.</span><br></pre></td></tr></table></figure><p>here document：将两个EOF（或其它字符）之间的内容作为输入传递给command。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">    欢迎来到</span><br><span class="line">    菜鸟教程</span><br><span class="line">    www.runoob.com</span><br><span class="line">EOF</span><br><span class="line">3          # 输出结果为 3 行</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>/dev/null是黑洞文件，将stdout/stderr重定向到这里不会输出任何结果。</p><h1 id="12-包含"><a href="#12-包含" class="headerlink" title="12. 包含"></a>12. 包含</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. filename</span><br><span class="line">source filename</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-SQL语法</title>
      <link href="/2023/03/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SQL%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/03/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SQL%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><p>SQL分为三类命令：</p><ul><li>数据操作语言DML：SELECT、INSERT、UPDATE、DELETE。</li><li>数据定义语言DDL：定义表、索引、视图等对象。</li><li>数据控制语言：安全控制等。</li></ul><h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--select</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tablename<span class="comment">--所有列</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> tablename<span class="comment">--col列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--distinct</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> col <span class="keyword">from</span> tablename <span class="comment">--col列互不相同，如果有多列，只有这几列值完全相同才会被排除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--where</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> tablename <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">2</span> <span class="comment">--添加条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--and or</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> tablename <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">2</span> <span class="keyword">and</span> id <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--order by</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> tablename <span class="keyword">order</span> <span class="keyword">by</span> id, col <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span> <span class="comment">--将结果依次按id、col升序|降序排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--insert into</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename <span class="keyword">values</span> (v1, v2, ...) <span class="comment">--尾部插入所有列的值</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename (c1, c2, ...) <span class="keyword">values</span> (v1, v2, ...) <span class="comment">--指定列插入值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--update</span></span><br><span class="line"><span class="keyword">update</span> tablename <span class="keyword">set</span> col1 <span class="operator">=</span> v1, col2 <span class="operator">=</span> v2, ... <span class="keyword">where</span> <span class="keyword">condition</span> <span class="comment">--更新符合条件的行指定列的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--delete</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tablename <span class="keyword">where</span> <span class="keyword">condition</span> <span class="comment">--删除符合条件的行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3-高级"><a href="#3-高级" class="headerlink" title="3. 高级"></a>3. 高级</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--limit</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> tablename <span class="keyword">where</span> <span class="keyword">condition</span> <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">5</span> <span class="comment">--返回符合条件的行中id前五位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--like 匹配全部</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> tablename <span class="keyword">where</span> name [<span class="keyword">not</span>] <span class="keyword">like</span> &quot;huang%&quot; <span class="comment">--模糊匹配（左模糊、右模糊、左右模糊）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--like通配符</span></span><br><span class="line"><span class="comment">--%：替代0个或多个任意字符</span></span><br><span class="line"><span class="comment">--_：替代一个字符</span></span><br><span class="line"><span class="comment">--[]：替代其中的一个字符</span></span><br><span class="line"><span class="comment">--[!/^]：替代不在其中的一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--regexp 匹配一部分</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> tablename <span class="keyword">where</span> name [<span class="keyword">not</span>] regexp <span class="string">&#x27;^huang&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--regexp通配符</span></span><br><span class="line"><span class="comment">--^：匹配字符串开始位置 放在字符串前面</span></span><br><span class="line"><span class="comment">--$：匹配字符串结束位置 放在字符串后面</span></span><br><span class="line"><span class="comment">--.：匹配任意字符</span></span><br><span class="line"><span class="comment">--下面三个都是放在单个字符后面</span></span><br><span class="line"><span class="comment">--*/&#123;0,&#125;：匹配0个或多个字符</span></span><br><span class="line"><span class="comment">--+/&#123;1,&#125;：匹配1个或多个字符</span></span><br><span class="line"><span class="comment">--?/&#123;0,1&#125;：匹配0个或1个字符</span></span><br><span class="line"><span class="comment">--&#123;&#125;：通用写法</span></span><br><span class="line"><span class="comment">--|：匹配两个字符串中的一个 放在两个字符串中间</span></span><br><span class="line"><span class="comment">--[]：与like相同，可通过a-d表示区间内的多个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--in 相当于or</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> tablename <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;huang&#x27;</span>, <span class="string">&#x27;yi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--between 相当于and</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> tablename <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--as 取别名</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">as</span> c, name <span class="keyword">as</span> n <span class="keyword">from</span> tablename</span><br><span class="line"></span><br><span class="line"><span class="comment">--join 连接两个表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--inner join = join 表中存在至少一个匹配时返回行</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> table1 <span class="keyword">inner</span> <span class="keyword">join</span> table2 <span class="keyword">on</span> table1.name <span class="operator">=</span> table2.name</span><br><span class="line"></span><br><span class="line"><span class="comment">--left join 从table1中返回所有行，table2中没有匹配则结果为null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--right join 从table2中返回所有行，table1中没有匹配则结果为null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--full join 只要其中一个表存在匹配，返回行 （MySQL不支持）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--union 合并两个或多个select语句的结果，col值不重复</span></span><br><span class="line"><span class="comment">--union all值可重复</span></span><br><span class="line"><span class="keyword">select</span> col <span class="keyword">from</span> table1 <span class="keyword">union</span> <span class="keyword">select</span> col <span class="keyword">from</span> table2</span><br><span class="line"></span><br><span class="line"><span class="comment">--select into 从一个表复制信息到另一个表</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">into</span> table2 <span class="keyword">from</span> table1</span><br><span class="line"></span><br><span class="line"><span class="comment">--insert into select 从table1复制数据，将数据插入到一个已存在的表table2，table2中已存在的行不受影响</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table2 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1 <span class="comment">--table2后可接指定的列，需与select后面的列匹配</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>where和having：</p><ul><li>where子句是在<strong>分组前过滤数据</strong>。在对查询结果进行分组前，将不符合条件的行去掉。</li><li>having子句是在<strong>分组后过滤数据</strong>。筛选满足条件的组。</li></ul><h1 id="4-条件"><a href="#4-条件" class="headerlink" title="4. 条件"></a>4. 条件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case</span><br><span class="line">when condition1 then dosth</span><br><span class="line">when condition2 then dosth</span><br><span class="line">...</span><br><span class="line">else dosth</span><br><span class="line">end</span><br><span class="line">--例子</span><br><span class="line">select </span><br><span class="line">case </span><br><span class="line">when age &lt; 25 or age is null then &#39;25岁以下&#39;</span><br><span class="line">else &#39;25岁及以上&#39;</span><br><span class="line">end as age_cut, </span><br><span class="line">count(*)</span><br><span class="line">from user_profile</span><br><span class="line">group by age_cut;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-json解析器</title>
      <link href="/2023/03/12/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-json%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
      <url>/2023/03/12/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-json%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="json-parse"><a href="#json-parse" class="headerlink" title="json_parse"></a>json_parse</h1><p>json：由对象（键值对集合）、数组组合而成。</p><p>json的值可以是null、逻辑值、数字、字符串、对象、数组。</p><p>因为对象键是有序的，所以不能用unordered_map而用map。</p><p>使用C++ 17标准的json解析器。</p><p>variant管理json多种值类型，string_view只读解析json字符流，optional提供异常处理。</p><p>递归下降解析。一种自顶向下的递归分析方法。</p><p>重载了[]操作符支持动态修改。</p><p>知识点：</p><h2 id="1-variant与union"><a href="#1-variant与union" class="headerlink" title="1. variant与union"></a>1. variant与union</h2><p>variant管理json的一个对象、数组或值，通过Node封装管理（重载对象/数组下标取值，以及为数组添加push_back方法）</p><p>为什么用variant替代union：union在有有析构函数的成员时，生命结束时不会自动析构。</p><p>variant的几个方法</p><ul><li><code>get&lt;type&gt;</code>：有该type则返回对应类型值，否则抛出异常。</li><li><code>holds_alternative&lt;type&gt;</code>：有该type返回true，否则返回false。</li><li><code>get_if&lt;type&gt;</code>：有该type返回对应类型指针，否则返回空指针。</li></ul><h2 id="2-optional"><a href="#2-optional" class="headerlink" title="2. optional"></a>2. optional</h2><p>解析成功时则返回正确的Value类型值，其他情况都返回nullopt</p><p>用于处理非法的json字符流时，返回nullopt。</p><p>方法：</p><ul><li><code>value()</code>：获得其中的值，为空时抛出异常。</li><li><code>value_or(default)</code>：获得其中的值，为空时返回默认值。</li><li><code>*/-&gt;</code>：重载了操作符获取值，为空时行为未定义。</li><li><code>has_value()</code>：判断是否有值。</li></ul><p>C++23中有expected，可以用另一种类型代替nullopt</p><h2 id="3-string-view"><a href="#3-string-view" class="headerlink" title="3. string_view"></a>3. string_view</h2><p>作为parser函数的参数，防止修改原本字符串，且不用拷贝字符串。</p><p>优点：作为参数传递时，既能保证只读（引用、指针传递）又不需要拷贝完整字符串（值传递）</p><p>只读、只保存指针和大小、不拷贝。</p><h2 id="4-if-constexpr"><a href="#4-if-constexpr" class="headerlink" title="4. if-constexpr"></a>4. if-constexpr</h2><p>与is_same_v模板配合使用，防止编译器报错，让编译器在编译期判断if走向。</p><h2 id="5-visit"><a href="#5-visit" class="headerlink" title="5. visit"></a>5. visit</h2><p>传入两个参数，将参数2作为参数传入参数1。</p><p>类似于visitor模式</p><h2 id="4-细节"><a href="#4-细节" class="headerlink" title="4. 细节"></a>4. 细节</h2><p>异常处理机制（没有转义的双引号、不符合格式的数字）：</p><ul><li>如果存在，string会被正常解析完毕，只是存储的值不符合期望；但是后续的解析程序会发现非法字符并返回nullopt。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>笔试记录-3-11-美团笔试</title>
      <link href="/2023/03/11/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95-3-11-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/"/>
      <url>/2023/03/11/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95-3-11-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1><p>题目：一串只有大写字母的字符串，修改其中的字符使得相邻字符互不相等。</p><p>输入：字符串。</p><p>输出：求最小修改次数。</p><p>思路：遍历连续的字符串，如果连续字符为n个，修改n / 2个就行。</p><h1 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h1><p>题目：一个mxn地图，每个位置都有两种颜色之一，且有一定数量金币。从左上角开始走，一次只能向右或向下走一步。如果一次走过两个位置不相同，就要支付k个金币，走到某个位置可以获取该位置的金币。可以在任意地点停止，问能获取的最大金币数。</p><p>输入：m、n、k，每个位置的颜色与金币</p><p>输出：能获取的最大金币数</p><p>思路：动态规划</p><h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h1><p>题目：</p><p>输入：n个流星开始和结束的时间</p><p>输出：能观察到的最大流星个数，与最大流星个数持续的时间。</p><p>时间大小10^9，流星个数10^5。</p><p>思路：差分数组。因为时间太大，vector会超时，使用map优化。</p><h1 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h1><p>题目：</p><p>16x16棋盘上有两个坦克，初始分别在(0, 0)朝右和(15, 15)朝左：</p><ul><li>坦克在的位置会被其占领。</li><li>坦克每轮可向上下左右走一步，或开火。</li><li>若走一步，先转向，然后当且仅当走一步后没有越界，且走一步后的位置没有被敌人占领，可以走一步。</li><li>每轮先开火后移动。</li><li>胜负条件：<ul><li>开火，若正前方有敌人则获胜。</li><li>若双方均开火击中敌人，则平局。</li><li>若双方移动到同一个位置，则平局。</li></ul></li><li>进行256轮后，若双方均存货，则占领位置多的获胜。</li></ul><p>输入：双方的256轮指令，大小为256的string。</p><p>输出：第x轮谁获胜，或是平局。</p><p>思路：模拟。不知道为什么只过了45</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>题目：二叉树，每个节点有两种颜色之一，如果某个节点所有子树的两种颜色数相同（不包含该节点），则该节点为平衡节点。有多少个平衡节点</p><p>输入：节点数。每个节点颜色。每个节点父节点。（以数组形式给出）</p><p>输出：平衡节点数</p><p>思路：一遍dfs就行了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-研究经历整理</title>
      <link href="/2023/03/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A0%94%E7%A9%B6%E7%BB%8F%E5%8E%86%E6%95%B4%E7%90%86/"/>
      <url>/2023/03/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%A0%94%E7%A9%B6%E7%BB%8F%E5%8E%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="单元测试的意义"><a href="#单元测试的意义" class="headerlink" title="单元测试的意义"></a>单元测试的意义</h1><p>目的</p><ul><li>发现bug</li><li>回归测试：修改旧代码后，用原来的测试用例测试程序行为是否变化</li></ul><p>量化衡量标准：目前只有覆盖率</p><h1 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h1><p>语句覆盖率：统计测试用例运行过的代码行数占总代码行数的比例</p><p>分支覆盖率：每条语句为一个节点，语句之间的跳转为边。统计测试用例运行过的边数占总边数的比例</p><ul><li>在没有else的if语句，语句覆盖只要if的条件为true就算完全覆盖，而分支覆盖还需要走if条件为false</li></ul><p>检查覆盖率：传统测试用例添加了断言。统计断言相关的变量执行过的语句占总语句的比例</p><h1 id="现有测试方法"><a href="#现有测试方法" class="headerlink" title="现有测试方法"></a>现有测试方法</h1><h2 id="Randoop"><a href="#Randoop" class="headerlink" title="Randoop"></a>Randoop</h2><p>反馈导向的随机测试生成。</p><p>随机基本类型变量和自定义类型变量都从变量池里取，每过一轮随机添加一个。</p><p>输入：</p><ul><li>待测单元</li><li>限时</li><li>一组约束（自定义或其他类自带）</li></ul><p>过程：</p><ul><li>用随机类方法、随机参数生成新语句，与正确语句序列集合中的一个序列组合</li><li>查重</li><li>执行并检查约束<ul><li>违反某条约束：放入错误序列集合</li><li>不违反：将检查的约束作为断言添加进序列，放入正确序列集合。放入前，还需要进行过滤，如检查其中的对象已经存在、为空指针、或是异常类，则抛弃。</li><li>语法错误：丢弃</li></ul></li></ul><h2 id="EvoSuite-WholeSuite"><a href="#EvoSuite-WholeSuite" class="headerlink" title="EvoSuite/WholeSuite"></a>EvoSuite/WholeSuite</h2><p>朴素遗传算法</p><p>适应度函数：总方法数-执行的方法数+各分支距离和。越低越好</p><p>过程：</p><ul><li>初始化：随机生成的一组测试用例集合，作为初始种群</li><li>初始种群中选出精英（适应度最低）</li><li>随机选出两个双亲，按一定概率交叉生成子代，否则复制生成子代</li><li>变异子代（增删语句、修改参数）</li><li>计算子代与父代的适应度，如果子代更低或代码行数更少，加入精英，否则父代加入精英</li><li>迭代直到精英大小等于初始种群大小</li><li>将精英作为初始种群，再选出精英迭代几轮，直到资源耗尽或达到目标适应度</li></ul><h2 id="MOSA"><a href="#MOSA" class="headerlink" title="MOSA"></a>MOSA</h2><p>将分支覆盖重新表述为多目标优化问题，优化目标是待测类中所有分支的分支距离。一个测试用例的适应度是一个大小为m（分支数）的适应度向量。</p><p>支配：对于测试用例x与y，x在所有分支适应度不差于y时，称x支配y，或x优于y。</p><p>当测试用例x不受所有可能测试用例中任何其他测试用例支配时，称x为帕累托最优。</p><p>档案（archive）：跟踪覆盖被测试程序每个分支的最佳测试用例</p><p>MOSA的主体基于遗传算法。</p><p>算法流程（优先级排序）</p><ul><li>输入候选测试用例集T。</li><li>为每一个未覆盖分支b，在T中选择一个最低适应度的测试用例，加入F0之中。</li><li>对剩余的测试用例，根据NSGAII非支配排序算法排序并从F1开始分配到相应等级集合中。</li></ul><p>算法流程（档案更新）</p><ul><li>输入候选测试用例集T。</li><li>对所有已覆盖的分支，取分数为0且长度最短的测试用例存储在archive中。</li></ul><p>算法流程</p><ul><li>初始化当前群体与档案。</li><li>产生后代放入当前群体中，并使用优先级排序。</li><li>将优先级排序后的测试用例按等级由低到高放入下一代群体，直到群体数量达到要求。对每一个优先级等级，按照拥挤距离排序。</li><li>使用新一代群体更新档案。</li><li>重复迭代直到资源耗尽，将档案作为最终输出结果测试套件。</li></ul><h2 id="DynaMOSA"><a href="#DynaMOSA" class="headerlink" title="DynaMOSA"></a>DynaMOSA</h2><p>与MOSA的区别：</p><ul><li>在搜索开始时，仅选择没有嵌套最外层的目标作为初始目标集，该集合随每一次测试用例生成而更新。</li><li>适应度计算、偏好排序和拥挤距离的计算都只考虑目标集中的目标。</li><li>更新算法为：深度优先遍历，将已被覆盖的目标从目标集中去除，直到找到每条路径上第一个未覆盖的目标或已覆盖所有目标。</li></ul><h2 id="MIO"><a href="#MIO" class="headerlink" title="MIO"></a>MIO</h2><p>MIO使用进化算法作为框架，进化算法相较于遗传算法，比起交叉更注重变异的过程。</p><p>MIO维护一个archive，对每个测试目标保留大小为n的测试群体。</p><p>算法流程：</p><p>1）在算法开始时，archive为空，随机采样一个新测试用例。</p><p>2）随机采样或变异archive中的一个测试用例。在采样/变异新测试后，计算其适应度。对某一目标k，一旦得到改进，就更有可能被继续选择</p><p>3）基本思想是，为每个目标保留一组候选的测试用例，但是当目标被覆盖时只需要保留最好的那个。</p><p>4）采样/变异控制：算法最开始时，采样生成新的随机测试用例的概率较高，且每个目标的测试群体大小较高，这些值随着算法进行、时间推移而线性减少，即从探索逐渐转变为对原有数据的发掘，最终直到采样概率变为0，且每个目标测试群体大小变为1，退化为进化算法。此外，更关心在某一目标上突出的个体而不是均衡的个体。</p><h1 id="遗传-进化算法"><a href="#遗传-进化算法" class="headerlink" title="遗传/进化算法"></a>遗传/进化算法</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>与问题领域无关的快速搜索能力</li><li>搜索过程简单可解释</li><li>概率交叉变异迭代，有随机性</li><li>可扩展性，可与其他过程结合</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>交叉率、变异率的参数选择影响效果，但是这些参数只能通过经验设置（类似于机器学习的参数设置）<ul><li>交叉概率为0.75</li><li>变异包括<ul><li>在测试套件中增加一个新的测试用例（函数）</li><li>在测试用例中增删改语句</li><li>增删改一条语句后，有一定概率重复该动作（概率逐渐降低）</li></ul></li></ul></li><li>因为精英子代需要等到下一次种群迭代才能参与，导致反馈信息得不到及时利用，搜索慢</li><li>初始种群影响算法效率</li><li>并行潜力（从群体中同时选出多对父母迭代）没有充分利用</li><li>容易早熟收敛</li></ul><h1 id="Type4py"><a href="#Type4py" class="headerlink" title="Type4py"></a>Type4py</h1><p>现有的类型推断工具</p><p>通过深度学习训练类型推断模型：标识符信息（标识符名称，通过自然语言处理获取可能存在的类型信息）、上下文信息（待推断的名称使用过的所有语句）、可见类型提示（通过import构建依赖关系图，区分不同类型），通过embedding生成词向量，然后训练。</p><p>改进点：</p><ul><li>数据集：代码去重、手动增加类型注释、去除噪音</li><li>类型建议：相较于top10，即10个较好的，更注重top1，即1个最好的的准确率</li></ul><h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><ul><li>Python作为动态语言，能利用的类型信息不多，不像静态语言可以在类型信息的约束下随机生成</li><li>尝试在测试中加入类型信息约束生成</li></ul><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><ul><li>输入：待测单元</li><li>代码分析：Python模块、类型信息</li><li>测试生成：将分析的结果（类、方法）与类型信息放入算法框架</li></ul><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><ul><li>阅读并理解框架代码</li><li>结合测试生成框架与类型信息获取</li><li>尝试改进现有的遗传算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试记录-3-7-阿里云网络二面</title>
      <link href="/2023/03/07/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95-3-7-%E9%98%BF%E9%87%8C%E4%BA%91%E7%BD%91%E7%BB%9C%E4%BA%8C%E9%9D%A2/"/>
      <url>/2023/03/07/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95-3-7-%E9%98%BF%E9%87%8C%E4%BA%91%E7%BD%91%E7%BB%9C%E4%BA%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>就二十分钟。。。必挂了。</p><h1 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h1><h1 id="2-Raft协议"><a href="#2-Raft协议" class="headerlink" title="2. Raft协议"></a>2. Raft协议</h1><h1 id="3-Raft协议集群变更"><a href="#3-Raft协议集群变更" class="headerlink" title="3. Raft协议集群变更"></a>3. Raft协议集群变更</h1><h1 id="4-Raft协议脑裂"><a href="#4-Raft协议脑裂" class="headerlink" title="4. Raft协议脑裂"></a>4. Raft协议脑裂</h1><p>怎么告诉客户端变更了leader、两个leader要怎么办。</p><h1 id="5-etcd"><a href="#5-etcd" class="headerlink" title="5. etcd"></a>5. etcd</h1><h1 id="6-网络编程API"><a href="#6-网络编程API" class="headerlink" title="6. 网络编程API"></a>6. 网络编程API</h1><p>服务端：</p><ul><li>socket创建套接字</li><li>bind绑定地址与端口</li><li>listen开始进入LISTEN态监听</li><li>accept获得一个全连接</li><li>send/recv读写</li></ul><p>客户端</p><ul><li>socket创建套接字</li><li>connect连接</li><li>send/recv读写</li></ul><h1 id="7-调用API的三次握手状态变换（SYN-SENT这些）"><a href="#7-调用API的三次握手状态变换（SYN-SENT这些）" class="headerlink" title="7. 调用API的三次握手状态变换（SYN_SENT这些）"></a>7. 调用API的三次握手状态变换（SYN_SENT这些）</h1><p>服务端：listen()进入LISTEN状态，然后接受客户端SYN报文建立连接，accept取出的是已经建立好的连接。</p><p>客户端：connect()进入SYN_SENT状态，接受到服务端的SYN+ACK报文后建立连接。</p><h1 id="8-多个客户端访问是否需要多次listen"><a href="#8-多个客户端访问是否需要多次listen" class="headerlink" title="8. 多个客户端访问是否需要多次listen"></a>8. 多个客户端访问是否需要多次listen</h1><p>listen只是让服务端进入LISTEN状态，后续只需要监听该套接字上是否有连接事件到来即可。</p><h1 id="9-QUIC的改进"><a href="#9-QUIC的改进" class="headerlink" title="9. QUIC的改进"></a>9. QUIC的改进</h1><ul><li>无队头阻塞</li><li>更快连接建立</li><li>连接迁移</li></ul><h1 id="10-QUIC的连接迁移具体步骤"><a href="#10-QUIC的连接迁移具体步骤" class="headerlink" title="10. QUIC的连接迁移具体步骤"></a>10. QUIC的连接迁移具体步骤</h1><p>通过头部的CID标识连接，双方在随机生成的CID列表上达成一致，列表上的CID映射到同一连接，切换环境时切换CID。（防止CID被窃取获得用户地址）</p><p>迁移后双方都向对方发起路径验证，探测可达性。</p><h1 id="11-SYN洪泛攻击"><a href="#11-SYN洪泛攻击" class="headerlink" title="11. SYN洪泛攻击"></a>11. SYN洪泛攻击</h1><p>攻击者不断发送syn报文给服务端，塞满其半连接队列。</p><h1 id="12-syncookie的工作原理"><a href="#12-syncookie的工作原理" class="headerlink" title="12. syncookie的工作原理"></a>12. syncookie的工作原理</h1><p>服务器收到SYN包并返回SYN+ACK包时，不放入半连接队列，而是根据这个SYN包计算出一个cookie值。</p><p>在收到ACK包时，TCP服务器在根据那个cookie值检查这个ACK包的合法性。如果合法，直接放入全连接队列中建立连接。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-多线程笔试题</title>
      <link href="/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>题目：编写一个程序，开启3个线程，这3个线程的ID分别为A、B、C，每个线程将自己的ID在屏幕上打印10遍，要求输出结果必须按ABC的顺序显示；如：ABCABC….依次递推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">unique_lock&lt;mutex&gt; ul;</span><br><span class="line">cond.wait(ul, [&amp;]&#123; <span class="keyword">return</span> id == flag; &#125;);  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  <span class="string">&#x27;A&#x27;</span> + id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">flag = (flag + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line"><span class="comment">// ul.unlock(); // notify_all后会自动释放</span></span><br><span class="line">cond.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread b(print, 1), c(print, 2);</span><br><span class="line">    print(<span class="number">0</span>);</span><br><span class="line">    b.join();</span><br><span class="line">    c.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>题目：子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环50次，试写出代码</p><p>子线程与主线程必有一个满足条件(flag == num),不满足条件的那个线程不可能获取unique_lock(会在wait中释放)，只有满足条件的线程才能获取锁，执行程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cond;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">cond.wait(ul, [&amp;]&#123; <span class="keyword">return</span> id == flag; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; id; ++j);</span><br><span class="line">flag = <span class="number">110</span> - id;</span><br><span class="line"><span class="comment">// ul.unlock(); // notify_all后会自动释放</span></span><br><span class="line">cond.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">sub</span><span class="params">(loop, <span class="number">10</span>)</span></span>;</span><br><span class="line">    loop(<span class="number">100</span>);</span><br><span class="line">    sub.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>题目(google笔试题)：有四个线程1、2、3、4。线程1的功能就是输出1，线程2的功能就是输出2，以此类推………现在有四个文件ABCD。初始都为空。现要让四个文件呈如下格式：<br>A：1 2 3 4 1 2….<br>B：2 3 4 1 2 3….<br>C：3 4 1 2 3 4….</p><p>D：4 1 2 3 4 1….</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> write_stat[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> turn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">ofstream file[<span class="number">4</span>];</span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> turn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; turn; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cond.wait(ul, [&amp;]&#123; <span class="keyword">return</span> write_stat[j] == id; &#125;);</span><br><span class="line">    file[j] &lt;&lt; (id + <span class="number">1</span>);</span><br><span class="line">    write_stat[j] = (write_stat[j] + <span class="number">1</span>) % <span class="number">4</span>; </span><br><span class="line">    <span class="comment">// ul.unlock(); // notify_all后会自动释放</span></span><br><span class="line">    cond.notify_all();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) file[i] = ofstream(to_string(<span class="string">&#x27;A&#x27;</span> + i) + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    thread a(print, 1, turn), b(print, 2, turn), c(print, 3, turn);</span><br><span class="line">    print(<span class="number">0</span>, turn);</span><br><span class="line">    a.join();</span><br><span class="line">    b.join();</span><br><span class="line">    c.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) file[i].close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>题目：两个线程交替打印1~100。要求：同一个函数；不空转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>, flag = <span class="number">1</span>;</span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="number">100</span>) &#123;</span><br><span class="line">  <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">cond.wait(ul, [&amp;]&#123; <span class="keyword">return</span> id == flag; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">++n;</span><br><span class="line">flag = <span class="number">3</span> - flag;</span><br><span class="line"><span class="comment">// ul.unlock(); // notify_all后会自动释放</span></span><br><span class="line">cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">a</span><span class="params">(print, <span class="number">2</span>)</span></span>;</span><br><span class="line">    print(<span class="number">1</span>);</span><br><span class="line">    a.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>线程池类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ThreadPool(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span></span><br><span class="line">      -&gt; std::future&lt;typename std::invoke_result&lt;F&gt;::type&gt;;</span><br><span class="line">  ~ThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// need to keep track of threads so we can join them</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; workers;</span><br><span class="line">  <span class="comment">// the task queue</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// synchronization</span></span><br><span class="line">  <span class="built_in">std</span>::mutex queue_mutex;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">  <span class="keyword">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the constructor just launches some amount of workers</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="keyword">size_t</span> threads)</span> : <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threads; ++i)</span><br><span class="line">    workers.emplace_back([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">          <span class="comment">// 等生产者生产</span></span><br><span class="line">          <span class="keyword">this</span>-&gt;condition.wait(</span><br><span class="line">              lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.empty(); &#125;);</span><br><span class="line">          <span class="comment">// 若是因为内存池停止，或是虚假唤醒 直接 return</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 拿任务</span></span><br><span class="line">          task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks.front());</span><br><span class="line">          <span class="keyword">this</span>-&gt;tasks.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new work item to the pool</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span></span><br><span class="line">    -&gt; std::future&lt;typename std::invoke_result&lt;F&gt;::type&gt; &#123;</span><br><span class="line">  <span class="comment">// std::invoke_result 用于推导可调用对象的放回值类型</span></span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> <span class="built_in">std</span>::invoke_result&lt;F&gt;::type;</span><br><span class="line">  <span class="comment">// 将获取 packaged_task</span></span><br><span class="line">  <span class="keyword">auto</span> task = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::packaged_task&lt;return_type()&gt;&gt;(</span><br><span class="line">      <span class="built_in">std</span>::bind(<span class="built_in">std</span>::forward&lt;F&gt;(f), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;return_type&gt; res = task-&gt;get_future();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// don&#x27;t allow enqueueing after stopping the pool</span></span><br><span class="line">    <span class="keyword">if</span> (stop)</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line"></span><br><span class="line">    tasks.emplace([task]() &#123; (*task)(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  condition.notify_one();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the destructor joins all threads</span></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~ThreadPool() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  condition.notify_all();</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::thread &amp;worker : workers)</span><br><span class="line">    worker.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试记录-3-1-阿里云PolarDB一面</title>
      <link href="/2023/03/01/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95-3-1-%E9%98%BF%E9%87%8C%E4%BA%91PolarDB%E4%B8%80%E9%9D%A2/"/>
      <url>/2023/03/01/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95-3-1-%E9%98%BF%E9%87%8C%E4%BA%91PolarDB%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h1><h1 id="2-线程和进程的区别"><a href="#2-线程和进程的区别" class="headerlink" title="2. 线程和进程的区别"></a>2. 线程和进程的区别</h1><h1 id="3-线程、进程的通信手段"><a href="#3-线程、进程的通信手段" class="headerlink" title="3. 线程、进程的通信手段"></a>3. 线程、进程的通信手段</h1><h1 id="4-管道"><a href="#4-管道" class="headerlink" title="4. 管道"></a>4. 管道</h1><h1 id="5-乐观锁、悲观锁、自旋锁、互斥锁"><a href="#5-乐观锁、悲观锁、自旋锁、互斥锁" class="headerlink" title="5. 乐观锁、悲观锁、自旋锁、互斥锁"></a>5. 乐观锁、悲观锁、自旋锁、互斥锁</h1><h1 id="6-自旋锁和互斥锁的使用场景"><a href="#6-自旋锁和互斥锁的使用场景" class="headerlink" title="6. 自旋锁和互斥锁的使用场景"></a>6. 自旋锁和互斥锁的使用场景</h1><h1 id="7-B-树"><a href="#7-B-树" class="headerlink" title="7. B+树"></a>7. B+树</h1><h1 id="8-B-树的并发控制"><a href="#8-B-树的并发控制" class="headerlink" title="8. B+树的并发控制"></a>8. B+树的并发控制</h1><p>问的实际上是锁</p><h1 id="9-LSM树"><a href="#9-LSM树" class="headerlink" title="9. LSM树"></a>9. LSM树</h1><p>日志结构合并树。</p><p>作为各种NoSQL的底层存储索引。</p><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><ul><li>横跨内外存，分为多个层，L0位于内存，L1-LN位于磁盘。</li><li>内存中一般采用<strong>有序、高性能查找的结构</strong>，如AVL树、红黑树、跳表等。</li><li>外存中每一层本质是多个<strong>文件</strong>，文件内是排序好的数据。</li><li>每一层树数据达到阈值后，按照<strong>一定策略</strong>向下层归并。</li><li>增删改LSM树均在内存操作，归并时将修改刷盘。</li><li>特点：<strong>写性能强、读性能弱</strong>。</li></ul><p>与B+树都使用了WAL计数，但B+树增删改均是随机写，LSM树只是追加顺序写，而LSM树读操作最坏需要遍历所有层，所以读效率一般不如B+树。</p><p>优：增删改速度快，写性能强。</p><p>缺：读性能弱；归并操作消耗资源；不支持范围查询。</p><h2 id="2-具体结构"><a href="#2-具体结构" class="headerlink" title="2. 具体结构"></a>2. 具体结构</h2><p>由memtable、immutable-memtable（内存）与SSTable（磁盘）组成。</p><h2 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h2><p><strong>只在内存中进行</strong></p><p>分为两步：</p><ol><li>WAL写日志</li><li>将待插入的数据定位到<strong>内存</strong>中待写入的位置，写入。（不在乎该数据是否在<strong>磁盘</strong>中）</li><li>如果数据已在内存，就变为更新。</li></ol><p>增删改操作在memtable中进行，memtable大小达到阈值后转变成immutable-memtable（即将刷盘的中间态），并新建一个memtable。后台线程将immutable-memtable写入磁盘L1层形成SSTable文件，随后销毁immutable-memtable。</p><p>SSTable不可修改，改善都是以顺序写入新记录的形式呈现。读取数据从新到旧读，所以先读到最新的数据。</p><p>单个SSTable不存在相同key的数据，而不同SStable可能存在。</p><h2 id="4-更新"><a href="#4-更新" class="headerlink" title="4. 更新"></a>4. 更新</h2><p><strong>只在内存中进行</strong></p><ol><li>在内存中找待更新的数据。</li><li>如果内存中找到，就更新。</li><li>否则改为插入到其应该在的位置。</li></ol><h2 id="5-删除"><a href="#5-删除" class="headerlink" title="5. 删除"></a>5. 删除</h2><p><strong>只在内存中进行</strong></p><p>只是将更新改为打上delete标签。如果找不到就插入一个有delete标签的数据。</p><h2 id="6-查找"><a href="#6-查找" class="headerlink" title="6. 查找"></a>6. 查找</h2><p>性能偏弱，按照层次增加依次查找，知道找到为止。</p><p>外存中每一层的多个SSTable配有布隆过滤器和索引。布隆过滤器快速判断block内部是否存在待查找的值，可能存在则通过索引加速查找。</p><p>最坏需要遍历所有层。</p><h2 id="7-归并"><a href="#7-归并" class="headerlink" title="7. 归并"></a>7. 归并</h2><p>将低级别多个SSTable文件中的数据放入高一级的SSTable文件，并清除这些低级别的文件。</p><p>三个问题：</p><ul><li>读放大：读取数据时实际读取量大于真正的数据量。如LSM读取数据时可能需要扫描多个SSTable。</li><li>写放大：写入数据时实际写入量大于真正的数据量。如LSM树种写入触发Compact操作。</li><li>空间放大：数据实际占用的磁盘空间比数据真正大小更多。如LSM种存放旧版数据都是无效的。</li></ul><p>必要性：对一个数据增删改时，磁盘中可能存有其历史版本，而这些历史版本不会被读取到、没有任何作用，但是占着磁盘，需要清理。</p><p>两种广泛应用的策略</p><h3 id="1-STCS-Size-Tiered-Compaction-Strategy"><a href="#1-STCS-Size-Tiered-Compaction-Strategy" class="headerlink" title="1. STCS Size-Tiered-Compaction-Strategy"></a>1. STCS Size-Tiered-Compaction-Strategy</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772b1dc05459429ca9fd7c837d3dddfa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" class="lazyload placeholder" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772b1dc05459429ca9fd7c837d3dddfa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>保证<strong>同一层</strong>中所有SSTable大小相近。</p><p>某层SSTable数量达到阈值时，将其合成一个更大的SSTable，放入下一个level，且在合并过程中清理重复的、被删除的数据。</p><p>多路归并排序。</p><p>对三个问题的解决：</p><ul><li>读放大：<strong>存在</strong>。不知道要查找的key在哪个SSTable，还是需要从新到旧遍历所有SSTable。</li><li>写放大：<strong>存在</strong>。写时触发Compact。</li><li>空间放大：<strong>存在</strong>。这种策略只能保证每个SSTable不存在重复数据，但同一层多个SSTable依然可能有相同数据。</li></ul><h3 id="2-LCS-Leveled-Compaction-Strategy"><a href="#2-LCS-Leveled-Compaction-Strategy" class="headerlink" title="2. LCS Leveled-Compaction-Strategy"></a>2. LCS Leveled-Compaction-Strategy</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38fbb237a5654586a225f6237424fd94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" class="lazyload placeholder" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38fbb237a5654586a225f6237424fd94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>保证<strong>磁盘</strong>所有层SSTable大小一致。</p><p>每一层限制总文件大小，层内按序排列且无重复数据（SSTable之间也有序）。</p><p>某层总文件大小达到阈值时，在该层选择一个SSTable与下一层key范围有交集的SSTable合并。保证合并后单个SSTable大小不超过阈值，且层内有序。多个不相关Compact可并行。</p><p>对三个问题的解决：</p><ul><li>读放大：较小。层内SSTable也有序，所以可直接定位到可能存放key的SSTable。</li><li>写放大：存在。写时触发Compact。</li><li>空间放大：较小。层内无重复数据，compact时不创建临时文件。</li></ul><h2 id="8-MVCC在LSM树的应用"><a href="#8-MVCC在LSM树的应用" class="headerlink" title="8. MVCC在LSM树的应用"></a>8. MVCC在LSM树的应用</h2><p>防止高频率读写时，一个连接读取的SSTable被Compact的问题。</p><p>悲观锁解决效率过低，通过MVCC解决。</p><p>本质上快照+对所有SSTable加上引用计数。某个版本的引用计数降为0时，清理版本内引用计数为0的SSTable。</p><h1 id="10-MySQL语句执行流程"><a href="#10-MySQL语句执行流程" class="headerlink" title="10. MySQL语句执行流程"></a>10. MySQL语句执行流程</h1><h1 id="11-10中的词法分析和语法分析具体是？"><a href="#11-10中的词法分析和语法分析具体是？" class="headerlink" title="11. 10中的词法分析和语法分析具体是？"></a>11. 10中的词法分析和语法分析具体是？</h1><h1 id="12-隔离级别和防止的问题"><a href="#12-隔离级别和防止的问题" class="headerlink" title="12. 隔离级别和防止的问题"></a>12. 隔离级别和防止的问题</h1><h1 id="13-vector和list"><a href="#13-vector和list" class="headerlink" title="13. vector和list"></a>13. vector和list</h1><h1 id="14-vector扩容机制"><a href="#14-vector扩容机制" class="headerlink" title="14. vector扩容机制"></a>14. vector扩容机制</h1><p>感觉可以讲讲reserve和resize、capacity和size</p><h1 id="15-拷贝构造函数什么时候调用"><a href="#15-拷贝构造函数什么时候调用" class="headerlink" title="15. 拷贝构造函数什么时候调用"></a>15. 拷贝构造函数什么时候调用</h1><h1 id="16-C-设计一个LRU"><a href="#16-C-设计一个LRU" class="headerlink" title="16. C++设计一个LRU"></a>16. C++设计一个LRU</h1><h1 id="17-问了面的另一个部门"><a href="#17-问了面的另一个部门" class="headerlink" title="17. 问了面的另一个部门"></a>17. 问了面的另一个部门</h1><h1 id="18-算法：K个有序数组排序"><a href="#18-算法：K个有序数组排序" class="headerlink" title="18. 算法：K个有序数组排序"></a>18. 算法：K个有序数组排序</h1><p>写了堆、讲了归并排序</p><h1 id="19-算法：多线程打印1-100-重要！！！"><a href="#19-算法：多线程打印1-100-重要！！！" class="headerlink" title="19. 算法：多线程打印1~100 重要！！！"></a>19. 算法：多线程打印1~100 重要！！！</h1><p>要求：交替、不空转、同一调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (id != flag) cv.wait(lck);</span><br><span class="line">        <span class="keyword">if</span> (id + (i % <span class="number">2</span>) == <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        flag = <span class="number">3</span> - flag;</span><br><span class="line">        cv.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">a</span><span class="params">(print, <span class="number">1</span>)</span></span>;</span><br><span class="line">    print(<span class="number">2</span>);</span><br><span class="line">    a.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试记录-2.23-阿里云网络一面</title>
      <link href="/2023/02/23/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95-2-23-%E9%98%BF%E9%87%8C%E4%BA%91%E7%BD%91%E7%BB%9C%E4%B8%80%E9%9D%A2/"/>
      <url>/2023/02/23/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95-2-23-%E9%98%BF%E9%87%8C%E4%BA%91%E7%BD%91%E7%BB%9C%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-23-阿里云网络一面（虚拟网络相关的组？）"><a href="#2-23-阿里云网络一面（虚拟网络相关的组？）" class="headerlink" title="2.23-阿里云网络一面（虚拟网络相关的组？）"></a>2.23-阿里云网络一面（虚拟网络相关的组？）</h1><h1 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h1><h1 id="2-项目"><a href="#2-项目" class="headerlink" title="2. 项目"></a>2. 项目</h1><p>文件压缩</p><ul><li>无损压缩：用在文本文件、代码文件、可执行文件中，去除换行符、空格之后用霍夫曼编码压缩（gzip等）。</li><li>有损压缩：用在多媒体数据。</li></ul><p>传输的格式（二进制）</p><h1 id="3-实现的http状态码"><a href="#3-实现的http状态码" class="headerlink" title="3. 实现的http状态码"></a>3. 实现的http状态码</h1><h1 id="4-HTTPS-握手"><a href="#4-HTTPS-握手" class="headerlink" title="4. HTTPS 握手"></a>4. HTTPS 握手</h1><p>讲了RSA</p><h1 id="5-服务端优化"><a href="#5-服务端优化" class="headerlink" title="5. 服务端优化"></a>5. 服务端优化</h1><p>nongzhai机制？（说了不是单服务器，应该是多服务器的机制？）</p><p>增加CPU核数（还是单机）</p><p>说了缓存</p><h1 id="6-代理服务器（建议我看下nginx）"><a href="#6-代理服务器（建议我看下nginx）" class="headerlink" title="6. 代理服务器（建议我看下nginx）"></a>6. 代理服务器（建议我看下nginx）</h1><p>正向代理与反向代理</p><p>正向代理：在客户端部署代理服务器，代替客户端对外收发消息。主要用途：</p><ol><li>提高访问速度：代理服务器有缓冲区，保存请求的响应。</li><li>隐藏客户端真实的IP。</li><li>突破访问控制：VPN。</li></ol><p>反向代理：在服务端部署代理服务器，替代原服务器接收请求发送响应。</p><ol><li>提高访问速度：缓存。</li><li>隐藏服务器真实IP。</li><li>安全保障：代理服务器作为防火墙。</li><li>负载均衡：代理服务器根据负载将请求发送到某台服务器。</li></ol><p>相同：</p><ol><li>提升访问速度。</li><li>隐藏IP。</li><li>都是转发请求与响应。</li></ol><p>区别：</p><ol><li>部署位置不同。</li><li>作用不同：正向代理帮助突破访问控制；反向代理提供安全保障与负载均衡。</li></ol><h1 id="7-强制缓存和协商缓存"><a href="#7-强制缓存和协商缓存" class="headerlink" title="7. 强制缓存和协商缓存"></a>7. 强制缓存和协商缓存</h1><h1 id="8-输入URL到发送数据给服务器的过程"><a href="#8-输入URL到发送数据给服务器的过程" class="headerlink" title="8. 输入URL到发送数据给服务器的过程"></a>8. 输入URL到发送数据给服务器的过程</h1><p>DNS协议、封装、ARP</p><p>忘了答握手</p><p>假设是端到端服务且用TCP通信。</p><ol><li>三次握手建立TCP连接。</li><li>数据包从聊天框发出，从聊天软件所在的用户空间拷贝到内核空间的发送缓冲区。</li><li>数据包依次经过传输层、网络层进入数据链路层，经过流控，通过RingBuffer发送到物理层的网卡。</li><li>网卡将数据包发送到互联网中，经过路由器和交换机的跳转，到达目的机器的网卡。</li><li>网卡通知DMA将数据包信息放到RingBuffer中，再触发硬中断给CPU，CPU触发软中断让ksoftirqd线程去收包。</li><li>数据包经过多个层到达传输层，从内核空间拷贝到用户空间的聊天软件中。</li></ol><h1 id="9-ARP相关"><a href="#9-ARP相关" class="headerlink" title="9. ARP相关"></a>9. ARP相关</h1><p>先通过主机路由表确定<strong>下一跳的IP地址</strong>，再通过ARP广播询问下一跳IP地址对应的MAC地址。</p><h1 id="10-项目问题：日志系统"><a href="#10-项目问题：日志系统" class="headerlink" title="10. 项目问题：日志系统"></a>10. 项目问题：日志系统</h1><p>同步写/异步写</p><p><strong>有专门的线程负责写日志</strong></p><h1 id="11-C10K"><a href="#11-C10K" class="headerlink" title="11. C10K"></a>11. C10K</h1><p>应该主要是想问IO多路复用。</p><p>服务器如何支持10K个并发连接。</p><p>最初的服务器基于线程/进程模型，每到来一个TCP连接需要分配一个线程/进程。就单机而言，1万个进程无法承受。</p><p>本质是<strong>操作系统</strong>的问题。关键在于CPU，尽可能减少CPU的核心资源消耗。</p><p>思路：</p><ul><li>为每个连接分配一个独立进程/线程：资源占用过多，可拓展性差。</li><li>同一线程/进程同时处理多个连接，即<strong>IO多路复用</strong></li></ul><p>引申：C10M问题</p><h1 id="12-epoll与select-poll"><a href="#12-epoll与select-poll" class="headerlink" title="12. epoll与select/poll"></a>12. epoll与select/poll</h1><h1 id="13-简历上的Raft一致性协议"><a href="#13-简历上的Raft一致性协议" class="headerlink" title="13. 简历上的Raft一致性协议"></a>13. 简历上的Raft一致性协议</h1><p>原理、偶数节点时同票的问题</p><h1 id="14-强一致性和最终一致性"><a href="#14-强一致性和最终一致性" class="headerlink" title="14. 强一致性和最终一致性"></a>14. 强一致性和最终一致性</h1><p>强一致性还分为线性、顺序、因果</p><h1 id="15-分布式CAP"><a href="#15-分布式CAP" class="headerlink" title="15. 分布式CAP"></a>15. 分布式CAP</h1><p>分布式系统的学习笔记得好好复习下</p><p>分布式系统三个指标，不能同时满足。因为P一般可以满足，所以C与A无法同时做到。</p><ul><li>一致性Consistency：同一数据在不同节点上的副本在同一逻辑时钟相同。每次请求要么获得最新的数据，要么失败。强调<strong>数据正确</strong>。</li><li>可用性Availability：每次请求都能获取到非错的响应，尽量保证低延迟。（不保证是最新的）强调<strong>不出错</strong>。</li><li>分区容错性Partition tolerance：任意节点故障时系统仍可以对外服务。强调<strong>不挂</strong>。</li></ul><h1 id="16-gdb调试"><a href="#16-gdb调试" class="headerlink" title="16. gdb调试"></a>16. gdb调试</h1><p><a href="https://www.yanbinghu.com/2019/04/20/41283.html">指南</a></p><h1 id="17-git-merge与git-rebase"><a href="#17-git-merge与git-rebase" class="headerlink" title="17. git merge与git rebase"></a>17. git merge与git rebase</h1><p>merge为两个分支创建一个相同的子分支节点</p><p>rebase直接对一个分支应用另一个分支上的所有提交</p><h1 id="18-Python用空格分隔字符串"><a href="#18-Python用空格分隔字符串" class="headerlink" title="18. Python用空格分隔字符串"></a>18. Python用空格分隔字符串</h1><p>不知道为啥问这个，，，split</p><h1 id="19-Linux内存管理"><a href="#19-Linux内存管理" class="headerlink" title="19. Linux内存管理"></a>19. Linux内存管理</h1><p>讲了虚拟内存和分页</p><p>Buddy伙伴系统因为不认得英文没答出来</p><p>Buddy系统：</p><p>伙伴块：</p><ul><li>大小相同</li><li>地址连续</li><li>从同一个大块分离出来</li></ul><p>用一位二进制数表示其伙伴关系，为1表示其中一块在使用，为0表示都空闲或都在使用。</p><p>系统每次分配和回收伙伴块时都对其伙伴位与1进行异或。</p><p>由链表管理，类似于STL，每个链表节点为2次幂大小的freelist</p><p>分配：</p><ul><li>查对应的freelist，如果有空闲块就直接摘下分配。</li><li>如果没有就向上查找，直到找到空闲块。</li><li>不断等分这个空闲块，直到恰好为满足条件的大小，把其他分下来的空闲块挂在相应freelist上。</li><li>如果找不到则放弃分配。</li></ul><p>释放：</p><ul><li>查对应的freelist，如果没有伙伴块就直接挂上。</li><li>如果有则摘下伙伴合并，然后向上查找是否可合并。</li><li>直到不能合并或已经合并到最大块。</li></ul><p>缺点：</p><ul><li>小块阻碍大块合并</li><li>按2的幂次分块，有一定浪费</li><li>拆分和合并涉及较多链表和位图操作，开销大</li></ul><h1 id="20-算法：最长回文子串"><a href="#20-算法：最长回文子串" class="headerlink" title="20. 算法：最长回文子串"></a>20. 算法：最长回文子串</h1><p>秒杀题。。。中心扩散（写的这种）、动态规划</p><p>马拉车不会</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-深度探索C++对象模型</title>
      <link href="/2023/02/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/02/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-关于对象"><a href="#1-关于对象" class="headerlink" title="1. 关于对象"></a>1. 关于对象</h1><ol><li>class与struct实际上是不矛盾的。即 <code>struct A; class A &#123; ... &#125;;</code>是可以同时存在的，默认是public还是private按定义的来（定义为class则默认private，否则默认public）。也可以用class继承struct。</li><li>class中，相同区间声明的成员一定按声明顺序存储，但不同区间则顺序不一定（private、public、父子类等）。</li><li>转换是一种编译器指令，大部分情况下并不改变指针的地址，而只是影响指针指向<strong>内存的大小和内容</strong>的<strong>解释方式</strong>。</li></ol><h1 id="2-构造函数语义学"><a href="#2-构造函数语义学" class="headerlink" title="2. 构造函数语义学"></a>2. 构造函数语义学</h1><ol><li>默认构造函数并不是默认一定会生成，只在编译器认为“需要”的时候编译生成。且只会初始化类对象，不会初始化标量。<ol><li>成员变量为“带有默认构造函数的类对象”，编译器会依定义顺序调用所有成员的默认构造函数。如果用户自定义了部分成员变量的初始化（不含参数），编译器会在用户自定义的代码前先插入其他成员的默认构造函数。</li><li>基类有默认构造函数。</li><li>有虚函数/基类有虚函数。必须要完成vptr与vtable的初始化。</li><li>有虚基类。虚基类也是通过vtable实现。</li></ol></li><li>编译器是否会生成拷贝构造函数，取决于类是否展现出“逐位拷贝语义”。类不展现出该语义的情况与1类似，此时编译器生成拷贝构造函数。<ol><li>1.1与1.2中，为其基类与成员调用其定义的拷贝构造函数。</li><li>1.3与1.4中，vtable必须深拷贝，vptr也不能直接拷贝使得两个对象有同一vtable。</li></ol></li><li>NRV优化：将函数中值传递的类对象返回值改为在参数中引用传递，返回void。必须要类显式定义了拷贝构造函数才会启动NRV优化。</li><li>成员初始化列表：会作为语句插入到用户自定义语句之前，且按照成员声明顺序排列。所以，成员初始化列表尽量按照声明顺序排列，以防止用某些还没初始化的成员初始化其他成员。</li></ol><h1 id="3-Data语意学"><a href="#3-Data语意学" class="headerlink" title="3. Data语意学"></a>3. Data语意学</h1><ol><li>空类：不同的编译器处理不同：对于A-&gt;B/C-&gt;D的菱形继承关系，它们都为空类。A的大小为1，但B、D的大小在不同的编译器上分别为8、12或4、8。<ol><li>一种编译器为B继承的A保留了其1字节的大小，又由于对齐，填充了3字节，使得最终大小为1（A）+3（padding）+4（vptr）=8</li><li>另一种编译器因为B有了vptr不为空，所以不需要A的1字节，为4。</li></ol></li></ol><h1 id="4-Function语意学"><a href="#4-Function语意学" class="headerlink" title="4. Function语意学"></a>4. Function语意学</h1><ol><li><code>((classname*)0)-&gt;member_function()</code>在下列条件下是能成功的。后续引入了静态成员函数替代这种写法。<ol><li>不直接读写成员变量</li><li>成员函数不声明为const、volatile、virtual</li></ol></li><li>多态虚表：一个class对应一个虚表，在编译器构建完成。虚表中包含该类的类型信息、虚函数的地址（按定义顺序排列）。</li><li>多继承的虚函数：thunk模型：每个被多继承的基类维护一个虚表指针，其中一个基类为主要基类，其他的为次要基类。主要基类的虚表指针维护<strong>该派生类从主要基类继承链上的全部虚函数</strong>，而次要基类的虚表指针只维护<strong>该次要基类继承链上的</strong>虚函数（从该次要基类开始，所以看不见派生类的）。主要基类的虚表中会维护需要调整this指针的函数（在其他次要基类中定义的）<ol><li>实际调用时，根据虚表中的记录调整this函数到相应位置，再通过虚表查询调用。</li><li>当然，这样频繁移动this指针会使运行效率更慢。</li></ol></li><li>虚成员函数的指针也可实现动态多态。</li><li>inline函数：<ol><li>处理流程<ol><li>分析函数定义，判断其能不能成为inline，如果不能则成为static函数</li><li>在调用点上扩展inline函数</li></ol></li><li>同名局部变量、副作用函数会使用临时变量进行处理</li></ol></li></ol><h1 id="5-构造、析构、拷贝语意学"><a href="#5-构造、析构、拷贝语意学" class="headerlink" title="5. 构造、析构、拷贝语意学"></a>5. 构造、析构、拷贝语意学</h1><ol><li>纯虚函数<ol><li>纯虚函数可以在类外被定义，也能被静态调用（类名::虚函数）</li><li>尽量不要将析构函数声明为纯虚函数。析构函数在编译时会扩张，以<strong>静态调用</strong>的方式调用其所有基类的析构函数，导致<strong>纯虚析构函数一定得在类外定义</strong>。</li></ol></li></ol><h1 id="6-执行期语意学"><a href="#6-执行期语意学" class="headerlink" title="6. 执行期语意学"></a>6. 执行期语意学</h1><ol><li>临时对象的生命期：临时性对象被摧毁，应该是对产生临时对象的完整表达式求值过程中的最后一个步骤。<ol><li>完整表达式一般指被涵括的表达式中最外围的那个。</li><li>两个例外：<ol><li>临时对象作为拷贝构造函数的参数：临时对象保留到对象构造完成。</li><li>临时对象被常引用绑定：临时对象保留到引用或临时对象的生命范畴结束。</li></ol></li></ol></li></ol><h1 id="7-站在对象模型的尖端"><a href="#7-站在对象模型的尖端" class="headerlink" title="7. 站在对象模型的尖端"></a>7. 站在对象模型的尖端</h1><ol><li>template模板<ol><li>template只存在声明时，里面的静态成员是不可用的，即使与类型无关。（不能 <code>Point::Status s</code>这样不带类型名）</li><li>成员函数只在其被调用的时候实例化。为了空间时间效率，以及支持尚未实现的功能的考虑。</li><li>int和long一致的架构中，类型实例化还是会产生两个实例。</li><li>错误处理：面对声明时，只将其收集为一系列tokens，即只做与语法有关的错误检查（不合法字符等），不作与语法无关的检查（类型检查等）。</li><li>名称决议法：在模板定义域与实例化域分别声明同名的不同重载函数（该函数不是模板类成员）时：<ol><li>如果函数与“用以实例化模板的参数类型”有关，则使用模板定义域的函数。</li><li>如果函数与“用以实例化模板的参数类型”无关，则使用模板实例化域的函数。</li><li>是否有关：向函数传入了该参数类型的参数。</li></ol></li><li>成员函数的实例化：<ol><li>编译时不产生任何实例化。</li><li>链接前，检查每个编译模块文件，寻找模板实例的相互参考与对应的定义。</li><li>对于参考到模板实例而该实例没有定义的情况，将该文件视为与另一个实例化等同。</li><li>重新执行编译器，编译每一个改变过的文件。</li><li>重复直到所有必要的实例化操作完成。</li><li>链接。</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-设计模式</title>
      <link href="/2023/02/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/02/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/431714886#:~:text=C%2B%2B%E5%90%84%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3%201%201.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%20%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%B1%9E%E4%BA%8E%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%A4%A7%E8%87%B4%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E4%B8%89%E7%B1%BB%EF%BC%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%82%20%E5%90%AC%E4%B8%8A%E5%8E%BB%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%8C%E9%83%BD%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%82%20...%202%202.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F,%E5%8D%95%E4%BE%8B%E7%9A%84%E4%B8%80%E8%88%AC%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BB%A3%E7%A0%81%E5%92%8CUML%E5%9B%BE%E3%80%82%20...%205%205.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E3%80%81%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%20DP%E4%B9%A6%E4%B8%8A%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%BA%EF%BC%9A%E7%94%A8%E5%8E%9F%E5%9E%8B%E5%AE%9E%E4%BE%8B%E6%8C%87%E5%AE%9A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%8C%E5%B9%B6%E4%B8%94%E9%80%9A%E8%BF%87%E6%8B%B7%E8%B4%9D%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%9E%8B%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82%20...%206%206.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">C++各类设计模式及实现详解 - 知乎 (zhihu.com)</a></p><h1 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1. 设计原则"></a>1. 设计原则</h1><p>总原则：开闭原则：对扩展开放，对修改关闭。程序需要扩展时不能修改原有的代码，而是扩展代码。</p><h2 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h2><p>每个类应该实现单一的职责，否则应该拆分。</p><h2 id="2-里氏替换原则LSP"><a href="#2-里氏替换原则LSP" class="headerlink" title="2. 里氏替换原则LSP"></a>2. 里氏替换原则LSP</h2><p>任何基类可以出现的地方，子类一定可以出现。对开闭原则的补充。</p><p>根据该原则，子类对父类方法尽量不要重写和重载。</p><h2 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3. 依赖倒转原则"></a>3. 依赖倒转原则</h2><p>用到具体类时，不与具体类交互而与其上层接口交互。开闭原则的基础。</p><p>尽量在抽象类定义变量与接口，并通过具体类实现具体功能。</p><h2 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h2><p>抽象类定义的接口不能是子类用不到却必须实现的方法，否则就应该拆分。</p><h2 id="5-迪米特法则-最少知道法则"><a href="#5-迪米特法则-最少知道法则" class="headerlink" title="5. 迪米特法则/最少知道法则"></a>5. 迪米特法则/最少知道法则</h2><p>一个类对自己依赖的类知道越少越好。</p><p>无论被依赖的类多复杂，都应该将逻辑封装在方法内部，通过public向外提供。</p><p>当被依赖的类变化时才能对依赖其的类影响最小。</p><h2 id="6-合成复用法则"><a href="#6-合成复用法则" class="headerlink" title="6. 合成复用法则"></a>6. 合成复用法则</h2><p>尽量首先用聚合，而非继承。</p><p>无法访问聚合对象的private变量与方法，只能使用其提供的接口，符合封装原则；继承会破坏封装。</p><h1 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h1><h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h2><p>简单工厂模式：只有一个工厂，create方法接受想要制造的产品作为参数，返回制造出来的类。</p><p>缺陷：要增加新产品需要修改工厂类。</p><p>工厂方法模式：工厂也提供一个抽象类与create接口，每种产品由专门的子工厂负责制造。</p><p>缺陷：要增加新产品需要增加一个对象的工厂。</p><p>抽象工厂模式：跟工厂方法模式差不多，只是有多个create接口生产这一种类产品的细分？</p><h2 id="2-策略模式"><a href="#2-策略模式" class="headerlink" title="2. 策略模式"></a>2. 策略模式</h2><p>定义一系列的算法，封装起来，并使它们可互相替换。</p><p>比如Cache替换算法，Cache类中维护一个算法指针，提供一个方法进行Cache替换，方法中直接用算法指针调用抽象接口。</p><p>实现1：直接用对应算法指针构造。但构造时客户需要知道算法的具体定义。</p><p>实现2：构造时利用简单工厂模式。构造时客户只需要知道算法的标签，但是构造还是要形参。</p><p>实现3：模板实现。</p><h2 id="3-适配器模式"><a href="#3-适配器模式" class="headerlink" title="3. 适配器模式"></a>3. 适配器模式</h2><p>将一个类的接口转换成客户希望的另一个，使得原本由于接口不兼容而不能一起工作的类可以一起工作。包括类适配器和对象适配器。</p><p>STL中的容器适配器。</p><p>如：</p><ul><li>Sequence类中定义push与pop操作</li><li>deque类中有push/pop_front/back的实现</li><li>定义Stack、Queue类继承Sequence类，并聚合deque类作为类成员，重写push与pop操作，在其中调用deque的具体方法。</li></ul><h2 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4. 单例模式"></a>4. 单例模式</h2><p>如果想创建某个特定的子类，一般通过getinstance传入标签。</p><p>饿汉模式：程序运行时立即初始化。</p><p>懒汉模式：第一次调用时才初始化。</p><p>保证懒汉模式线程安全：</p><ul><li>C++ 11 static定义getinstance方法内的静态局部变量，由编译器保证。</li><li>双检测锁，锁前后都需要判断是否为空。</li></ul><h2 id="5-原型-模板方法模式"><a href="#5-原型-模板方法模式" class="headerlink" title="5. 原型/模板方法模式"></a>5. 原型/模板方法模式</h2><p>原型方法：用原型实例指定创建对象的种类，通过<strong>拷贝</strong>这些原型创建新的对象。</p><p>简单地说，实现拷贝构造、Clone方法的深拷贝。</p><p>当直接创建对象代价较大时，可缓存该对象，需要时创建克隆。</p><p>模板方法：定义一个函数f，其中包含操作流程，每一步操作都是虚函数，然后在派生类中重写这些操作。使用时调用f。</p><h2 id="6-建造者模式"><a href="#6-建造者模式" class="headerlink" title="6. 建造者模式"></a>6. 建造者模式</h2><p>感觉跟策略模式没啥区别。。。</p><p>基类定义抽象接口，然后派生类定义具体要怎么建造每个部位。</p><p>指挥官类构造时传入基类指针，然后建造时调用基类的抽象接口。</p><h2 id="7-外观模式-组合模式"><a href="#7-外观模式-组合模式" class="headerlink" title="7. 外观模式/组合模式"></a>7. 外观模式/组合模式</h2><p>外观模式：将一系列类聚合到一个类中，然后对外提供一个方法，其中调用这些类各自的方法。</p><p>组合模式/部分整体模式：好难描述。。。以树形结构描述对象组合，表示部分-整体的层次结构。客户可以像处理简单元素一样处理复杂元素。</p><p><img src="https://pic4.zhimg.com/80/v2-5c095155528ea3fe7ea25af365c71d47_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-5c095155528ea3fe7ea25af365c71d47_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="8-代理模式"><a href="#8-代理模式" class="headerlink" title="8. 代理模式"></a>8. 代理模式</h2><p>为其他对象提供代理来控制对该对象的访问。</p><p>比如图形对象创建开销很大，应该在打开文档时避免一次性创建所有图形对象，打开图形对象的代理替代图形，并由代理负责打开图形。<strong>懒汉思想。</strong></p><p>具体实现：代理初始化被代理对象，保存被代理对象的指针。</p><p>C++的<strong>智能指针</strong>就是代理模式，还应用了<strong>RAII</strong>思想。</p><h2 id="9-享元模式"><a href="#9-享元模式" class="headerlink" title="9. 享元模式"></a>9. 享元模式</h2><p>运用共享技术有效支持大量细粒度的对象。</p><p>具体的，棋盘与棋子。棋子只需要创建黑白两个对象，vector保存棋子位置，而不是棋子对象。</p><h2 id="10-桥接模式"><a href="#10-桥接模式" class="headerlink" title="10. 桥接模式"></a>10. 桥接模式</h2><p>抽象部分与其实现部分分离。</p><p><img src="https://pic2.zhimg.com/80/v2-0f82c904c73dc1f182302dafdd359245_720w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-0f82c904c73dc1f182302dafdd359245_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="11-装饰模式"><a href="#11-装饰模式" class="headerlink" title="11. 装饰模式"></a>11. 装饰模式</h2><p>动态的给一个对象添加一些额外的职责。</p><p>又一个说不明白的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    Phone() &#123;&#125;  </span><br><span class="line">    <span class="keyword">virtual</span> ~Phone() &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowDecorate</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iPhone</span> :</span> <span class="keyword">public</span> Phone &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="built_in">string</span> m_name; <span class="comment">//手机名称  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    iPhone(<span class="built_in">string</span> name): m_name(name)&#123;&#125;  </span><br><span class="line">    ~iPhone() &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowDecorate</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;的装饰&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//具体的手机类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NokiaPhone</span> :</span> <span class="keyword">public</span> Phone &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="built_in">string</span> m_name;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    NokiaPhone(<span class="built_in">string</span> name): m_name(name)&#123;&#125;  </span><br><span class="line">    ~NokiaPhone() &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowDecorate</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;的装饰&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorPhone</span> :</span> <span class="keyword">public</span> Phone &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    Phone *m_phone;  <span class="comment">//要装饰的手机  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    DecoratorPhone(Phone *phone): m_phone(phone) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowDecorate</span><span class="params">()</span> </span>&#123; m_phone-&gt;ShowDecorate(); &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//具体的装饰类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorPhoneA</span> :</span> <span class="keyword">public</span> DecoratorPhone &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    DecoratorPhoneA(Phone *phone) : DecoratorPhone(phone) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowDecorate</span><span class="params">()</span> </span>&#123; DecoratorPhone::ShowDecorate(); AddDecorate(); &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddDecorate</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;增加挂件&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125; <span class="comment">//增加的装饰  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//具体的装饰类  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorPhoneB</span> :</span> <span class="keyword">public</span> DecoratorPhone &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    DecoratorPhoneB(Phone *phone) : DecoratorPhone(phone) &#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowDecorate</span><span class="params">()</span> </span>&#123; DecoratorPhone::ShowDecorate(); AddDecorate(); &#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddDecorate</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;屏幕贴膜&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125; <span class="comment">//增加的装饰  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Phone *iphone = <span class="keyword">new</span> NokiaPhone(<span class="string">&quot;6300&quot;</span>);  </span><br><span class="line">    Phone *dpa = <span class="keyword">new</span> DecoratorPhoneA(iphone); <span class="comment">//装饰，增加挂件  </span></span><br><span class="line">    Phone *dpb = <span class="keyword">new</span> DecoratorPhoneB(dpa);    <span class="comment">//装饰，屏幕贴膜  </span></span><br><span class="line">    dpb-&gt;ShowDecorate();  </span><br><span class="line">    <span class="keyword">delete</span> dpa;  </span><br><span class="line">    <span class="keyword">delete</span> dpb;  </span><br><span class="line">    <span class="keyword">delete</span> iphone;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="12-备忘录模式"><a href="#12-备忘录模式" class="headerlink" title="12. 备忘录模式"></a>12. 备忘录模式</h2><p>不破坏封装性的前提下捕获对象的内部状态，并在对象外保存该状态。</p><p>以后可以将对象恢复到保存的状态。</p><p><img src="https://pic4.zhimg.com/80/v2-d540b88bc98159d7a88b26a46458decb_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-d540b88bc98159d7a88b26a46458decb_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>gamerole通过save返回memento对象，load传入memento对象载入状态。caretake save传入memento对象保存，load通过下标找到存档并返回。</p><h2 id="13-中介者模式"><a href="#13-中介者模式" class="headerlink" title="13. 中介者模式"></a>13. 中介者模式</h2><p><img src="https://pic2.zhimg.com/80/v2-b186359760b39e81db4614a741271019_720w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-b186359760b39e81db4614a741271019_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>mediator聚合两个Person指针对象。Person聚合一个mediator对象。互相通过set设置好。</p><p>Person send方法调用mediator的send方法，mediator send方法再调用另一个对象的get方法，使另一个对象获得信息。</p><h2 id="14-职责链模式"><a href="#14-职责链模式" class="headerlink" title="14. 职责链模式"></a>14. 职责链模式</h2><p>将对象连成一条链，沿着这条链传递请求，直到有一个对象处理为止。</p><p><img src="https://pic3.zhimg.com/80/v2-0b8c1ce17c8f0b5a4b98cb1b68ba58be_720w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-0b8c1ce17c8f0b5a4b98cb1b68ba58be_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>Manager聚合一个Manager指针对象，表示自己上级。deal时，如果自己能处理请求则处理，否则调用上级的deal函数。</p><h2 id="15-观察者模式-发布-订阅模式"><a href="#15-观察者模式-发布-订阅模式" class="headerlink" title="15. 观察者模式/发布-订阅模式"></a>15. 观察者模式/发布-订阅模式</h2><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><img src="https://pic3.zhimg.com/80/v2-f0ba09772cbb11f708594086e0e5a436_720w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-f0ba09772cbb11f708594086e0e5a436_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>blog中保存更新status与观察者列表，observer中聚合blog指针对象。blog通过setstatus更新后，调用notify，遍历观察者列表并调用其update方法。</p><p>update方法中调用blog指针对象的getstatus方法，获取更新。</p><h2 id="16-状态模式"><a href="#16-状态模式" class="headerlink" title="16. 状态模式"></a>16. 状态模式</h2><p>允许一个对象在其内部状态改变时改变其行为。</p><p><img src="https://pic1.zhimg.com/80/v2-1d5dd8c3ddf2f62a08caddc4d4a9d02c_720w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-1d5dd8c3ddf2f62a08caddc4d4a9d02c_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>war聚合state指针对象，根据days天数改变state。</p><p>currentstate传入war指针，调用每个state各自的方法。</p><p>天数超出当前state后，为war的setstate传入新的state，然后调用getstate。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-Linux</title>
      <link href="/2023/02/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Linux/"/>
      <url>/2023/02/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1. 内存管理"></a>1. 内存管理</h1><p>共4G虚拟内存（32位最大寻址空间）。</p><h2 id="1-内存各段的意义"><a href="#1-内存各段的意义" class="headerlink" title="1. 内存各段的意义"></a>1. 内存各段的意义</h2><p>从下向上为：</p><ul><li>.text程序文件段：程序的二进制可执行代码，只读。</li><li>.data已初始化数据段：已初始化的全局变量和静态常量。</li><li>.bss未初始化数据段：未初始化的静态变量和全局变量。</li><li>堆段：动态分配的内存，低地址向上增长。</li><li>文件映射段：动态库、共享内存等，低地址向上增长。</li><li>栈段：函数的参数值、局部变量、函数调用上下文。大小固定，可通过参数配置。高地址向下增长。</li></ul><h2 id="2-分页的意义-为什么分页"><a href="#2-分页的意义-为什么分页" class="headerlink" title="2. 分页的意义/为什么分页"></a>2. 分页的意义/为什么分页</h2><ul><li>释放内存以页为单位释放，不会产生外部内存碎片。但会产生内部内存碎片。</li><li>加载程序时不必一次性加载完，可以只在需要用到对应部分的时候再加载到内存中。</li><li>内存空间不足时可将最近没使用的内存页面暂时置入磁盘，一次只需要置入几个页，解决交换效率低的问题。</li></ul><h1 id="2-信号"><a href="#2-信号" class="headerlink" title="2. 信号"></a>2. 信号</h1><p>用户、系统、进程发送给目标进程的信息，通知某个状态改变或系统异常。</p><p>常用信号：</p><ul><li>SIGHUP控制终端挂起。</li><li>SIGPIPE向读端关闭的通道或socket连接中写数据。</li><li>SIGURG：socket连接上收到紧急数据。</li></ul><h1 id="3-Linux设计"><a href="#3-Linux设计" class="headerlink" title="3. Linux设计"></a>3. Linux设计</h1><ul><li>MutiTask多任务：多个任务并发或并行。</li><li>SMP对称多处理：每个CPU地位相同，使用权限相同，共享一个内存，每个CPU都可以访问完整的内存和硬件资源。</li><li>ELF可执行文件链接格式</li><li>Monolithic Kernel宏内核：内核是一个完整的可执行程序，拥有最高权限。</li></ul><h1 id="4-I-O"><a href="#4-I-O" class="headerlink" title="4. I/O"></a>4. I/O</h1><p>通常涉及到磁盘、网络，需要IO接口支持数据交换。</p><p>I/O一般分为两步：</p><ul><li>等待数据准备好（设备管理器/网卡拷贝数据到内核缓冲区）</li><li>操作系统将数据从内核缓冲区拷贝到用户。</li></ul><p>同步IO与异步IO的区别就是要不要等待第二步。</p><h2 id="1-I-O模型"><a href="#1-I-O模型" class="headerlink" title="1. I/O模型"></a>1. I/O模型</h2><h3 id="1-阻塞式IO"><a href="#1-阻塞式IO" class="headerlink" title="1. 阻塞式IO"></a>1. 阻塞式IO</h3><p>系统调用，如果没满足条件（如数据没准备好）就阻塞自己，直到内核准备好数据并拷贝到用户态，唤醒进程并操作数据。</p><p>阻塞时可让出CPU。</p><p>耗费时间，适合CPU并发低、时效性要求低的场合。</p><h3 id="2-非阻塞式IO"><a href="#2-非阻塞式IO" class="headerlink" title="2. 非阻塞式IO"></a>2. 非阻塞式IO</h3><p>类似于自旋锁，如果没满足条件就轮询（一直进行系统调用问），直到内核准备好数据（IO第一步完成），然后等待其拷贝到用户态。</p><h3 id="3-IO多路复用"><a href="#3-IO多路复用" class="headerlink" title="3. IO多路复用"></a>3. IO多路复用</h3><p>调用select/poll，阻塞在这两个系统调用上，而非真正的IO系统调用上。</p><p>IO第一步完成时，select返回可读条件，调用recvfrom，等待完成IO第二步（阻塞）。</p><p>可注册多个进程，select监听所有注册好的IO。</p><p>优点：可同时监听多个描述符，且可以等待多个描述符就绪。</p><h3 id="4-信号驱动IO"><a href="#4-信号驱动IO" class="headerlink" title="4. 信号驱动IO"></a>4. 信号驱动IO</h3><p>通过sigaction系统调用安装一个信号处理函数，立即返回。</p><p>IO第一步完成时，内核给该进程产生一个ISGIO信号，进程接到信号后调用信号处理函数，在启动调用recvfrom，等待完成IO第二步（阻塞）。</p><p>优点：信号到达前不被阻塞，可继续执行程序。</p><h3 id="5-异步IO"><a href="#5-异步IO" class="headerlink" title="5. 异步IO"></a>5. 异步IO</h3><p>通过aio_read系统调用，传递描述符、缓冲区指针、缓冲区大小和文件偏移，告知内核操作完后如何通知，然后继续执行。</p><p>内核收到后立刻返回，然后执行第一步、第二部，然后通知进程IO完成。</p><p>与信号驱动的区别：</p><ul><li>信号驱动通知的是可进行IO事件。（仍需等待第二步）</li><li>异步IO通知的是IO完成。（不需要等待第二步）</li></ul><h3 id="6-高效多路复用：epoll"><a href="#6-高效多路复用：epoll" class="headerlink" title="6. 高效多路复用：epoll"></a>6. 高效多路复用：epoll</h3><p>红黑树/线性结构、epoll_ctl、事件驱动与回调函数/轮询、就绪队列/整个线性结构、返回全是就绪事件/还需要对返回值遍历、ET+LT/LT。</p><h1 id="5-控制台-常用命令"><a href="#5-控制台-常用命令" class="headerlink" title="5. 控制台/常用命令"></a>5. 控制台/常用命令</h1><h2 id="命令实现的原理"><a href="#命令实现的原理" class="headerlink" title="命令实现的原理"></a>命令实现的原理</h2><ul><li>terminal终端：字符输入输出设备的抽象，在linux下是一种<strong>特殊的文件</strong>，键盘输入写入这个文件，对应的终端驱动程序会执行回显等工作。</li><li>shell：本质是命令解释软件。</li><li><strong>运行shell时，shell的stdin、stdout、stderr会打开并指向一个特定的terminal文件，使得我们的键盘输入实际上写到terminal里，但shell通过stdin从terminal文件得到。</strong></li></ul><p>执行方式：</p><ul><li>ubuntu中默认的shell是bash，打开终端时就会启动bash。接下来输入的字符通过terminal传递给bash运行。bash执行指令的方式有三种<ul><li>绝对路径执行，指定执行的命令脚本的路径+命令文件</li><li>sh执行，用脚本对应的sh或bash接脚本执行</li><li>shell环境执行，在当前的shell环境中执行，使用.接脚本或source接脚本</li><li>前两种方式会使用一个新的bash子进程执行命令，父进程睡眠。子进程执行完后回到父进程。</li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/74935718">可看</a></p><p>规律：</p><ul><li>-i一般为需要输出信息、提示时</li><li>-f与-i相对，一般为无需显示确认信息</li><li>-r/-R一般为递归执行操作</li></ul><p>通配符：</p><ul><li>？可替代单个字符</li><li>*可替代任意多字符</li><li>[charset]可替代其中任意单个字符</li></ul><h2 id="1-标准输入和参数"><a href="#1-标准输入和参数" class="headerlink" title="1. 标准输入和参数"></a>1. 标准输入和参数</h2><p>标准输入</p><ul><li>编程语言中scanf、readline这种命令（程序运行中）</li><li>管道符 | 和重定向符 &gt; &lt; 将数据作为程序的标准输入</li><li>本质上是个文件，被自动链接到终端的前台程序。程序切换时切换链接</li></ul><p>参数</p><ul><li>main函数传入的args字符数组（程序启动时）</li><li>$(cmd)读取cmd输出的数据作为参数</li></ul><p>区分</p><ul><li>伴随程序启动时就附在命令后的属于参数，程序启动后才从终端输入的属于标准内容。</li><li>命令能让终端阻塞，说明接收标准输入，否则不接受</li></ul><h2 id="2-后台运行"><a href="#2-后台运行" class="headerlink" title="2. 后台运行"></a>2. 后台运行</h2><p>cmd &amp;：后台运行，但是关闭shell还是会关闭程序。因为shell下运行的程序都是shell进程的子进程。</p><p>(cmd &amp;)：后台运行，关闭shell不关闭程序。相当于挂到systemd守护进程下，而不是shell进程。</p><h2 id="3-sudo"><a href="#3-sudo" class="headerlink" title="3. sudo"></a>3. sudo</h2><p>sudo会让系统使用/etc/sudoers文件中规定的用户权限和环境变量。</p><p>不用sudo，使用的是/home/(username)/bin中的</p><p>sudo使用本地脚本文件时，用绝对路径，防止找不到。</p><h2 id="4-文件名组合"><a href="#4-文件名组合" class="headerlink" title="4. 文件名组合"></a>4. 文件名组合</h2><p>{s1, s2}, {s3, s4}为取两者交集，即{s1, s2, s3, s4}</p><p>{s1, s2}{s3, s4}为两者乘积，即{s1s3, s1s4, s2s3, s2s4}</p><h2 id="5-路径相关"><a href="#5-路径相关" class="headerlink" title="5. 路径相关"></a>5. 路径相关</h2><ul><li>cd -：返回刚才的路径</li><li>!$：替换成上一次命令最后的路径</li><li>!*：替换成上一次命令所有文件路径</li><li>环境变量CDPATH中加入工作目录，cd在当前目录找不到时会自动到CDPATH中找</li></ul><h2 id="6-命令相关"><a href="#6-命令相关" class="headerlink" title="6. 命令相关"></a>6. 命令相关</h2><ul><li>!!：替换成上一次使用的命令</li><li>history | grep ‘cmd’：找到所有包含cmd的历史命令</li><li>!cmdid：找到历史命令后，使用id运行</li></ul><h2 id="7-★-查找"><a href="#7-★-查找" class="headerlink" title="7. ★ 查找"></a>7. ★ 查找</h2><p>find/grep区别：</p><ul><li>find搜索文件，完全匹配（通配符）</li><li>grep搜索文本，包含匹配（正则表达式）</li></ul><p>命令：</p><ul><li>find [path] -选项 参数：根据选项的参数要求在path中寻找文件。支持-and、-or、！表示与或非。<ul><li>find [path] -name filename/“re”：根据path（绝对/相对路径）查找文件名为filename/文件名匹配re正则表达式的文件。</li></ul></li><li>grep (-额外选项) pattern path：在path（没有子目录）中找包含pattern的文件与行，且输出符合额外选项的规范<ul><li>额外选项：<ul><li>-c(count)：只输出匹配行计数</li><li>-i(ignore)：不区分大小写</li><li>-h：查询多文件时不显示文件名</li><li>-I：查询多文件时只输出文件名</li><li>-n：显示匹配行与行号</li><li>-s：不显示不存在或无匹配的错误信息</li><li>-v：反转查找</li><li>-r：要求搜索子目录</li></ul></li><li>特别的用法：带输出的命令 | grep (-选项) “pattern”。在输出中查找匹配pattern的行。相当于将命令的标准输出，通过匿名管道传入grep，作为grep的标准输入。</li></ul></li></ul><h2 id="8-ls"><a href="#8-ls" class="headerlink" title="8. ls"></a>8. ls</h2><p>ls [path default = ./] [-选项] [选项的额外参数]</p><ul><li>-a(all)：显示所有文件与目录（包含隐藏）</li><li>-d(directory)：只列出目录</li><li>-l(long)：长格式显示文件和目录信息</li><li>-r(reverse)：倒序显示</li><li>-t(time)：按修改时间排序</li><li>-A：-a但不列出.与..</li><li>-F：列出文件后：可执行文件加”*”，目录加”/“</li><li>-R：递归显示子目录</li></ul><h2 id="9-★-chmod"><a href="#9-★-chmod" class="headerlink" title="9. ★ chmod"></a>9. ★ chmod</h2><p>修改文件权限</p><p>说明：</p><ul><li>u为owner文件拥有者，g为group与文件拥有者同一group，o为other其他人，a为三者（或ugo）。</li><li>+为增加权限，-为取消，=表示唯一设定。</li><li>r为可读取，w为可写入，x为可执行，X为仅当该文件是子目录或该文件已经被设置为可执行。</li><li>也可用数字表示，三个三位数字，每个数字最高位表示r、次高位表示w、最低位表示x。</li><li>-R：递归</li><li>-c：有更改才显示更改动作</li><li>-f：无法更改不显示错误</li></ul><p>示例：</p><ul><li>chmod ugo+r 1.txt：所有人皆可读取</li><li>chmod ug+w,o-w 1.txt：文件拥有者与同一组人可写，其他人不可写</li><li>chmod -R a+r *：当前目录与子目录所有文件给所有人读取权限</li><li>chmod 777 1.txt：所有人对该文件有所有权限</li><li>chmod 4755 name：此程序有root权限</li></ul><h2 id="10-查看文件"><a href="#10-查看文件" class="headerlink" title="10. 查看文件"></a>10. 查看文件</h2><ul><li>vi：编辑方式，如果没有则创建</li><li>cat：显示全部文件内容</li><li>more：分页显示</li><li>less：与more相似，可以往前翻页</li><li>tail：仅查看尾部</li><li>head：仅查看头部</li></ul><h2 id="11-★-sed"><a href="#11-★-sed" class="headerlink" title="11. ★ sed"></a>11. ★ sed</h2><p>按行匹配文件并进行修改，将修改结果放在标准输出。不修改源文件。</p><p>sed [-hnv] [-e&lt;script&gt;] [-f&lt;script文件&gt;] [文件]</p><ul><li>-e/-f：以选项中指定的script处理输入文本文件（也可以省略，带双引号就行了？）</li><li>-h：help</li><li>-n：只显示处理后的结果</li><li>-i：修改文件</li></ul><p>动作：n动作string：指定第n行，指定动作，如果是写入动作则写入string，没有则不带string</p><ul><li>a：新增</li><li>c：取代</li><li>d：删除</li><li>i：插入，在上一行出现</li><li>p：打印，与-n一起</li><li>s：取代，可搭配正则表达式</li><li>‘/oo/p或d或{一组动作}’：所有包含oo的行</li><li>‘s/old/new/g’：查找与替换（如果old与new中有/，可以用#等分隔符代替）<ul><li>加了g表示全局替换，将所有匹配的都替换掉</li></ul></li><li>动作前加a,b表示指定的行范围，$为最后一行。</li><li>可用分号连接多个动作。</li></ul><p>示例：</p><ul><li>sed -e 4a\newline filename：在filename第四行后添加一行，将结果输出到标准输出</li><li>nl filename | sed ‘3,$d’：删除第三行到最后一行</li><li>cat 2 | sed -e ‘4,$s#111#222#g’：将文件2中第四行到最后一行的所有111换成222</li></ul><h2 id="12-awk"><a href="#12-awk" class="headerlink" title="12. awk"></a>12. awk</h2><p>awk是处理列的。sed是处理行的。</p><p>awk将每行按空格分割成数组，通过$n获取指定列，从1开始。</p><p>示例：</p><ul><li>awk &#39;{print $1}&#39; filename：输出每行第一个元素</li><li>awk “NR==n” filename：输出第n行</li></ul><h2 id="13-正则表达式"><a href="#13-正则表达式" class="headerlink" title="13. 正则表达式"></a>13. 正则表达式</h2><h3 id="1-字符匹配"><a href="#1-字符匹配" class="headerlink" title="1. 字符匹配"></a>1. 字符匹配</h3><ul><li>[:alnum:]：字母和数字</li><li>[:lower:]：小写字母</li><li>[:upper:]：大写字母</li><li>[:digit:]：数字</li><li>[:xdigit:]：十六进制数字</li></ul><h3 id="2-匹配次数"><a href="#2-匹配次数" class="headerlink" title="2. 匹配次数"></a>2. 匹配次数</h3><ul><li>*：任意次</li><li>\?：0或1次</li><li>\+：至少一次</li><li>\{n\}：n次</li><li>\{m,n\}：m~n次</li><li>\{,n\}：至多n次</li><li>\{n,\}：至少n次</li></ul><h3 id="3-位置锚定"><a href="#3-位置锚定" class="headerlink" title="3. 位置锚定"></a>3. 位置锚定</h3><ul><li>^：行首锚定</li><li>$：行尾锚定</li><li>^PATTERN$：模式匹配整行</li><li>\&lt; \b：词首锚定</li><li>\&gt; \b：词尾锚定</li></ul><h3 id="4-后向引用"><a href="#4-后向引用" class="headerlink" title="4. 后向引用"></a>4. 后向引用</h3><p>括号分组，左起第n个左括号与其匹配的右括号中间匹配到的字符为第n组。后续可通过\n指定。</p><h2 id="14-expr"><a href="#14-expr" class="headerlink" title="14. expr"></a>14. expr</h2><ul><li>字符串长度：<code>expr length &quot;str&quot;</code></li><li>字符串子串：<code>expr substr &quot;string&quot; [start] [len]</code>。start为下标，从1开始。</li><li>字符串中某字符第一次出现的位置：<code>expr index &quot;string&quot; io</code>。i或o第一次出现的位置，从1开始。</li><li>整数运算：<code>expr 30 \* 3</code>：乘号必须转义，否则shell可能会误解。</li></ul><h2 id="15-★-top"><a href="#15-★-top" class="headerlink" title="15. ★ top"></a>15. ★ top</h2><p>查看cpu占用。</p><p>选项：</p><ul><li>-d n：每隔n秒更新一次，默认3秒</li><li>-b：批处理模式输出，一般与-n合用，重定向到文件中</li><li>-n：top命令执行的次数</li><li>-p pid：只查看指定pid进程</li><li>-u user：只监听指定用户的进程</li></ul><p>top窗口交互：</p><ul><li>P：按cpu使用率排序，默认</li><li>M：按内存使用率排序</li><li>N：按pid排序</li><li>T：按cpu累计运行时间排序</li><li>k：按pid给予某个进程信号</li><li>r：按pid设置某个进程优先级</li><li>q：退出</li></ul><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><p>kill：将指定信息送至程序，让其终止。</p><ul><li>kill -l：列出所有可发送的信号</li><li>kill -9/-KILL pid：杀死pid线程（另：-1/-HUP为重新加载，-15/-TERM为正常停止）</li></ul><p>ctrl+c/z</p><ul><li>c：强制中断程序执行并<strong>释放内存</strong>。SIGINT。只对当前前台进程,和他的所在的进程组的每个进程都发送。</li><li>z：暂停程序，不释放内存。进程处于<strong>挂起态</strong>。SIGTSTP。</li><li>另：d：不是发送信号，而是输入EOF</li><li>kill：SIGTERM。只有当前进程收到，可以被阻塞、处理、捕获。</li><li>kill -9：SIGKILL。无视任何处理直接杀死。</li></ul><p>cp：复制文件</p><ul><li>-i：覆盖前逐一询问</li><li>-f：覆盖无需确认</li><li>-r：递归复制文件夹</li><li>-p：还复制修改时间和访问权限</li><li>-l：不复制，只生成链接文件</li><li>-d：复制时保留链接</li><li>-a：-dpr</li><li>scp：远程拷贝</li></ul><p>rm：删除</p><ul><li>-i：删除前逐一询问</li><li>-f：即使设置只读也删除而无需确认</li><li>-r：递归删除</li><li>可组合，如-rf</li><li>rmdir：删除空文件夹</li></ul><p>mv：移动/重命名</p><p>ps：显示当前进程状态</p><ul><li>查找指定进程：<code>ps -ef | grep 进程关键字</code></li></ul><p>终端：/dev/tty</p><p>黑洞文件：/dev/null（写多少都会消失）</p><p>wc：计算文件byte数、字数、行数。文件名缺省则读取标准输入</p><ul><li>-c/–bytes/–chars：只显示byte数</li><li>-l/–lines：只显示行数</li><li>-w/–words：只显示字数</li></ul><p>head/tail：头/尾显示文件，默认10行</p><ul><li>-f：循环读取</li><li>-c n：显示n字节</li><li>-n n：显示n行</li><li>–pid=PID：与-f合用，在PID进程死掉后结束</li></ul><p>bg/fg</p><ul><li>bg：后台任务调度到前台</li><li>fg：前台任务调度到后台</li></ul><p>which/whereis：查找特定文件</p><ul><li>which只查可执行文件</li><li>whereis只查二进制文件、说明文档、源文档等</li></ul><p>alias：给命令取别名，如alias la = ‘ls -a’</p><p>whatis：查询命令简要用法</p><p>ifconfig：显示所有网卡信息</p><ul><li>ifconfig eth0 down/up：开关网卡</li><li>ifconfig eth0 add/del IPv6 64：设置IPv6地址</li><li>ifconfig eth0 hw ether MAC：设置MAC地址</li><li>ifconfig eth0 IP netmask ntmk broadcast bdct：IP地址、子网掩码、广播地址，可以只设置前面的</li></ul><p>lsof（list open files）：列出当前系统打开文件</p><ul><li>lsof -i:端口号：查看端口占用</li><li>list -c abc/-p 1234：查看名为abc/进程号1234的进程打开的文件</li></ul><p>netstat：显示网络状况</p><ul><li>-a：详细</li></ul><p>sort：排序</p><ul><li>-f：将小写字母视为大写字母</li><li>-d：只处理英文字母、数字与空格</li><li>-m：合并排序好的文件</li><li>-n：按数值大小排序</li><li>-u：去重</li><li>-o output_file：将输出结果存入指定文件</li><li>-r：反向</li></ul><p>uniq：去重、统计</p><ul><li>-c：在每列旁显示该行重复出现的次数。</li><li>-d：只显示重复出现的行列。</li><li>-u：只显示出现一次的行列。</li></ul><h1 id="6-调试"><a href="#6-调试" class="headerlink" title="6. 调试"></a>6. 调试</h1><h2 id="1-段错误"><a href="#1-段错误" class="headerlink" title="1. 段错误"></a>1. 段错误</h2><p>由于内存问题引起</p><ul><li>访问不存在的内存地址</li><li>访问系统保护的内存地址</li><li>访问只读的内存地址</li><li>栈溢出</li><li>delete使用错误（删除了非new的内存、重复delete）</li><li>数组越界</li></ul><h2 id="2-core"><a href="#2-core" class="headerlink" title="2. core"></a>2. core</h2><ul><li>ulimit -c：查看core开关</li><li>ulimit -c [size]/unlimited 设置core大小</li><li>gdb [exec file] [core file]：运行后执行bt查看错误位置的堆栈信息</li><li>gdb -c [core file] -&gt; file [exec file] -&gt; bt：跟上面一样</li><li>x [virtual addr]：查看指定虚拟地址存储内容</li></ul><h2 id="3-gdb"><a href="#3-gdb" class="headerlink" title="3. gdb"></a>3. gdb</h2><ul><li>gdb ./二进制可执行文件：进入gdb</li><li>run：直接运行程序</li><li>start：在main起始位置停下</li><li>list：查看调试行上下五行。<ul><li>list xxx.c:20：查看该文件20行上下五行</li></ul></li><li>step：逐步调试。进入函数内部</li><li>next：逐步调试。直接运行完函数</li><li>until xxx.c:20：直接运行到该行</li><li>continue：从当前位置开始运行</li><li>break xxx.c:20：打断点</li><li>info break：查看断点</li><li>delete [断点号]：删除所有断点/删除指定断点</li><li>backtrace：查看函数调用栈</li><li>print 变量名</li><li>x：打印指定内存的信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-查漏补缺</title>
      <link href="/2023/02/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
      <url>/2023/02/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><ul><li>面试官您好，我的名字是xxx，今年23岁，来自湖南。（基本信息）</li><li>我本科和硕士阶段都就读于南京大学的计算机科学与技术系，硕士阶段的主要研究方向是自动化单元测试。（学历）</li><li>实验室方面，目前主要在做有关于Python自动化单元测试工具的工作，就是输入待测文件，通过随机算法、遗传算法等自动测试生成算法获得随机生成的测试用例输出，以及对应的覆盖率。我的工作主要是对这个工具进行实证研究，以及在原有的基础上进行一些改进，比如测试生成算法、结合类型标注等。（科研）</li><li>项目方面，做了一个webserver，它的主要功能是，用户在浏览器端输入网址，登陆验证后可请求服务器端的资源。服务器端接受连接、解析报文并做出响应。（项目）</li><li>基础知识方面，我对C++的一些语言特性、数据结构、算法与计算机网络方面的知识比较熟悉，目前主要使用C++来进行编程。（基础）</li></ul><h1 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h1><ul><li>我们这个部门主要做的业务是什么？</li><li>对我的建议？学习方向？</li></ul><h1 id="1-C-C"><a href="#1-C-C" class="headerlink" title="1. C/C++"></a>1. C/C++</h1><ol><li><p>epoll_wait可通过timeout参数空值是否阻塞。-1表示永远等待，0表示不等待直接返回，其他表示在超时事件内如果没有事件发生，返回0。</p></li><li><p>memcpy实现：满足四字节对齐时进行四字节拷贝，否则进行单字节拷贝。注意dst与src拷贝后是否有重叠。注意类型。</p></li><li><p>socket函数：socket是一种特殊的文件，socket函数就是对其进行的操作。</p><ol><li><code>int socket(int domain, int type, int protocol);</code><ol><li>domain：协议族。AF_INET、AF_INET6。用于本机通信的为AF_UNIX。</li><li>type：socket类型。SOCK_STREAM、SOCK_DGRAM。</li><li>protocol：指定协议。IPPROTO_TCP、IPPROTO_UDP。</li><li>返回值：<ol><li>非负：成功，代表文件描述符</li><li>-1：出错</li></ol></li></ol></li><li><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><ol><li>sockfd：创建的socket描述字。</li><li>addr：指向绑定给sockfd的协议地址，储存了地址类型、IP地址和端口号。</li><li>addrlen：地址长度。</li><li>返回值：<ol><li>0：成功</li><li>-1：出错</li></ol></li></ol></li><li><code>int listen(int sockfd, int backlog);</code><ol><li>sockfd：要监听的socket描述字。</li><li>backlog：全连接队列长度。</li><li>listen将socket变为被动类型，等待客户连接请求。</li><li>返回值：<ol><li>0：成功</li><li>-1：出错</li></ol></li></ol></li><li><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); </code><ol><li>sockfd：客户端的socket描述字。</li><li>addr：服务器的socket地址。</li><li>addrlen：socket地址长度。</li><li>返回值：<ol><li>0：成功</li><li>-1：出错</li></ol></li></ol></li><li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><ol><li>sockfd：服务器的socket描述字。</li><li>addr：返回客户端的协议地址。</li><li>addrlen：客户端协议地址的长度。</li><li>返回值：<ol><li>非负：成功，代表已连接套接字</li><li>-1：出错</li></ol></li></ol></li><li><code>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</code><ol><li>sockfd：发送端套接字。</li><li>buf：存放要发送数据的缓冲区。</li><li>len：要发送的字节数。</li><li>flags：参数。</li><li>返回值：<ol><li>非负：成功拷贝至发送缓冲区的字节数</li><li>-1：出错并置错误号errno（len大于缓冲区长度、拷贝时出错、网络断开）</li></ol></li></ol></li><li><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</code><ol><li>返回值：<ol><li>非负：成功拷贝的字节数</li><li>-1：出错并置错误号errno（拷贝时出错、网络断开）</li></ol></li></ol></li></ol></li><li><p>write返回值：</p><ol><li>&gt;0且等于给定字节数：正常。</li><li>小于给定字节数：底层物理介质空间不够；文件大小不够；被中断信号打断。</li><li>0：<ol><li>有errno设定：相应的失败情况。</li><li>无：指定写入0字节。</li></ol></li><li>-1：出错，查看errno</li></ol></li><li><p>read返回值：</p><ol><li>&gt;0且等于给定字节数：正常。</li><li>小于给定字节数：读到EOF；被信号打断。</li><li>0：读到EOF，或socket对端关闭。</li><li>-1：出错，查看errno。</li></ol></li><li><p>内存对齐：计算机系统对基本类型在数据中的存放位置有限制，要求其首地址从某个数的倍数开始，一般是4或8.</p><ol><li>原因：<ol><li>平台原因：某些硬件平台只能在某些地址处取某些特定类型的数据。</li><li>性能原因：访问未对齐的内存需要通过其他的辅助手段来获得这个位置的具体类型，不仅耗时且可能还有额外空间消耗。</li></ol></li><li>规则：<ol><li>每个特定平台的编译器都有对齐系数，可通过pragma pack预编译命令改变。</li><li>有效对齐值：pragma和结构体最长数据类型中较小的那个。</li><li>结构体第一个成员的偏移量为0，所有成员的偏移量与结构体的总大小都是有效对齐值的整数倍。</li></ol></li></ol></li><li><p>pthread_cond_wait：内部会先有一个解锁操作。一般的流程为，线程获得互斥锁后判断条件是否满足，不满足则调用该函数阻塞自己。此时如果不解锁，那线程就会带着互斥锁阻塞，其他线程无法获得互斥锁。被唤醒后，会先获得互斥锁再返回。</p></li><li><p>epoll函数：</p><ol><li><p><code>int epoll_create(size_t size)</code>：这个参数不起作用，只需要大于0就可以，内核会自动调整大小。返回epdf，epoll文件描述符。</p></li><li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>：</p><ol><li><p>epfd：create创建的描述符</p></li><li><p>op：</p><ol><li>EPOLL_CTL_ADD：注册新的fd</li><li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件</li><li>EPOLL_CTL_DEL：删除fd</li></ol></li><li><p>event：待监听的事件，可用<strong>按位或</strong>表示监听多个事件 <code>struct epoll_event &#123; __uint32_t events;  epoll_data_t data; &#125;;</code></p><ol><li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li><li>EPOLLOUT：表示对应的文件描述符可以写</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li><li>EPOLLERR：表示对应的文件描述符发生错误</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</li><li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li></ol></li></ol></li><li><p><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code>：返回就绪的文件描述符个数，时间到返回0，出错返回-1</p><ol><li>events：得到就绪事件集合。</li><li>maxevents：告知events有多大，不能大于size。</li><li>timeout：<ol><li>-1：阻塞</li><li>0：立即返回</li><li>&gt;0：等待timeout秒返回</li></ol></li></ol></li></ol></li></ol><h1 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2. 操作系统"></a>2. 操作系统</h1><ol><li>惊群现象：多个线程等待同一资源时，只要有一个资源到来，所有线程都来竞争资源。<ol><li>后果：无效调度、上下文频繁切换，影响系统性能；为确保只有一个线程得到资源，需要加锁，产生额外开销。</li><li>典型：socket accept，多个用户线程监听同一个端口。</li><li>解决：<ol><li>Linux2.6前：监听同一个socket的线程挂在一个等待队列上，请求到来时唤醒所有子线程，使用锁解决。</li><li>后：引入标记位。<ol><li>进程加入等待队列时，如果有标记位，被添加到队列尾部，否则到队列首部。</li><li>wake唤醒第一个有标记的进程后停止。</li></ol></li></ol></li></ol></li><li>grep和find<ol><li>find：根据文件的属性进行查找</li><li>grep：根据文件的内容进行查找，对文件的每一行按照给定的模式进行匹配查找。</li></ol></li><li>Linux文件权限：针对三类对象：owner属主，group属组，other其他。每个文件针对每个访问者定义三种权限：read读、write写、execute执行。<ol><li>针对文件：读写、x为执行权限，对除二进制程序以外的文件没意义。</li><li>针对目录：r：查看目录下的文件列表、w：删除创建文件、x：cd、查看文件详细属性、访问目录下文件内容。</li><li>chmod XXX file：三个X分别对三类对象给的权限。X如果=7，二进制表示为111，表示r、w、x权限都开放。以此类推。</li></ol></li><li>Core dump：<ol><li>概念：程序运行过程中异常终止或崩溃，操作系统就会将程序当时的内存状态记录下来，保存在一个文件中。core保存寄存器信息、内存管理信息、其他处理器和操作系统状态和信息等。</li><li>产生原理：信号处理函数。</li></ol></li><li>Buddy系统：<ol><li>伙伴块定义：<ol><li>大小相同</li><li>地址连续</li><li>从同一个大块分离出来</li><li>用一位二进制数表示其伙伴关系，为1表示其中一块在使用，为0表示都空闲或都在使用。系统每次分配和回收伙伴块时都对其伙伴位与1进行异或。</li></ol></li><li>管理：由链表管理，类似于STL，每个链表节点为2次幂大小的freelist</li><li>分配：<ol><li>查对应的freelist，如果有空闲块就直接摘下分配。</li><li>如果没有就向上查找，直到找到空闲块。</li><li>不断等分这个空闲块，直到恰好为满足条件的大小，把其他分下来的空闲块挂在相应freelist上。</li><li>如果找不到则放弃分配。</li></ol></li><li>释放：<ol><li>查对应的freelist，如果没有伙伴块就直接挂上。</li><li>如果有则摘下伙伴合并，然后向上查找是否可合并。</li><li>直到不能合并或已经合并到最大块。</li></ol></li><li>缺点：<ol><li>小块阻碍大块合并</li><li>按2的幂次分块，有一定浪费</li><li>拆分和合并涉及较多链表和位图操作，开销大</li></ol></li></ol></li></ol><h1 id="3-计网"><a href="#3-计网" class="headerlink" title="3. 计网"></a>3. 计网</h1><ol><li>中间人攻击：客户端发起HTTPS请求时，被假基站转发到了中间人服务器。中间人分别冒充对方，与双方完成TLS握手。<ol><li>前提是用户点击接受了中间人服务器的证书，这种证书浏览器能识别出来是非法的，并提醒用户。</li></ol></li><li>正向代理与反向代理<ol><li>正向代理：在客户端部署代理服务器，代替客户端对外收发消息。主要用途：<ol><li>突破访问控制：VPN。</li><li>提高访问速度：代理服务器有缓冲区，保存请求的响应。</li><li>隐藏客户端真实的IP。</li></ol></li><li>反向代理：在服务端部署代理服务器，替代原服务器接收请求发送响应。<ol><li>隐藏服务器真实IP。</li><li>负载均衡。代理服务器根据负载将请求发送到某台服务器。</li><li>提高访问速度：缓存。</li><li>安全保障：代理服务器作为防火墙。</li></ol></li><li>相同：<ol><li>提升访问速度。</li><li>隐藏IP。</li><li>都是转发请求与响应。</li></ol></li><li>区别：<ol><li>部署位置不同。</li><li>作用不同：正向代理帮助突破访问控制；反向代理提供安全保障与负载均衡。</li></ol></li></ol></li></ol><h1 id="4-MySQL"><a href="#4-MySQL" class="headerlink" title="4. MySQL"></a>4. MySQL</h1><h1 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5. Redis"></a>5. Redis</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-Git</title>
      <link href="/2023/02/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Git/"/>
      <url>/2023/02/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Git/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h1><p>git整个数据库存储在.git/目录下.</p><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><p>Git object：</p><ul><li>blob类型：只储存一个文件的内容，不包括文件名等其他信息。将这些信息通过SHA1哈希算法得到哈希值，作为object在Git仓库中的唯一标识。</li><li>tree类型：将当前目录结构打一个快照，储存一个目录结构。存储文件的权限和文件名。</li><li>commit类型：储存一个提交的信息。</li></ul><p><img src="https://pic1.zhimg.com/80/v2-1cbdf1cf24c0c0b3c0a6e9a7429bb070_720w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-1cbdf1cf24c0c0b3c0a6e9a7429bb070_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>Git本质上是一个k-v数据库加默克尔树形成的有向无环图。</p><h2 id="2-分区"><a href="#2-分区" class="headerlink" title="2. 分区"></a>2. 分区</h2><p><img src="https://pic1.zhimg.com/80/v2-71aa7d6613b4b9efbee48415f1369590_720w.webp" class="lazyload placeholder" data-srcset="https://pic1.zhimg.com/80/v2-71aa7d6613b4b9efbee48415f1369590_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>工作目录：操作系统文件，在此进行编辑。</li><li>索引：暂存区域，下次commit时提交到Git仓库。</li><li>Git仓库：Git object记录每一次提交的快照，以及链式结构记录的提交变更历史。</li></ul><h2 id="3-解决冲突"><a href="#3-解决冲突" class="headerlink" title="3. 解决冲突"></a>3. 解决冲突</h2><p>具体步骤：</p><ul><li>前提：不能在master分支上修改，该分支只能通过pull和merge变更。修改的分支为dev。</li><li>dev分支执行git merge origin/master，将远程master分支合并到dev。</li><li>如果没有报错，直接跳过这一步。根据提示解决冲突，保存文件，然后add与commit添加commit信息。</li><li>切换到master分支。</li><li>pull确保当前master是最新代码。</li><li>dev合并回master分支。</li><li>push提交。</li></ul><h2 id="4-多人协作"><a href="#4-多人协作" class="headerlink" title="4. 多人协作"></a>4. 多人协作</h2><ul><li>试图git push origin [branch] 推送自己的修改。</li><li>如果推送失败，说明远程分支比自己的更新，先git pull试图合并。</li><li>合并可能产生冲突，解决冲突并在本地提交。</li><li>git push origin [branch]推送</li></ul><h1 id="2-git-add-commit-rm"><a href="#2-git-add-commit-rm" class="headerlink" title="2. git add/commit/rm"></a>2. git add/commit/rm</h1><p>add将文件添加到暂存区，commit将暂存区的修改提交到分支。</p><p>与add相对，git rm是删除文件，删了后同样要用commit提交</p><p>提交时并不会盲目复制整个目录，而是将当前版本与上一个版本进行对比，打包所有的差异，作为一个提交记录。</p><h1 id="3-git-branch"><a href="#3-git-branch" class="headerlink" title="3. git branch"></a>3. git branch</h1><p>创建分支只是指向某个提交记录，不会额外耗费内存。</p><p>创建分支后分支没有变，要用git checkout改变分支。</p><p>2.23版本后用git switch取代git checkout。</p><ul><li>git branch -f 分支 提交：将分支移动到提交处。</li><li>git branch -u o/main foo 或 git checkout -b foo o/main：让foo跟踪远程分支。</li><li>git branch -d 分支 删除分支（-D：强行删除分支，即使上面还有没有提交的修改）</li></ul><h1 id="4-git-merge"><a href="#4-git-merge" class="headerlink" title="4. git merge"></a>4. git merge</h1><p>合并两个分支。</p><ul><li>如果它们没有父子关系，则创建一个新的提交，并指向这两个分支。</li><li>如果它们有父子关系，只需要移动指针到最新的提交。</li></ul><p>如果出现冲突，解决冲突后再git add与commit，就会创建一个新提交，指向这两个分支。</p><h1 id="5-git-rebase"><a href="#5-git-rebase" class="headerlink" title="5. git rebase"></a>5. git rebase</h1><p>在rebase后的分支a的基础上，从a与当前分支的共同祖先开始，逐一应用该祖先到当前分支的所有修改。最后将当前分支指向最新的分支。</p><p>同样是合并分支。将并行开发转换成线性开发。</p><ul><li>如果没有父子关系，从当前分支取出一系列提交记录，然后逐个应用在参数分支。</li><li>如果有父子关系，只需要移动指针到最新的提交。</li></ul><h1 id="6-HEAD"><a href="#6-HEAD" class="headerlink" title="6. HEAD"></a>6. HEAD</h1><p>一般情况下，HEAD指向当前分支，当前分支指向某个提交。</p><p>通过git checkout分离HEAD，可使其指向某个提交。</p><p>^表示上个提交，~n表示上n个提交。通过HEAD^来相对移动。</p><h1 id="7-git-reset"><a href="#7-git-reset" class="headerlink" title="7. git reset"></a>7. git reset</h1><p>回退提交记录，相当于重定位HEAD指针。但是对远程分支无效。</p><p>还可以回退文件，git reset HEAD filename：将该文件暂存区的修改撤销。</p><h1 id="8-git-revert"><a href="#8-git-revert" class="headerlink" title="8. git revert"></a>8. git revert</h1><p>创建新提交，引入更改来撤销当前提交。即，新提交状态与上上个提交相同。</p><h1 id="9-git-cherry-pick"><a href="#9-git-cherry-pick" class="headerlink" title="9. git cherry-pick"></a>9. git cherry-pick</h1><p>将一些提交操作在当前的分支下复现。相当于单个提交的rebase。</p><p>如果冲突，会停下来，用户解决完冲突，add加入暂存区后，通过–continue选项继续执行，或–abort放弃。</p><h1 id="10-交互式rebase"><a href="#10-交互式rebase" class="headerlink" title="10. 交互式rebase"></a>10. 交互式rebase</h1><p>加入-i参数，使用交互式界面操作rebase。交互式界面可操作提交数目与顺序。</p><p>git rebase -i 创建分支的提交位置</p><h1 id="11-git-tag"><a href="#11-git-tag" class="headerlink" title="11. git tag"></a>11. git tag</h1><p>tag与分支同样指向一个提交，但tag不能被随意变动。</p><p>tag只在本地有，不自动推送到远程。</p><ul><li>git tag [tagname] [hash]：打标签，不加hash就在当前提交打<ul><li>-a：tagname</li><li>-m：说明</li><li>-d：删除</li></ul></li><li>git show [tagname]</li></ul><h1 id="12-git-describe"><a href="#12-git-describe" class="headerlink" title="12. git describe"></a>12. git describe</h1><p>找到最近的标签。</p><p><code>git describe 提交/默认HEAD</code></p><p>输出 <code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code></p><ul><li>tag为离提交最近的标签。</li><li>numcommits为该提交与ref相差多少提交记录。</li><li>hash为提交的哈希值前几位。</li></ul><h1 id="13-git-clone"><a href="#13-git-clone" class="headerlink" title="13. git clone"></a>13. git clone</h1><h1 id="14-git-fetch"><a href="#14-git-fetch" class="headerlink" title="14. git fetch"></a>14. git fetch</h1><ul><li>从远程仓库下载本地仓库缺失的提交记录</li><li>更新远程分支指针</li></ul><p>不会修改本地文件，只是单纯下载进行这一操作所需的所有数据。</p><h1 id="15-git-pull"><a href="#15-git-pull" class="headerlink" title="15. git pull"></a>15. git pull</h1><p>git fetch + git merge</p><p>git pull –rebase = git fetch + git rebase</p><h1 id="16-git-push"><a href="#16-git-push" class="headerlink" title="16. git push"></a>16. git push</h1><p>git push origin master</p><p>切到本地仓库的main分支，获取所有的提交，再到远程仓库origin找到main分支，将远程仓库没有的提交记录添加。</p><h1 id="17-git-status-diff-reflog"><a href="#17-git-status-diff-reflog" class="headerlink" title="17. git status/diff/reflog"></a>17. git status/diff/reflog</h1><p>查看状态。</p><p>Status查看当前待commit的文件信息、冲突信息。</p><p>Diff传入文件名，查看该文件上一次提交修改的内容。</p><p>reflog查看输入过的命令。</p><h1 id="18-git-checkout"><a href="#18-git-checkout" class="headerlink" title="18. git checkout"></a>18. git checkout</h1><ul><li>改变分支（2.4后用switch区分语义）<ul><li>git checkout -b [dev]：创建dev并改变HEAD至dev。（不加-b则仅改变，需要先通过git branch [dev]创建）</li></ul></li><li>改变文件<ul><li>git checkout – filename：将该文件回到最后一次commit/add的状态（能恢复删除的文件）</li></ul></li></ul><h1 id="19-git-remote"><a href="#19-git-remote" class="headerlink" title="19. git remote"></a>19. git remote</h1><p>关联：git remote add origin [url]</p><p>第一次提交：git push -u origin master：将本地master分支提交到远程仓库。</p><p>后续：git push -u origin master</p><p>删除：git remote rm origin：删除本地库与远程库之间的关联。</p><h1 id="20-git-switch"><a href="#20-git-switch" class="headerlink" title="20. git switch"></a>20. git switch</h1><p>git 2.4后才有的</p><p>为了区分checkout改变分支与文件的动作，用switch来改变分支。</p><ul><li>git switch -c dev：创建并改变分支</li></ul><h2 id="21-git-stash"><a href="#21-git-stash" class="headerlink" title="21. git stash"></a>21. git stash</h2><p>暂存现场工作</p><ul><li>git stash：暂存现场工作</li><li>git stash list：查看暂存的工作</li><li>git stash apply stash@{1}：恢复 默认上一条，如果加最后一个参数则恢复指定的</li><li>git stash drop：删除暂存的工作</li><li>git stash pop：上两条合并</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-Redis</title>
      <link href="/2023/02/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Redis/"/>
      <url>/2023/02/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h1><h2 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1. Redis"></a>1. Redis</h2><p>基于<strong>内存</strong>的数据库，常用于缓存、消息队列、分布式锁等场景。</p><p>提供多种数据类型，对数据类型的操作都是原子性的，因为执行命令由单线程负责。</p><h2 id="2-与Memcached"><a href="#2-与Memcached" class="headerlink" title="2. 与Memcached"></a>2. 与Memcached</h2><p>相同：</p><ul><li>基于内存的数据库，一般用来当作缓存使用。</li><li>有过期策略。</li><li>性能很高。</li></ul><p>不同：</p><ul><li>数据类型：Redis更丰富，Memcached只支持k-v。</li><li>持久化：Redis有，Memcached无。</li><li>集群模式：Redis原生支持，Memcached无原生集群模式。</li><li>其他功能：订阅模型、Lua脚本、事务等。</li></ul><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3. 特点"></a>3. 特点</h2><h3 id="1-高性能"><a href="#1-高性能" class="headerlink" title="1. 高性能"></a>1. 高性能</h3><p>Redis在内存中，可以缓存MySQL中的数据，操作内存速度比操作磁盘快很多。</p><h3 id="2-高并发"><a href="#2-高并发" class="headerlink" title="2. 高并发"></a>2. 高并发</h3><p>Redis单机每秒处理请求次数远高于MySQL。</p><h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h1><h2 id="1-常见数据类型"><a href="#1-常见数据类型" class="headerlink" title="1. 常见数据类型"></a>1. 常见数据类型</h2><h3 id="1-String字符串"><a href="#1-String字符串" class="headerlink" title="1. String字符串"></a>1. String字符串</h3><p>存储字符串、整数、浮点数</p><h4 id="1-底层结构"><a href="#1-底层结构" class="headerlink" title="1. 底层结构"></a>1. 底层结构</h4><p>int和SDS（简单动态字符串）。</p><h4 id="2-应用场景："><a href="#2-应用场景：" class="headerlink" title="2. 应用场景："></a>2. 应用场景：</h4><p>缓存对象、常规技术</p><p>分布式锁：NX参数表示“key不存在才插入”，插入是否成功表示加锁是否成功。</p><p>共享session信息：多台服务器将自己的session信息与redis服务器同步。</p><h3 id="2-List列表"><a href="#2-List列表" class="headerlink" title="2. List列表"></a>2. List列表</h3><p>字符串链表，按插入顺序排序，可以头尾添加，最大长度2^32 - 1。</p><h4 id="1-底层结构-1"><a href="#1-底层结构-1" class="headerlink" title="1. 底层结构"></a>1. 底层结构</h4><p>3.2前用双向链表/压缩链表（列表元素小于512个、每个元素值小于64字节）实现，3.2后只有quicklist实现。</p><h4 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h4><p>消息队列：必须满足的需求：消息保序、处理重复消息、保证消息可靠性。</p><p><strong>消息保序</strong>：List先进先出的特性保证。</p><p>Redis提供BRPOP命令，客户端没有读取到数据时自动阻塞。</p><p><strong>处理重复消息</strong>：自行为每个消息生成全局唯一ID，消息中包含该ID。</p><p><strong>消息可靠性</strong>：防止处理消息时出现故障，导致消息没处理完成，而又已经不在List中。</p><p>提供BRPOPLPUSH命令，从List中读取消息后插入另一个备份List中。</p><p><strong>缺陷</strong>：不支持<strong>多个消费者</strong>（消费组）消费同一消息，因为消息一旦拉取后就删除。由Stream提供支持。</p><h3 id="3-Hash哈希"><a href="#3-Hash哈希" class="headerlink" title="3. Hash哈希"></a>3. Hash哈希</h3><p>包含键值对的无序散列表</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/hash.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/hash.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h4 id="1-底层结构-2"><a href="#1-底层结构-2" class="headerlink" title="1. 底层结构"></a>1. 底层结构</h4><p>7.0前由压缩列表（列表元素小于512个、每个元素值小于64字节）或哈希表实现，7.0后只有listpack实现。</p><h4 id="2-应用场景-1"><a href="#2-应用场景-1" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h4><p>缓存对象</p><p>购物车：用户id为key，商品id为field，商品数量为value。</p><h3 id="4-Set集合"><a href="#4-Set集合" class="headerlink" title="4. Set集合"></a>4. Set集合</h3><p>包含字符串的无序集合</p><p>特性：无序、不可重复、支持并交差等操作。</p><h4 id="1-底层结构-3"><a href="#1-底层结构-3" class="headerlink" title="1. 底层结构"></a>1. 底层结构</h4><p>由哈希表或整数集合（集合元素都是整数，且元素个数小于512）实现。</p><h4 id="2-应用场景-2"><a href="#2-应用场景-2" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h4><p>数据去重、保障唯一性。</p><p>点赞、共同关注、抽奖活动等<strong>并交差计算</strong>场景。</p><h3 id="5-ZSet有序集合"><a href="#5-ZSet有序集合" class="headerlink" title="5. ZSet有序集合"></a>5. ZSet有序集合</h3><p>与hash相似但有序</p><p>相比Set多了一个排序属性score。每个存储元素由有序结合的元素值+排序值组成。</p><h4 id="1-底层结构-4"><a href="#1-底层结构-4" class="headerlink" title="1. 底层结构"></a>1. 底层结构</h4><p>7.0前由压缩列表（元素个数小于128且每个元素值小于64）或跳表实现；7.0后因压缩列表废弃由listpack实现。</p><h4 id="2-应用场景-3"><a href="#2-应用场景-3" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h4><p>排行榜、电话姓名排序等<strong>排序</strong>场景。</p><h3 id="6-BitMap"><a href="#6-BitMap" class="headerlink" title="6. BitMap"></a>6. BitMap</h3><h4 id="1-底层结构-5"><a href="#1-底层结构-5" class="headerlink" title="1. 底层结构"></a>1. 底层结构</h4><p>使用String类型实现。</p><h4 id="2-应用场景-4"><a href="#2-应用场景-4" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h4><p>适合数据量大且能用二值统计的场景。</p><p>签到打卡、判断用户登录、连续签到用户总数</p><h3 id="7-HyperLogLog"><a href="#7-HyperLogLog" class="headerlink" title="7. HyperLogLog"></a>7. HyperLogLog</h3><p>基于概率统计基数，不是很准确。即统计集合中不重复的元素个数。</p><p>每个HyperLogLog键只需要花费12KB内存，就能计算接近2^64个不同元素的基数。</p><p>能添加元素、合并Log、估算指定元素的基数。</p><h4 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h4><p>百万级网页UV计数。</p><h3 id="8-GEO"><a href="#8-GEO" class="headerlink" title="8. GEO"></a>8. GEO</h3><p>用于存储地理位置信息并操作。</p><p>使用GeoHash编码方法实现经纬度到score的转换。一组经纬度落在二维地图某个区间后，就用区间的编码值表示，并将其作为score。</p><p>能存储指定位置、从给定key中返回所有指定名称的位置、计算距离、根据经纬度坐标获取指定范围的地理位置集合。</p><h4 id="1-底层结构-6"><a href="#1-底层结构-6" class="headerlink" title="1. 底层结构"></a>1. 底层结构</h4><p>用Zset实现。</p><h4 id="2-应用场景-5"><a href="#2-应用场景-5" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h4><p>滴滴叫车：将车辆ID存入GEO，叫车时根据用户位置查找附近车辆。</p><h3 id="9-Stream"><a href="#9-Stream" class="headerlink" title="9. Stream"></a>9. Stream</h3><p>5.0后专门为消息队列设计的类型。</p><p>插入消息并生成全局唯一ID、按消费组形式读取消息、查询已读取未确认的消息、确认消息处理完成。</p><h4 id="1-rax"><a href="#1-rax" class="headerlink" title="1. rax"></a>1. rax</h4><p>前缀树。rax可压缩，形成压缩的前缀树。一般的前缀树形如g-r-o-u-p-[1, 2]，而压缩的前缀树形如group-[1, 2]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raxNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> iskey:<span class="number">1</span>;     <span class="comment">/* 是否为key节点（是否可以结束） */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> isnull:<span class="number">1</span>;    <span class="comment">/* 是否存储了额外的值 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> iscompr:<span class="number">1</span>;   <span class="comment">/* 是否为压缩节点 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size:<span class="number">29</span>;     <span class="comment">/* 子节点数量 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[];</span><br><span class="line">&#125; raxNode;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191213161915941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNzIwMzI5,size_16,color_FFFFFF,t_70" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/20191213161915941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNzIwMzI5,size_16,color_FFFFFF,t_70" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>mygroup1、mygroup2的key下都存储了一个对象。</p><h4 id="2-stream"><a href="#2-stream" class="headerlink" title="2. stream"></a>2. stream</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">streamID</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> ms;        <span class="comment">/* Unix time in milliseconds. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> seq;       <span class="comment">/* Sequence number. */</span></span><br><span class="line">&#125; streamID;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stream</span> &#123;</span></span><br><span class="line">    rax *rax;               <span class="comment">/* 存储数据 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> length;        <span class="comment">/* 元素个数 */</span></span><br><span class="line">    streamID last_id;       <span class="comment">/* 最后一个消息ID */</span></span><br><span class="line">    rax *cgroups;           <span class="comment">/* 监听该Stream的消费端信息 */</span></span><br><span class="line">&#125; stream;</span><br></pre></td></tr></table></figure><h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h4><p>消息队列</p><p>用于生产者-消费者模型的队列中同一消费组的成员只能消费一次同一条消息，而不同消费组的成员可消费同一条消息。Stream自动留存消费者读取的消息，直到消费者使用XACK命令通知其消息处理完成。</p><h3 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/9fa26a74965efbf0f56b707a03bb9b7f.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/9fa26a74965efbf0f56b707a03bb9b7f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><p>Redis使用哈希表保存所有键值对。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f302fce6c92c0682024f47bf7579b44c.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/f302fce6c92c0682024f47bf7579b44c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>dict存放了两个哈希表，哈希表2只在rehash时才用。</li><li>key指向string对象，value可以指向基本数据类型对象。所有对象都为redisObject类型。</li></ul><h3 id="1-redisObject"><a href="#1-redisObject" class="headerlink" title="1. redisObject"></a>1. redisObject</h3><p>封装上图中的value</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 数据类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 底层存储的编码格式：int、embstr、raw</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">// 最后一次访问时间</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 对象被引用的次数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 指向底层数据结构的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/58d3987af2af868dca965193fb27c464.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/58d3987af2af868dca965193fb27c464.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h3 id="2-SDS简单动态字符串"><a href="#2-SDS简单动态字符串" class="headerlink" title="2. SDS简单动态字符串"></a>2. SDS简单动态字符串</h3><p>c语言字符串的缺陷：</p><ul><li>线性时间获取长度。</li><li>碰到\0提前结束，导致不能存储\0，以及不能保存二进制数据。</li><li>字符操作不高效不安全，容易导致缓冲区溢出。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* 已用长度 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* buf分配的总长度，判断空间是否满足修改需求，如果不满足回自动扩展再修改 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 0-4，表示sds类型 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">/* sds空间指针在这个位置 */</span></span><br><span class="line">    <span class="comment">// buf由已用的、未用的和end三部分组成</span></span><br><span class="line">    <span class="comment">// end固定占8位，为&#x27;/0&#x27;，不计入alloc</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>提供sdshdr8~64四种结构，只有len和alloc长度不同（还有一种sdshdr5不一样，但是没用到过）</p><p>与string的比较：</p><ul><li>常数时间获取长度</li><li>通过len判断结束，即使有\0也会继续读取，实现二进制安全。为了兼容c标准库，字符串结尾还是会加上\0。</li><li>空间预分配，buffer不够时，如果所需长度小于1MB，就翻倍，否则加1MB；清空sds时只将len设为0，之后再用时可以少做一次内存分配。执行效率较高。</li><li>拼接字符串会提前检查空间，不会造成缓冲区溢出。</li></ul><p><code>__attribute__ ((__packed__))</code>取消了内存对齐，有三个好处：</p><ul><li>节省内存</li><li>动态更改结构体大小时方便</li><li>可通过sds[-1]获取flags</li></ul><h3 id="3-String"><a href="#3-String" class="headerlink" title="3. String"></a>3. String</h3><p>内部编码有：int、raw和embstr</p><p>如果字符串对象保存整数值，且能用long表示，字符串对象将整数值保存在ptr中（void*转long），encoding设为INT。</p><p>如果字符串对象保存字符串，且长度小于等于x字节，字符串对象用SDS保存该字符串，encoding设置为embstr。一次内存分配函数，SDS紧跟在redisObject后，是连续的。</p><p>大于x字节，用SDS保存该字符串，encoding设置为raw。两次内存分配函数，ptr指向SDS的空间，是不连续的。</p><p>x不同版本不同，2.+ 32，3.0-4.0 39，5.0 44。</p><p>embstr和raw分配方式不同：</p><ul><li>创建/释放字符串对象，embstr内存分配/释放只需一次。</li><li>连续内存有利于缓存。</li></ul><p>缺点：如果字符串长度增加要重新分配内存，整个redisObject和sds都需要重新分配空间。所以embstr编码的字符串对象实际上只读，修改时会先转换成raw再修改。</p><h3 id="4-链表"><a href="#4-链表" class="headerlink" title="4. 链表"></a>4. 链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>节点<strong>内存不连续</strong>，无法高效利用<strong>CPU缓存</strong>。</li><li>额外头节点与指针有<strong>额外的空间开销</strong>。</li></ul><h3 id="5-ziplist压缩列表"><a href="#5-ziplist压缩列表" class="headerlink" title="5. ziplist压缩列表"></a>5. ziplist压缩列表</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/a3b1f6235cf0587115b21312fe60289c.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/a3b1f6235cf0587115b21312fe60289c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>结构：</p><ul><li>zlbytes：zl列表总字节数，32bits。</li><li>zltail：zl列表最后一个entry的指针，32bits。</li><li>zllen：zl列表entry总数，16bits。</li><li>entry：zl列表元素。<ul><li>prevlen：前一项长度。<ul><li>前一项长度小于254，prevlen用1字节空间。</li><li>否则，prevlen用5字节空间。</li></ul></li><li>encoding：当前项长度信息的编码结果。<ul><li>节点数据为整数，用1字节。</li><li>节点数据为字符串，根据长度用1/2/5字节。前两位表示类型，后面表示实际长度。</li></ul></li><li>data：当前项实际存储数据。</li></ul></li><li>zlend：zl列表结束标志，8bits。</li></ul><p>连锁更新问题：</p><p>新插入长度大于等于254字节的元素时，导致后面节点的prevlen空间扩大，prevlen空间扩大进而使得长度大于等于254字节，发生连锁反应。</p><p>直接影响压缩列表的访问性能。因此，压缩列表仅用于保存节点数量不多的场景。</p><h3 id="6-哈希表"><a href="#6-哈希表" class="headerlink" title="6. 哈希表"></a>6. 哈希表</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/dc495ffeaa3c3d8cb2e12129b3423118.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/dc495ffeaa3c3d8cb2e12129b3423118.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;  </span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">//键值对中的键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//键值对中的值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h4 id="1-哈希冲突"><a href="#1-哈希冲突" class="headerlink" title="1. 哈希冲突"></a>1. 哈希冲突</h4><p>两个以上数量的key被分配到哈希表中同一个哈希桶。</p><p>Redis采用链式哈希解决哈希冲突。但是随着链表长度增加，查询该位置耗时增加，最高到线性时间。</p><h4 id="2-rehash"><a href="#2-rehash" class="headerlink" title="2. rehash"></a>2. rehash</h4><p>分为三步：</p><ul><li>给哈希表2分配空间，一般比哈希表1大两倍。</li><li>迁移数据。</li><li>释放哈希表1空间，将哈希表2设置为哈希表1，然后在哈希表2新建一个空白哈希表。</li></ul><h4 id="3-渐进式rehash"><a href="#3-渐进式rehash" class="headerlink" title="3. 渐进式rehash"></a>3. 渐进式rehash</h4><p>如果哈希表1数据量很大，迁移数据时涉及大量数据拷贝，对Redis造成阻塞，无法服务其他请求。</p><p>渐进式rehash不一次迁移，而是<strong>每次哈希表元素增删改查时，将对应索引位置上所有k-v迁移</strong>。</p><p>负载因子大于等于1，且没执行RDB快照或AOF重写时，进行rehash；负载因子大于等于5时，强制进行rehash。</p><h3 id="7-整数集合"><a href="#7-整数集合" class="headerlink" title="7. 整数集合"></a>7. 整数集合</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 编码方式，有INT16、INT32、INT64</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">// 保存元素，并不保存int8_t而是根据encoding决定</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><h4 id="1-升级"><a href="#1-升级" class="headerlink" title="1. 升级"></a>1. 升级</h4><p>当新加入元素的类型比现有所有元素类型都要大时，进行升级，也就是按新元素类型扩展数组空间。</p><p>用于在没有大数据时节省内存空间。</p><p>操作：</p><ul><li>扩容</li><li>从后往前拷贝原来的数据</li><li>添加新数据</li></ul><p>不支持降级操作。</p><h3 id="8-跳表"><a href="#8-跳表" class="headerlink" title="8. 跳表"></a>8. 跳表</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">//后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">//每一层中的前向指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;<span class="comment">//x.level[i].span 表示节点x在第i层到其下一个节点需跳过的节点数。注：两个相邻节点span为1</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;<span class="comment">//节点总数</span></span><br><span class="line">    <span class="keyword">int</span> level;<span class="comment">//总层数</span></span><br><span class="line">&#125; zskiplis</span><br></pre></td></tr></table></figure><h4 id="1-查询"><a href="#1-查询" class="headerlink" title="1. 查询"></a>1. 查询</h4><p>从头节点最高层开始：</p><ul><li>如果下一个节点权重小于要查找的权重，访问该层下一个节点。</li><li>如果下一个节点权重大于要查找的权重，且下一个节点SDS类型数据小于要查找的数据，访问该层下一个节点。</li><li>否则前往当前节点的下一层继续查找。</li></ul><h4 id="2-层数设置"><a href="#2-层数设置" class="headerlink" title="2. 层数设置"></a>2. 层数设置</h4><p>相邻两层节点数理想比例为2：1。</p><p>创建节点时随机生成每个节点的层数。生成0~1内的随机数，如果小于0.25则层数+1。</p><h4 id="3-与平衡树"><a href="#3-与平衡树" class="headerlink" title="3. 与平衡树"></a>3. 与平衡树</h4><ul><li>内存占用：跳表平均每个节点包含的指针数比平衡树更少。</li><li>范围查找：跳表可直接遍历，平衡树需要先找到边界值，再中序查找。</li><li>算法实现：跳表更简单，平衡树增删需要调整结构，且调试更困难。</li></ul><h3 id="9-quicklist"><a href="#9-quicklist" class="headerlink" title="9. quicklist"></a>9. quicklist</h3><p>双向链表+压缩列表，链表中的每个元素是压缩列表。</p><p>通过控制每个链表节点中压缩列表的长度，规避连锁更新问题。</p><p><img src="https://img-blog.csdnimg.cn/17791fd91716449c9657f109f8c94424.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhpYm9fbHY=,size_20,color_FFFFFF,t_70,g_se,x_16" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/17791fd91716449c9657f109f8c94424.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhpYm9fbHY=,size_20,color_FFFFFF,t_70,g_se,x_16" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>LZF压缩：数据与前面重复的，记录重复位置与长度，否则直接记录原始数据内容。</p><h3 id="10-listpack"><a href="#10-listpack" class="headerlink" title="10. listpack"></a>10. listpack</h3><p>ziplist会出现连锁更新问题。</p><p>quicklist有效降低连锁更新的影响面，但无法避免。</p><p>listpack用于全面替换ziplist。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c5fb0a602d4caaca37ff0357f05b0abf.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/c5fb0a602d4caaca37ff0357f05b0abf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>结构：<code>&lt;tot-bytes&gt; &lt;num-elements&gt; &lt;element-1&gt; ... &lt;element-N&gt; &lt;listpack-end-byte&gt;</code></p><ul><li><p>tot-bytes：整个listpack空间大小，4字节。</p></li><li><p>num-elements：entry个数，2字节。entry个数大于65535时仍为65535，但获取元素个数需要遍历。</p></li><li><p>entry：具体元素。<code>&lt;encoding-type&gt;&lt;element-data&gt;&lt;element-tot-len&gt;</code></p><ul><li>element-tot-len记录encoding+data的长度，字节数小于等于5。</li><li>element-tot-len占用的每个字节第一个bit用于标识，0表示结束，1表示尚未结束。用于从后向前遍历时判断tot-len字段是否结束。</li><li>element-tot-len主要用于从后向前遍历。</li></ul></li><li><p>end：结束标志，1字节，0xFF。</p></li></ul><p>每个列表项只记录自己的长度而不记录上一项的长度，从而避免了连锁更新。</p><h1 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3. 持久化"></a>3. 持久化</h1><h2 id="1-AOF日志"><a href="#1-AOF日志" class="headerlink" title="1. AOF日志"></a>1. AOF日志</h2><p>AOF持久化：保存<strong>写操作命令</strong>到日志。（不保存读操作）</p><p>默认不开启。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/337021a153944fd0f964ca834e34d0f2.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/337021a153944fd0f964ca834e34d0f2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>*3表示命令有三部分，$3则表示本部分的字符数，set表示具体命令。</p><p>写操作后记录日志的好处：</p><ul><li>保证写入日志的命令都正确且可执行，避免额外检查开销（语法检查等）</li><li>不会阻塞当前写操作命令。因为写操作命令执行成功后才记录日志。</li></ul><p>风险：与日志写回硬盘的时机有关</p><ul><li>服务器在执行写操作和写日志之间宕机，导致数据丢失。</li><li>因为写日志与写操作是单线程，可能阻塞下一个命令。</li></ul><p>具体写入流程：</p><ul><li>redis执行写操作命令，追加到<strong>server.aof_buf缓冲区</strong>。</li><li>系统调用write，写入<strong>内核的page cache</strong>。</li><li>内核持久化到<strong>硬盘</strong>。</li></ul><h3 id="1-写回策略"><a href="#1-写回策略" class="headerlink" title="1. 写回策略"></a>1. 写回策略</h3><p>控制appendfsync配置项，具体实现为控制fsync调用时机</p><ul><li>always：每次写操作命令执行完就刷盘。<strong>写入AOF文件数据后执行fsync</strong>。<ul><li>最大程度保证数据不丢失，但因为IO消耗大，影响性能</li><li>高可靠</li></ul></li><li>everysec：每次写操作命令执行完先写到page cache，每隔1s刷盘。<strong>创建异步任务执行fsync</strong>。<ul><li>均衡方案</li></ul></li><li>no：操作系统控制刷盘时机。<strong>不执行fsync。</strong><ul><li>IO次数最少，但数据丢失概率最大</li><li>高性能</li></ul></li></ul><h3 id="2-重写机制"><a href="#2-重写机制" class="headerlink" title="2. 重写机制"></a>2. 重写机制</h3><p>避免AOF日志文件过大。</p><p>读取当前数据库中所有键值对，将每个键值对用一条命令记录到新AOF文件。全部记录完后，用新的AOF文件替换现有的。（避免重写失败导致文件污染）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/723d6c580c05400b3841bc69566dd61b.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/723d6c580c05400b3841bc69566dd61b.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>好处：</p><ul><li>减少命令数量。多次修改的某个键值对，只需要根据该对当前的最新状态，用一条命令记录。</li></ul><h3 id="3-后台重写"><a href="#3-后台重写" class="headerlink" title="3. 后台重写"></a>3. 后台重写</h3><p>重写由后台子进程bgrewriteaof完成。</p><p>好处：</p><ul><li>避免阻塞主进程。</li><li>子进程带有主进程的数据副本。使用进程，因为多线程共享内存，修改时需要加锁从而降低性能。使用进程，父子进程以只读方式共享内存数据，修改时发生写时复制，父子进程有独立副本，不用加锁。</li></ul><p>写时复制：主进程的页表复制给子进程，使不同的虚拟空间指向同一片物理空间，权限标记为只读。触发写时复制时，CPU触发写中断保护，复制物理内存，然后将两块物理内存权限设置为可读写。只用复制写的那页。</p><p>父进程在创建子进程、写时复制时会陷入阻塞。</p><h3 id="4-重写中的数据不一致"><a href="#4-重写中的数据不一致" class="headerlink" title="4. 重写中的数据不一致"></a>4. 重写中的数据不一致</h3><p>重写过程中主进程修改了已存在的k-v。</p><p>解决：设置AOF重写缓冲区。</p><ul><li>重写期间，主进程执行完写命令后，同时写入AOF缓冲区与AOF重写缓冲区。</li><li>子进程完成重写后，向主进程发送一条信号。</li><li>主进程收到信号，调用信号处理函数。</li><li>信号处理函数将AOF重写缓冲区内容追加到新AOF文件，并将新AOF文件改名覆盖。</li></ul><p>信号处理函数执行时会阻塞主进程。</p><h2 id="2-RDB快照"><a href="#2-RDB快照" class="headerlink" title="2. RDB快照"></a>2. RDB快照</h2><p>保存<strong>二进制数据</strong>。</p><p>提供两个命令生成RDB文件：</p><ul><li>save：主线程生成RDB文件。</li><li>bgsave：创建子进程生成RDB文件。</li></ul><p>RDB加载工作在服务器启动时自动执行。</p><p>bgsave可以设置自动执行，条件为每900/300/60s内对数据库进行了至少1/10/10000次修改。</p><p>Redis的快照是全量快照，将内存中所有数据记录到磁盘。</p><h3 id="1-与AOF比较"><a href="#1-与AOF比较" class="headerlink" title="1. 与AOF比较"></a>1. 与AOF比较</h3><ul><li>保存的是数据，恢复时直接读取就行，AOF则需要一条条执行命令，因此<strong>恢复效率比AOF高</strong>。</li><li>因为是全量快照，执行快照时消耗大，所以不能太频繁，一般至少5分钟一次。这也导致服务器故障时<strong>丢失的数据一般比AOF更多</strong>。</li></ul><h3 id="2-bgsave"><a href="#2-bgsave" class="headerlink" title="2. bgsave"></a>2. bgsave</h3><p>子进程快照时主进程修改数据，依然采用<strong>写时复制</strong>技术。</p><p>风险：</p><ul><li>如果系统在RDB快照文件创建完毕后崩溃，会丢失主线程在<strong>快照期间</strong>修改的数据。</li><li>如果所有的共享内存都被修改，写时复制会造成内存占用是原先的两倍。</li></ul><h2 id="3-混合持久化"><a href="#3-混合持久化" class="headerlink" title="3. 混合持久化"></a>3. 混合持久化</h2><p>混合使用AOF日志和内存快照。</p><p>工作在AOF日志重写过程。</p><p>具体过程：将AOF重写中“写入set键值对命令”替换为“以RDB方式写入AOF文件”。写入完RDB数据后，将AOF重写缓冲区的命令以AOF方式写入。</p><p>重写后，AOF文件前半部分是RDB格式的全量数据，后半部分是AOF格式的增量数据。</p><p>好处：</p><ul><li>重启Redis加载数据时，前半部分是RDB，<strong>加载很快</strong>。</li><li>后半部分是AOF重写期间主线程处理的操作命令，<strong>数据丢失更少</strong>。</li></ul><p>缺点：</p><ul><li>RDB格式数据使得AOF文件可读性变差。</li><li>兼容性差，不能兼容4.0之前版本。</li></ul><h2 id="4-大key对持久化的影响"><a href="#4-大key对持久化的影响" class="headerlink" title="4. 大key对持久化的影响"></a>4. 大key对持久化的影响</h2><h3 id="1-对AOF日志"><a href="#1-对AOF日志" class="headerlink" title="1. 对AOF日志"></a>1. 对AOF日志</h3><ul><li>always策略：同步写，会阻塞主线程。</li><li>everysec策略：异步写，不会影响主线程。</li><li>no策略：不会影响主线程。</li></ul><h3 id="2-对AOF重写和RDB"><a href="#2-对AOF重写和RDB" class="headerlink" title="2. 对AOF重写和RDB"></a>2. 对AOF重写和RDB</h3><p>大量大key使得AOF文件很大，迅速触发AOF重写。</p><p>父进程阻塞的时机：</p><ul><li>创建子进程时，复制页表等。大key会占用很大内存，导致页表变大，复制页表耗时也变长，从而导致主进程阻塞更久。</li><li>写时复制时。如果对大key修改，会将大key所在的物理内存复制一份，导致主进程阻塞更久。</li><li>AOF重写缓冲区信号处理函数执行时。</li></ul><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><ul><li>客户端超时阻塞：操作大key耗时，会阻塞Redis。客户端很久得不到响应。</li><li>网络阻塞：获取大key产生的网络流量大。</li><li>阻塞工作线程：使用del删除大key时。</li><li>内存分布不均：集群模型在slot分片均匀的情况下，会出现数据和查询倾斜，部分有大key的Redis节点占用内存多，QPS大。</li></ul><h3 id="4-避免"><a href="#4-避免" class="headerlink" title="4. 避免"></a>4. 避免</h3><ul><li>设计时拆分为小key。</li><li>定时检查是否存在大key，如果存在用unlink命令异步删除。</li></ul><h1 id="4-过期删除策略"><a href="#4-过期删除策略" class="headerlink" title="4. 过期删除策略"></a>4. 过期删除策略</h1><p>对key设置过期时间，可设置绝对时间/相对时间过期。</p><p>这样会将key带上过期时间存储到过期字典中。key是指向键对象的指针，value是long long类型的整数，保存过期时间。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>查询key时，先判断key是否在过期字典中，不在则正常读取。如果在，则判断是否过期，没过期则正常读取，否则直接结束。</p><h2 id="1-定时删除"><a href="#1-定时删除" class="headerlink" title="1. 定时删除"></a>1. 定时删除</h2><p>设置过期时间时创建一个定时事件，时间到达时由事件处理器自动执行删除操作。</p><p><strong>对内存友好，对CPU不友好</strong>。</p><p>优点：保证过期key尽快删除，内存尽快释放。</p><p>缺点：过期key较多时删除操作占用CPU时间，当内存不紧张但CPU紧张时会对服务器响应时间和吞吐量造成影响。</p><h2 id="2-惰性删除"><a href="#2-惰性删除" class="headerlink" title="2. 惰性删除"></a>2. 惰性删除</h2><p>不主动删除过期key，每次从数据库访问key时检查其是否过期，过期则删除。</p><p><strong>对内存不友好，对CPU友好</strong>。</p><p>优点：对CPU时间最友好。</p><p>缺点：未访问的过期key一直得不到删除，造成内存空间浪费。</p><h2 id="3-定期删除"><a href="#3-定期删除" class="headerlink" title="3. 定期删除"></a>3. 定期删除</h2><p>每隔一段时间随机从数据库中抽取一定数量key检查，删除过期key。</p><p>优点：通过限制删除操作的时长和频率减少对CPU影响，同时也能删除部分过期key，释放内存。</p><p>缺点：</p><ul><li>内存清理不如定时删除，CPU占用不如惰性删除。</li><li>难以确定操作的时长和频率。</li></ul><h2 id="4-Redis策略"><a href="#4-Redis策略" class="headerlink" title="4. Redis策略"></a>4. Redis策略</h2><p>惰性删除+定期删除</p><p>惰性删除流程：</p><ul><li>改查key前调用expireIfNeeded检查是否过期。<ul><li>过期则删除。异步或同步由lazyfree_lazy_expire决定。</li><li>没有过期不做任何处理。</li></ul></li></ul><p>定期删除流程：</p><ul><li>Redis默认每秒执行10次定期删除，每次抽查20个key并删除过期key。</li><li>删除时间超过25ms，停止抽查。</li><li>过期key超过5个（25%），返回第一步；过期key未超过5个，停止抽查。</li></ul><h3 id="1-持久化时对过期键的处理"><a href="#1-持久化时对过期键的处理" class="headerlink" title="1. 持久化时对过期键的处理"></a>1. 持久化时对过期键的处理</h3><ul><li>RDB文件生成阶段：不保存过期键</li><li>RDB加载阶段：<ul><li>主服务器：不载入过期键</li><li>从服务器：载入过期键。一般主从服务器数据同步时，从服务器数据被清空，所以载入过期键没影响。</li></ul></li><li>AOF文件写入阶段：如果过期键没被删除，保留过期键；过期键被删除时，追加一条DEL命令。</li><li>AOF重写阶段：不保存过期键</li></ul><h3 id="2-主从模式中对过期键的处理"><a href="#2-主从模式中对过期键的处理" class="headerlink" title="2. 主从模式中对过期键的处理"></a>2. 主从模式中对过期键的处理</h3><p>从库不进行过期扫描。</p><p>主库key到期时，在AOF文件里增加一条DEL指令，然后同步到从库，从库再删除过期key。</p><h1 id="5-内存淘汰策略"><a href="#5-内存淘汰策略" class="headerlink" title="5. 内存淘汰策略"></a>5. 内存淘汰策略</h1><p>maxmemory参数设置默认内存，64位系统默认为0，表示没有内存大小限制，不对可用内存检查；32位系统默认为3G。</p><h2 id="1-不进行数据淘汰的策略"><a href="#1-不进行数据淘汰的策略" class="headerlink" title="1. 不进行数据淘汰的策略"></a>1. 不进行数据淘汰的策略</h2><p>noeviction（3.0后默认）：运行内存超限后，不进行淘汰，如果写入新的数据则触发OOM，进行其他操作还可以正常工作。</p><h2 id="2-进行数据淘汰的策略"><a href="#2-进行数据淘汰的策略" class="headerlink" title="2. 进行数据淘汰的策略"></a>2. 进行数据淘汰的策略</h2><h3 id="1-在设置了过期时间的数据中淘汰"><a href="#1-在设置了过期时间的数据中淘汰" class="headerlink" title="1. 在设置了过期时间的数据中淘汰"></a>1. 在设置了过期时间的数据中淘汰</h3><ul><li>volatile-random：随机淘汰。</li><li>volatile-ttl：优先淘汰更早过期的键值。</li><li>volatile-lru（3.0前默认）：淘汰最久未使用的。</li><li>volatile-lfu：淘汰最少使用的。</li></ul><h3 id="2-在所有数据中淘汰"><a href="#2-在所有数据中淘汰" class="headerlink" title="2. 在所有数据中淘汰"></a>2. 在所有数据中淘汰</h3><ul><li>allkeys-random：随机淘汰。</li><li>allkeys-lru：淘汰最久未使用的。</li><li>allkeys-lfu：淘汰最少使用的。</li></ul><h2 id="3-LRU"><a href="#3-LRU" class="headerlink" title="3. LRU"></a>3. LRU</h2><p>传统LRU使用链表，存在两个问题：</p><ul><li>链表额外空间开销。</li><li>每次访问数据需要移动到头端，大量数据访问时很耗时。</li></ul><p>Redis实现近似LRU算法。</p><ul><li>在redisObject中的lru字段，存储最近一次访问时间。</li><li>淘汰内存时，随机取5个值，淘汰最久未使用的。</li></ul><p>优点：</p><ul><li>不必为所有数据维护一个大链表，节省空间。</li><li>不用每次访问移动项，提高性能。</li></ul><p>缺点：无法解决缓存污染问题。（大量数据只读一次）</p><h2 id="4-LFU"><a href="#4-LFU" class="headerlink" title="4. LFU"></a>4. LFU</h2><p>redisObject中的lru字段，在LFU中：</p><ul><li>高16bits存储ldt，记录访问时间戳。</li><li>低8bits存储logc，记录访问频次，初始值为5。</li></ul><p>每次访问key：</p><ul><li>按上次访问距离当前时长衰减logc。lfu-decay-time以min为单位，默认为1，越大衰减越慢。</li><li>概率增加logc，logc越大概率越低。lfu-log-factor越大，logc增长越慢。</li></ul><h1 id="6-主从复制"><a href="#6-主从复制" class="headerlink" title="6. 主从复制"></a>6. 主从复制</h1><p>单点故障：持久化技术能保证服务器重启不会损失太多数据，但是服务器重启期间无法接收请求，且如果服务器硬盘损坏，那么无法恢复数据。</p><p>一般备份数据到多台服务器，它们都可以提供服务。</p><p>主从复制保证多台服务器的数据一致性，且主从服务器采用读写分离的方式。</p><p>读写分离：主服务器可读写，写操作时同步给从服务器，从服务器一般只读，并同步主服务器的写操作。</p><p>数据同步需要时间，无法保证强一致性。</p><h2 id="1-第一次同步"><a href="#1-第一次同步" class="headerlink" title="1. 第一次同步"></a>1. 第一次同步</h2><p>从服务器B执行 <code>replicaof 服务器A IP 服务器A Redis端口号</code>变成其从服务器。</p><p>分为三个阶段：</p><ol><li>建立链接、协商同步：命令格式为 <code>order runID offset</code>。<ol><li>B发送 <code>psync ? -1</code>给A，表示进行数据同步。</li><li>A收到后用 <code>FULLRESYNC runIDA offset</code>响应，表示采用<strong>全量复制</strong>方式，同步所有数据给B。</li><li>runID：Redis服务器启动时产生随机ID唯一标识自己。从服务区因为还不知道主服务器ID，设为？。</li><li>offset：复制进度。</li></ol></li><li>同步数据：<ol><li>A执行bgsave命令生成RDB文件，发送给B。</li><li>B清空数据，载入RDB文件。载入后回复ACK。</li><li>A将以下时间内收到的写操作写入replication buffer缓冲区：<ol><li>A生成RDB期间</li><li>A发送RDB给B期间</li><li>B加载RDB期间</li></ol></li></ol></li><li>发送新的写操作：A将replication buffer记录的写操作发送给B，B执行。</li></ol><h2 id="2-命令传播"><a href="#2-命令传播" class="headerlink" title="2. 命令传播"></a>2. 命令传播</h2><p>完成第一次同步后，双方维护TCP长连接。</p><p>后续继续同步写操作命令。</p><p>称为<strong>基于长连接的命令传播。</strong></p><h2 id="3-分摊压力"><a href="#3-分摊压力" class="headerlink" title="3. 分摊压力"></a>3. 分摊压力</h2><p>如果从服务器数量多，且每次都全量同步，主服务器会频繁fork与传输RDB文件，占用主服务器主线程时间与带宽。</p><p>为了解决问题，设置从服务器C可以成为其他从服务器B的从服务器，通过从服务器B中转命令。</p><h2 id="4-增量复制"><a href="#4-增量复制" class="headerlink" title="4. 增量复制"></a>4. 增量复制</h2><p>主从服务器网络如果断开了，会使得数据不一致。</p><p>使用增量复制继续同步。</p><p>获得断线期间的写命令：</p><ul><li>repl_backlog_buffer：环形缓冲区。主服务器发送写命令时写入该缓冲区。</li><li>replication offset：标记同步进度。主服务器用master_repl_offset记录写到的位置，从服务器用slave_repl_offset记录读到的位置。</li></ul><p>有三个步骤：</p><ol><li><p>B恢复网络后发送psync，offset参数为slave_repl_offset。</p></li><li><p>A发送CONTINUE，表示接下来通过增量复制同步数据。</p></li><li><p>A根据master_repl_offset与slave_repl_offset：</p><ol><li>B要读的数据不在repl_backlog_buffer，执行全量同步。</li><li>执行增量同步。</li></ol></li></ol><p>repl_backlog_buffer = second * write_size_per_second 估算缓冲区最小大小。</p><p>second为断线重连平均时间，write_size_per_second为主服务器每秒写命令产生的平均数据量。</p><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><h3 id="1-判断节点正常工作"><a href="#1-判断节点正常工作" class="headerlink" title="1. 判断节点正常工作"></a>1. 判断节点正常工作</h3><p>ping-pong检测机制。</p><ul><li>主节点默认每10s发送ping。</li><li>从节点每1s上报当前复制偏移量，目的是：<ul><li>检测网络状态。</li><li>上报偏移量，检测数据是否丢失。</li></ul></li></ul><h3 id="2-同步-异步"><a href="#2-同步-异步" class="headerlink" title="2. 同步/异步"></a>2. 同步/异步</h3><p>主节点收到写命令后先写到内部缓冲区，然后异步发送。</p><h3 id="3-两个buffer"><a href="#3-两个buffer" class="headerlink" title="3. 两个buffer"></a>3. 两个buffer</h3><ul><li><p>出现阶段：</p><ul><li>repl backlog buffer：增量复制阶段。一个主节点只有一个repl backlog buffer。</li><li>replication buffer：全量复制和增量复制阶段。主节点给每个从节点分配一个replication buffer。</li></ul></li><li><p>大小限制：</p><ul><li>repl backlog buffer：环形结构，满了覆盖起始位置。</li><li>replication buffer：满了导致连接断开，从节点重新连接并全量复制。</li></ul></li></ul><h3 id="4-主从不一致"><a href="#4-主从不一致" class="headerlink" title="4. 主从不一致"></a>4. 主从不一致</h3><p>主服务器写完就直接返回客户端确认，之后再发给从服务器，如果从服务器写失败或没写就会导致不一致。</p><p>解决：</p><ul><li>尽量保证主从服务器之间网络良好。</li><li>开发外部程序监控复制进度。</li></ul><h3 id="5-数据丢失"><a href="#5-数据丢失" class="headerlink" title="5. 数据丢失"></a>5. 数据丢失</h3><h4 id="1-异步复制同步丢失"><a href="#1-异步复制同步丢失" class="headerlink" title="1. 异步复制同步丢失"></a>1. 异步复制同步丢失</h4><p>主服务器写完后，没来得及同步给从服务器就断电了。</p><p>解决：一旦所有从节点数据复制和同步的延迟超过了一定时间，就认为主节点宕机后会损失很多数据，主节点拒绝接受任何请求。客户端发现不可写后可先缓存。</p><h4 id="2-脑裂"><a href="#2-脑裂" class="headerlink" title="2. 脑裂"></a>2. 脑裂</h4><ul><li>主从节点失联。</li><li>主节点接收客户端的写命令，缓存且无法同步。</li><li>哨兵发现主节点失联，重新选出主节点。</li><li>网络恢复，哨兵将旧主节点降级为从节点。</li><li>旧主节点向新主节点请求同步，第一次同步为全量复制，导致旧主节点清空了脑裂期间的写入数据，从而丢失数据。</li></ul><p>解决：主节点发现从节点下线数量太多或网络延迟大时，拒绝接收请求。</p><h1 id="7-哨兵"><a href="#7-哨兵" class="headerlink" title="7. 哨兵"></a>7. 哨兵</h1><p>作用：实现主从节点<strong>故障转移</strong>。监控主节点的状态，如果主节点挂了，则选举一个从节点为主节点，并将新主节点的相关信息通知给其他从节点和客户端。</p><p>本质：一个运行在特殊模式下的Redis进程，也是一个节点。</p><p>负责监控、选主与通知。</p><h2 id="1-监控"><a href="#1-监控" class="headerlink" title="1. 监控"></a>1. 监控</h2><ul><li>每隔1s PING所有主从节点，主从节点收到后响应哨兵。</li><li>如果有节点没有在规定时间内响应，标记为<strong>主观下线</strong>。主观下线不代表故障，可能是系统压力大或网络拥塞导致的。为了减少误判，部署多个哨兵节点为哨兵集群（至少3个且为奇数），一起判断。</li><li>如果某个哨兵判断主节点为主观下线，就向其他哨兵发起命令征求同意。其他哨兵根据主节点的相应情况赞成或反对投票。如果该哨兵收到票数达到设定值quorum（一般为节点数一半+1），就标记主节点为<strong>客观下线</strong>。</li></ul><h2 id="2-选主"><a href="#2-选主" class="headerlink" title="2. 选主"></a>2. 选主</h2><p>从哨兵中选出一个leader，进行主从切换。</p><p>选举：</p><ul><li>当某个哨兵标记主节点为客观下线时，它成为参选者，并向其他哨兵发出命令表明希望成为leader，请求投票。每个哨兵只能投一票，只有候选者能投自己。</li><li>任一候选者满足条件，则成为leader，否则重投：<ul><li>半数以上赞成票。</li><li>票数大于等于quorum值。</li></ul></li></ul><p>转移：</p><ul><li>在旧主节点的所有从节点中选出一个，发送SLAVEOF no one命令，转换为主节点。<ul><li>筛选掉网络不好的从节点：主从节点发生断联次数超过10次。</li><li>依次按照优先级、复制进度、ID号进行三轮考察。</li></ul></li><li>向其他所有从节点发送SLAVEOF命令，使其指向新主节点。</li></ul><h2 id="3-通知"><a href="#3-通知" class="headerlink" title="3. 通知"></a>3. 通知</h2><p>发布/订阅者机制。通过在不同频道发送消息来表示不同事件。</p><ul><li>每个哨兵节点提供发布/订阅者机制，客户端与哨兵建立连接时订阅哨兵。哨兵向“主库地址发生变化”频道发送新主节点的IP地址和端口信息，客户端收到后用新的IP和端口通信。</li><li>继续监视旧主节点，其上线时发送SLAVEOF命令，转换为新主节点的从节点。</li></ul><h2 id="4-哨兵集群"><a href="#4-哨兵集群" class="headerlink" title="4. 哨兵集群"></a>4. 哨兵集群</h2><p>哨兵节点间通过发布/订阅者机制相互发现。</p><p>哨兵之间通过主节点的hello频道发现。某个哨兵在该频道上发送IP与端口，其他哨兵发现并订阅。</p><p>哨兵每10s向主节点发送INFO命令，获取所有从节点的信息，并与其建立连接。</p><h1 id="8-集群"><a href="#8-集群" class="headerlink" title="8. 集群"></a>8. 集群</h1><p>主从复制、哨兵模式、切片集群。</p><h2 id="1-切片集群"><a href="#1-切片集群" class="headerlink" title="1. 切片集群"></a>1. 切片集群</h2><p>缓存数据量大到一台服务器无法缓存时使用。</p><p>将数据分布在不同服务器上，降低系统对单主节点的依赖，提高读写性能。</p><p>采用<strong>哈希槽</strong>处理数据和节点间的映射关系。一个切片集群有16384个哈希槽。</p><p>每个键值对根据key映射到一个哈希槽中，具体过程：</p><ul><li>根据CRC16算法计算key得到一个16bit数。</li><li>对16384取模。</li></ul><p>哈希槽到具体的Redis节点的分配方案：</p><ul><li>平均分配。创建集群时，自动将所有哈希槽平均分布到节点集群。</li><li>手动分配。</li></ul><h2 id="2-脑裂-1"><a href="#2-脑裂-1" class="headerlink" title="2. 脑裂"></a>2. 脑裂</h2><p>主节点丢失连接，再回来后降级为从节点，数据清空。主节点丢失连接期间，客户端写的数据丢失。</p><p>解决方案：主节点发现从节点下线数量太多或网络延迟大时，拒绝接收请求。</p><h1 id="9-缓存"><a href="#9-缓存" class="headerlink" title="9. 缓存"></a>9. 缓存</h1><h2 id="1-缓存雪崩"><a href="#1-缓存雪崩" class="headerlink" title="1. 缓存雪崩"></a>1. 缓存雪崩</h2><p>大量缓存在同一时间过期或Redis宕机，大量用户请求无法在Redis中处理，进而直接访问数据库，造成数据库压力骤增，严重的甚至导致宕机。</p><h3 id="1-大量数据同时过期"><a href="#1-大量数据同时过期" class="headerlink" title="1. 大量数据同时过期"></a>1. 大量数据同时过期</h3><ul><li>均匀设置过期时间：随机数。</li><li>互斥锁：发现访问数据不在Redis中时，加上互斥锁，保证同一时间只有一个请求构建缓存。没拿到锁的请求要么等待锁释放后重新读取，要么返回默认值。</li><li>双key策略：对缓存数据使用两个key，主key设置过期时间，备key不设置。访问不到主key时，直接返回备key数据，更新缓存时同时更新主key与备key数据。<ul><li>构建缓存期间可以直接返回备key数据，快速响应请求。</li></ul></li><li>后台更新缓存：业务线程不再负责更新缓存，缓存不设置有效期，由后台线程定时更新。但系统内存紧张可能导致缓存数据淘汰，业务认为数据丢失。<ul><li>后台线程还负责检测缓存是否有效，发现失效时立即从数据库中读取数据。</li><li>业务线程发现失效后，通过消息队列通知后台线程更新缓存。</li></ul></li></ul><h3 id="2-Redis故障宕机"><a href="#2-Redis故障宕机" class="headerlink" title="2. Redis故障宕机"></a>2. Redis故障宕机</h3><ul><li>服务熔断：暂停业务应用对缓存服务的访问，直接返回错误，等Redis恢复正常后再提供服务。</li><li>请求限流：只将少部分请求发送到数据库处理，其他的直接拒绝，等Redis恢复正常并预热缓存后再解除。</li><li>构建Redis缓存高可靠集群：通过主从节点的方式构建。</li></ul><h2 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h2><p>缓存中某个热点数据过期，且大量的请求访问了该数据。</p><p>是缓存雪崩的一个特例，只针对一个数据。</p><p>使用互斥锁或不设置过期时间的方式应对。</p><h2 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3. 缓存穿透"></a>3. 缓存穿透</h2><p>用户访问的数据既不在数据库中也不在缓存中，请求缓存时发现缺失，就再去访问数据库，发现也不存在，导致做了两次无效请求。大量这样的访问到来，导致数据库压力骤增。</p><p>可能情况：</p><ul><li>业务误删除</li><li>黑客攻击</li></ul><p>应对措施：</p><ul><li>非法请求限制：在API入口处判断请求参数是否合理。</li><li>缓存空值或默认值。</li><li>布隆过滤器快速判断存在。</li></ul><p>布隆过滤器由位图与N个哈希函数组成。每次新数据到来：</p><ul><li>N个哈希函数分别对数据哈希。</li><li>N个哈希值分别对位图长度取模，得到每个哈希值对应位置。</li><li>对应位置置1。</li></ul><p>有新数据到来时，先算出N个哈希值，位图对应位置只要有一个为0，说明数据不在数据库中。</p><h2 id="4-数据库与缓存的一致性"><a href="#4-数据库与缓存的一致性" class="headerlink" title="4. 数据库与缓存的一致性"></a>4. 数据库与缓存的一致性</h2><p>两个请求并发更新同一数据时，由于到达时间差异，可能出现不一致。</p><p>如：A请求更新缓存为1，在更新数据库前B请求到达缓存，更新为2，然后B请求更新数据库为2，A请求再更新数据库为1。最终缓存为2，数据库为1。</p><p>解决：</p><ul><li>更新缓存前加分布式锁</li><li>更新完缓存时加上较短的过期时间</li></ul><h3 id="1-旁路缓存策略-Cache-Aside"><a href="#1-旁路缓存策略-Cache-Aside" class="headerlink" title="1. 旁路缓存策略 Cache Aside"></a>1. 旁路缓存策略 Cache Aside</h3><p>更新数据库时，删除缓存中的数据。</p><p>到读取数据时，发现缓存中没有数据，再从数据库中读到缓存中。</p><h4 id="1-先删缓存再更新数据库"><a href="#1-先删缓存再更新数据库" class="headerlink" title="1. 先删缓存再更新数据库"></a>1. 先删缓存再更新数据库</h4><p>读操作在删缓存与更新数据库之间完成，在缓存中添加了删除的旧值，还是会导致不一致。</p><h4 id="2-先更新数据库再删缓存"><a href="#2-先更新数据库再删缓存" class="headerlink" title="2. 先更新数据库再删缓存"></a>2. 先更新数据库再删缓存</h4><p>读操作在读取数据库的值后，写操作更新为另一值，然后读操作再写回缓存，导致缓存为旧值，而数据库为新值。</p><p>实际中该问题出现概率不高，因为<strong>缓存的写入远快于数据库的写入</strong>。因此该方案可以保证数据一致性。</p><p>问题：删除缓存时失败，导致缓存中为旧值，数据库为新值。</p><h4 id="3-过期时间"><a href="#3-过期时间" class="headerlink" title="3. 过期时间"></a>3. 过期时间</h4><p>即使2方案有不一致，通过过期时间可以达到最终一致性。</p><h4 id="4-解决1的不一致"><a href="#4-解决1的不一致" class="headerlink" title="4. 解决1的不一致"></a>4. 解决1的不一致</h4><p>延迟双删：先删再更，然后睡眠一段时间，再删除缓存。但是睡眠时间不好设置，不如2。</p><h4 id="5-解决2的删除缓存失败"><a href="#5-解决2的删除缓存失败" class="headerlink" title="5. 解决2的删除缓存失败"></a>5. 解决2的删除缓存失败</h4><p>重试机制：引入消息队列，将删除缓存操作的数据加入消息队列，由消费者操作。如果删除失败，可以从消息队列中重新读取并删除；如果删除成功，从消息队列中移除。</p><p>订阅MySQL binlog，再操作缓存：更新数据库成功后会写入binlog，可以通过订阅binlog拿到具体操作的数据，然后再删除缓存。</p><p>Canal中间件是基于此实现的。其模拟主从复制的交互协议，伪装成MySQL从节点，向主节点发送dump请求。MySQL收到请求后开始推送binlog，Canal解析后转换为便于读取的结构化数据，供下游程序订阅。</p><h1 id="10-线程模型"><a href="#10-线程模型" class="headerlink" title="10. 线程模型"></a>10. 线程模型</h1><p>Redis单线程指[接收客户端请求-&gt;解析请求-&gt;数据读写等操作-&gt;发送数据给客户端]是由一个线程完成，不等于Redis程序是单线程。</p><p>Redis为关闭文件、AOF刷盘、释放内存这些任务创建单独的后台线程。这些任务很耗时，与主线程一起处理容易阻塞，从而无法处理后续请求。</p><h2 id="1-单线程模式"><a href="#1-单线程模式" class="headerlink" title="1. 单线程模式"></a>1. 单线程模式</h2><h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><p>初始化：</p><ul><li>创建epoll与服务端socket</li><li>bind服务端socket</li><li>通过epoll监听该socket，注册<strong>连接事件处理函数</strong>。</li></ul><p>循环：基于reactor模式</p><ul><li>先调用处理发送队列函数，看是否有任务，如果有则通过write函数，发送客户端发送缓存区里的数据。如果没发送完，就注册<strong>写事件处理函数</strong>，等待epoll监听到写事件再处理。</li><li>epoll_wait等待就绪事件：<ul><li>连接事件：调用连接事件处理函数。accept获取已连接的socket，加入epoll监听并注册<strong>读事件处理函数</strong>。</li><li>读事件：调用读事件处理函数。read获取客户端发送的数据，解析处理命令，将客户端对象添加到发送队列，将执行结果写到发送缓存区等待发送。</li><li>写事件：调用写事件处理函数。write发送客户端发送缓存区里的数据，如果没发送完，就注册<strong>写事件处理函数</strong>。</li></ul></li></ul><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h3><p>使用reactor：</p><ul><li>Redis大部分操作都在内存中完成，且数据结构高效。性能瓶颈不在CPU而在内存或带宽，所以CPU效率低点无所谓。</li><li>避免多线程竞争，带来时空额外开销、线程安全问题、额外的系统复杂度等。</li><li>I/O多路复用机制处理多个I/O流。</li></ul><p>不用one loop per thread：</p><ul><li>redis还是数据结构数据库，值支持多种数据结构，加锁麻烦。</li><li>redis运行过程是空间和时间均衡的过程，存储数据的时候数据结构是变换的。</li></ul><h3 id="3-6-0后引入多线程的原因"><a href="#3-6-0后引入多线程的原因" class="headerlink" title="3. 6.0后引入多线程的原因"></a>3. 6.0后引入多线程的原因</h3><p>网络硬件性能提升了，瓶颈有时出现在网络IO处理上。</p><p>只对网络IO采用多线程处理，执行命令仍用单线程模型。</p><p>线程数一定要小于机器核数。</p><p>启动时一般为六个线程：主线程、异步处理文件关闭、AOF刷盘、释放内存、3个网络IO线程。</p><h1 id="11-具体场景"><a href="#11-具体场景" class="headerlink" title="11. 具体场景"></a>11. 具体场景</h1><h2 id="1-延迟队列"><a href="#1-延迟队列" class="headerlink" title="1. 延迟队列"></a>1. 延迟队列</h2><p>把当前要做的事情往后推迟一段时间再做，如订单超过一定时间未付款/接单，自动取消。</p><p>有序集合Zset，score存储延迟执行的时间</p><h2 id="2-大key"><a href="#2-大key" class="headerlink" title="2. 大key"></a>2. 大key</h2><p>key对应的value很大，String大于10KB或容器类型元素个数超过5000。</p><p>问题：</p><ul><li>客户端超时延迟。操作大key耗时，阻塞工作线程。</li><li>引发网络阻塞。获取大key产生的网络流量大。</li><li>内存分布不均。有大key的Redis节点占用内存多、QPS大。</li></ul><p>处理：分批次删除；异步删除。</p><h2 id="3-管道"><a href="#3-管道" class="headerlink" title="3. 管道"></a>3. 管道</h2><p><strong>客户端提供</strong>的批处理技术，用于一次处理多个Redis命令。</p><p>把多个命令整合到一起发送给服务端，服务端处理后统一回复客户端。</p><p>解决多个命令执行的网路等待。</p><h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h2><p>SET命令的NX参数实现“key不存在才插入”。</p><ul><li>如果key不存在，显示插入成功，即为加锁成功。</li><li>如果key存在，显示插入失败，即为加锁失败。</li></ul><p>再加上EX/PX参数设置过期时间，每个客户端设置唯一值，区分上锁的客户端。</p><p>解锁时判断解锁的客户端是否与上锁的客户端为同一个。因为有判断与解锁两个操作，需要Lua脚本保证解锁的原子性。</p><p>优点：</p><ul><li>性能高效</li><li>实现方便</li><li>避免单点故障。Redis跨集群部署</li></ul><p>缺点：</p><ul><li>超时时间不好设置。可以基于续约的方式设置，启动守护线程，在锁快过期时续约加锁。</li><li>主从复制的数据是异步复制，导致分布式锁不可靠。主节点获取到锁但没同步时宕机，新的主节点仍能获取锁。</li></ul><p>Redis Redlock算法：客户端和多个独立的Redis节点依次请求加锁，如果客户端和半数以上的节点成功加锁，则认为客户端获得锁。</p><p>过程：</p><ul><li>客户端获取时间t1。</li><li>客户端按顺序依次向N个Redis节点执行加锁操作：<ul><li>使用SET，带上NX、EX/PX与客户端唯一标识。</li><li>为了保证Redis节点故障时算法运行，给加锁操作设置过期时间，远小于锁的过期时间。</li></ul></li><li>一旦客户端从超过半数节点上获取到锁，再次获取时间t2，计算消耗的时间，如果小于锁的过期时间，认为加锁成功。</li></ul><p>加锁成功需要满足：</p><ul><li>客户端从超过半数节点获取到锁。</li><li>获取锁的时间消耗小于锁的过期时间。</li></ul><p>加锁成功后，锁的过期时间减去消耗时间即为有效时间。如果有效时间来不及完成共享数据，可以先释放锁。</p><p>释放锁：客户端向所有节点发起释放锁的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目学习-TinyWebServer</title>
      <link href="/2023/01/30/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-TinyWebServer/"/>
      <url>/2023/01/30/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-TinyWebServer/</url>
      
        <content type="html"><![CDATA[<h1 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h1><p>用户使用Web浏览器与服务器进行通信。键入域名后，浏览器首先通过缓存或DNS查询将域名解析成IP地址，然后向对应IP地址的服务器发送一个请求。</p><p>服务器端，首先监听来自客户端的连接。之后，服务器调用accept取出一个已完成的连接，根据HTTP报文请求的内容，构造一个响应报文，发回用户端。用户端的浏览器解析HTTP报文并渲染后，显示在浏览器上。</p><p>主要由主线程、工作线程和文件系统三部分构成，相邻两个部分通过队列连接。</p><ul><li>主线程：监听事件，处理客户端连接，读写网络数据。</li><li>工作线程：处理业务逻辑的线程。</li><li>文件系统：跳表、日志。</li></ul><h1 id="2-I-O模型"><a href="#2-I-O模型" class="headerlink" title="2. I/O模型"></a>2. I/O模型</h1><p>以读数据为例，I/O分为两个部分：</p><ul><li>数据准备：内核通过设备控制器通知设备准备数据。设备控制器将数据从磁盘拷贝到内核空间。</li><li>内核将数据从内核空间拷贝到用户空间。</li></ul><p>同步与异步</p><p><strong>区别</strong>：内核通知用户的是IO就绪事件还是IO完成事件；由谁负责IO读写。</p><p><strong>区分方式</strong>：用户是否等待I/O过程。</p><ul><li>同步IO<ul><li>阻塞I/O：调用方法后等待两个部分。</li><li>非阻塞I/O：如果数据尚未准备完成，就做其他事，直到某次检测到数据准备完成，然后等待第二部分。</li><li>信号驱动I/O：由信号通知第一部分完成，然后等待第二部分。</li><li>I/O复用：用一个线程检测多个I/O函数，直到有数据可读就等待第二部分。</li></ul></li><li>异步I/O：都不等待，内核拷贝到用户空间后通知用户。</li></ul><h1 id="3-事件处理模式"><a href="#3-事件处理模式" class="headerlink" title="3. 事件处理模式"></a>3. 事件处理模式</h1><p>同步与异步：</p><ul><li>IO模型中：<ul><li>同步：内核通知的是IO就绪事件；由应用程序负责完成IO读写。</li><li>异步：内核通知的是IO完成事件；由内核负责完成IO读写。</li></ul></li><li>并发模型中：<ul><li>同步：程序完全按照代码顺序执行。</li><li>异步：程序的执行需要系统事件的驱动，如中断、信号等。</li></ul></li></ul><h2 id="1-reactor与proactor模型"><a href="#1-reactor与proactor模型" class="headerlink" title="1. reactor与proactor模型"></a>1. reactor与proactor模型</h2><p>reactor：主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，如果有则通知工作线程（逻辑单元）。工作线程负责读写数据、接受新连接、业务处理。通常由同步I/O实现。</p><p>proactor：主线程和内核负责读写数据、处理新连接等I/O操作，工作线程只负责业务处理。通常由异步I/O实现。</p><p>半同步半异步I/O（就是IO多路复用）：主线程为异步线程，负责监听与读写；工作线程为同步线程，负责处理业务。</p><ul><li>主线程在epoll注册读就绪事件。</li><li>主线程等待数据可读。</li><li>当有数据可读时，主线程从socket循环读取数据直到没有数据可读，然后将数据封装成请求对象并插入请求队列，并通过条件变量唤醒沉睡的工作线程。</li><li>睡眠在条件变量上的一个工作请求被唤醒，从队列中取出一个请求，处理请求并生成响应，然后注册写就绪事件，继续在条件变量上沉睡。</li><li>主线程等待数据可写。</li><li>当有数据可写时，主线程往socket写入处理结果，写完后继续注册读事件。</li></ul><p>优点？IO多路复用（单reactor多线程）相较于阻塞IO（单reactor单线程）的优点</p><ul><li>阻塞IO在等待IO完毕时不能干其他事，如监听事件、业务处理，效率低。</li></ul><p>缺点：</p><ul><li>请求队列需要加锁访问，浪费CPU时间。</li><li>每个工作线程同一时间只能处理一个客户端请求。如果工作线程较少，容易造成任务堆积，响应速度越来越慢；如果工作线程角度，切换会浪费大量CPU时间。</li></ul><h2 id="2-select-poll与epoll"><a href="#2-select-poll与epoll" class="headerlink" title="2. select/poll与epoll"></a>2. select/poll与epoll</h2><p>阻塞IO/BIO的原理</p><ul><li>网卡接收到数据，通过DMA方式写入内核（RingBuffer和sk_buff）。</li><li>网卡发出中断请求，告诉内核新的数据。</li><li>内核响应中断，系统切换为内核态，通过中断处理程序，从RingBuffer中拿出一个包并处理协议栈，填充socket。<ul><li>每一个socket都与用户进程、端口号绑定，根据数据到来的端口判断交给哪个socket。</li></ul></li><li>从socket中取得挂起在这上面的用户进程的ID，将其修改为可运行状态。</li><li>内核代码执行完毕，控制权交还给用户态，通过调度，最终调度到该用户进程。</li><li>用户进程处理数据。</li></ul><p>缺陷：频繁收到数据包，导致频繁发出中断请求，造成大量上下文切换，也可能使用户长时间无法获得数据。</p><p>多路复用的优化：用一个专门线程批量处理用户态数据。所有待监听socket统一保存执行select/poll/epoll函数的进程ID，任一socekt接收数据都会唤醒监视进程。</p><p>select/poll/epoll优缺点：</p><ol><li>调用：epoll在<strong>内核</strong>用<strong>红黑树</strong>维护监听文件描述符集合，每次添加文件描述符时系统调用；select/poll每次调用时将要监听的描述符集合拷贝入内核，select使用线性表，poll使用链表。</li><li>事件触发：epoll有事件触发时，通过回调函数通知epoll文件描述符，内核将就绪的文件描述符放入就绪队列中，等待epoll_wait调用，返回就绪队列；select/poll通过遍历检查是否有事件发生，如果有则将整个文件描述符集合拷贝回用户空间，用户仍需遍历一遍判断活动的文件描述符。</li><li>模式：select/poll只能工作在LT模式，epoll支持LT与ET。</li></ol><p>适用：文件描述符数量少、且都很活跃时，epoll每次添加文件描述符都要系统调用，且系统调用开销大，所以用select/poll；不满足这些条件时，则用epoll。</p><p>EPOLLONESHOT事件：该事件的文件描述符上的注册事件只触发一次，要想重新注册事件需要调用epoll_ctl重置文件描述符上的事件。防止socket上一个数据没处理完时又有新数据到达触发事件，被另一个线程获得处理，产生多个线程操作同一socket。</p><h2 id="3-触发方式"><a href="#3-触发方式" class="headerlink" title="3. 触发方式"></a>3. 触发方式</h2><p>LT：水平触发：有可读事件发生时，服务端不断从epoll_wait中苏醒，直到缓冲区数据被读取完。类似于select/poll的遍历。</p><p>ET：边缘触发：有可读事件发生时，服务端只从epoll_wait苏醒一次，即使没有读取数据。下次苏醒需要等到下次有可读事件发生。</p><p>使用ET时必须保证该文件描述符非阻塞（因为是主线程负责读数据，如果设置为阻塞会导致主线程读完阻塞，无法处理其他事件），且每次I/O都必须等到读写完。</p><p>ET可减少epoll_wait的系统调用次数，因此效率一般较高。</p><h2 id="4-具体实现"><a href="#4-具体实现" class="headerlink" title="4. 具体实现"></a>4. 具体实现</h2><ul><li>主循环开始前先通过epoll_ctl注册listenfd的读事件</li><li>主循环中，就绪事件为listenfd读事件，表示accept可以取出已经建立的连接，accept返回一个新的socket文件描述符fd用于通信。</li><li>fd读事件注册到epoll中，等待用户通信。</li><li>主循环中，就绪事件为fd读事件，主线程读出HTTP请求报文，放入fd的封装结构http_conn的读缓冲区中，并将该封装结构放入线程池的请求队列。</li><li>放入请求队列时，通过信号量唤醒线程池中的线程，线程竞争获得锁，并从请求队列中取出连接处理业务。</li><li>处理完毕后将响应报文写入fd对应的http_conn写缓冲区中，fd注册写事件。</li><li>主循环中，就绪事件为fd写事件，主线程读出HTTP响应报文，通过writev发送给客户端。</li></ul><h2 id="5-改进"><a href="#5-改进" class="headerlink" title="5. 改进"></a>5. 改进</h2><ul><li>多reactor多线程模式：<strong>每个线程一个循环</strong>的思想<ul><li>主reactor只监听连接建立事件，并轮询子reactor，分发连接。</li><li>每个线程作为一个子reactor，接收传入的连接，并继续监听其上的读写事件。</li><li>子线程在循环中监听到读写事件，直接在循环里处理。</li><li>子线程从连接对象的套接字中读出数据，解析、生成响应报文并发送。</li></ul></li><li>主reactor与子reactor传递连接的方式。（为了避免主reactor传递连接时子reactor正在epoll_wait阻塞）<ul><li>主reactor为每个子reactor创建一个管道。</li><li>主reactor通过轮询，将连接fd写入子reactor对应的管道。</li><li>子reactor在建立时将管道fd读事件加入epoll监听。</li><li>子reactor接到事件后判断fd是否为管道fd，是则读出管道里的连接fd，为其注册读事件。</li></ul></li><li>优点：<ul><li>逻辑简单：每个线程用一个epoll循环实现，且主线程与子线程耦合度低。</li><li>效率高：<ul><li>主线程与子线程之前通过管道通信，不必像队列那样加锁。</li><li>IO由子线程分摊进行，提高CPU利用率。</li></ul></li></ul></li></ul><h1 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h1><p>本质思想：用空间（对象指针数组）换时间（创建与销毁对象的额外开销）。</p><p>事先创建并初始化好的线程数组。thread绑定函数后，通过detach将线程设置为脱离态，线程运行结束时资源会被自动回收。</p><p>线程数目设置：对于CPU密集型任务，线程数可以设置为CPU核数；对于IO密集型任务，线程数一般大于CPU核数，因为IO处理一般较慢，较多的线程数能为CPU争取更多的任务，不至于所有线程都在等待IO。</p><p>使用线程池的原因：</p><ul><li>创建与销毁新线程需要为其分配并初始化资源，会带来额外开销。</li><li>需要限制同时运行的线程数。</li></ul><h1 id="5-HTTP报文处理"><a href="#5-HTTP报文处理" class="headerlink" title="5. HTTP报文处理"></a>5. HTTP报文处理</h1><h2 id="1-大致流程"><a href="#1-大致流程" class="headerlink" title="1. 大致流程"></a>1. 大致流程</h2><ul><li>浏览器发出http连接请求，主线程创建http对象接收请求，将数据读入buffer，之后将对象插入任务队列，工作线程取出一个任务处理。</li><li>工作线程调用process_read函数，处理报文。通过状态机逐行解析报文。</li><li>解析完报文后调用do_request函数生成响应报文，process_write写入buffer返回给浏览器。</li></ul><h2 id="2-状态"><a href="#2-状态" class="headerlink" title="2. 状态"></a>2. 状态</h2><p>read主状态机：标识解析位置</p><ul><li>CHECK_STATE_REQUESTLINE，解析请求行，用parse_request_line函数解析。</li><li>CHECK_STATE_HEADER，解析请求头，用parse_headers解析。</li><li>CHECK_STATE_CONTENT，解析消息体（只有POST请求有），用parse_content解析。</li></ul><p>read从状态机：标识解析一行的状态</p><ul><li>LINE_OK，完整读取一行。</li><li>LINE_BAD，报文语法有误。</li><li>LINE_OPEN，读取的行不完整。</li></ul><p>报文解析状态：</p><ul><li>NO_REQUEST，请求不完整，需要继续读取</li><li>GET_REQUEST，获得完整请求。</li><li>BAD_REQUEST，语法错误。</li><li>INTERNAL_ERROR，服务器内部错误。</li></ul><h2 id="3-解析过程"><a href="#3-解析过程" class="headerlink" title="3. 解析过程"></a>3. 解析过程</h2><p>http报文每一行的数据由\r\n结束，可以通过查找这个将报文拆成单独的行解析，并在查找到后，用一个指针指向\r\n后面的第一个字符，然后将\r\n置为\0\0。这样就能用上次的指针直接获得本行数据（字符串以\0结束）。</p><p>解析GET时，每一行都是\r\n结束，因此判断从状态机LINE_OK即可跳出解析循环。</p><p>解析POST时，根据请求头得到的消息体长度直接读取对应大小的数据。消息体末尾没有\r\n结束字符，因此从状态机是LINE_OPEN状态，此时还需要判断主状态机是否为CHECK_STATE_CONTENT，如果是则标识消息体解析完毕，退出循环。</p><p>对于本项目来说，POST中的数据只有用户名和密码，用于进行登录校验。</p><p>如果是图片和视频页面，浏览器解析html发现还有文件时会再次请求，因为action不属于任意一种情况，所以会直接将本地文件目录与请求的资源名相拼接，从而获取对应的图片和视频。</p><p>html文件用html格式传输，图片、视频用二进制格式传输。</p><h2 id="4-解决读报文的粘包问题"><a href="#4-解决读报文的粘包问题" class="headerlink" title="4. 解决读报文的粘包问题"></a>4. 解决读报文的粘包问题</h2><p>请求行和请求头可以直接根据格式是否匹配读取。</p><p>应用层HTTP头部带有content-length字段，可以指示消息体大小。</p><h1 id="6-用户校验"><a href="#6-用户校验" class="headerlink" title="6. 用户校验"></a>6. 用户校验</h1><p>POST请求报文在包体中携带用户名密码。</p><ul><li>对登录操作，只需要判断跳表中有没有键值对即可。</li><li>对注册操作，先插入跳表中，然后判断跳表中有没有键值对。</li><li>跳表用RAII思想实现，构造时自动导入本地dumpfile文件，析构时自动导出到本地dumpfile文件。</li></ul><h1 id="7-优化：非活动连接处理"><a href="#7-优化：非活动连接处理" class="headerlink" title="7. 优化：非活动连接处理"></a>7. 优化：非活动连接处理</h1><p>使用SIGALRM信号实现定时器，周期触发SIGALRM信号。主循环接到信号后对升序链表上所有定时器处理，如果该段时间内没有交换数据则关闭连接，释放资源。</p><p>本项目信号处理函数只发送信号通知程序主循环，对应处理逻辑放在主循环中。（为了不让信号屏蔽太久）</p><p>每次触发信号，遍历定时器升序链表，判断当前时间与定时器超时时间，直到遇到第一个超时的定时器，然后执行回调函数并删除，并继续便利。</p><p>使用定时器：</p><ul><li>连接时创建连接对应的定时器，添加到链表上。</li><li>关闭连接时移除定时器。</li><li>处理定时信号时，定时标志设置为true。</li><li>处理读写事件时，如果该连接有事件则后移定时器，否则执行定时事件。</li></ul><p>接收信号：</p><ul><li>内核放到对应进程的信号队列中，向进程发送一个中断使其陷入内核态。</li></ul><p>检测信号：</p><ul><li>进程从内核态返回用户态前。</li><li>进程在内核态中从睡眠状态被唤醒。</li></ul><p>处理信号：</p><ul><li>内核将内核栈内容拷贝到用户栈，修改指令寄存器指向信号处理函数。</li><li>进程返回用户态执行信号处理函数。</li><li>执行完后返回内核态检查是否有其他信号未处理。</li><li>如果没有未处理的信号，就将内核栈回复（从用户栈备份拷贝回来），恢复指令寄存器，最后回到用户态继续执行进程。</li></ul><h1 id="8-单例模式"><a href="#8-单例模式" class="headerlink" title="8. 单例模式"></a>8. 单例模式</h1><h2 id="1-懒汉模式"><a href="#1-懒汉模式" class="headerlink" title="1. 懒汉模式"></a>1. 懒汉模式</h2><p>第一次被使用时才初始化，初始化方法放在获得实例的方法中。即如果获得的实例指针为空，则初始化，然后返回实例指针。</p><p>线程不安全，因为可能有多个线程同时读取实例指针为空，然后同时修改指针。</p><p>实现：</p><p>函数内的局部静态对象实现线程安全懒汉模式。（C++11后要求编译器保证内部静态变量的线程安全性）</p><p>双检测锁实现线程安全懒汉模式：判断指针为空后先上锁，再判断指针是否为空，如果为空则创建。</p><h2 id="2-饿汉模式"><a href="#2-饿汉模式" class="headerlink" title="2. 饿汉模式"></a>2. 饿汉模式</h2><p>程序运行时立马初始化。</p><p>一定是线程安全的。</p><h1 id="9-日志"><a href="#9-日志" class="headerlink" title="9. 日志"></a>9. 日志</h1><p>同步日志：日志写入与工作线程串行执行。调用write_log时立即加锁写。</p><p>异步日志：所写的日志内容存入阻塞队列，写线程从队列中读取并写入。调用write_log时，只将要写的内容放入队列中。</p><p>单例模式：一个类只有一个实例，同时提供全局访问方法。</p><h2 id="1-条件变量"><a href="#1-条件变量" class="headerlink" title="1. 条件变量"></a>1. 条件变量</h2><p>实现生产者消费者队列。</p><p><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)</code>：</p><ol><li>等待条件变量满足</li><li>释放获得的锁（1、2一起是一个原子操作，所以如果调用的时候满足条件，就不需要释放锁）</li><li>阻塞</li><li>被唤醒时解除阻塞，尝试获取锁</li></ol><p><strong>感觉.。。。不如c++11 condition_variable + unique_lock</strong></p><p>一般在调用前先上锁，且在循环里使用，因为多个线程等待锁时，返回的时候并不一定能竞争到锁。</p><p>调用线程放入条件变量的请求队列后再解锁：如果在释放互斥锁前、放入队列之后等待的条件改变了，因为线程不在队列上，会忽略条件满足的信号。</p><h1 id="10-压测-amp-webbench原理"><a href="#10-压测-amp-webbench原理" class="headerlink" title="10. 压测&amp;webbench原理"></a>10. 压测&amp;webbench原理</h1><p>并发量：创建的子进程的总数。QPS：访问成功总次数/访问时间</p><p>大致流程：</p><ul><li>先尝试一次合法连接。</li><li>如果成功就由父进程fork多个子进程。</li><li>每个子进程循环做web访问测试，将访问结果通过管道告知父进程。</li><li>父进程做最终结果统计。</li></ul><p>源码：</p><p>getopt_long：循环读取命令行参数。</p><ul><li>-c：子进程数量</li><li>-t：运行时间</li><li>-p：使用代理服务器并传入代理网络号和端口号</li></ul><p>build_request：构造请求报文</p><p>bench：父进程测试连接，连接成功就先建立管道通信，然后不断fork子进程，子进程调用benchcore请求，并将自己请求成功/失败数目发给父进程，父进程通过管道接收结果，统计计算。</p><p>benchcore：子进程设置超时信号，然后不断进行HTTP请求。</p><p>优点：</p><ol><li>部署简单，适用于小型网站压测（最多模拟3万并发）</li><li>能支持动静态页面测试</li><li>支持对含有SSL的安全网站测试</li></ol><p>缺点：</p><ol><li>不适合中大型网站测试</li><li>并发采用多进程而非多线程，长时间使用大量占用内存与CPU，所以不适合长时间使用</li></ol><h1 id="11-改进"><a href="#11-改进" class="headerlink" title="11. 改进"></a>11. 改进</h1><ul><li>实现文件上传功能</li><li>定时器改成堆<ul><li>过期定时器都是连续的，需要顺序遍历，用堆一个个弹出反而增加了复杂度</li><li>连接出错需要关闭指定的定时器，堆无法做到（可以增加一个删除标记，懒删除）</li></ul></li><li>c++11重构 muduo库网络编程 + c++11多线程</li></ul><h1 id="12-准备"><a href="#12-准备" class="headerlink" title="12. 准备"></a>12. 准备</h1><h2 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1. 基本知识"></a>1. 基本知识</h2><p>简介：主要由主线程、工作线程和文件系统三部分构成，相邻两个部分通过队列通信。</p><ul><li>主线程：通过epoll监听事件，处理客户端连接，读写网络数据，封装数据并通过队列传递给工作线程。</li><li>工作线程：从队列上取数据，解析并生成响应报文，然后通知主线程有写事件。</li><li>文件系统：使用队列实现日志系统、使用跳表存储用户名-密码键值对。</li></ul><p><strong>印象最深的部分</strong>：主循环的<strong>统一事件源</strong>思想：将信号事件当作IO事件一样处理。具体的，将<strong>管道读事件注册到epoll中</strong>，这样能与其他读事件一样被监听到，被主循环统一处理。</p><p>具体操作：</p><ul><li>服务器接收到新连接时，为其创建对应的定时器，包括绑定回调函数等，然后添加到链表上。</li><li>主循环开始前设置一个超时信号。</li><li>信号到来时，回调函数写管道描述符。</li><li>管道描述符出现读事件被epoll监听到，在主循环内跟其他事件同时处理。</li><li>处理异常事件时，关闭连接，在链表上删除对应的定时器。</li><li>处理信号时，将超时标志设置为true，一轮循环结束后再处理。</li><li>处理读写事件时，如果读写成功，重置对应连接的超时时间，否则关闭连接并删除定时器。</li></ul><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><h3 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1. 设计模式"></a>1. 设计模式</h3><p>线程池类有一个私有成员数组，表示线程池中的线程。</p><ul><li>thread数组初始化每个线程并传递成员函数run与参数this指针、detach设置脱离态。</li><li>run中工作线程阻塞在条件变量上，竞争获得锁后从请求队列中取出一个任务处理。</li></ul><h3 id="2-同步机制"><a href="#2-同步机制" class="headerlink" title="2. 同步机制"></a>2. 同步机制</h3><p>信号、信号量、条件变量、互斥锁</p><h3 id="3-工作线程工作过程"><a href="#3-工作线程工作过程" class="headerlink" title="3. 工作线程工作过程"></a>3. 工作线程工作过程</h3><p>队列不为空，通过信号量唤醒等待的工作线程，多个线程竞争任务；工作线程取出一个任务，执行完业务逻辑后，通过信号量继续阻塞自己等待。</p><h3 id="4-客户端数目很多，线程数不多，怎么及时响应"><a href="#4-客户端数目很多，线程数不多，怎么及时响应" class="headerlink" title="4. 客户端数目很多，线程数不多，怎么及时响应"></a>4. 客户端数目很多，线程数不多，怎么及时响应</h3><p>并不是一个线程对应一个客户连接，客户的请求储存在工作队列，线程依次从工作队列中取出进行处理。如果速度很慢，就需要增大线程池容量，或者部署多个服务器等做法。</p><h3 id="5-客户请求占用很久时间"><a href="#5-客户请求占用很久时间" class="headerlink" title="5. 客户请求占用很久时间"></a>5. 客户请求占用很久时间</h3><p>相当于可用线程数减少，会影响到接下来的客户请求与总体响应速度。可以为线程处理任务设置超时时间，如果超时则直接断开连接或重新插入任务。</p><h2 id="3-并发模型"><a href="#3-并发模型" class="headerlink" title="3. 并发模型"></a>3. 并发模型</h2><h3 id="1-并发模型"><a href="#1-并发模型" class="headerlink" title="1. 并发模型"></a>1. 并发模型</h3><p>线程池设计模式为同步IO模拟的Proactor事件处理模式。</p><p>同步线程处理客户逻辑，异步线程处理IO事件。</p><p>主线程为异步线程，负责监听所有socket的实践。如果有新连接到来，接收新连接socket并往epoll内核事件表中注册其读写事件；如果监听的socket发生了读写事件，就先读写数据，然后将连接与对应的数据封装成对象，插入到请求队列。</p><p>工作线程睡眠在请求队列上，有任务到来时通过竞争获得任务。</p><h3 id="2-reactor与proactor"><a href="#2-reactor与proactor" class="headerlink" title="2. reactor与proactor"></a>2. reactor与proactor</h3><p>reactor：</p><p>单reactor单线程：</p><ul><li>reactor监听事件。如果是连接建立事件分发给acceptor，如果是读写事件分发给对应的handler。</li><li>acceptor建立连接，创建一个当前连接的对应的handler对象。</li><li>handler进行read-&gt;业务处理-&gt;send的流程。</li></ul><p>缺点：一个线程无法利用多核CPU；handler处理业务时会阻塞。</p><p>单reactor多线程（类似于同步IO模拟的proactor，但是这个是子线程直接send，而不是发回给handler send）：</p><ul><li>主线程reactor监听事件，如果是连接建立事件分发给acceptor，如果是读写事件分发给对应的handler。</li><li>acceptor建立连接，创建一个当前连接的对应的handler对象。</li><li>handler read，将数据发送给子线程processor；子线程处理完毕后send。</li><li>processor进行业务处理。</li></ul><p>优点：充分利用了多核CPU性能。</p><p>缺点：只有一个reactor监听事件，易成为性能瓶颈。</p><p>多reactor多线程（主从reactor）：</p><ul><li>主线程reactor监听连接事件，分发给acceptor建立连接。</li><li>acceptor建立连接。</li><li>主线程将连接分发给某个子线程reactor。</li><li>子线程reactor分到连接时创建对应连接的handler对象，并监听读写事件。</li><li>子线程reactor监听到读写事件时，调用对应handler处理。</li><li>handler进行read-&gt;业务处理-&gt;send流程。</li></ul><p>优点：</p><ul><li>主线程和子线程分工明确，主线程只监听连接事件，子线程只监听读写事件。</li><li>主线程和子线程交互简单，主线程只要传递新连接，子线程处理完业务后直接发回而不经过主线程。</li></ul><p>reactor与proactor的区别：IO操作在主线程则为proactor、在工作线程为reactor。</p><h3 id="3-epoll-select-poll"><a href="#3-epoll-select-poll" class="headerlink" title="3. epoll/select/poll"></a>3. epoll/select/poll</h3><h2 id="4-HTTP报文解析"><a href="#4-HTTP报文解析" class="headerlink" title="4. HTTP报文解析"></a>4. HTTP报文解析</h2><h3 id="1-状态机"><a href="#1-状态机" class="headerlink" title="1. 状态机"></a>1. 状态机</h3><p>使用状态机主要是为了封装逻辑。因为HTTP报文由很多部分组成，一步步解析的话十分复杂。使用状态机，服务器可以根据不同状态或者消息类型进行相应的逻辑处理，这样可以使得程序清晰易懂，可读性与可理解性强。</p><h3 id="2-安全的HTTPS协议"><a href="#2-安全的HTTPS协议" class="headerlink" title="2. 安全的HTTPS协议"></a>2. 安全的HTTPS协议</h3><p>连接阶段使用了TLS四次握手，能验证对方的身份并交换密钥；</p><p>数据交互阶段使用交换的密钥进行交互，能防止篡改与窃听。</p><h3 id="3-SSL连接过程"><a href="#3-SSL连接过程" class="headerlink" title="3. SSL连接过程"></a>3. SSL连接过程</h3><p>以RSA握手算法为例。</p><ul><li><p>第一次握手：客户端发送随机数r1、TLS版本号、支持的密码套件（密钥交换算法+签名算法+对称加密+摘要算法）。</p></li><li><p>第二次握手：服务端验证TLS版本号是否支持。发送：</p><ul><li>随机数r2。</li><li>服务端选择的密码套件（RSA）。</li><li>服务端的数字证书。</li></ul></li><li><p>第三次握手：客户端根据证书验证服务端身份。生成随机数r3，根据r1r2r3生成会话密钥。发送：</p><ul><li>随机数r3。</li><li>会话改变通知，表明随后的通信都改用会话密钥加密。</li><li>握手完成通知，表明客户端的握手已结束。同时客户端对握手过程中发送的报文做一个摘要一并发送，供对方校验。</li></ul></li><li><p>第四次握手：服务端获得r3，生成会话密钥。发送：</p><ul><li>会话改变通知，表明随后的通信都改用会话密钥加密。</li><li>握手完成通知，表明服务端的握手已结束。同时服务端对握手过程中发送的报文做一个摘要一并发送，供对方校验。</li></ul></li></ul><h3 id="4-GET与POST"><a href="#4-GET与POST" class="headerlink" title="4. GET与POST"></a>4. GET与POST</h3><p>get也可以有body，而post也可以将申请的资源放在url中。</p><p>本质区别：浏览器与服务器对两种消息的处理不同。</p><ul><li>浏览器与服务器会对url大小作出限制。</li><li>如果在GET中用body添加数据，有些服务器会读出数据，而有些服务器会忽略。</li></ul><p>一次包&amp;两次包：</p><ul><li>有些浏览器发送POST，不一定会分header与body发两次包。</li><li>网络环境好时一次包与两次包时间差别不大，但是两次包在TCP验证完整性上有很大优势。</li></ul><h3 id="5-HTTP1-1"><a href="#5-HTTP1-1" class="headerlink" title="5. HTTP1.1"></a>5. HTTP1.1</h3><p>与1.0的区别：挑比较重要的说</p><ul><li>长连接改善了短连接造成的性能开销（HTTP1.0每次发送请求都要建立一次TCP连接）。Connection：Keep-Alive。</li><li>多了Host域，存放url。因为HTTP1.1时代一个物理主机上已经可以存在多个虚拟主机，且共享一个IP地址，要通过域名区分。</li><li>多了range域，支持只请求资源的某个部分。Content-Range中声明返回对象的偏移值和长度。服务器返回了该范围则返回206，防止Cache将响应误认为是完整对象。</li></ul><p>关闭TCP连接：</p><ul><li>退出主循环</li><li>写失败</li><li>超时信号</li></ul><h2 id="5-用户名密码存储"><a href="#5-用户名密码存储" class="headerlink" title="5. 用户名密码存储"></a>5. 用户名密码存储</h2><h3 id="1-登录"><a href="#1-登录" class="headerlink" title="1. 登录"></a>1. 登录</h3><ul><li>构造跳表时，加载本地dumpfile文件的用户名-密码对。</li><li>注册与登录时携带了用户名密码作为数据，使用POST报文，并将用户名密码放在包体中。</li><li>浏览器端解析出POST报文与其内容，根据url末尾的action字段判断登录还是注册。</li><li>注册时插入跳表。</li><li>登录直接查跳表。</li><li>程序结束时，跳表析构函数中调用方法存储dumpfile文件。</li></ul><h3 id="2-页面跳转"><a href="#2-页面跳转" class="headerlink" title="2. 页面跳转"></a>2. 页面跳转</h3><p>请求报文请求行的url中，最后一个/后面的信息代表想要跳转的页面。这个属性通过html页面按钮的action属性设置，点击按钮就能请求对应action的页面，将action附带在url尾部。</p><p>解析报文时，将url尾部的action属性截取下来，然后根据之前在html中设置的进行分类。</p><p><strong>传输文本使用text/html格式，传输图片和视频使用二进制格式。</strong></p><h3 id="3-状态保存"><a href="#3-状态保存" class="headerlink" title="3. 状态保存"></a>3. 状态保存</h3><p>可以利用session或cookie保存。</p><p>cookie是服务端发给用户端，用户端保存的身份标识。服务端在TCP第二次握手时发给用户端，用户端保存好cookie，后续发送数据时附带cookie，服务端通过解析cookie辨认用户端。</p><p>session是服务端保存的状态。每当客户发送http报文过来，服务端在记录的用户数据中查找，核实用户身份。</p><h3 id="4-大量用户数据"><a href="#4-大量用户数据" class="headerlink" title="4. 大量用户数据"></a>4. 大量用户数据</h3><p>通过多级哈希对用户信息进行分组。每当有用户信息到来时，先进行多级哈希，判断所在的组是否加载到内存中，如果加载了则直接验证，否则只需要加载对应组的数据。</p><h2 id="6-定时器"><a href="#6-定时器" class="headerlink" title="6. 定时器"></a>6. 定时器</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><p>处理非活跃连接，释放资源。</p><h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><p>每个连接分配一个定时器，然后将定时器挂在升序链表上。</p><p>通过alarm函数周期性触发SIGALARM信号，信号回调函数通过管道通知主循环。Linux中进程收到信号时，操作系统中断当前流程，转入信号处理函数执行，完成后再返回中断的地方继续执行。一般信号处理函数需要屏蔽其他信号，为了避免信号屏蔽时间过长，信号处理函数只负责通过管道通知主循环，在主循环中进行实际的信号处理。</p><ul><li>信号处理函数：通过具名管道给主线程发信号。（主线程通过epoll_wait可获知具名管道描述符上的读事件）</li></ul><p>主循环接到管道通信后对升序链表上的定时器进行处理，对比过期时间与当前时间，然后关闭超时的连接。</p><p>信号处理程序的跳转和结束都由内核操作，所以信号处理的整个过程有<strong>两次</strong>从用户态变到内核态。</p><p><strong>统一事件源</strong>思想：将信号事件与其他事件一样处理。具体的，将<strong>管道读事件注册到epoll中</strong>，这样能与其他读事件一样被监听到，被主循环统一处理。</p><p>具体操作：</p><ul><li>服务器接收到新连接时，为其创建对应的定时器，包括绑定回调函数等，然后添加到链表上。</li><li>主循环开始前设置一个超时信号。</li><li>信号到来时，管道描述符出现读事件被epoll监听到，按照统一事件源思想，在主循环内跟其他事件同时处理。</li><li>处理异常事件时，关闭连接，在链表上删除对应的定时器。</li><li>处理信号时，将超时标志设置为true，一轮循环结束后再处理。</li><li>处理读写事件时，如果读写成功，重置对应连接的超时时间，否则关闭连接并删除定时器。</li></ul><h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3. 优化"></a>3. 优化</h3><p>添加ON复杂度，删除O1复杂度。最小堆、调表。最小堆增删都是OLogN，以超时时间建立最小堆，每次判断堆顶是否超时，如果超时则删除堆顶继续判断。</p><h2 id="7-日志"><a href="#7-日志" class="headerlink" title="7. 日志"></a>7. 日志</h2><p>由单独的线程写。</p><h3 id="1-运行机制"><a href="#1-运行机制" class="headerlink" title="1. 运行机制"></a>1. 运行机制</h3><ul><li>程序开始运行时利用单例模式初始化日志，根据参数队列长度是否小于等于0，确认同步或异步写入。</li><li>异步写入的话，创建一个线程绑定写日志函数，该函数不断从阻塞队列中取。</li><li>产生动作的线程自己负责构造日志，记录服务器的状态，并放入消费队列。写线程只负责写。</li></ul><h3 id="2-异步与同步"><a href="#2-异步与同步" class="headerlink" title="2. 异步与同步"></a>2. 异步与同步</h3><p>同步方式：写日志的方法与工作线程串行执行。因为涉及IO操作，单条日志较大时会阻塞工作线程，导致服务器并发能力下降。</p><p>异步方式：将要写的日志放入阻塞队列，队列不为空时唤醒写线程。使用生产者-消费者模型提升并发能力。</p><h3 id="3-将日志分发到不同机器上"><a href="#3-将日志分发到不同机器上" class="headerlink" title="3. 将日志分发到不同机器上"></a>3. 将日志分发到不同机器上</h3><p>使用消息队列进行分发。Kafka？</p><h2 id="8-压测"><a href="#8-压测" class="headerlink" title="8. 压测"></a>8. 压测</h2><p>使用webbench进行测试，满足上万并发量。1w+QPS。</p><p>并发量：创建的子进程的总数。</p><h3 id="1-webbench原理"><a href="#1-webbench原理" class="headerlink" title="1. webbench原理"></a>1. webbench原理</h3><p>webbench是一款轻量级的用于对中小型网站进行压力测试的工具，可以实现高达数万的并发测试。</p><p>主要原理：</p><ul><li>先尝试连接一次服务器看能否连接上。</li><li>如果可以，父进程中fork若干个子进程。</li><li>子进程在一定时限内对目标服务器发出访问请求，之后通过管道将访问成功、失败数量等信息发送给父进程。</li><li>父进程统计这些数据并计算，最后显示出来。</li></ul><p>优点：工具小，部署简单。</p><p>缺点：只支持上万并发，不适合对中大型网站测试；使用多进程模型，运行时间长可能导致CPU、内存消耗过大，不适合长时间测试。</p><h2 id="9-优化"><a href="#9-优化" class="headerlink" title="9. 优化"></a>9. 优化</h2><ul><li>C++11面向对象式实现（muduo网络编程库+thread系列头文件）</li><li>非关系数据库替代MySQL（已实现跳表）</li><li>添加cookie或session</li><li>文件上传功能</li></ul><h2 id="10-印象深刻的问题"><a href="#10-印象深刻的问题" class="headerlink" title="10. 印象深刻的问题"></a>10. 印象深刻的问题</h2><p>处理超时事件和处理I/O事件的顺序</p><ul><li>由于超时事件会断开连接，因此如果先处理超时事件，有可能断开了即将要在I/O事件处理函数中处理的连接，因此需要先处理I/O事件再处理超时事件</li></ul><p>定位</p><ul><li>浏览器接收不到回应，但是日志里记录正常生成了响应报文，且日志里没有记录发送报文，确认可能是写报文出现了问题。</li><li>已经处理了缓冲区已满导致的写失败，因此写失败可能是套接字出现的问题，如连接已断开。</li><li>连接已断开可能的原因：<ul><li>读失败：已经生成了响应报文，不可能。</li><li>写失败：在断开前就已经写失败了。</li><li>定时器超时。</li></ul></li><li>定位到定时器超时原因，在循环中，epoll_wait后先处理IO事件再处理超时事件。（将超时事件设置一个标记位，循环后如果标记位为true，统一处理）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-分布式系统</title>
      <link href="/2023/01/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/01/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-CAP定理"><a href="#1-CAP定理" class="headerlink" title="1. CAP定理"></a>1. CAP定理</h2><p>对于一个分布式系统，以下三点不能同时很好的满足。</p><ul><li>一致性Consistency：所有节点在同一物理时间具有相同数据。每次请求要么获得最新的数据，要么失败。强调<strong>数据正确</strong>。</li><li>可用性Availability：保证每个请求不管成功或失败都有响应。（不保证是最新数据）强调<strong>不出错</strong>。</li><li>分区容错性Partition tolerance：任意节点故障时系统仍可以对外服务。强调<strong>不挂</strong>。</li></ul><p>排列组合可得：</p><ul><li>CA：单点集群，可扩展性不强。</li><li>CP：性能不高，因为需要一段时间同步，这段时间没法回复请求。</li><li>AP：对一致性要求较低。有些节点可能请求到较旧的数据。</li></ul><p>BASE：NoSQL数据库对可用性及一致性的弱要求原则：</p><ul><li>基本可用Basically Available</li><li>软状态/柔性事务Soft-state：无连接</li><li>最终一致性Eventually Consistency：ACID的最终目的</li></ul><h3 id="1-数据一致性"><a href="#1-数据一致性" class="headerlink" title="1. 数据一致性"></a>1. 数据一致性</h3><p>由于代价过高，一般用弱一致性提高性能</p><ul><li>强一致性：无论更新在哪一个副本执行，之后所有读操作都要获得最新数据。</li><li>弱一致性：读到最新数据需要一段时间，称为不一致性窗口。</li><li>最终一致性：弱一致性的特例，保证最终（尽量长）能读到更新。</li></ul><p>解决方案</p><ul><li>分布式事务：两段提交</li><li>分布式锁</li><li>消息队列、消息持久化、重试、幂等操作</li><li>Raft等一致性算法</li></ul><h3 id="2-服务可用性"><a href="#2-服务可用性" class="headerlink" title="2. 服务可用性"></a>2. 服务可用性</h3><p>只要收到用户的请求，服务器就必须给出相应。</p><p>解决方案：</p><ul><li>负载均衡</li><li>降级：根据业务情况及流量对一些服务和页面有策略的降级，以释放服务器资源、保证核心用户正常运行。</li><li>熔断：对于大量超时或失败时应熔断该服务所有调用，直到服务好转。</li><li>流量控制</li><li>异地多活：不同地区维护不同子系统。</li></ul><h3 id="3-分区容错性"><a href="#3-分区容错性" class="headerlink" title="3. 分区容错性"></a>3. 分区容错性</h3><p>对于分布式系统而言，分区容错性是前提，必须保证。因而数据同步的时延势必导致C和A不能同时满足。</p><h2 id="2-数据一致性"><a href="#2-数据一致性" class="headerlink" title="2. 数据一致性"></a>2. 数据一致性</h2><p>另：事务一致性指的就是ACID</p><h3 id="1-基本要求"><a href="#1-基本要求" class="headerlink" title="1. 基本要求"></a>1. 基本要求</h3><ol><li>可终止性：一致的结果在有限时间内能完成。</li><li>共识性：不同节点最终完成决策的结果应该相同。</li><li>合法性：决策的结果必须是其他进程提出的提案。</li></ol><h3 id="2-强一致性"><a href="#2-强一致性" class="headerlink" title="2. 强一致性"></a>2. 强一致性</h3><p>系统中某个数据被更新后，后续的任何读取都应该读到更新后的值。</p><p>约束强度：线性 &gt; 顺序 &gt; 因果</p><h4 id="1-线性一致性"><a href="#1-线性一致性" class="headerlink" title="1. 线性一致性"></a>1. 线性一致性</h4><p>原子一致性、严格一致性。</p><p>比顺序一致性多的条件：如果不同进程的事件不是并发时间，那么重排后的顺序与时钟顺序一致。</p><h4 id="2-顺序一致性"><a href="#2-顺序一致性" class="headerlink" title="2. 顺序一致性"></a>2. 顺序一致性</h4><p>条件：</p><ol><li>同一进程内的事件先后顺序不能改变。</li><li>对同一变量的读写，每次读到的都是最近写入的数据。（不允许先读出新值再读出旧值）</li></ol><p>对不同进程的事件之间的顺序没有要求，即使它们在时钟上有早晚。</p><h4 id="3-因果一致性"><a href="#3-因果一致性" class="headerlink" title="3. 因果一致性"></a>3. 因果一致性</h4><p>条件：</p><ol><li>满足因果关系的事件必须按因果关系先后出现。（比如：评论与回复）</li><li>同一进程内的事件先后顺序不能改变。</li></ol><h3 id="3-带约束的一致性"><a href="#3-带约束的一致性" class="headerlink" title="3. 带约束的一致性"></a>3. 带约束的一致性</h3><p>强一致性系统较难实现，适当放宽成为弱一致性，即在某个时刻系统达到一致。</p><p>最终一致性/乐观复制：保证能达到一致性，但不能保证达到的时间（窗口时间）。</p><h3 id="4-一致性与共识性"><a href="#4-一致性与共识性" class="headerlink" title="4. 一致性与共识性"></a>4. 一致性与共识性</h3><p>一致性描述系统一组进程在某个时刻的<strong>状态</strong>，是系统<strong>静态</strong>状态；共识描述一组进程间协作的<strong>动态过程，目的是在相关进程间确定下一个操作。</strong></p><h1 id="2-高并发系统设计"><a href="#2-高并发系统设计" class="headerlink" title="2. 高并发系统设计"></a>2. 高并发系统设计</h1><h2 id="1-拆分子系统"><a href="#1-拆分子系统" class="headerlink" title="1. 拆分子系统"></a>1. 拆分子系统</h2><h2 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2. 缓存"></a>2. 缓存</h2><p>利用大部分高并发读多写少的特点。</p><h2 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h2><p>利用异步写的消息队列。</p><h2 id="4-分库分表"><a href="#4-分库分表" class="headerlink" title="4. 分库分表"></a>4. 分库分表</h2><h2 id="5-读写分离"><a href="#5-读写分离" class="headerlink" title="5. 读写分离"></a>5. 读写分离</h2><p>主从架构，主表写从表读。</p><h2 id="6-高并发服务器方案"><a href="#6-高并发服务器方案" class="headerlink" title="6. 高并发服务器方案"></a>6. 高并发服务器方案</h2><ul><li>应用程序与静态资源分离，将静态资源（图片、视频、js、css等）单独保存到专门的静态资源服务器</li><li>客户端缓存</li><li>反向代理与负载均衡：请求先经过反向代理服务器，它可以直接返回结果，也可以根据后端服务器的负载，将请求交给其中一台处理。感觉前三点Nginx都能做到。</li><li>集群和分布式。集群指所有服务器都有相同的功能，起分流作用；分布式将不同的业务放到不同服务器中，请求一个业务可能需要使用多台服务器，加快处理速度。它们的作用都是将原属于一台服务器的压力分散到多台，同时加快请求速度</li></ul><h1 id="3-分布式缓存"><a href="#3-分布式缓存" class="headerlink" title="3. 分布式缓存"></a>3. 分布式缓存</h1><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><ul><li>页面缓存：缓存HTML、CSS和图片等Web页面内容。</li><li>并行处理：中间计算结果需要共享。</li></ul><h2 id="2-缓存雪崩-击穿"><a href="#2-缓存雪崩-击穿" class="headerlink" title="2. 缓存雪崩/击穿"></a>2. 缓存雪崩/击穿</h2><p>原有缓存失效而新缓存未到，导致所有应该访问缓存的请求都去访问数据库，造成巨大压力。</p><p>缓存雪崩是大规模的key失效，而缓存击穿是大量并发集中访问某一个key，而这个key失效。</p><p>一般多个缓存采用相同过期时间，同一时刻大量缓存过期。</p><p>解决：</p><ul><li>热点数据设置永不过期；其他数据合理分配过期时间。</li><li>竞争互斥锁查询数据库，但会导致系统性能变差。</li></ul><h2 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3. 缓存穿透"></a>3. 缓存穿透</h2><p>数据库中没有的数据，用户查缓存一遍找不到（缓存不会缓存空结果），还要去数据块中再查一遍，相当于两次无用查询。</p><p>解决：</p><ul><li>缓存空对象</li><li>布隆过滤器：有变量被加入集合时，通过K个映射函数映射成位图中K个点并置1，查询时先查这些点是不是1，是则可能存在（可能有哈希碰撞），不是一定不存在。</li></ul><h2 id="4-缓存预热"><a href="#4-缓存预热" class="headerlink" title="4. 缓存预热"></a>4. 缓存预热</h2><p>预加载。</p><h2 id="5-缓存淘汰"><a href="#5-缓存淘汰" class="headerlink" title="5. 缓存淘汰"></a>5. 缓存淘汰</h2><p>定时清理过期缓存：维护大量缓存key较为麻烦。</p><p>用户请求过来再判断是否过期，过期则去更新：每次用户过来都要判断，逻辑复杂。</p><h2 id="6-缓存降级"><a href="#6-缓存降级" class="headerlink" title="6. 缓存降级"></a>6. 缓存降级</h2><p>访问量剧增、服务出现问题或非核心服务影响到核心服务性能时，仍需要保证服务可用，即使有损服务。</p><p>目的是保证核心服务可用，即使有损。</p><p>解决前需要先梳理哪些服务可降级，哪些不行。</p><p>解决：数据库出现问题时，可以不去查询而直接返回默认值。</p><h1 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h1><p>redis和zookeeper都还没看过，先占个坑</p><h2 id="1-Redis-Redlock算法"><a href="#1-Redis-Redlock算法" class="headerlink" title="1. Redis Redlock算法"></a>1. Redis Redlock算法</h2><p>客户端和多个独立的Redis节点依次请求加锁，如果客户端和半数以上的节点成功加锁，则认为客户端获得锁。</p><p>过程：</p><ul><li>客户端获取时间t1。</li><li>客户端按顺序依次向N个Redis节点执行加锁操作：<ul><li>使用SET，带上NX、EX/PX与客户端唯一标识。</li><li>为了保证Redis节点故障时算法运行，给加锁操作设置过期时间，远小于锁的过期时间。</li></ul></li><li>一旦客户端从超过半数节点上获取到锁，再次获取时间t2，计算消耗的时间，如果小于锁的过期时间，认为加锁成功。</li></ul><p>加锁成功需要满足：</p><ul><li>客户端从超过半数节点获取到锁。</li><li>获取锁的时间消耗小于锁的过期时间。</li></ul><p>加锁成功后，锁的过期时间减去消耗时间即为有效时间。如果有效时间来不及完成共享数据，可以先释放锁。</p><p>释放锁：客户端向所有节点发起释放锁的操作。</p><h1 id="5-分布式事务"><a href="#5-分布式事务" class="headerlink" title="5. 分布式事务"></a>5. 分布式事务</h1><h2 id="1-2PC-XA方案"><a href="#1-2PC-XA方案" class="headerlink" title="1. 2PC/XA方案"></a>1. 2PC/XA方案</h2><p>两阶段提交。每个数据库都回复ok，事务管理器再提交事务，并在各个数据库上操作，否则回滚。</p><p>适用单块应用里，跨多个库的分布式事务。严重依赖于数据库层面搞定复杂事务，效率很低，不适合高并发。</p><h2 id="2-TCC强一致性方案"><a href="#2-TCC强一致性方案" class="headerlink" title="2. TCC强一致性方案"></a>2. TCC强一致性方案</h2><ul><li>Try：对各个服务的资源做检测，然后锁定或预留资源。</li><li>Confirm：在各个服务中执行实际操作。</li><li>Cancel：如果任何一个服务方法执行出错，则将已成功的服务回滚。</li></ul><p>事务回滚严重依赖于自己写逻辑实现回滚和补偿，造成巨大补偿代码量。</p><h2 id="3-可靠消息最终一致性方案"><a href="#3-可靠消息最终一致性方案" class="headerlink" title="3. 可靠消息最终一致性方案"></a>3. 可靠消息最终一致性方案</h2><p>基于MQ（消息队列）实现事务。</p><ul><li>A系统发送prepared消息到MQ，如果发送失败就取消操作，成功则进行下一步。</li><li>执行本地事务，如果成功就告诉MQ发送确认消息，失败则告诉MQ回滚消息。</li><li>如果MQ没收到确认消息，就自动定时轮询发送prepared消息的A系统，问本地事务是否处理成功。</li><li>A检查本地事务状态，确认是否成功并告知MQ。</li><li>如果发送了确认消息，B系统接到确认消息，执行本地事务。</li><li>如果B系统事务失败，就重试，或想办法通知A系统失败回滚。</li></ul><h2 id="4-最大努力通知方案"><a href="#4-最大努力通知方案" class="headerlink" title="4. 最大努力通知方案"></a>4. 最大努力通知方案</h2><ul><li>A系统本地事务执行完后发消息到MQ。</li><li>有专门消费MQ的最大努力通知服务，消费MQ并记录，然后通知B系统。</li><li>B系统执行成功则结束；否则最大努力通知服务定时尝试重新调用系统，达到指定次数后放弃。</li></ul><h1 id="6-消息队列"><a href="#6-消息队列" class="headerlink" title="6. 消息队列"></a>6. 消息队列</h1><p>MQ Message Queue，一般作为单独的中间件产品存在，独立部署。</p><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><ul><li>解耦：将调用关系/生产消费关系用中间件隔离，生产者只需要向MQ写消息，消费者只需要从MQ读消息，双方不必关心对方成员的增减、是否消费成功。</li><li>异步：不需要将数据一个个同步发送过去再响应成功，而是直接将数据写到MQ里即可响应成功。</li><li>削峰：将某一段时间的超高流量分摊到一段长时间内消化，防止被流量洪峰击垮系统。</li></ul><h2 id="2-缺陷"><a href="#2-缺陷" class="headerlink" title="2. 缺陷"></a>2. 缺陷</h2><ul><li>增加了系统复杂性：需要考虑消息是否丢失、消息积压、MQ满、消息重复等问题。</li><li>降低系统可用性：各个系统强依赖MQ，需要额外保证MQ高可用。</li><li>一致性问题：部分系统消费成功而其它系统消费失败。</li></ul><h1 id="7-微服务"><a href="#7-微服务" class="headerlink" title="7. 微服务"></a>7. 微服务</h1><p>一种架构风格。将一个项目拆成独立的多个服务，每个服务占用线程，独立运行。</p><p>本质是有效拆分应用，实现便捷开发和部署。</p><h2 id="1-为什么"><a href="#1-为什么" class="headerlink" title="1. 为什么"></a>1. 为什么</h2><p>传统IT行业，软件大多是独立系统的堆砌。扩展性差、可靠性不高、维护成本高。</p><p>SOA服务化，但是其早期使用了总线模式，与某种技术栈强绑定，导致很多企业的遗留系统很难对接，切换时间长，成本高，新系统稳定性的收敛也需要时间。</p><h2 id="2-与单体架构的区别"><a href="#2-与单体架构的区别" class="headerlink" title="2. 与单体架构的区别"></a>2. 与单体架构的区别</h2><ul><li>耦合性：<ul><li>单体架构所有模块耦合在一起，代码量大、维护困难</li><li>微服务每个模块相当于一个独立项目，代码量小、遇到问题解决容易</li></ul></li><li>存储方式：<ul><li>单体架构所有模块共用一个数据库，存储方式单一</li><li>微服务每个模块存储方式不同，数据库也是独立使用</li></ul></li><li>开发技术：<ul><li>单体架构所有模块开发技术一致</li><li>微服务每个模块都可以使用不同开发技术，开发模式更灵活</li></ul></li></ul><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3. 特点"></a>3. 特点</h2><ul><li>解耦：同一系统内服务大部分可解耦，因此应用可被轻易构建、修改和升级</li><li>组件化：相互独立的组件，可轻易替换升级</li><li>职责明确：每个微服务可专注于某种单一能力</li><li>自治：开发者和团队可独立工作，提高开发速度</li><li>持续交付：允许持续发布新版本，通过系统化自动手段来创建、测试和批准新版本</li><li>去中心化管理：没有标准化的计数模式，开发者可选择最好的工具解决自己的问题</li><li>敏捷性：支持敏捷开发，任何新功能都可被快速开发或丢弃</li></ul><h2 id="4-优势"><a href="#4-优势" class="headerlink" title="4. 优势"></a>4. 优势</h2><ul><li>独立开发</li><li>独立部署</li><li>错误隔离：某个服务故障不影响整个系统</li><li>混合技术栈：可使用不同语言和技术为同一个应用构建不同服务</li><li>按粒度扩展：可根据需求扩展某一个组件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-大数据场景处理</title>
      <link href="/2023/01/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86/"/>
      <url>/2023/01/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-找相同字符串"><a href="#1-找相同字符串" class="headerlink" title="1.找相同字符串"></a>1.找相同字符串</h1><p>场景：找相同URL</p><h2 id="1-分治法"><a href="#1-分治法" class="headerlink" title="1. 分治法"></a>1. 分治法</h2><p>按照哈希值分组，所有相同字符串一定在同一组，然后在同一组中求相同字符串。如果组仍然太大，还可以再次哈希。</p><h2 id="2-前缀树"><a href="#2-前缀树" class="headerlink" title="2. 前缀树"></a>2. 前缀树</h2><p>字典树</p><h1 id="2-找高频词"><a href="#2-找高频词" class="headerlink" title="2. 找高频词"></a>2. 找高频词</h1><p>场景：访问最多的IP、请求最多的资源</p><p>分治法：</p><ol><li>哈希分组，每组用哈希表统计频数</li><li>优先队列求高频词</li></ol><h1 id="3-找不重复整数"><a href="#3-找不重复整数" class="headerlink" title="3. 找不重复整数"></a>3. 找不重复整数</h1><h2 id="1-分治法-1"><a href="#1-分治法-1" class="headerlink" title="1. 分治法"></a>1. 分治法</h2><h2 id="2-位图法"><a href="#2-位图法" class="headerlink" title="2. 位图法"></a>2. 位图法</h2><p>用位表示状态，可以每个数用2bit表示，00表示没出现过、01表示出现过一次、10表示多次出现。</p><p>整理成位图后再遍历位图即可。</p><h1 id="4-判断某个数是否存在"><a href="#4-判断某个数是否存在" class="headerlink" title="4. 判断某个数是否存在"></a>4. 判断某个数是否存在</h1><h2 id="1-分治法-2"><a href="#1-分治法-2" class="headerlink" title="1. 分治法"></a>1. 分治法</h2><h2 id="2-位图法-1"><a href="#2-位图法-1" class="headerlink" title="2. 位图法"></a>2. 位图法</h2><p>0表示不存在，1表示存在</p><h1 id="5-找中位数"><a href="#5-找中位数" class="headerlink" title="5. 找中位数"></a>5. 找中位数</h1><h2 id="1-双堆法"><a href="#1-双堆法" class="headerlink" title="1. 双堆法"></a>1. 双堆法</h2><p>两个堆，分别维护更大的一半数与更小的一半数，根据堆顶元素即可得中位数。</p><h2 id="2-分治法"><a href="#2-分治法" class="headerlink" title="2. 分治法"></a>2. 分治法</h2><ol><li>先按最高位分治，根据两个集合中数据个数判断中位数在哪个集合中。</li><li>之后再按次高位分支，循环直到集合大小能装进内存中。</li><li>在内存中排序并找到中位数。</li></ol><h1 id="6-排序大量数字"><a href="#6-排序大量数字" class="headerlink" title="6. 排序大量数字"></a>6. 排序大量数字</h1><h2 id="1-分治法-3"><a href="#1-分治法-3" class="headerlink" title="1. 分治法"></a>1. 分治法</h2><p>按数值区间分桶，在每个桶内分别排序，然后按区间组合。</p><h1 id="7-排序大量数字，其中有重复的"><a href="#7-排序大量数字，其中有重复的" class="headerlink" title="7. 排序大量数字，其中有重复的"></a>7. 排序大量数字，其中有重复的</h1><h2 id="1-分治法-4"><a href="#1-分治法-4" class="headerlink" title="1. 分治法"></a>1. 分治法</h2><p>按数值区间分桶，在每个桶内以数字个数为权值设置堆。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-C++</title>
      <link href="/2023/01/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C++/"/>
      <url>/2023/01/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C++/</url>
      
        <content type="html"><![CDATA[<h1 id="C和C-区别"><a href="#C和C-区别" class="headerlink" title="C和C++区别"></a>C和C++区别</h1><ul><li>面向过程&amp;面向对象：C++有类和对象，支持模板，有STL。</li><li>动态内存管理：malloc&amp;new。</li><li>类型安全</li><li>输入输出</li></ul><h1 id="1-关键字-方法"><a href="#1-关键字-方法" class="headerlink" title="1. 关键字/方法"></a>1. 关键字/方法</h1><h2 id="1-new与malloc"><a href="#1-new与malloc" class="headerlink" title="1. new与malloc"></a>1. new与malloc</h2><h3 id="1-new-delete"><a href="#1-new-delete" class="headerlink" title="1. new/delete"></a>1. new/delete</h3><p>new：</p><ul><li><p>实现：</p><ul><li>调用operator new标准库函数，分配内存。</li><li>在该段内存上赋值或执行构造函数（placement new）。</li></ul></li><li><p>分类：</p><ul><li>plain new/operator new：普通的new，空间分配失败抛出异常bad_alloc。</li><li>operator new不能满足内存请求时：如果set_new_handler指定了错误处理函数，则调用后再次尝试请求内存；否则抛出异常。</li><li>nothrow new：空间分配失败返回NULL</li><li>placement new：允许在一块已经分配成功的内存上重新构造对象，不分配内存。构造成功的对象要显式调用析构函数销毁，因为构造的对象大小并不一定等于原来分配的内存大小，delete会造成内存泄漏。</li></ul></li></ul><p>STL中，new操作符内部先使用plain new分配空间，然后使用placement new在分配的空间上初始化。</p><p>delete</p><ul><li>实现：<ul><li>对指针指向的对象调用析构函数。</li><li>调用operator delete标准库函数释放所用内存。</li></ul></li></ul><p>operator new/delete封装了malloc/free实现内存分配。</p><p>new对象数组时C++会额外分配4字节保存数组大小，在delete[]时就能取出保存的大小，从而知道需要析构多少次。</p><h3 id="2-malloc-free"><a href="#2-malloc-free" class="headerlink" title="2. malloc/free"></a>2. malloc/free</h3><p>malloc的实现：判断申请空间大小。</p><p>类似于STL的allocator，8字节为一个单位，分为128个链表，称为bin，链表节点称为chunk。前64个bin为small bin，后面的为large bin。</p><ul><li>第一个bin为unsorted bin。</li><li>同一个small bin里的chunk大小相同，相邻small bin相差8字节。</li><li>large bin包含一个给定范围内的chunk，按大小序排列，每个bin相差64字节。</li><li>还有一个fast bin，申请释放一些小内存空间时，不大于max_fast（默认64B）的空间释放后进入。会定时合并其中相邻的chunk。</li><li></li><li>top chunk：在mmap区域分配一块较大的空闲内存，模拟sub-heap。bin无法满足需求时使用。</li><li>mmaped chunk：top chunk都无法满足时，直接用mmap。使用后立即解除映射归还操作系统。</li><li>last remainder chunk：找不到合适的small chunk，如果last remainder大小大于所需，就分裂该chunk，其中一个给用户，另一个变成新的last remainder chunk。</li></ul><p>流程：</p><ul><li>一开始，用户请求大小小于mmap阈值：加上128KB申请，作为初始heap。</li><li>后续小于mmap阈值：fast-&gt;small-&gt;合并fast加入unsorted-&gt;unsorted-&gt;unsorted加入large-&gt;large（前面精确匹配，large里最小匹配或最优匹配）</li><li>以上都查找失败且小于mmap阈值：top chunk。</li><li>以上都查找失败且小于mmap阈值：mmap申请空间，增加top chunk。</li><li>以上都失败或大于mmap阈值：mmap。</li></ul><p>具体：</p><ul><li>bin里的chunk分配调用brk()实现（把数据段.data的最高地址指针往高地址推）。brk会在堆中分配相应的空间，且使用该空间后不会立刻还给操作系统，而是缓存在malloc内存池中。（brk分配的内存需要等到更高地址的内存都被释放了才能释放）</li><li>较大空间调用mmap()实现（匿名映射）。mmap会在文件映射区中分配相应的虚拟空间，且使用该空间后立刻还给操作系统。mmap将文件映射区的虚拟地址与内核中的文件进行绑定。因为读写文件要经过page cache，所以相当于用户空间直接读写内核中的page cache。通过msync数据同步、munmap解除映射关系时主动刷盘；或者进程退出、系统关机时被动刷盘。<ul><li>mmap将文件映射区的虚拟地址与文件进行绑定。因为读写文件要经过page cache，所以相当于用户空间直接读写page cache。通过msync数据同步、munmap解除映射关系时主动刷盘；或者进程退出、系统关机时被动刷盘。</li></ul></li></ul><p>分大小调用的原因：</p><ul><li>不全用brk：堆空间不够大；空间使用结束后不会立刻还给操作系统，频繁申请大内存容易造成内存碎片。</li><li>不全用mmap：每次调用都重新分配空间，且使用完立刻还给操作系统，第一次访问该空间一定会发生缺页中断，影响系统性能。</li></ul><p>被free释放的内存会被保存在空闲双链表中，下次申请时直接找合适的返回，避免频繁的系统调用。</p><h3 id="3-new与malloc区别"><a href="#3-new与malloc区别" class="headerlink" title="3. new与malloc区别"></a>3. new与malloc区别</h3><p>new实际上封装了malloc。</p><ul><li>类型：new是C++运算符，malloc是C/C++语言标准库函数</li><li>分配空间大小：new自动计算分配空间大小，malloc需要手动计算</li><li>类型安全：new类型安全，即返回的就是构造类型的指针，malloc不是，需要从void*强制转换</li><li>构造：new不仅分配空间，还调用构造函数</li><li>异常处理：new分配失败会抛出bad_alloc异常，malloc分配失败返回NULL</li></ul><h2 id="2-align-结构体对齐"><a href="#2-align-结构体对齐" class="headerlink" title="2. align 结构体对齐"></a>2. align 结构体对齐</h2><p>alignof：传入类型，计算出其对齐方式。</p><p>alignas：用于struct关键字后，指定结构体的对齐方式，如struct alignas(2)指定2字节对齐。但是如果指定的字节小于自然对齐的最小单位，则被忽略（结构体中有int这种大于2字节的）。</p><h2 id="3-const与"><a href="#3-const与" class="headerlink" title="3. const与*"></a>3. const与*</h2><p>把char与括号里的东西忽略，直接看const修饰的是p还是*p。</p><ul><li>const char* p，const修饰<em>p，说明 <em>p是const，p可变。</em></em>指针常量，即指针指向的对象是常量**。底层const。</li><li>char* const p，const修饰p，说明p是const， *p可变。<strong>常量指针，即指针本身是常量</strong>。顶层const。</li><li>const (char*) p，忽略括号const修饰p，说明p是const，*p可变。</li><li>const char* const p，常量指针常量。</li></ul><h2 id="4-static"><a href="#4-static" class="headerlink" title="4. static"></a>4. static</h2><ul><li>不在类中<ul><li>隐藏：带static的全局变量和函数只能在该文件所在的编译模块中使用。static函数在整个内存中只有一份，而普通函数在每个调用该函数的编译单元中都有一份拷贝。</li><li>一次初始化：函数内定义的静态变量只能进行一次初始化，函数退出后依然存在，且不能初始化。常用：饱汉式单例模式。</li></ul></li><li>在类中<ul><li>成员变量：只与类关联而不与对象关联，不能在类声明中初始化，只能在类定义体外部初始化。</li><li>成员函数：没有this指针，无法访问本类的非static成员变量与成员函数，不能被声明为const、virtual和volatile。</li></ul></li></ul><h2 id="5-const"><a href="#5-const" class="headerlink" title="5. const"></a>5. const</h2><ul><li><p>作用：</p><ul><li>修饰变量：不能被改变。<ul><li>类成员在类内（C++11）或初始化列表初始化。</li><li>默认为文件局部变量，能实现隐藏。其他文件如果使用，需要extern显式声明。</li></ul></li><li>修饰指针：常量指针、指针常量。</li><li>修饰引用：避免拷贝，避免修改。</li><li>修饰成员函数：函数内不能修改成员变量。</li></ul></li><li><p>不在类中</p><ul><li>阻止一个变量被改变</li><li>修饰变量与static有一样的隐藏作用，只能在该文件中出现，其他文件不能引用声明。</li><li>定义时必须初始化</li><li>类对象只能调用const成员函数</li><li>const形参可接受const和非const实参</li></ul></li><li><p>在类中</p><ul><li>成员变量：不能在类定义外部初始化、不能在声明时初始化，只能通过构造函数初始化列表初始化，且必须要有构造函数。</li><li>成员函数：const对象不能调用非const成员函数，不可改变非mutable数据的值。</li></ul></li></ul><h2 id="6-override"><a href="#6-override" class="headerlink" title="6. override"></a>6. override</h2><p>如果父类中使用了虚函数，在子类中重写该虚函数时可以加override，这样如果父类中没有相应的虚函数时，编译器会报错。</p><p>防止重写时打错名字。</p><h2 id="7-final"><a href="#7-final" class="headerlink" title="7. final"></a>7. final</h2><p>不希望某个类被继承或某个虚函数被重写。</p><h2 id="8-volatile"><a href="#8-volatile" class="headerlink" title="8. volatile"></a>8. volatile</h2><p>类型修饰符，表明该变量是随时发生变化的，可以被某些编译器未知的因素更改。</p><p>每次使用值时总是从它所在的内存读取，而不是寄存器、读缓存等。读取的数据立刻被保存。（可能通过汇编代码等偷偷修改变量的值而不被编译器察觉）</p><p>并且编译器不会对它的操作进行优化。</p><p>用途：</p><ul><li>被几个任务共享的变量。</li><li>中断服务程序修改的供其他程序检测的变量。<ul><li>例：循环判断某个变量的状态，而在本程序中并未修改它，编译器就可能优化为只执行一次判断，而实际上该变量可能会被中断处理程序修改。</li></ul></li><li>存储器映射的硬件寄存器。</li></ul><p>volatile指针和const指针辨认方法类似。</p><p>注意点：</p><ul><li><strong>const与volatile可以一起</strong>。const控制程序本身不改变该值，volatile告诉编译器该值可能被程序之外的方式修改。</li><li>可以把非volatile对象赋给volatile对象，反之不行。</li></ul><p>应用：<code>for (volatile int i = 0; i &lt; 100000; ++i);</code></p><p>不加volatile编译器会优化，不会做这个循环。加了volatile就会循环完。</p><h2 id="9-mutable"><a href="#9-mutable" class="headerlink" title="9. mutable"></a>9. mutable</h2><p>修饰的变量即使在const函数中也可变。</p><h2 id="10-explicit"><a href="#10-explicit" class="headerlink" title="10. explicit"></a>10. explicit</h2><p>修饰只用一个参数的构造函数。（只有一个参数，或其他参数有默认值）</p><p>被修饰的类不能发生相应的隐式类型转换（用=号构造），只能显式类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): a(a), b(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point a = <span class="number">1</span>; <span class="comment">// 匹配上了Point(1)，隐式调用了构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-alloc系列函数"><a href="#11-alloc系列函数" class="headerlink" title="11. alloc系列函数"></a>11. alloc系列函数</h2><p>malloc：void *malloc(unsigned int num_bytes)。</p><p>num_bytes为要申请的空间大小，需要手动计算。</p><p>calloc：void *calloc(size_t n, size_t size)。</p><p>传入个数n与sizeof(type)即可申请空间，不需要人为计算，申请后将空间的值初始化为0。因为有初始化操作，效率较malloc低。</p><p>realloc：void realloc(void *ptr, size_t new_Size)。</p><p>对动态内存扩充。</p><h2 id="12-cast强制转换"><a href="#12-cast强制转换" class="headerlink" title="12. cast强制转换"></a>12. cast强制转换</h2><p>转换是一种编译器指令，大部分情况下并不改变指针的地址，而只是影响指针指向<strong>内存的大小和内容</strong>的<strong>解释方式</strong></p><ul><li>reinterpret_cast：普通的强制类型转换（只是对二进制位用新类型重新解释），高度危险但最灵活。可以进行static_cast不能进行的转换。</li><li>const_cast：去除类型的const或volatile属性。常量指针、引用转换成非常量指针、引用，仍然指向原来的对象。</li><li>static_cast：静态转换，即编译期转换。没有运行时类型检查，不能用于无关类型指针、int和指针的转换。<ul><li>类层次结构中父子类之间指针引用的转换。上行转换安全，但下行转换不安全，直接使用转换后的对象可能报错。</li><li>基本数据类型间转换</li><li>空指针转换成目标类型的空指针</li><li>任何类型的表达式转成void</li></ul></li><li>dynamic_cast：只能转换<strong>指针和引用类型</strong>，只能用于<strong>存在虚函数的父子关系类中的转换</strong>，有类型检查，运行时借助RTTI（Run Time Type Identification，运行时类型识别）进行类型转换，要求<strong>基类必须包含虚函数</strong>。<ul><li>上行转换与static_cast无条件，不会进行任何检测；下行转换有类型检查，比static_cast安全，但是只有一部分能成功（基类指针/引用确实指向一个派生类对象），不成功会返回空指针。</li><li>转换后必须是类的指针、引用或void*。</li><li>转换指针失败返回nullptr。</li><li>转换引用失败抛出异常。（因为引用不能为空）</li></ul></li></ul><h2 id="13-strcpy、sprintf、memcpy"><a href="#13-strcpy、sprintf、memcpy" class="headerlink" title="13. strcpy、sprintf、memcpy"></a>13. strcpy、sprintf、memcpy</h2><p>手撕时要考虑const、判断非空、重叠问题！</p><ul><li>操作对象：<ul><li>strcpy操作对象均为字符串</li><li>sprintf源操作对象可以是多种数据类型，目的操作对象是字符串</li><li>memcpy操作对象可以是任意可操作的内存地址</li></ul></li><li>执行效率：<ul><li>memcpy、strcpy、sprintf</li></ul></li><li>实现功能：<ul><li>strcpy实现字符串变量间的拷贝</li><li>sprintf实现其他数据类型格式到字符串的转化</li><li>memcpy实现内存块间的拷贝</li></ul></li></ul><h2 id="14-inline"><a href="#14-inline" class="headerlink" title="14. inline"></a>14. inline</h2><p>编译器的处理：</p><ul><li>将inline函数体复制到调用点。</li><li>为函数中的局部变量分配内存空间。</li><li>将函数参数和返回值映射到局部变量空间中。</li><li>如果有多个返回点，使用goto。</li></ul><p>编译限制：</p><ul><li>不能有循环、过多条件判断：执行函数体内代码时间比函数调用开销大。</li><li>函数体不能太大：内存消耗代价高。</li><li>不能递归</li><li>声明必须在调用语句前。</li></ul><p>注意点：</p><ul><li>类中内联时，可以只在定义处加inline关键字。</li><li>内联只是建议，编译器并不一定内联，所以将构造函数、析构函数声明为内联函数可以，只是没有用，因为编译器会在这些函数中添加额外的操作。</li><li>虚函数可以是内联函数，但表现出多态性时内联无效：指向派生类的指针调用声明为虚函数时，不会展开（多态）；对象本身调用虚函数时且函数不复杂时，会内联展开。（即，没有表现多态特性）</li></ul><h2 id="15-iovec"><a href="#15-iovec" class="headerlink" title="15. iovec"></a>15. iovec</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">ptr_t</span> iov_base; <span class="comment">/* Starting address */</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">/* Length in bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *<span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *<span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>定义向量元素，iov_base指向存放的数据，iov_len表示接收的最大长度/实际写入的长度。</p><p>vector为iovec数组，count为vector大小。</p><h2 id="16-可变形参-vsprintf"><a href="#16-可变形参-vsprintf" class="headerlink" title="16. 可变形参/vsprintf"></a>16. 可变形参/vsprintf</h2><p>可变形参通过宏实现，定义在stdarg.h中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>&#123;<span class="comment">// num为参数个数，后面的为可变形参</span></span><br><span class="line">        va_list ap;</span><br><span class="line">        va_start(ap, num);</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, va_arg(ap, <span class="keyword">int</span>));</span><br><span class="line">               num--;</span><br><span class="line">        &#125;</span><br><span class="line">        va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int vsprintf(char *str, const char *format, va_list arg)</code></p><p>format和arg与printf类似输入。</p><h2 id="17-fstream"><a href="#17-fstream" class="headerlink" title="17. fstream"></a>17. fstream</h2><p>函数：</p><ul><li>构造函数 <code>fstream()</code></li><li>构造函数 <code>fstream(filename: string, mode)</code>。这样构造时调用open。mode用按位或连接。<ul><li>ios::in：读</li><li>ios::out：写</li><li>ios::ate：初始位置在文件尾</li><li>ios::app：尾部写入</li><li>ios::trunc：如果文件已存在则先删除</li><li>ios::binary：二进制方式</li></ul></li><li><code>open(filename: string, mode)</code>。</li><li><code>is_open()</code></li><li><code>close()</code>：将缓存中的数据排出并关闭文件。析构时自动调用。</li><li>写：<ul><li><code>write(data: const char*, n: streamsize)</code></li><li>操作符&lt;&lt;重载</li></ul></li><li>读：<ul><li><code>getline(data: const char*, n: streamsize, delim: char)</code>：读取到delim停止，默认为’\n’即读取一行。</li><li><code>getline(is: istream&amp;, str: string&amp;, delim: char)</code></li><li>操作符&gt;&gt;重载。根据后面跟的变量类型决定什么时候停止（字符串读到空白字符停止）</li></ul></li></ul><h2 id="18-extern"><a href="#18-extern" class="headerlink" title="18. extern"></a>18. extern</h2><p>单定义规则：变量只能有一次定义。</p><p>C++提供了两种变量声明：</p><ul><li>定义声明：简称定义，给变量分配内存空间。</li><li>引用声明：简称声明，不给变量分配内存空间，因为引用已有变量。</li></ul><p>引用声明用extern关键字且不初始化，否则视为定义，分配空间。</p><p>在文件中使用其他文件定义的外部变量时，需要extern声明变量。（全局变量一般声明在.c文件中，而include一般作用于.h文件）</p><p><code>extern &quot;C&quot; &#123; ... &#125;</code></p><p>c和c++中，同一个函数编译生成的符号不同。如在.c文件中定义 <code>add()</code>，然后在.cpp文件中include了该 <code>add()</code>的.h文件，并调用，会报错：无法找到 <code>add()</code>。</p><p>该声明中放入#include或 <code>add()</code>的声明，在链接阶段起作用，告诉链接器寻找c语言符号，而不是经过c++修饰的符号。</p><p>可用于c++调用c函数，或c调用c++函数。</p><h2 id="19-union"><a href="#19-union" class="headerlink" title="19. union"></a>19. union</h2><p>作用：</p><ul><li>强制类型转换</li><li>查看类型分布（用char[]与想查看的类型union）</li><li>优化短字符串（char[]与unsigned long long union，可直接用ull作为哈希值，比较字符串是否相等）</li><li>取别名（数组与结构体union，通过数组遍历结构体成员）</li></ul><p>缺点：如果union了多个指针，没法释放被覆盖的指针指向的内存；union含有带析构函数的成员时，不会自动析构。</p><p>特点：</p><ul><li>可以有构造/析构函数</li><li>不能有引用类型成员</li><li>匿名union在定义作用域可直接访问成员，且只能包含public成员</li><li>全局匿名union必须是static</li></ul><p>改进：C++ 17 variant</p><h2 id="20-位域"><a href="#20-位域" class="headerlink" title="20. 位域"></a>20. 位域</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bit_field_name</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    type member_name : width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为每个位域成员设置名称并决定宽度，以bit为单位。成员赋值大小不能超过位域成员容量。</p><p>对齐：</p><ul><li>可以不设置成员名称，仅起填充作用。</li><li>一个位域成员不允许跨越两个unsigned的边界，编译器会自动移位，使其按照unsigned边界对齐。<ul><li>为了防止实际与预期不符，可以用未命名成员填充。</li></ul></li></ul><h2 id="21-using"><a href="#21-using" class="headerlink" title="21. using"></a>21. using</h2><ul><li>指定使用的符号<ul><li><code>using ns1::func()</code>或者 <code>using ns2::func()</code>，来通过 <code>func()</code>调用作用域ns1/ns2中的 <code>func()</code>。</li></ul></li><li>改变访问性<ul><li>派生类using可见的基类成员，改变 public/protected/private属性。</li></ul></li><li>函数重载<ul><li>派生类只要定义了基类函数的一个重载版本，其他版本都会不可见。</li><li>在派生类中using基类的重载函数名，然后定义想要重载的函数即可，而无需重新定义其他的。</li></ul></li><li>取代typedef</li></ul><h2 id="22-enum"><a href="#22-enum" class="headerlink" title="22. enum"></a>22. enum</h2><p>枚举类：<code>enum class color &#123; ... &#125;;</code></p><ul><li>作用域不是全局</li><li>不能隐式转换为其他类型</li><li>可以指定继承特定的类型来存储，如 <code>enum class color: char</code></li></ul><p>类中的枚举类型：实现只有类中有效的常量。编译时期求值，不占用对象的存储空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        BOY = <span class="number">0</span>,</span><br><span class="line">        GIRL</span><br><span class="line">    &#125;SexType;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//访问的时候通过，Person::BOY或者Person::GIRL来进行访问。</span></span><br></pre></td></tr></table></figure><h2 id="23-RTTI"><a href="#23-RTTI" class="headerlink" title="23. RTTI"></a>23. RTTI</h2><p>Runtime Type Identification运行时类型检查。</p><p>C++通过以下的两个操作提供RTTI，且只有类中有虚函数时，RTTI才生效：</p><ul><li>typeid运算符，该运算符返回其表达式或类型名的实际类型，封装为type_info类的实例。</li><li>dynamic_cast运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。</li></ul><h1 id="2-比较"><a href="#2-比较" class="headerlink" title="2. 比较"></a>2. 比较</h1><h2 id="1-指针和引用"><a href="#1-指针和引用" class="headerlink" title="1. 指针和引用"></a>1. 指针和引用</h2><p>区别：</p><ul><li>存储内容：指针存储地址，引用实际上只是一个别名。</li><li>嵌套：指针可以有多级，引用只有一级。</li><li>初始化：指针可以为空，引用不行且必须在定义时初始化。</li><li>更改：指针定义后可以改变指向，而引用不可改变。</li><li>sizeof：指针得到4字节（指针大小），引用得到其引用变量的大小。</li><li>参数传递：指针参数传递本质上还是值传递，指针本身作为值被复制，在函数中改变指针地址并不会影响原指针；任何对于引用参数的处理都会通过间接寻址操作到主调函数的相关变量。</li><li>从汇编的层次看，引用是通过指针实现的，引用只是指针的一个语法糖，所以两者性能完全相同。</li></ul><h2 id="2-堆和栈"><a href="#2-堆和栈" class="headerlink" title="2. 堆和栈"></a>2. 堆和栈</h2><ul><li>管理方式<ul><li>堆由程序员控制</li><li>栈由操作系统自动管理</li></ul></li><li>内存管理机制<ul><li>堆由空闲内存链表分配，是不连续的内存区域，大小可灵活调整</li><li>栈顶和栈底预设好，大小固定，超出会报栈溢出</li></ul></li><li>空间大小<ul><li>堆大小受限于有效虚拟内存</li><li>栈大小是操作系统预设的，windows下为2M</li></ul></li><li>碎片问题<ul><li>堆会产生碎片，栈不会</li></ul></li><li>生长方向<ul><li>堆向高地址方向生长，而栈向低地址</li></ul></li><li>分配方式<ul><li>堆都是动态分配</li><li>栈的静态分配由编译器完成，动态分配由alloca函数完成，由编译器释放</li></ul></li><li>分配效率<ul><li>堆由C/C++函数库提供，机制复杂（分配内存时需要寻找合适的内存，获取堆内容需要指针和实际内存两次访问），效率低</li><li>栈是操作系统提供的结构，计算机底层提供支持（专门寄存器存栈地址，专门指令执行操作），效率高</li></ul></li></ul><h2 id="3-宏与函数-typedef-内联函数-const"><a href="#3-宏与函数-typedef-内联函数-const" class="headerlink" title="3. 宏与函数/typedef/内联函数/const"></a>3. 宏与函数/typedef/内联函数/const</h2><p>与函数的区别：</p><ul><li>宏在预处理阶段，编译阶段前完成，直接进行文本插入替换；函数调用是在运行时跳转</li><li>宏定义没有类型，不检查类型</li><li>宏定义因为属于直接替换代码，没有返回值</li><li>宏不是语句，不要加分号</li></ul><p>与typedef的区别：</p><ul><li>typedef发生在编译阶段</li><li>typedef检查类型</li><li>typedef是语句</li></ul><p>与内联函数的区别：</p><ul><li>内联函数可以进行参数类型检查、语法判断</li><li>内联函数在编译时将函数代码嵌入目标代码，能省去函数调用开销，还能实现重载；宏在预处理阶段嵌入</li></ul><p>与const的区别：</p><ul><li>宏在预处理阶段直接替换，不占用内存；const在编译、运行时起作用，且占用内存。</li><li>宏不检查类型；const检查。</li></ul><h2 id="4-变量声明与变量定义"><a href="#4-变量声明与变量定义" class="headerlink" title="4. 变量声明与变量定义"></a>4. 变量声明与变量定义</h2><p>声明：只告知编译器变量声明的位置与类型，不分配内存。可多次出现。</p><p>定义：分配内存。只能有一个定义。</p><h2 id="5-数组名和指针"><a href="#5-数组名和指针" class="headerlink" title="5. 数组名和指针"></a>5. 数组名和指针</h2><p>数组名不是真正的指针，没有自增自减操作。</p><p>数组名当作形参传给函数后，退化成一般指针，可以自增自减、可被修改，但无法用sizeof得到数组大小（sizeof只会返回指针大小）。</p><h2 id="6-赋值初始化与成员初始化列表"><a href="#6-赋值初始化与成员初始化列表" class="headerlink" title="6. 赋值初始化与成员初始化列表"></a>6. 赋值初始化与成员初始化列表</h2><p>赋值初始化，在所有数据成员被分配内存空间后才进行；在构造函数中赋值操作，而复杂类型成员变量的赋值操作会产生临时对象，所以有可能降低效率。</p><p>列表初始化，在给数据成员分配内存空间时就进行；对于复杂类型成员变量初始化，少调用一次拷贝构造函数，所以会快一些。必须用到的场合：</p><ul><li>初始化引用成员、常量成员</li><li>调用基类构造函数且其有参数</li><li>调用成员类构造函数且其有参数</li></ul><p>派生类构造函数的执行顺序：</p><ol><li>虚拟基类的构造函数</li><li>基类的构造函数</li><li>（如果存在）虚表指针初始化</li><li>类类型的成员对象的构造函数（按照初始化顺序）</li><li>派生类自己的构造函数（用户在当前类构造函数中写的代码）</li></ol><p>析构顺序与构造顺序相反。</p><h2 id="7-vector的emplace-back与push-back"><a href="#7-vector的emplace-back与push-back" class="headerlink" title="7. vector的emplace_back与push_back"></a>7. vector的emplace_back与push_back</h2><p>对于vector&lt;A&gt;：</p><p>emplace_back接收A的构造函数的参数，进行<strong>原地</strong>构造。emplace_back也可进行<strong>转移</strong>构造。</p><p>push_back接收A类型的对象，然后触发<strong>拷贝/转移</strong>构造函数。</p><p>如果要插入临时对象，emplace_back可以少触发一次转移构造函数。</p><h2 id="8-组合和继承"><a href="#8-组合和继承" class="headerlink" title="8. 组合和继承"></a>8. 组合和继承</h2><p>继承：</p><ul><li>优点：<ul><li>子类可以重写父类的方法来方便扩展。</li></ul></li><li>缺点：<ul><li>父类内部细节对子类可见</li><li>子类无法在运行期间改变从父类继承的方法的行为</li><li>如果对父类方法修改，子类必须做出相应的修改，父子类高耦合，违背了面向对象思想。</li></ul></li></ul><p>组合</p><ul><li>优点：<ul><li>包含对象的内部细节对当前对象不可见</li><li>低耦合关系，修改包含对象代码不需要修改当前对象</li><li>当前对象可以在运行时动态绑定包含对象</li></ul></li><li>缺点：<ul><li>容易产生过多对象</li></ul></li></ul><h2 id="9-Debug与Release版本"><a href="#9-Debug与Release版本" class="headerlink" title="9. Debug与Release版本"></a>9. Debug与Release版本</h2><p>只是定义的区别，实际上可以任意修改。</p><p>Debug调试版本：</p><ul><li>包含调试信息，所以容量很大。</li><li>不进行任何优化，因为优化会使调试复杂化。</li><li>有pdb文件，记录断点等调试信息。</li></ul><p>Release发布版本：</p><ul><li>不包含调试信息</li><li>编译时进行优化</li><li>无pdb文件</li></ul><h2 id="10-函数模板和类模板"><a href="#10-函数模板和类模板" class="headerlink" title="10. 函数模板和类模板"></a>10. 函数模板和类模板</h2><ul><li>函数模板的实例化由编译程序在处理函数调用时自动完成，而类模板的实例化必须由程序员在程序中显式指定。因此，函数模板允许隐式调用，而类模板不允许。隐式调用，即调用时不需要特别用尖括号指出匹配的类型。</li><li>函数只允许全特化，偏特化用函数重载完成。类允许全特化与偏特化。调用优先级全&gt;偏&gt;无。</li></ul><h2 id="11-自由存储区与堆"><a href="#11-自由存储区与堆" class="headerlink" title="11. 自由存储区与堆"></a>11. 自由存储区与堆</h2><p>new是在自由存储区上申请内存。</p><p>自由存储区是C++通过new和delete操作的内存的抽象概念，只要通过new申请来的内存就可称为自由存储区。</p><p>大部分C++编译器默认用堆实现自由存储区。</p><h2 id="12-数组指针与指针数组"><a href="#12-数组指针与指针数组" class="headerlink" title="12. 数组指针与指针数组"></a>12. 数组指针与指针数组</h2><p>指针数组：<code>char *p[26]</code></p><p>数组指针：<code>char (*p)[26]</code></p><p>加括号的就是数组指针。</p><h1 id="3-类"><a href="#3-类" class="headerlink" title="3. 类"></a>3. 类</h1><h2 id="1-面向对象三大特性"><a href="#1-面向对象三大特性" class="headerlink" title="1. 面向对象三大特性"></a>1. 面向对象三大特性</h2><ul><li>继承：某种类型对象获得另一个类型对象的属性和方法。</li><li>封装：将数据以及对数据的操作封装成类。</li><li>多态：向不同对象发送同一消息，不同对象产生不同行为。重载实现编译时多态，虚函数实现运行时多态。允许子类类型的指针赋值给父类类型的指针。</li></ul><p>基于对象没有继承，因而更谈不上多态。</p><h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h2><ul><li>默认构造函数：没有参数</li><li>初始化构造函数：有参数。14开始，如果类没有定义任何构造函数，编译期会自动生成一个参数个数和成员一样的构造函数，将{}里的内容桉顺序赋值给每一个成员。只支持通过{}构造。</li><li>拷贝构造函数：可自定义深拷贝</li><li>移动构造函数：将被移动对象的空间移动到本对象，本质上是浅拷贝，但是把被拷贝的指针指向NULL，就能避免释放带来的不安全。其参数是右值引用，也就是说只有用右值或将亡值初始化另一个对象时，才会调用</li><li>委托构造函数：使用初始化列表的形式，将部分工作委托给其他构造函数</li><li>继承构造函数：将部分工作委托给基类构造函数</li><li>转换构造函数：只有一个形参，且为其他类型变量，将其他类型变量隐式转换为本类变量</li></ul><h2 id="3-拷贝初始化"><a href="#3-拷贝初始化" class="headerlink" title="3. 拷贝初始化"></a>3. 拷贝初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str3 = <span class="string">&quot;I am a string&quot;</span>;</span><br></pre></td></tr></table></figure><p>这句代码先用字符串作为参数，用指定构造函数构造一个临时对象，然后再用拷贝构造函数拷贝到正在创建的对象。</p><p>编译器进行优化，跳过临时对象这一步，变为直接调用构造函数，因此等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="4-重载、重写、覆盖和隐藏"><a href="#4-重载、重写、覆盖和隐藏" class="headerlink" title="4. 重载、重写、覆盖和隐藏"></a>4. 重载、重写、覆盖和隐藏</h2><p>重载：同一范围，函数名相同，参数类型和数目不同，不能只有返回值不同。</p><p>重写/覆盖：在派生类中覆盖基类中的同名函数，要求基类函数必须是虚函数，且参数个数、参数类型、返回值类型相同。</p><p>与重载的区别：</p><ul><li>关系：重写存在于父类和子类，重载是同一范围</li><li>参数：重写要求参数列表相同，重载要求参数列表不同</li><li>调用方法：重写调用的方法根据对象类型决定，重载根据实参和形参的对应关系决定</li></ul><p>隐藏：派生类的函数屏蔽了基类中的<strong>同名</strong>函数。这种情况下通过类指针只能调用派生类函数，无法调用基类同名函数。</p><p>原理：命名空间查找。派生类作用域定义了该函数名，就认为已经找到，不会去基类查找。</p><ul><li>两个函数参数相同，基类不是虚函数</li><li>两个函数参数不同，不管基类是否是虚函数</li></ul><p>隐藏情况下的普通对象和对象指针：</p><ul><li>定义派生类普通对象，该对象只能调用派生类的同名函数，因为先在派生类作用域内查找。</li><li>定义基类指针指向该对象，该指针只能调用基类同名函数，因为先在基类作用域查找。</li><li>总之一句话：只要没有动态绑定（虚函数），永远根据定义时的类型走。</li></ul><h2 id="5-NRV优化"><a href="#5-NRV优化" class="headerlink" title="5. NRV优化"></a>5. NRV优化</h2><p>具名返回值（name return value）优化：</p><p>对于 <code>A a = f()</code>，f为 <code>A f() &#123;...&#125;</code></p><p>不发生优化时，f返回b时调用拷贝构造函数，将局部对象b拷贝到a。</p><p>具体做法为，把f变为 <code>void f(A&amp; __result) &#123;...&#125;</code>，并在返回前调用拷贝构造函数，将b拷贝给__result。</p><p>如果发生了优化，编译器直接把a的地址传进f，让a代替b完成f中的操作，返回b时就不需要拷贝了，因为a就是b。</p><p>具体做法为，把f变为 <code>void f(A&amp; __result) &#123;...&#125;</code>，并直接用__result代替b执行所有操作。</p><p>早期的编译器必须在定义了拷贝构造函数才会执行NRV优化：早期编译器需要一个判断标准决定是否优化。如果用户定义了自己的拷贝构造函数，说明客户由于某些原因摆脱了高效的逐位拷贝，拷贝开销将增大，所以应该实行优化，以引用替代拷贝降低开销。</p><h2 id="6-静态绑定与动态绑定"><a href="#6-静态绑定与动态绑定" class="headerlink" title="6. 静态绑定与动态绑定"></a>6. 静态绑定与动态绑定</h2><p>静态类型是对象在声明时的类型，编译期确定；动态类型是一个指针引用目前所指对象的类型，运行时决定。</p><p>静态绑定绑定的是静态类型，对应的函数或属性依赖于对象的静态类型，发生在编译期；动态绑定绑定的是动态类型，对应的函数或属性依赖于对象的动态类型，发生在运行时。</p><ul><li><strong>继承体系中只有虚函数用的是动态绑定，其他的全是静态绑定</strong>。只能通过<strong>指针与引用</strong>实现。</li><li>虚函数中的默认参数是静态绑定的，只看指针或引用本身的类型。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*virtual*/</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">C* pc = <span class="keyword">new</span> C(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">B* pb = <span class="keyword">new</span> B(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">A* pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">C *pnull = <span class="literal">NULL</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">  </span><br><span class="line">    pa-&gt;func();      <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">pc-&gt;func();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">pnull-&gt;func();   <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；（实际上是调用的C::func(pnull)）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-具体过程"><a href="#1-具体过程" class="headerlink" title="1. 具体过程"></a>1. 具体过程</h3><p>静态绑定的具体过程：编译时发生</p><ul><li>查找pnull类型为C，发现其有非虚成员函数func。</li><li>找到func，生成函数调用C::func。</li></ul><p>动态绑定的具体过程：17 多态与虚函数</p><p>如果基类被初始化为派生类（即 <code>A a = new B</code>这种操作），因为派生类的内存一般都会大于基类，所以会触发slice切割操作，从而回避了多态机制，进而没有用B类的vtable初始化a。</p><h3 id="2-样例分析"><a href="#2-样例分析" class="headerlink" title="2. 样例分析"></a>2. 样例分析</h3><p>A的func不定义为虚函数时，pa的静态类型是A*，所以静态绑定A的func。</p><p>类的成员函数不与具体对象绑定，所有对象共用一份成员函数体。区分不同对象靠的是this指针，成员函数中对成员变量的访问都转化为this-&gt;成员对象。只要不对this指针指向的内容读取或修改，就能通过空对象访问成员函数。</p><p>对于pnull，该调用相当于func(C* this)，而函数体中没有用到this，所以能正常调用。（可以联动一下5 NRV优化）</p><p>A的func定义为虚函数时，所有的调用都要等到运行时指向对象的类型决定。pa绑定的是B的func，而pnull会报错空指针异常。</p><p>所以，<strong>绝对不要重新定义继承而来的非虚函数</strong>。</p><p>引用也能实现动态绑定。</p><h2 id="7-实现只能静态-动态创建对象"><a href="#7-实现只能静态-动态创建对象" class="headerlink" title="7. 实现只能静态/动态创建对象"></a>7. 实现只能静态/动态创建对象</h2><p>静态：new与delete重载成private/delete（更温和）</p><p>动态：构造、析构函数设置为protected，再用子类动态创建</p><h2 id="8-对象复用"><a href="#8-对象复用" class="headerlink" title="8. 对象复用"></a>8. 对象复用</h2><p>Flyweight享元模式：将对象存储到对象池中实现重复利用，避免多次创建重复对象的开销。</p><h2 id="9-空类"><a href="#9-空类" class="headerlink" title="9. 空类"></a>9. 空类</h2><p>空类也会实例化，在内存中分配一块地址，所以编译期会隐含添加一个字节。</p><p>空类在实例化时，默认添加：缺省构造函数、拷贝构造函数、析构函数、赋值运算符、*取址运算符与const *取址运算符。</p><h2 id="10-阻止类被实例化"><a href="#10-阻止类被实例化" class="headerlink" title="10. 阻止类被实例化"></a>10. 阻止类被实例化</h2><ol><li>将类定义为抽象基类</li><li>将构造函数声明为private</li></ol><h2 id="11-禁止程序自动生成拷贝构造函数"><a href="#11-禁止程序自动生成拷贝构造函数" class="headerlink" title="11. 禁止程序自动生成拷贝构造函数"></a>11. 禁止程序自动生成拷贝构造函数</h2><ol><li>重写拷贝构造函数与拷贝赋值函数为private。</li><li>为了防止类成员函数和friend函数调用，可以定义一个base类，在base类中设置private，派生类中将不会自动生成这两个函数。</li></ol><h2 id="12-memset-this-0-sizeof-this"><a href="#12-memset-this-0-sizeof-this" class="headerlink" title="12. memset(this,0,sizeof(*this))"></a>12. memset(this,0,sizeof(*this))</h2><ul><li>类含有虚函数表，会将虚函数表指针置为0</li><li>类含有C++类型对象，会破坏初始化结果</li></ul><h2 id="13-友元"><a href="#13-友元" class="headerlink" title="13. 友元"></a>13. 友元</h2><ol><li>友元关系不能被继承</li><li>友元关系单向、不可传递</li></ol><h2 id="14-类的内存空间"><a href="#14-类的内存空间" class="headerlink" title="14. 类的内存空间"></a>14. 类的内存空间</h2><p>一般的：由下列三项加和</p><ul><li>非静态成员的数据类型大小之和</li><li>编译器加入的额外成员变量，如指向虚函数表的指针</li><li>为了边缘对齐优化加入的padding</li></ul><p>特殊的：</p><ul><li>空类对象size为1，为了让对象的实例化能相互区别</li><li>作为基类时size为0</li></ul><h2 id="15-this指针"><a href="#15-this指针" class="headerlink" title="15. this指针"></a>15. this指针</h2><h3 id="1-创建时刻"><a href="#1-创建时刻" class="headerlink" title="1. 创建时刻"></a>1. 创建时刻</h3><p>在成员函数开始执行前构造，执行结束后清除。</p><h3 id="2-存放位置"><a href="#2-存放位置" class="headerlink" title="2. 存放位置"></a>2. 存放位置</h3><p>因编译器不同存放位置不同，栈、寄存器或全局变量。</p><h3 id="3-传递方式"><a href="#3-传递方式" class="headerlink" title="3. 传递方式"></a>3. 传递方式</h3><p>大部分指针通过ecx寄数寄存器传递this指针。</p><p>在call之前通过函数参数的首参传递。</p><p>在非const函数中，this指针类型为 <code>A *const</code>；在const函数中，this指针类型为 <code>const A *const</code></p><h2 id="16-成员函数中delete-this"><a href="#16-成员函数中delete-this" class="headerlink" title="16. 成员函数中delete this"></a>16. 成员函数中delete this</h2><p>对象必须是通过new创建的，否则调用delete this会直接报告invalid pointer。</p><p>在成员函数中delete this，在之后进行的任何函数调用，不能访问该对象任何成员变量、虚函数与this指针，否则会出现不可预期的问题：内存空间并不是马上被回收到系统中，此时可以访问，但是其中的值不确定，所以不可预期。</p><p>如果在析构函数中调用，则会导致堆栈溢出，因为delete函数本身就要调用析构函数。</p><h2 id="17-多态与虚函数"><a href="#17-多态与虚函数" class="headerlink" title="17. 多态与虚函数"></a>17. 多态与虚函数</h2><h3 id="1-多态"><a href="#1-多态" class="headerlink" title="1. 多态"></a>1. 多态</h3><p>编译时多态：重载。名字相同，参数数目和类型不同的函数，编译时根据参数的类型、数目确定调用的方法。</p><p>运行时多态：重写。在派生类中重写基类的虚函数，运行时会根据指针指向对象的实际类型调用相应的函数。</p><h3 id="2-虚函数实现原理"><a href="#2-虚函数实现原理" class="headerlink" title="2. 虚函数实现原理"></a>2. 虚函数实现原理</h3><p>this-&gt;vptr-&gt;vtable-&gt;vfunction（所以静态函数不能为虚函数，因为没有this指针）</p><ul><li>类中含有virtual关键字修饰的方法时，编译器自动生成虚表，保存<strong>类的类型信息</strong>与各个虚函数的入口地址（<strong>一个类对应一个虚表</strong>）。对象地址的前四个字节存储指向虚表的指针。</li><li>编译期派生类构造虚表时：<ul><li>先将基类虚表拷贝到自己的虚表对应位置中</li><li>如果自己实现了从基类继承的虚函数，则用自己的函数地址覆盖虚表中基类的函数地址</li><li>如果自己定义了新的虚函数，就放在虚表新的位置</li><li>编译器再将虚函数调用转换为虚表对应函数的项的调用（编译器并不知道具体是哪个函数）</li></ul></li><li>基类指针赋值子类对象时，基类虚表指针被子类对象的虚表指针覆盖，所以查虚表查到的是子类的对应实现。</li></ul><p>C++中虚函数表位于只读数据段。</p><p>虚表指针初始化在基类成员构造函数调用之后，成员初始化列表之前。</p><p>引用本质就是指针，所以引用也能实现虚函数，只不过引用不能换绑。</p><h3 id="3-特殊函数能否为虚函数？"><a href="#3-特殊函数能否为虚函数？" class="headerlink" title="3. 特殊函数能否为虚函数？"></a>3. 特殊函数能否为虚函数？</h3><ul><li><p>析构函数：一般写成虚函数，因为派生类中可能有基类不存在的成员变量，如果不写成虚函数，删除基类指针时只会调用基类的析构函数，只释放基类所用的内存，造成内存泄露。但是，CRTP模板除外。</p></li><li><p>static：不能是虚函数。没有this指针</p></li><li><p>inline：必须在编译时展开，而虚函数在运行时才能确定调用的是哪个函数。</p><ul><li>虚函数不表现多态时，可以inline。</li></ul></li><li><p>构造函数：不能是虚函数，因为</p><ul><li>对象不初始化就没有指向虚函数表的指针。</li><li>虚函数在运行时动态确定类型，而在构造对象时对象还未创建成功，编译器无法知道其实际类型。</li><li>也不应该在构造函数中调用虚函数，因为基类的构造函数期间将虚表指针指向基类的虚表，实际还是调用的基类的虚函数。</li></ul></li></ul><h3 id="4-虚函数开销"><a href="#4-虚函数开销" class="headerlink" title="4. 虚函数开销"></a>4. 虚函数开销</h3><p>空间：</p><ul><li>类开头多了4字节的虚函数表指针。</li><li>堆开辟虚函数表。</li></ul><p>时间：访问虚函数时多一次内存寻址。</p><p>本质：直接调用与间接调用的区别。直接调用的跳转地址由编译器确定，间接调用则是运行到该指令时，从寄存器取出地址跳转。</p><p>直接调用不存在分支跳转，CPU直接去跳转地址去指令即可，不存在分支预测，可保证CPU流水线不被打断。</p><p>间接调用跳转地址不确定，所以可能有多个分支可能，需要分支预测器进行预测，预测失败会导致流水线冲刷，重新取指、译码，影响程序性能。</p><h2 id="18-CRTP模板"><a href="#18-CRTP模板" class="headerlink" title="18. CRTP模板"></a>18. CRTP模板</h2><p>表现：</p><ul><li>基类是模板类</li><li>派生类继承基类时，将自身作为模板参数传递给基类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T&amp; derived = <span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;Derived&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Derived class &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>static_cast从基类到派生类的转换本来是不安全的，但是CRTP的设计原则就是假设Derived会继承于Base。</p><p>在实际使用时，只使用Derived的对象，而不会直接用Base&lt; Derive &gt; 定义对象，这保证了static_cast执行时，基类指针一定指向一个子类对象。</p><p>优点：省去动态绑定、查询虚函数表带来的开销。</p><p>缺点：模板影响代码可读性。</p><p>用途：</p><ul><li>“静态多态”/静态分发：每个派生类继承的基类随模板参数不同而不同，也就是不是同一个基类，并不是严格的多态。</li><li>每个子类的计数器</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> t = <span class="keyword">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            t-&gt;op();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span> :</span> <span class="keyword">public</span> Base&lt;Derived1&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived1() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived1::op()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> :</span> <span class="keyword">public</span> Base&lt;Derived2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived2() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived2::op()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 辅助函数：完成静态分发</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DerivedClass&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helperFunc</span><span class="params">(Base&lt;DerivedClass&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">    d.func();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span>&#123;</span><br><span class="line">    Derived1 d1;</span><br><span class="line">    Derived2 d2;</span><br><span class="line">    helperFunc(d1);</span><br><span class="line">    helperFunc(d2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-模板特例化"><a href="#19-模板特例化" class="headerlink" title="19. 模板特例化"></a>19. 模板特例化</h2><p>template后加空尖括号，本质仍然是一个模板，按照最优匹配原则匹配。</p><p>类可以偏特化，函数必须全部。</p><p>偏特化：不一定只是对其中部分参数指定某个具体值，也可以是针对任何参数更进一步的条件限制的特化版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;</span>T*&gt; &#123;...&#125;; <span class="comment">// 仅适用于“T为原生指针”的情况</span></span><br></pre></td></tr></table></figure><h2 id="20-多继承与虚拟继承"><a href="#20-多继承与虚拟继承" class="headerlink" title="20. 多继承与虚拟继承"></a>20. 多继承与虚拟继承</h2><p>多继承即一个派生类指定多个基类，这样可以使一个派生类调用多个基类中的接口，但是如果出现菱形继承，派生类调用公共祖先类的接口时会出现二义性。</p><p>菱形继承关系中出现，无论基类被继承多少次，只会出现一个实体。子类会增加某种形式的指针，指向虚基类的子对象或一个相关的表格，其中存放虚基类的子对象地址或偏移量。</p><p><strong>虚继承的子类有一个虚类指针，占4字节。而且派生类会继承基类的指针，而不像虚函数一样共享一个。</strong></p><p>（虚继承还有另一种编译器的实现方式，就是放在vtable中）</p><h2 id="21-自动生成默认构造函数"><a href="#21-自动生成默认构造函数" class="headerlink" title="21. 自动生成默认构造函数"></a>21. 自动生成默认构造函数</h2><ol><li>带有默认构造函数的类成员对象</li><li>带有默认构造函数的基类</li><li>带有虚函数</li><li>带有虚基类</li></ol><p>并不是任何没有构造函数的类都会自动生成。</p><p>生成的默认构造函数中，只有基类子对象和成员类对象会被初始化。</p><h2 id="22-抽象基类"><a href="#22-抽象基类" class="headerlink" title="22. 抽象基类"></a>22. 抽象基类</h2><p>定义：带有纯虚函数的类（虚函数定义后加=0）。</p><p>作用：只能作为基类使用，不能定义对象。其纯虚函数的实现由派生类给出，如果派生类没有实现，那就仍然作为抽象类。用于定义派生类的通用接口，并强迫派生类实现这些接口（否则就不能实例化）。</p><p>很多情况下，基类本身是一个抽象概念，其生成对象是不合理的，比如图形与圆、三角。但是又需要抽象出这些图形的一些通用方法。</p><h2 id="23-自动生成拷贝构造函数"><a href="#23-自动生成拷贝构造函数" class="headerlink" title="23. 自动生成拷贝构造函数"></a>23. 自动生成拷贝构造函数</h2><ol><li>用到了<ol><li>对一个对象做显式初始化操作</li><li>对象作为参数、返回值传递</li></ol></li><li>带有有拷贝构造函数的类成员变量</li><li>带有有拷贝构造函数的基类</li><li>带有虚函数、虚基类</li></ol><h2 id="24-取类成员偏移"><a href="#24-取类成员偏移" class="headerlink" title="24. 取类成员偏移"></a>24. 取类成员偏移</h2><p>&amp;类名::成员，取到相对于类基址的偏移（而不是取其地址）</p><h2 id="25-和-调用拷贝构造函数"><a href="#25-和-调用拷贝构造函数" class="headerlink" title="25. {}和()调用拷贝构造函数"></a>25. {}和()调用拷贝构造函数</h2><ul><li>类型安全：{}是非强制转换，更安全<ul><li>int(3.14f)不会出错，而int{3.14f}会出错。</li></ul></li><li>可读性：()还可能是函数调用<ul><li>int(3.14)看起来可能是个函数，而int{3.14}没有这种歧义。</li></ul></li><li>需要强制类型转换时，应该用static_cast、reinterpret_cast</li></ul><h1 id="4-C-11"><a href="#4-C-11" class="headerlink" title="4. C++ 11"></a>4. C++ 11</h1><h2 id="1-auto与decltype"><a href="#1-auto与decltype" class="headerlink" title="1. auto与decltype"></a>1. auto与decltype</h2><h3 id="1-auto"><a href="#1-auto" class="headerlink" title="1. auto"></a>1. auto</h3><p>让编译器通过初始值进行类型推演，获得定义类型的变量。</p><ul><li>必须初始化</li><li>二义性：一行定义多个变量时，各个变量不能推导出不同auto结果，否则编译失败</li><li>限制：不能用作函数参数、非静态成员变量、数组定义、模板参数</li><li>cv限制符：在不声明为引用或指针时，auto忽略等号右边的引用类型和const/volatile；否则保留。</li></ul><h3 id="2-decltype"><a href="#2-decltype" class="headerlink" title="2. decltype"></a>2. decltype</h3><p>选择并返回操作数的数据类型，编译器只分析表达式并得到其类型，而不实际计算。</p><p>decltype(exp)规则：根据exp决定</p><ul><li>不被括号包围的表达式/类成员访问表达式/变量：与exp类型一致。</li><li>函数调用：与返回值类型一致</li><li>左值/被括号包围：exp类型引用</li><li>cv限制符：会传递const、volatile、引用，指针解引用会返回引用类型。</li></ul><p>decltype(auto)：C++14新增。声明变量以及指示函数返回类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u) &#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-左值右值"><a href="#2-左值右值" class="headerlink" title="2. 左值右值"></a>2. 左值右值</h2><p>左值：可以放到等号左边，可以取地址并且有名字</p><ul><li>函数名、变量名</li><li>返回左值引用的函数调用</li><li>前置自增自减表达式</li><li>由赋值表达式或赋值运算符连接的表达式，a=b、a+=b等</li><li>解引用表达式*p</li><li>字符串字面量”abcd”（存在常量段，可以取地址）</li></ul><p>右值：不能放到等号左边，不能取地址且没有名字</p><ul><li>纯右值prvalue：<ul><li>除字符串外的字面值</li><li>返回非引用类型的函数引用</li><li>后置自增自减表达式（因为实现是先用临时值存储，然后自增，然后返回临时值）</li><li>算术表达式</li><li>取地址表达式</li></ul></li><li>将亡值xrvalue：<ul><li>将要被移动的对象</li><li>T&amp;&amp;函数返回值</li><li>move函数返回值</li><li>转换为T&amp;&amp;类型转换函数的返回值</li></ul></li></ul><p>区分方式：能否初始化一个左值引用。</p><p>右值引用出现的意义：</p><ul><li>减少拷贝：高效传入函数参数，避免<strong>频繁使用拷贝</strong>构造函数降低效率。</li><li>转移资源：<strong>转移</strong>将亡对象申请的<strong>资源</strong>，避免资源频繁申请与释放。</li></ul><p>左值可通过move转化为右值。</p><p>右值在一系列参数为右值的函数中被传递时，会因为其被右值引用绑定，变为左值。</p><p>在成员函数后加&amp;或&amp;&amp;，可以限定其只能被左值/右值对象调用。</p><p>类型和值类别：</p><ul><li>类型指数据类型</li><li>值类别指lvalue、rvalue，rvalue可分为prvalue、xrvalue。</li></ul><p>declval&lt;T&gt;()：返回一个类型的右值引用，不管它有没有构造函数、能否创建对象（抽象基类）</p><h3 id="1-移动语义"><a href="#1-移动语义" class="headerlink" title="1. 移动语义"></a>1. 移动语义</h3><p>转让资源，通过移动构造函数（move）实现，仅对于实现了移动构造函数的类有作用。</p><p>move源码：简单来说，通过remove_reference&lt;T&gt;移除所有引用，然后加上右值引用后强制转换。</p><p>remove_reference&lt;T&gt;：对普通类型、左值引用、右值引用分别特化</p><h3 id="2-完美转发"><a href="#2-完美转发" class="headerlink" title="2. 完美转发"></a>2. 完美转发</h3><p>写一个接收任意实参的函数模板，并转发到其他函数，目标函数会收到与转发函数完全相同的实参。在定义函数模板时使用右值引用做参数，能保证参数的const属性和值类型不发生变化。</p><p>完美转发=forward+万能引用+引用折叠。</p><p>万能引用：模板 + T&amp;&amp;，会将传进来的左值推导成左值引用，右值推导成右值引用。</p><p>forward 规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"> <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line"> forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line"> &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p>简单来说，参数传成左值，return右值，通过引用折叠保证不变。（引用不会变，而常量会变为右值引用）</p><ul><li>碰到右值int &amp;&amp;，T匹配成int</li><li>碰到左值int，T匹配成int&amp;</li><li>碰到左值const int，T匹配成const int &amp;</li><li>碰到左值const int *，T匹配成const int *&amp;</li><li>碰到左值cosnt int* const，T匹配成const int *const &amp;</li></ul><p>完美转发一般的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line">print(<span class="built_in">std</span>::forward&lt;T&gt;(v)); <span class="comment">// print有T&amp;与T&amp;&amp;两个重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-bind和function"><a href="#3-bind和function" class="headerlink" title="3. bind和function"></a>3. bind和function</h2><p>bind：将可调用对象和参数一起绑定，绑定结果使用function进行保存，延迟调用到任何需要的时候。还可以只绑定一部分参数，剩余参数使用placeholders(_1, _2, _3)表示正式调用时将第几个参数传入对应的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">std</span>::bind(f, _3, <span class="built_in">std</span>::bind(g, _3), _3, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">f2(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);  <span class="comment">// 相当于 f(12, g(12), 12, 4, 5);</span></span><br></pre></td></tr></table></figure><p>function：可调用对象的封装器。</p><p>可调用对象：</p><ul><li>函数指针</li><li>具有operator()成员函数的类对象（仿函数）、lambda表达式</li><li>可被转换成函数指针的类对象</li><li>类成员（函数）指针</li><li>bind表达式结果</li></ul><h2 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h2><p>智能指针：封装常规指针，能在销毁时自动释放指向的对象。</p><p><strong>代理模式+RAII思想</strong>。</p><p>迭代器就是一种智能指针。</p><h3 id="1-shared-ptr"><a href="#1-shared-ptr" class="headerlink" title="1. shared_ptr"></a>1. shared_ptr</h3><p>使用了引用计数，每一个共享指针的拷贝都指向相同内存，每次拷贝计数+1，每次析构计数-1，计数为0内存才释放。引用计数采用int*方式实现，使用了原子操作。</p><p>shared_ptr内部还会维护一个weak_count。只要weak_count不为0，即使shared_count为0控制块也不会释放，但此时调用weak_ptr的lock就会返回空指针。</p><ul><li>不要用一个裸指针初始化多个共享指针，会导致引用计数只有1，出现多次释放。</li><li>通过shared_from_this返回this指针，而不是直接作为shared_ptr返回，因为可能导致重复析构，不能把this交给智能指针管理。</li><li>尽量用make_shared初始化</li><li>不要delete get到的裸指针</li><li>同一个共享指针被多个线程写是不安全的。</li><li>避免循环引用（使用weak_ptr）</li></ul><h3 id="2-weak-ptr"><a href="#2-weak-ptr" class="headerlink" title="2. weak_ptr"></a>2. weak_ptr</h3><p>作为旁观者监视shared_ptr中管理的资源是否存在。</p><ul><li>只读</li><li>指向的资源不一定是可用的</li><li>使用前需要用lock()/expired()检查是否为空。</li></ul><p>shared_from_this就是通过weak_ptr返回的this指针。</p><p>解决循环引用问题。</p><p>应用：消息订阅机制；缓存对象。</p><h3 id="3-unique-ptr"><a href="#3-unique-ptr" class="headerlink" title="3. unique_ptr"></a>3. unique_ptr</h3><p>不允许其他智能指针共享内部指针，也不允许unique_ptr拷贝和复制，但可以拷贝与赋值一个将要被销毁的unique_ptr。可通过C++ 11的delete关键字，禁止自动生成拷贝构造函数实现。</p><h2 id="5-default、delete与explicit"><a href="#5-default、delete与explicit" class="headerlink" title="5. default、delete与explicit"></a>5. default、delete与explicit</h2><p>default：ClassType() = default生成默认构造函数</p><p>delete：如果没有定义特殊成员函数，编译器在需要这些函数时会隐式自动生成，如拷贝构造函数、拷贝赋值操作符。A(const A&amp;) = delete可禁止拷贝构造。unique_ptr即通过此实现。</p><p>explicit：修饰构造函数，只能显式构造而不能隐式转换。</p><h2 id="6-constexpr"><a href="#6-constexpr" class="headerlink" title="6. constexpr"></a>6. constexpr</h2><p>修饰的表达式在编译期间就会被计算出来，整个运行过程中都不可以改变。</p><p>修饰变量：</p><ul><li>变量为const常量，使用常量表达式初始化。</li><li>修饰的变量同时也是const。</li></ul><p>constexpr定义指针只对指针有效。</p><p>修饰函数：</p><ul><li>函数体除了using、typedef与static_assert外，只能有一条return。</li><li>必须有返回值，不为void。返回值必须为常量表达式。</li><li>使用前必须有定义，不能用声明代替。</li><li>可以是递归。</li></ul><p>修饰构造函数：</p><ul><li>所有成员用初始化列表初始化，并用常量表达式赋值，函数体为空。</li><li>成员函数必须用constexpr修饰，对象实例化也必须为constexpr。</li></ul><p>修饰模板函数：如果模板实例化后不满足上面对函数的要求，就当作普通函数处理。</p><p>修饰if表达式：if的条件需要在编译期计算出来，如通过模板判断是否为T类型等。</p><p>与const区别：大部分情况下等价。const表示“只读”的语义，而constexpr表示“常量”的语义。</p><p>const只读可以通过常引用的变量修改其值。</p><h2 id="7-lambda表达式"><a href="#7-lambda表达式" class="headerlink" title="7. lambda表达式"></a>7. lambda表达式</h2><p>lambda表达式的方括号提供闭包功能。</p><p>lambda表达式实际上是一个仿函数。每定义后，编译器会自动生成一个匿名类，且重载了()运算符，称为闭包类型。运行时即为生成一个该类型的匿名对象，调用()操作符。</p><p>可以通过传值或引用的方式捕捉其封装作用域内的变量。值捕获为lambda表达式<strong>创建时</strong>捕获，而非调用时。可以加mutable来修改值捕获的变量，但是修改的是拷贝的，不影响外面。哪种方式都能修改全局变量。</p><h3 id="1-C-14-新特性"><a href="#1-C-14-新特性" class="headerlink" title="1. C++ 14 新特性"></a>1. C++ 14 新特性</h3><h4 id="1-捕捉表达式"><a href="#1-捕捉表达式" class="headerlink" title="1. 捕捉表达式"></a>1. 捕捉表达式</h4><p>方括号内可以用表达式初始化捕捉的变量。</p><p>该特性可以通过move捕捉到unique_ptr，因为其不允许复制，无法以值方式捕捉。</p><h4 id="2-泛型lambda表达式"><a href="#2-泛型lambda表达式" class="headerlink" title="2. 泛型lambda表达式"></a>2. 泛型lambda表达式</h4><p>将类型指定为auto，类型推断规则与函数模板一样。</p><h2 id="8-nullptr"><a href="#8-nullptr" class="headerlink" title="8. nullptr"></a>8. nullptr</h2><p>是nullptr_t类型（指针空值类型）的右值常量。不是指针类型，但可以隐式转换成任何一种指针类型。</p><p>作用：代替NULL。</p><p>NULL在重载函数的参数分别为int、char*会产生歧义，因为不知道该把NULL解析成0还是空指针。</p><p>但是nullptr在重载函数参数为不同类型的指针时还是会产生歧义。</p><p>与NULL区别：</p><ul><li>NULL是宏定义(void*)0，C++中为0，编译器优先将其当成整型常量；nullptr为编译期常量，类型为nullptr_t，不是整型也不是指针类型。</li><li>模板推导时NULL会被推导为整型，而nullptr被推导为原类型。</li><li>重载时NULL会在整型与指针型间产生歧义。</li></ul><h2 id="9-列表初始化"><a href="#9-列表初始化" class="headerlink" title="9. 列表初始化"></a>9. 列表初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;d&#125;; <span class="comment">// 存在丢失信息风险，转换未执行，编译器报错</span></span><br><span class="line"><span class="keyword">int</span> a = d; <span class="comment">// 丢失信息，转换执行</span></span><br></pre></td></tr></table></figure><h2 id="10-array"><a href="#10-array" class="headerlink" title="10. array"></a>10. array</h2><p>定长数组。<code>array&lt;int, 5&gt; b</code>。</p><p>可用{}初始化、拷贝构造，不能用内置数组[]构造。</p><p>提供迭代、随机访问、头尾访问、[]。</p><h2 id="11-多线程"><a href="#11-多线程" class="headerlink" title="11. 多线程"></a>11. 多线程</h2><p><a href="https://blog.csdn.net/sjc_0910/article/details/118861539">参考</a></p><h3 id="1-thread"><a href="#1-thread" class="headerlink" title="1. thread"></a>1. thread</h3><p>代替pthread</p><p>方法：</p><ul><li>构造函数：默认、初始化（传入一个函数以及需要的参数）、移动。（复制构造函数为delete）</li><li><code>join()</code>：等待线程结束并回收资源。（不是开始线程，线程在创建时就开始执行了）</li><li><code>joinable()</code></li><li><code>detach()</code>：将线程与调用其的线程分离，彼此独立执行。（分离的线程会在调用其的线程结束或自己结束时释放资源）（只能在线程创建时调用，且让线程不能再join）</li><li><code>get_id()</code></li><li>赋值</li></ul><p>初始化构造函数为 <code>template &lt;class Fn, class… Args&gt; explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;… args)</code>，右值引用显然不能传入左值，所以要借助ref与cref方法包装，分别包装按引用传递的值、按const引用传递到值。</p><p>注意点：</p><ul><li>线程会在函数运行完毕后自动释放，且不推荐其他释放方式。</li><li>必须执行join或detach，否则程序结束会引发异常。</li><li>join不是开始线程，线程在创建时就开始了。</li></ul><h3 id="2-mutex"><a href="#2-mutex" class="headerlink" title="2. mutex"></a>2. mutex</h3><p>代替mutex_t。</p><ul><li><code>lock()</code></li><li><code>unlock()</code></li><li><code>try_lock()</code>（如果未被上锁，则上锁并返回true）</li></ul><p>问题：一次只有一个线程能获得锁，还需要加锁解锁，太慢了。</p><h3 id="3-atomic"><a href="#3-atomic" class="headerlink" title="3. atomic"></a>3. atomic</h3><p>将变量改为atomic类型，让多线程必须同步操作该对象，避免锁机制的巨大开销。</p><p>a++与int a = b实际上都是线程不安全的，因为会被拆分成多条汇编指令。（int a = b不能直接拷贝，必须借助寄存器中转）</p><p>原子操作：</p><ul><li><code>load(val, order)</code>：读取值<ul><li>order：memory_order_relaxed/memory_order_consume/memory_order_acquire/memory_order_seq_cst</li></ul></li><li><code>store(val, order)</code>：存储值。<ul><li>order：memory_order_relaxed/memory_order_release/memory_order_seq_cst</li></ul></li></ul><p>不能通过atomic&lt;int&gt; v = 99初始化，因为拷贝构造函数通过delete禁止生成。（有初始化构造函数）</p><p>原理：即为两个保证CPU缓存一致性的方法</p><ul><li>锁总线（总线嗅探）。其他cpu无法通过总线读写。</li><li>锁cache（MESI）。执行操作的CPU将自身cache里的原子变量设为独占，并lock；其他cpu将原子变量所在缓存无效。cpu修改完后，unlock。</li></ul><p>应用：无锁队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出当前atomic对象指向的值</span></span><br><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// CAS，如果内存中的值和参数一相同，那么替换为参数二，成功返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val,</span></span></span><br><span class="line"><span class="function"><span class="params">           memory_order sync = memory_order_seq_cst)</span> <span class="keyword">volatile</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockFreeQueue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">T _value;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Node*&gt; _next;</span><br><span class="line">Node(<span class="keyword">const</span> T&amp; x)</span><br><span class="line">: _value(x)</span><br><span class="line">, _next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">LockFreeQueue() &#123;</span><br><span class="line">_head = _tail = <span class="keyword">new</span> Node(T());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LockFreeQueue(<span class="keyword">const</span> LockFreeQueue&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">~LockFreeQueue() &#123;</span><br><span class="line">Node* cur = _head;</span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Enqueue</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> Node(x);</span><br><span class="line">Node* oldtail = <span class="literal">nullptr</span>;</span><br><span class="line">Node* nullnode = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">oldtail = _tail.load();</span><br><span class="line">&#125; <span class="keyword">while</span> (oldtail-&gt;_next.compare_exchange_weak(nullnode, newnode) != <span class="literal">true</span>);</span><br><span class="line">_tail.compare_exchange_weak(oldtail, newnode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">Dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node* oldhead = _head.load();</span><br><span class="line">T headvalue;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">Node* next = oldhead-&gt;_next;</span><br><span class="line"><span class="keyword">if</span> (next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> T();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">headvalue = next-&gt;_value;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span> (_head.compare_exchange_weak(oldhead, oldhead-&gt;_next) != <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> oldhead;</span><br><span class="line"><span class="keyword">return</span> headvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head.load() == _tail.load();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Node*&gt; _head;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Node*&gt; _tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-async"><a href="#4-async" class="headerlink" title="4. async"></a>4. async</h3><p>定义在future头文件中，是个函数，返回值为future类型。相较于thread，可根据情况同步执行或创建新线程异步执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fn</span>, <span class="keyword">class</span>… <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="built_in">future</span>&lt;<span class="keyword">typename</span> result_of&lt;Fn(Args…)&gt;::type&gt;</span><br><span class="line">    async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;… args);</span><br></pre></td></tr></table></figure><p>policy：</p><ul><li>launch::async(0x1)：异步启动</li><li>launch::deferred(0x2)：调用future::get、future::wait时同步启动。实际上不创建线程，而是在本线程中运行。</li><li>launch::async | launch::deferred(0x3)：根据操作系统而定。系统资源紧张时会用同步启动。</li></ul><p>第一个参数也可省略，默认为0x3。</p><h3 id="5-future"><a href="#5-future" class="headerlink" title="5. future"></a>5. future</h3><p>定义 <code>future&lt;T&gt;</code>类型的对象val接收async的返回值（T为async传入函数的返回值类型），然后调用val.get()阻塞等待线程结束，并获取其返回值。</p><p>future对象没有复制构造函数。</p><p>成员函数：</p><ul><li><code>T get()</code>：阻塞等待线程结束并获取返回值。</li><li>类型为引用： <code>R&amp; future&lt;R&amp;&gt;::get()</code>：若类型为void，与wait相同。</li><li>类型为void：<code>void future::get()</code>：只能调用一次。特化void的原因：future作用不只有获取返回值，还可以检测线程是否已结束、阻塞等待。</li><li><code>void wait() const</code>：阻塞等待线程结束。</li><li><code>template &lt;class Rep, class Period&gt; future_status wait_for(const chrono::duration&lt;Rep,Period&gt;&amp; rel_time) const;</code>：阻塞等待rel_time，如果这段时间内线程结束，返回 <code>future_status::ready</code>，否则返回 <code>future_status::timeout</code>；如果async以 <code>launch::deferred</code>启动，不阻塞立即返回 <code>future_status::deferred</code>。</li></ul><h3 id="6-promise"><a href="#6-promise" class="headerlink" title="6. promise"></a>6. promise</h3><p>获得thread的返回值。实际上是作为引用参数，通过引用返回值。</p><p>promise是future的一个包装，不改变已有future的值，而是创建新的future对象。</p><p>同样没有复制构造函数。</p><p>成员函数：</p><ul><li><code>set_value</code>：与future的特化差不多。设置promise的值并设置 <code>future_status::ready</code>。void特化：只讲共享状态设置为ready。</li><li><code>get_future()</code>：重新构造一个future对象，值和状态都与promise相同。</li></ul><p>然后，将其作为函数的一个参数引用传递，线程运行完后通过 <code>val.get_future().get()</code>获得返回值。</p><h3 id="7-this-thread"><a href="#7-this-thread" class="headerlink" title="7. this_thread"></a>7. this_thread</h3><p>一个命名空间。通过 <code>this_thread::func()</code>调用。</p><p>函数：</p><ul><li><code>get_id()</code></li><li><code>template&lt;class Rep, class Period&gt; void sleep_for( const std::chrono::duration&lt;Rep, Period&gt;&amp; sleep_duration)</code>：等待sleep_duration这段时间，如 <code>chrono::seconds(1)</code></li><li><code>void yield() noexcept</code>：暂时放弃线程执行，将主动权交出。</li></ul><h3 id="8-lock-guard"><a href="#8-lock-guard" class="headerlink" title="8. lock_guard"></a>8. lock_guard</h3><p>mutex封装类。</p><p>当对象被创建后，就会尝试获得给到他的mutex的所有权。当控制权不在该对象被创建的范围后，对象被析构，mutex被释放。</p><p>可带第二个参数：</p><ul><li>adopt_lock：该互斥量已被lock。假设一方已经lock成功，就通知lock_guard不需要再在构造函数中lock mutex，用这个参数的前提是自己需要先lock mutex。</li><li>try_to_lock：尝试lock mutex，没成功则立即返回，用这个参数的前提是自己不能先lock。</li><li>defer_lock：初始化一个没加锁的mutex。用这个参数的前提是不能自己先lock，否则报异常。</li></ul><h3 id="9-unique-lock"><a href="#9-unique-lock" class="headerlink" title="9. unique_lock"></a>9. unique_lock</h3><p>与lock_guard的区别：可以中途用unlock解锁，如果析构时发现已经解锁则没有操作。lock_guard只能在析构时解锁。</p><p>需要额外存储锁的状态，效率稍差。</p><p>第二个可选参数：</p><ul><li>std::adpot_lock：在创建unique_lock前，传入的mutex已上锁。<ul><li>必须自己先lock</li></ul></li><li>std::try_to_lock：没有锁定成功也会立即返回，不随阻塞。<ul><li>自己不能先lock</li></ul></li><li>std::defer_lock：初始化不加锁。<ul><li>自己不能先lock。</li></ul></li></ul><h3 id="10-condition-variable"><a href="#10-condition-variable" class="headerlink" title="10. condition_variable"></a>10. condition_variable</h3><p>condition_variable：有默认构造函数，拷贝构造函数被删除。</p><p>方法：</p><ul><li><code>wait(unique_lock)</code>：阻塞。</li><li><code>wait(unique_lock, lambda)</code>：lambda表达式返回false时阻塞。</li><li><code>wait_for(unique_lock, chrono::time_point)</code>：阻塞一段时间。</li><li><code>wait_for(unique_lock, chrono::time_point, lambda)</code>：lambda返回false时阻塞一段时间。</li><li><code>notify_one()</code>：唤醒第一个阻塞在条件变量上的线程。</li><li><code>notify_all()</code>：唤醒所有。</li></ul><p>虚假唤醒/惊群现象：多个线程被唤醒，但是条件只支持一个线程运行。</p><p>condition_variable_any：可以和任何满足条件的互斥量一起工作，会产生额外开销。</p><h3 id="11-packaged-task"><a href="#11-packaged-task" class="headerlink" title="11. packaged_task"></a>11. packaged_task</h3><p>与function类似，绑定一个可调用对象并执行，但返回类型是void，必须用get_future获取返回值。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 如何给它传入固定参数, 而不必在调用时指定</span><br><span class="line">    std::packaged_task&lt;int(int)&gt; t(factorial);</span><br><span class="line">    std::packaged_task&lt;int()&gt; t(std::bind(factorial, 6));</span><br><span class="line"></span><br><span class="line">    // do something else</span><br><span class="line"></span><br><span class="line">    t(); // in a different context， always return void</span><br><span class="line">    int x = t.get_future().get();</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于把一个可调用对象链接到未来，用于多线程执行。</p><h2 id="12-可变参数模板"><a href="#12-可变参数模板" class="headerlink" title="12. 可变参数模板"></a>12. 可变参数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vair_fun</span><span class="params">(T...args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解包方式：</p><p>递归：必须要设置一个出口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vir_fun</span><span class="params">()</span> </span>&#123; <span class="comment">// 模板函数递归的出口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vir_fun</span><span class="params">(T argc, args... argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; argc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    vir_fun(argv...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vir_fun(<span class="number">1</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>, <span class="number">2.34</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非递归：第7行对每个参数展开为 <code>(display(arg), 0)</code>，意思是先计算display(arg)，然后将0作为表达式的值返回给数组。arr只是为了将参数展开。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vir_fun</span><span class="params">(args... argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; (display(argv), <span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vir_fun(<span class="number">1</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>, <span class="number">2.34</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="13-align"><a href="#13-align" class="headerlink" title="13. align"></a>13. align</h2><h3 id="1-alignof"><a href="#1-alignof" class="headerlink" title="1. alignof"></a>1. alignof</h3><p>返回指定类型的对齐方式</p><ul><li>对基础类型：与sizeof用法相同</li><li>对类：返回其对齐方式</li></ul><h3 id="2-alignas"><a href="#2-alignas" class="headerlink" title="2. alignas"></a>2. alignas</h3><p>用在struct关键字后面或基本类型数组前面，跟#pragma pack(n)作用相同，约束也一样</p><ul><li>偏移量为n和当前变量大小较小值的整数倍。</li><li>结构体大小为n和最大变量大小较小值的整数倍。</li><li>n必须为2的幂，为其他值则语句失效。</li></ul><h3 id="3-align-storage"><a href="#3-align-storage" class="headerlink" title="3. align_storage"></a>3. align_storage</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="built_in">std</span>::<span class="keyword">size_t</span> Len, <span class="built_in">std</span>::<span class="keyword">size_t</span> Align = <span class="comment">/*default-alignment*/</span> &gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">aligned_storage_t</span> = <span class="keyword">typename</span> aligned_storage&lt;Len, Align&gt;::type;</span><br></pre></td></tr></table></figure><p>提供对齐存储</p><h3 id="4-align"><a href="#4-align" class="headerlink" title="4. align"></a>4. align</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param  alignment 是想要分配的内存符合的内存对齐大小</span></span><br><span class="line"><span class="comment">/// @param  size 想要分配内存的大小</span></span><br><span class="line"><span class="comment">/// @param  ptr 是个输入输出参数，输入时指向待使用的内存，输出时调整为符合alignment对齐要求的内存地址</span></span><br><span class="line"><span class="comment">/// @param  space 是ptr指向的内存剩余的空间</span></span><br><span class="line"><span class="comment">/// @return 如果 ptr 经过调整后能满足大小为 alignment 的对齐要求，则返回ptr的值，否则返回 nullptr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">align</span><span class="params">( <span class="built_in">std</span>::<span class="keyword">size_t</span> alignment,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::<span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span>*&amp; ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::<span class="keyword">size_t</span>&amp; space)</span></span>;</span><br></pre></td></tr></table></figure><p>一般用在分配buffer空间中。</p><h1 id="5-STL"><a href="#5-STL" class="headerlink" title="5. STL"></a>5. STL</h1><h2 id="1-STL标准模板库"><a href="#1-STL标准模板库" class="headerlink" title="1. STL标准模板库"></a>1. STL标准模板库</h2><p>C++ STL包括：</p><ul><li>算法：排序、复制等常用算法，以及不同容器特定的算法。</li><li>容器：数据的存放形式，包括序列式容器和关联式容器。<ul><li>序列式：以线性排列存储某一指定类型的数据。vector、deque、list。</li><li>关联式：在存储元素值时还会额外配备一个键，可直接通过键值找到目标元素。set、map。</li></ul></li><li>迭代器：在不暴露容器内部结构的情况下对容器的遍历。提供一个遍历容器元素的接口，因此内部必须保存与容器相关联的指针，然后重载*、-&gt;、++、–等运算来遍历。</li><li>仿函数：类中实现operator()，从而使该类的使用看上去像一个函数。</li><li>适配器：使一种事物的行为类似于另外一种事物行为的机制。迭代器适配器、函数适配器、容器适配器。queue、priority_queue、stack。其所有操作围绕类里的Sequence底层容器实现，stack、queue默认为deque，priority_queue默认为vector，通过封装<strong>heap系列算法</strong>实现。其元素进出必须符合一定规则，所以没有迭代器。</li><li>分配器：allocator空间管理。</li></ul><p>交互关系：</p><ul><li>容器通过分配器取得数据存储空间。</li><li>算法通过迭代器存储容器的内容。</li><li>仿函数协助算法完成不同的策略变化。</li><li>适配器可修饰容器、仿函数。</li></ul><p>特点：</p><ul><li>数据结构和算法分离，迭代器充当两者交互的中间件，如 <code>sort(arr.begin(), arr.end(), greater&lt;int&gt;)</code>。</li><li>高可复用性：不面向对象。为了具有足够通用性，STL主要依赖模板。</li><li>高性能。</li><li>高移植性：用STL编写的模块可跨项目移植。</li></ul><h2 id="2-内存配置器与内存池"><a href="#2-内存配置器与内存池" class="headerlink" title="2. 内存配置器与内存池"></a>2. 内存配置器与内存池</h2><p>new、malloc等申请内存的问题在于，由于每次申请的大小不定，频繁使用时会造成大量内存碎片降低性能。</p><p>内存池在真正使用内存之前，先申请分配一定数量、大小相等的内存块备用。有新的内存需求时就分出一部分内存块。</p><p>STL内存池使用双层级配置器。<strong>通过宏指定默认</strong>为第一级配置器还是第二级配置器。</p><p>第一级配置器只对malloc进行了一层封装，还是有碎片化问题。大内存块（大于128bytes）使用第一级配置器。</p><ul><li>allocate（封装的malloc，如果调用不成功则调用oom_malloc）与realloc（封装realloc，不成功则调用oom_realloc）分配内存，成功直接返回，失败调用处理函数</li><li>如果用户自定义了分配错误处理函数_malloc_alloc_oom_handler就调用，否则返回异常</li><li>如果处理函数处理完了，就再分配试试</li></ul><p>第二级配置器内置了轻量级内存池。对于小内存块申请，从空闲链表与内存池中分配。对于大内存块申请，移交第一级配置器。</p><p>用数组维护16条链表，最小8字节且以8字节逐渐递增，最大128字节。</p><ul><li>传入需要的内存字节数后，将所需内存大小上调至8倍数边界，找到对应的节点，查看是否为空，如果不为空则直接从对应的free_list中拔出，将拔出的指针后移一位。</li><li>如果free_list为空，调用refill，逻辑为：先看其内存池是否为空，如果不为空<ul><li>先调用chunk_alloc尝试拿20块内存（所需内存大小（上调后）*20），足够拿20个则其中一个分配给用户，另外19个挂在相应的free_list下。</li><li>如果不够20个节点大小，查看是否满足1个节点大小，如果足够则直接拿出一个给用户，剩下的空间分配尽可能多节点挂在相应的free_list下。</li><li>如果1个节点都不够，直接将剩余空间挂在free_list下（先查找到相应的），然后malloc给内存池申请内存，继续。</li></ul></li><li>内存池申请：chunk_alloc<ul><li>内存池为空且申请了内存，第二级配置器使用malloc从heap上申请内存，一次申请2 * 所需节点内存大小 * 20 + 一段额外空间，申请40块，一半拿来用（19+1），一半放内存池中。</li><li>malloc没成功，从<strong>比所需节点空间大的free_list</strong>中搜索，从中拔出一个节点用。</li><li>还是没成功，调用第一级配置器，期望获得内存分配给内存池。（第一级配置器有oom处理机制，将分配失败丢给第一级配置器处理）</li><li>如果没有因为异常终止，则在return时递归调用自己，再次尝试分配。</li></ul></li></ul><p>缺点：</p><ul><li>空间只能为8字节的倍数，引入内部碎片问题。</li><li>自由链表上的空间在进程结束前不会还给操作系统，如果不断开辟小块内存，最后整个堆的空间都会被挂在链表上，导致开辟大块内存失败；别的进程申请不到空间，也不能用当前进程的空闲内存，从而引发问题。</li></ul><h2 id="3-deque"><a href="#3-deque" class="headerlink" title="3. deque"></a>3. deque</h2><p>deque是容器而不是适配器。</p><p>deque的底层结构比vector复杂得多，是多段连续的内存空间，这些空间通过map管理，对外保持整体连续的假象。</p><p>map中每一个value都是指向一片连续空间的指针，称为缓存区，用来真正存储数据。</p><p>deque还维护了start与finish两个迭代器，分别表示begin与end。迭代器内部维护这块连续空间的开头与结尾，以及这块空间大小。初始指向申请空间的中心，为了留出两边插入元素的空间按。</p><p>与vector的差别：</p><ul><li>deque允许常数时间对头部增删元素</li><li>deque没有capacity的概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间连接起来。这些空间用一块map管理。</li></ul><p>使用场景：既需要头尾两端插入元素，又需要随机存取功能。（但是deque随机存取效率低，因为可能存在空间之间的跳跃）</p><h2 id="4-hashtable"><a href="#4-hashtable" class="headerlink" title="4. hashtable"></a>4. hashtable</h2><p>STL中的hashtable使用开链法解决冲突问题。其他解决方式还有线性探测、二次探测、再散列、公共溢出区。</p><p>即散列相同的数据存储在一个桶里，桶用其自己定义的hashtable_node组成的链表维护，桶本身用vector进行存储。</p><p>其内置了28个质数，如果hashtable内元素数目超过了当前选择的质数，就找出下一个比当前数目大的质数，重建table。</p><h2 id="5-type-traits类型萃取"><a href="#5-type-traits类型萃取" class="headerlink" title="5. type traits类型萃取"></a>5. type traits类型萃取</h2><p><a href="https://zhuanlan.zhihu.com/p/547313994">类型萃取</a></p><p>作用：提供编译器的计算、判断、转换、查询功能，与编译器的true/false。避免运行时再判断，提高程序效率。</p><p>利用类模板偏特化，如果匹配到偏特化类模板，就匹配到true_type的子类，否则匹配到一般类模板，false_type的子类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">v</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_constant</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> T value = v; </span><br><span class="line">  <span class="comment">// static和constexpr缺一不可，表示在编译器确定 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> b&gt;</span><br><span class="line"><span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="keyword">bool</span>,b&gt;; </span><br><span class="line"><span class="comment">// using代替typedef，c++11特性</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> bool_constant&lt;<span class="literal">true</span>&gt; true_type; <span class="comment">// true_type中value被初始化为true，false_type中value则为false</span></span><br><span class="line"><span class="keyword">typedef</span> bool_constant&lt;<span class="literal">false</span>&gt; false_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_same</span> :</span> <span class="keyword">public</span> false_type &#123;&#125;;</span><br><span class="line"><span class="comment">// 主模板</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_same</span>&lt;</span>_Tp, _Tp&gt; : <span class="keyword">public</span> true_type &#123;&#125;; <span class="comment">// 如果T与U类型相同，即符合偏特化模板，会优先套用偏特化模板</span></span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="title">bool</span> =</span> is_same&lt;T, U&gt;::value &gt; <span class="comment">// 默认模板参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;they are different type&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&lt;</span>T, U, <span class="literal">true</span>&gt; &#123; <span class="comment">// 偏特化版本</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;they are same type&quot;</span>);</span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>定义内嵌型别与原生指针都有trivial的默认构造函数、拷贝构造函数、赋值操作符、析构函数且是POD类型。然后可在如分配空间后的初始化函数中，通过类似迭代器萃取advance函数那样传递调用。自定义类可自己实现特化的type traits，防止其使用默认的保守type traits。</p><p>一般如果class内含有指针成员且进行了动态配置，就要实现non_trivial_xxx。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_assignment;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;</span><span class="keyword">char</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_assignment;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另一个应用：SFINAE（Substitution Failure Is Not An Error）替换失败并非错误特性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectX</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fallback</span> &#123;</span> <span class="keyword">int</span> X; &#125;; <span class="comment">// add member name &quot;X&quot;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> T, Fallback &#123; &#125;; <span class="comment">//多继承T和Fallback</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, U&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Check</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span> ArrayOfOne[<span class="number">1</span>];  <span class="comment">// typedef for an array of size one.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span> ArrayOfTwo[<span class="number">2</span>];  <span class="comment">// typedef for an array of size two.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayOfOne &amp; <span class="title">func</span><span class="params">(Check&lt;<span class="keyword">int</span> Fallback::*, &amp;U::X&gt; *)</span></span>; <span class="comment">// 如果T中也有X，那么由于&amp;U::X会出现二义性，func第一个重载匹配会失败，转而匹配第二个重载，导致得到ArrayOfTwo类型，即长度为2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayOfTwo &amp; <span class="title">func</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> DetectX type;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> IsMemberExist = <span class="keyword">sizeof</span>(func&lt;Derived&gt;(<span class="number">0</span>)) == <span class="number">2</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-扩容机制-reserve与resize"><a href="#6-扩容机制-reserve与resize" class="headerlink" title="6. 扩容机制 reserve与resize"></a>6. 扩容机制 reserve与resize</h2><p>以vector为例。</p><p>vector实际上维护三个迭代器：begin、finish（end()方法的返回值）与end_of_storage（空间的结束）。</p><p>size为finish - begin，capacity为end_of_storage - begin。</p><p>reserve改变capacity。可以预先分配一块内存，在空间未满时不糊引起重新分配，提高了效率。但是，这些内存空间可能仍不能访问，用[]访问可能越界。</p><p>resize改变size。</p><p>capacity返回容器总空间大小，size返回已用空间大小，如果两者相等说明vector目前的空间已经用完，再添加新元素会引起空间动态增长。</p><p>成倍扩容的原因：指数增长比线性增长快，扩充指定大小时，倍数扩容每次所需的均摊时间复杂度是常数，而等长扩容是线性。</p><p>选择1.5倍或2倍的原因：按照小于2倍的方式（1.5倍）扩容，多次扩容后可以重用之前开辟的空间。</p><p>linux按2倍方式扩容：引入伙伴系统分配内存，将整个内存区域构建成基本大小basicsize的2的幂次倍大小，向上取整取空闲分区分配。伙伴即为同一块内存分成的两块大小相等的内存，回收空间时会检查其伙伴是否空闲，如果空闲则合并这两块。</p><p>vs按1.5倍：堆管理系统会对释放的堆块进行合并。</p><h2 id="7-unordered-map与map"><a href="#7-unordered-map与map" class="headerlink" title="7. unordered_map与map"></a>7. unordered_map与map</h2><ul><li>底层实现：unordered_map是哈希表，map是红黑树。使用前者要求类型定义了计算哈希的函数以及重载了==，使用后者要求类型重载了&lt;。</li><li>有无序：前者无序存储，后者按key有序。</li><li>复杂度：前者能在常数复杂度内完成插入，但不稳定，极端情况下可能为线性复杂度；后者需要对数复杂度。</li></ul><h2 id="8-迭代器"><a href="#8-迭代器" class="headerlink" title="8. 迭代器"></a>8. 迭代器</h2><p>容器对应的迭代器</p><ul><li>随机访问迭代器：vector、deque</li><li>双向迭代器：list、(multi)set/map</li><li>前向迭代器：unordered_(multi)set/map、forward_list</li><li>无：容器适配器</li></ul><p>迭代器与萃取：详细的可以看看STL源码剖析121页</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type; <span class="comment">// 将迭代器I中的value_type萃取出来，用于函数的返回值定义等</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果I不是类成员呢，而是原生指针呢？要怎么获取value_type，也就是指针指向的值？</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>I*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> I value_type; <span class="comment">// 定义原生指针的偏特化模板，只有指针能匹配到这个模板</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果传入的是const该怎么匹配</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> I*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> I value_type; <span class="comment">// 定义原生指针的偏特化模板，只有指针能匹配到这个模板</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> iterator_traits&lt;I&gt; <span class="title">func</span><span class="params">(I iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *iter; <span class="comment">// I为迭代器，重载了*方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果迭代器要想使用STL算法，就应该这提供五个内嵌型别。自定义迭代器可继承iterator</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Category, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Distance = <span class="keyword">ptrdiff_t</span>, <span class="keyword">typename</span> Pointer = T*, <span class="keyword">typename</span> Reference = T&amp;&gt;</span><br><span class="line">struct iterator  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;; <span class="comment">// 一般的迭代器应该提供的型别，后三种有默认值</span></span><br><span class="line"><span class="comment">// 编写自定义迭代器，可继承iterator类，传入迭代策略Category与存储的数据类型T，然后重载相应方法即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type; <span class="comment">// 计算两个迭代器的距离</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对原生指针的特化（const懒得写了）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>I*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> I value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> I* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> I&amp; reference; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>iterator_category：</p><ul><li>input iterator：只读。支持==、!=、++、*、-&gt;</li><li>output iterator：只写。支持++、*</li><li>forward iterator：允许写入型算法在这种迭代器形成的区间上进行读写操作。支持input/output。</li><li>bidirectional iterator：可双向移动。支持forward与-操作。</li><li>random access iterator：支持bidirectional，并允许随机移动，比如p+n/p-n/p[n]/p1-p2/p1&lt;p2</li></ul><p>强化关系：1、2 &lt; 3 &lt; 4 &lt; 5，较弱的迭代策略形参一定能接收较强的迭代策略实参，类似于父子类。</p><p>作用：advance(p, n)为将迭代器p前进n步。一般的实现方式是，通过if-else语句判断p的类型，然后根据类型调用不同的迭代策略advance函数。但是，需要运行时判断，效率低。</p><p>advance只需要提供两个参数，作为对外开放的接口，内部通过traits机制提取出迭代器类型，并将工作转交给__advance完成。原生指针通过traits机制获得random_access_iterator_tag作为迭代策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> &#123;</span>&#125;: <span class="keyword">public</span> input_iterator_tag;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span>&#123; <span class="comment">// 命名为InputIterator：按照能支持的最底层的迭代器命名，因为能支持该种迭代器，说明一定能支持比其更高层的</span></span><br><span class="line">    __advance(i, n, iterator_traits&lt;I&gt;::iterator_category());<span class="comment">// 第三个参数产生一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(InputIterator&amp; i, Distance n, input_iterator_tag) &#123; <span class="comment">// 不需要第三个参数，只是拿来区分重载，所以不用命名</span></span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(RandomAccessIterator i, Distance n, random_access_iterator_tag) &#123;</span><br><span class="line">    i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SGI STL还提供了函数决定迭代器的内嵌型别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">telmpate &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category <span class="title">iteratory_category</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> category();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> itrator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-迭代器失效"><a href="#9-迭代器失效" class="headerlink" title="9. 迭代器失效"></a>9. 迭代器失效</h2><p>顺序容器/序列式容器（vector、deque）、连续空间的容器：</p><p>erase会使被删除元素与之后的迭代器都失效，所以不能用 <code>erase(i++)</code>；erase会返回删除元素的下一个元素的迭代器，应用 <code>i = erase(i)</code></p><p>关联容器（map、set）、基于节点的容器：</p><p>erase只使删除元素的迭代器失效，但是返回void，所以通过 <code>erase(i++)</code>删除</p><ul><li>vector/deque<ul><li>插入元素时，如果size &lt; capacity则插入元素后的所有迭代器失效，否则所有迭代器均失效（需要重新分配空间）。</li><li>删除元素时，删除位置后的所有迭代器失效。</li></ul></li><li>list：每一个节点内存不连续，删除仅当前迭代器失效，返回下一个有效迭代器。</li><li>map/set：底层是红黑树，同样不影响其他迭代器，mp.erase(it++)获取下一个迭代器。</li><li>unordered：rehash后全部失效。</li></ul><h2 id="10-list、slist"><a href="#10-list、slist" class="headerlink" title="10. list、slist"></a>10. list、slist</h2><p>list是双向链表，slist是单向链表，功能不如list但消耗空间更小、操作更快。在C++ 11中slist为forward_list。</p><p>list是环形链表，node节点指针始终指向尾端一个空白节点，是前闭后开的结构。</p><h2 id="11-uninitialized"><a href="#11-uninitialized" class="headerlink" title="11. uninitialized"></a>11. uninitialized</h2><p>将内存配置与对象构造分开。</p><p>uninitialized_copy：应用于容器的全区间构造函数。</p><p>uninitialized_fill(_n)</p><p>要么构造出所有必要元素，要么不构造任何东西（其中一个元素的copy construct失败）</p><p>会先萃取出容器元素的类型，区分是否为POD型别（Plain Old Data，标量型别或传统的struct型别，拥有trivial的构造/拷贝函数（我认为意思是可以直接为内存赋值的那种））。对于POD型别，直接copy或fill；对于非POD型别，会求保险调用construct。</p><h2 id="12-算法"><a href="#12-算法" class="headerlink" title="12. 算法"></a>12. 算法</h2><p>质变/非质变算法：算法在运算过程中是否会改变迭代区间内的内容。</p><p>很多质变算法还提供就地修改与copy修改两类。</p><p>根据迭代器的五种类型，算法也可以分为五类，代表它能接受的最低要求的迭代器。</p><h2 id="13-红黑树"><a href="#13-红黑树" class="headerlink" title="13. 红黑树"></a>13. 红黑树</h2><p>特性：</p><ul><li>节点为黑色或红色。</li><li>根节点为黑色，叶子节点（空节点，不是传统意义上的叶子节点）</li><li>如果一个节点是红色的，其子节点必定是黑色的。</li><li>从一个节点到其子孙节点的所有路径包含相同数目的黑节点。<strong>保证了相对平衡</strong>，不会出现二叉搜索树树的最坏情况（拉长成一条链表）</li></ul><p>删除操作：</p><ol><li>删除叶子节点（不是空节点，传统意义上的）<ol><li>为红色，可直接删除</li><li>为黑色<ol><li>父节点、兄弟节点、兄弟节点的子节点有红色，可通过旋转完成平衡。</li><li>上述三种都为黑色。将兄弟节点染红，但是子树黑高度降低了，将父节点视为当前节点，<strong>继续向上调整</strong>。</li></ol></li></ol></li><li>删除只有一个子节点的节点，该节点一定为黑色，子节点一定为红色（因为该节点的另一个节点为黑色的空节点，而该节点到所有黑节点距离相同），用子节点代替该节点并染黑。</li><li>删除有两个子节点的节点，找到该节点的后继节点，用后继节点的值代替该节点，转为1删除后继节点。</li></ol><p>插入操作：</p><ol><li>键已经存在，直接改写值。</li><li>插入空树，作为根节点染黑。</li><li>插入位置的父节点为黑，直接插入。</li><li>插入位置的父节点为红，出现插入节点与父节点两个相邻红色节点（因为插入前满足红黑树性质，所以爷爷节点一定为黑）<ol><li>叔叔节点为红：将爷爷节点染红，父亲和叔叔节点染黑。将爷爷节点视为当前节点，继续向上调整。（爷爷节点又有可能跟上面二连红）</li><li>叔叔节点为黑或不存在（空节点一样视为黑）：以父节点为支点旋转，将父节点染黑，爷爷节点染红。</li></ol></li></ol><p>与AVL相比：红黑树只追求大致平衡，增删节点时的平均旋转次数小于AVL，在增删频繁时效率相对较高。</p><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h1><h2 id="1-main函数执行前后"><a href="#1-main函数执行前后" class="headerlink" title="1. main函数执行前后"></a>1. main函数执行前后</h2><p>main函数执行前：</p><ul><li>设置栈指针</li><li>初始化静态static变量和global全局变量，即.data段</li><li>将未初始化部分的全局变量赋初值，即.bss段</li><li>全局对象初始化</li><li>传递argc、argv参数给main函数</li><li>__attribute__(constructor))：函数定义前修饰，main函数前执行</li></ul><p>main函数执行后：</p><ul><li>全局对象的析构函数</li><li>atexit：可以注册一个函数，程序正常终止时执行。</li><li>__attribute__((destructor))：函数定义后修饰，main函数后执行</li></ul><h2 id="2-指针的sizeof"><a href="#2-指针的sizeof" class="headerlink" title="2. 指针的sizeof"></a>2. 指针的sizeof</h2><p>指针的大小与编译环境有关，而与机器位数无关。</p><p>32位环境下指针4字节，64位环境下就是8字节。</p><h2 id="3-C-的类型安全"><a href="#3-C-的类型安全" class="headerlink" title="3. C++的类型安全"></a>3. C++的类型安全</h2><ul><li>空间分配：操作符new返回的指针类型严格与对象匹配，而不是void*</li><li>模板：改写C中以void*为参数的函数为模板参数，支持类型检查</li><li>宏定义：引入const、inline与模板代替#define</li><li>强制转换：提供dynamic_cast关键字，使得转换过程更加安全</li></ul><h2 id="4-零拷贝"><a href="#4-零拷贝" class="headerlink" title="4. 零拷贝"></a>4. 零拷贝</h2><p>vector中的emplace_back。</p><p>push_back需要调用拷贝构造函数与转移构造函数，而emplace_back原地构造。</p><h2 id="5-内存对齐"><a href="#5-内存对齐" class="headerlink" title="5. 内存对齐"></a>5. 内存对齐</h2><p>原因：大部分处理器一般以2幂次字节存取内存，称为内存存取粒度。如果任意存放，处理器还需要剔除不想要的字节，额外操作。</p><p>规则：</p><ol><li>分配内存的顺序按照声明顺序</li><li>每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍</li><li>整个结构体的大小必须是其中变量类型最大值的整数倍，如果不是需要在最后一个变量后面填充</li></ol><p>如果添加了#pragma pack(n)（不添加时默认为4）</p><ol><li>偏移量为n和当前变量大小较小值的整数倍。</li><li>结构体大小为n和最大变量大小较小值的整数倍。</li><li>n必须为2的幂，为其他值则语句失效。</li></ol><p>C++11 align</p><h2 id="6-编译、连接和模板类"><a href="#6-编译、连接和模板类" class="headerlink" title="6. 编译、连接和模板类"></a>6. 编译、连接和模板类</h2><p>编译单元：一个cpp文件以及其include的所有h文件，h文件中的代码将会被扩展到包含它的cpp文件里，然后该cpp文件被编译为一个obj文件。</p><p>分离式编译模式：一个程序由若干源文件共同实现，每个源文件单独编译生成目标文件，不知道彼此存在，最后连接所有目标文件形成单一的可执行文件。</p><p>例子：main.cpp中有f的调用，test.h中有f的声明，test.cpp中有f的实现。</p><ul><li>编译main.cpp时，编译器不知道f的实现，只给出一个指示，指示连接器应该为它寻找f的实现。</li><li>编译test.cpp时，编译器找到了f的实现，f的实现出现在test.obj中。</li><li>连接时，连接器在test.obj中找到f的实现代码地址，将main.obj中的地址改成f实际的地址。</li></ul><p>模板函数声明与实现无法分离：f&lt;T&gt;与f&lt;int&gt;等具体类型不是一个东西！</p><p>然而，如果f是模板函数，C++标准规定，当一个模板不被用到的时候，就不该被实例化。所以在原本的第2步，编译器不能实例化该模板，只能创建一个具有外部连接的符号，期待连接器找到符号的地址。所以原本应该出现的f的实现不会出现在test.obj中。这样导致整个工程的obj文件中都没有任何模板实例的二进制代码。</p><p>如：main.cpp中用到了f&lt;int&gt;，这时候会在展开的test.h中实例化对f&lt;int&gt;进行声明。由于分离式编译模式，编译时只需要类的声明即可编译成功，所以main.cpp会编译成功；</p><p><strong>链接</strong>时，需要找到f的实现，但是test.cpp编译单元中的实现**是f&lt;T&gt;而不是f&lt;int&gt;**，即找不到f&lt;int&gt;的实现，进而报错“对f&lt;int&gt;未定义的引用”。</p><p>编译器对函数模板进行两次编译：声明的地方对模板代码本身编译，调用的地方对参数替换后的代码编译。</p><h2 id="7-C-C-的输入输出缓冲与流"><a href="#7-C-C-的输入输出缓冲与流" class="headerlink" title="7. C/C++的输入输出缓冲与流"></a>7. C/C++的输入输出缓冲与流</h2><p>cin读取输入时，流程为键盘-输入缓冲区-cin。</p><p>缓冲分为三种：</p><ul><li>全缓冲：填满标准IO缓存才进行实际IO操作。读写磁盘文件。</li><li>行缓冲：输入输出中遇到换行符时执行真正的IO操作。键盘读写数据。</li><li>不带缓冲：不进行缓冲。标准出错情况stderr。</li></ul><p>缓冲区的刷新，即缓冲区内容被清空，清空前触发IO读写：</p><ul><li>缓冲区满</li><li>flush</li><li>endl</li><li>关闭文件</li></ul><p>缓冲区的限制：</p><ul><li>当且仅当标准输入/输出不涉及交互设备（键盘、屏幕等）时，它们是全缓存，如读写文件；如果涉及交互设备，一般默认为行缓存。</li><li>标准出错不是全缓存。</li></ul><p>流：数据传输的过程，例如键盘-输入缓冲区-cin的横线。</p><h2 id="8-引用传参-返回值"><a href="#8-引用传参-返回值" class="headerlink" title="8. 引用传参/返回值"></a>8. 引用传参/返回值</h2><p>好处：</p><ol><li>函数内部可以对参数进行修改</li><li>提高函数调用和运行的效率（没有传值和生成副本的时空消耗）</li></ol><p>限制：</p><ol><li>不能返回局部变量的引用，因为函数返回后就会被销毁</li><li>不能返回函数内部new分配内存的引用，因为会造成内存泄漏</li></ol><h2 id="9-C-标准库"><a href="#9-C-标准库" class="headerlink" title="9. C++标准库"></a>9. C++标准库</h2><p>标准函数库：通用、独立、不属于任何类的函数，继承自C++。输入/输出IO、字符串和字符处理、数学等。</p><p>面向对象类库：C++IO类、标准模板库等。</p><h2 id="10-回调函数"><a href="#10-回调函数" class="headerlink" title="10. 回调函数"></a>10. 回调函数</h2><ol><li>发生某种事件时，系统或其他函数会自动调用的一段函数，类似于中断处理函数。</li><li>将其指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，称其为回调函数。</li><li>可以将调用者被调用者分开，调用者可以不关心被调用者是谁。</li></ol><h2 id="11-C-从代码到可执行程序的流程"><a href="#11-C-从代码到可执行程序的流程" class="headerlink" title="11. C++从代码到可执行程序的流程"></a>11. C++从代码到可执行程序的流程</h2><h3 id="1-预编译"><a href="#1-预编译" class="headerlink" title="1. 预编译"></a>1. 预编译</h3><p>主要处理以#开头的预编译指令</p><ol><li>删除#define并展开宏定义</li><li>处理条件预编译指令，如#if</li><li>处理#include预编译指令，将文件内容替换到其位置</li><li>删除所有的注释</li><li>保留#pragma编译器指令</li><li>添加行号和文件标识</li></ol><p>生成.i、.ii文件</p><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h3><p>词法分析、语法分析、语义分析以及优化，生成汇编代码.s</p><ol><li>词法分析：将源代码的字符序列分割成一系列记号</li><li>语法分析：产生以表达式为节点的语法树</li><li>语义分析：判断表达式是否有意义</li><li>优化</li><li>目标代码生成：将中间代码转换成目标机器代码，生成汇编语言</li><li>目标代码优化：寻找合适的寻址方式、使用位移代替乘法运算、删除多余指令等</li></ol><h3 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3. 汇编"></a>3. 汇编</h3><p>将汇编代码转变成机器可以执行的机器码文件，产生目标文件.o、.obj</p><h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4. 链接"></a>4. 链接</h3><p>将不同源文件产生的目标文件链接，形成一个可以执行的程序</p><p>静态链接：链接器从静态库中复制函数和数据，将其和应用程序的其他模块组合，创建最终的可执行文件。</p><p>特点：</p><ul><li>空间浪费：每个可执行程序对所有有需要的目标文件都有一份副本</li><li>更新困难：每当库函数代码修改，都要重新编译链接</li><li>运行速度快</li></ul><p>动态链接：把程序按照模块拆分成独立部分，运行时再链接。多个程序执行时共享一份共享库。</p><p>特点：</p><ul><li>更新方便：只需要替换原来的目标文件，不需要再链接一遍</li><li>性能损耗：每次执行都要链接；只要用到命令就需要附带整个链接库，造成空间浪费。</li></ul><p>装入时动态链接：可执行文件中只包含该cpp文件的代码部分，以及记录该可执行文件依赖哪些动态库。<strong>启动可执行文件时</strong>，装载器发现不完整，所以动态链接动态库文件。</p><p>运行时动态链接：可执行文件中只包含该cpp文件的代码部分，以及在某些第三方库的函数调用中记录需要使用这些库。<strong>程序运行到这些位置时</strong>，将第三方库的函数代码链接。</p><h3 id="5-二进制文件执行"><a href="#5-二进制文件执行" class="headerlink" title="5. 二进制文件执行"></a>5. 二进制文件执行</h3><p>最终形成的二进制文件包含了</p><ul><li>程序头：包含供操作系统加载的信息，操作系统根据这些信息加载可执行程序。</li><li>程序主体（二进制机器代码）。程序运行时逐条执行这些机器代码，形成程序运行序列。</li></ul><h2 id="12-垃圾回收机制"><a href="#12-垃圾回收机制" class="headerlink" title="12. 垃圾回收机制"></a>12. 垃圾回收机制</h2><p>实现垃圾回收器会带来额外的时空开销，使得C++不适合进行很多底层操作，所以C++不自带垃圾回收</p><h2 id="13-C-的内存管理"><a href="#13-C-的内存管理" class="headerlink" title="13. C++的内存管理"></a>13. C++的内存管理</h2><p>与Linux类似，从高地址到低地址依次是：</p><ul><li>栈：向低地址生长。函数内局部变量在栈上创建，函数返回时被自动释放。栈内存分配运算内置于处理器的指令集中，效率很高但容量有限。</li><li>堆：向高地址生长。分配与释放由应用程序控制，如果程序不释放，那么在程序结束后操作系统自动回收。灵活、容量大但效率不高。</li><li>全局/静态存储区：共同占用同一块内存区，在该区定义的变量如果没有初始化，会自动初始化为0。</li><li>常量存储区：不允许修改。</li><li>代码区：存储函数体的二进制代码。</li></ul><h2 id="14-RAII"><a href="#14-RAII" class="headerlink" title="14. RAII"></a>14. RAII</h2><p>Resource Acquisition is Initialization，资源获取即初始化，也就是说在构造函数中申请资源，在析构函数中释放资源。应该使用类管理资源，将资源和对象的生命周期绑定。</p><p>可用于防止内存泄漏。</p><p>智能指针即为RAII最具代表的实现。</p><h2 id="15-i和i"><a href="#15-i和i" class="headerlink" title="15. ++i和i++"></a>15. ++i和i++</h2><p>后者是右值，会产生临时对象导致效率降低，所以用前者更好。</p><p>后置重载要加上const：防止i++++这种操作出现，你期望+2，而实际上是对i++产生的临时对象再用++，只+1。</p><h2 id="16-常引用"><a href="#16-常引用" class="headerlink" title="16. 常引用"></a>16. 常引用</h2><p>引用：</p><p><code>int &amp;a = b</code>相当于 <code>int *const a = b</code></p><p>常引用：</p><p><code>const int &amp;a = b</code>就相当于 <code>const int *const a = b</code></p><p>常引用是万能引用，可以用左值或右值初始化。（另：<code>const int &amp;&amp;</code>只能用右值赋值）</p><p>对某个变量建立常引用时，允许发生类型转换，而一般的引用不允许。</p><p>对一个表达式建立常引用时</p><ul><li>如果该表达式的结果可以寻址，且表达式的数据类型与引用类型相同，就可以直接将该表达式结果的地址送入引用变量，导致的结果是表达式的地址与引用变量地址相同。</li><li>否则如果<strong>类型不相同</strong>，或表达式不可寻址，就只能另外建立一个匿名临时变量存放表达式的结果（或转换后的值），然后引用绑定匿名临时变量。</li></ul><p>常引用的作用：作为参数时可以传入左右值，同时禁止函数对其一切修改。</p><h2 id="17-乱序执行"><a href="#17-乱序执行" class="headerlink" title="17. 乱序执行"></a>17. 乱序执行</h2><p>如果后面的代码不需要等待前面的代码执行完毕，就会乱序执行。</p><p>一定不会出现乱序执行：</p><ul><li>对同一块内存访问，不会修改访问顺序。</li><li>新定义的变量值依赖于之前定义的变量，不会修改定义顺序。</li></ul><p>C++库提供了内存模型，用于在多线程情况下防止编译器乱序执行。</p><h2 id="18-重载函数匹配机制"><a href="#18-重载函数匹配机制" class="headerlink" title="18. 重载函数匹配机制"></a>18. 重载函数匹配机制</h2><p>编译器使用了命名倾轧技术，将相同作用域下的同名函数以命名空间+函数名长度+函数名+参数类型，命名成不同名加以区分。</p><h3 id="1-确定候选函数集"><a href="#1-确定候选函数集" class="headerlink" title="1. 确定候选函数集"></a>1. 确定候选函数集</h3><p>根据作用域和函数名，选择这两点相同的函数。</p><h3 id="2-选出可行函数集"><a href="#2-选出可行函数集" class="headerlink" title="2. 选出可行函数集"></a>2. 选出可行函数集</h3><p>根据参数列表信息（类型+个数）选出可行函数集。</p><ul><li>每个实参类型要与对应的形参相同，或者可以转换成形参类型</li><li>参数个数相同</li></ul><p>如果没找到，编译器报告无法匹配函数错误</p><h3 id="3-寻找最佳匹配"><a href="#3-寻找最佳匹配" class="headerlink" title="3. 寻找最佳匹配"></a>3. 寻找最佳匹配</h3><p>依次检查可行函数集的每一个函数</p><ul><li>检查每一个函数的形参与被调函数实参</li><li>寻找最匹配的<ul><li>其每个实参匹配都不劣于其他可行函数的匹配</li><li>至少有一个实参匹配优于其他可行函数的匹配</li></ul></li></ul><p>如果有多个可行函数同时满足，编译器报告二义性错误</p><h1 id="问C-14、17、20新特性"><a href="#问C-14、17、20新特性" class="headerlink" title="问C++14、17、20新特性"></a>问C++14、17、20新特性</h1><p>问C++14、17、20的新特性，可以说的：</p><ul><li>string_view：””s操作符、分配在栈上、只存储指针和长度、只读</li><li>optional、expected</li><li>variant</li><li>共享锁shared_lock、shared_mutex、shared_timed_mutex。配合shared_lock、unique_lock实现RAII的读写锁。</li><li>结构化绑定：pair、tuple、vector等。</li></ul><h1 id="7-C-14"><a href="#7-C-14" class="headerlink" title="7. C++ 14"></a>7. C++ 14</h1><p>比较熟悉的特性：shared_lock、shared_timed_mutex读写锁</p><h2 id="1-auto函数返回值类型推导"><a href="#1-auto函数返回值类型推导" class="headerlink" title="1. auto函数返回值类型推导"></a>1. auto函数返回值类型推导</h2><ul><li>函数内多个返回语句必须返回相同类型。</li><li>不能返回初始化列表。</li><li>不能推导虚函数。</li><li>可以用在前向声明，但是必须在定义在一个编译单元。</li><li>可以用在递归函数，但是必须用一个返回语句作为先导。（即递归出口必须写在开头）</li></ul><h2 id="2-模板"><a href="#2-模板" class="headerlink" title="2. 模板"></a>2. 模板</h2><p>支持变量模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">constexpr</span> T pi = T(<span class="number">3.1415926535897932385L</span>);</span><br></pre></td></tr></table></figure><p>支持别名模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    T t;</span><br><span class="line">    U u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> B = A&lt;T, <span class="keyword">int</span>&gt;;</span><br></pre></td></tr></table></figure><h2 id="3-constexpr"><a href="#3-constexpr" class="headerlink" title="3. constexpr"></a>3. constexpr</h2><p>可以用局部变量、循环、多条返回。</p><h2 id="4-deprecated"><a href="#4-deprecated" class="headerlink" title="4. [[deprecated]]"></a>4. [[deprecated]]</h2><p>修饰名字/实体，指示其被弃用，允许使用但不推荐，会报警告。</p><h2 id="5-分隔符"><a href="#5-分隔符" class="headerlink" title="5. 分隔符"></a>5. 分隔符</h2><p>分隔二进制字面量与整形字面量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0b0001&#x27;0011&#x27;1010</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">3.14&#x27;1234&#x27;1234&#x27;1234</span>;</span><br></pre></td></tr></table></figure><h2 id="6-make-unique"><a href="#6-make-unique" class="headerlink" title="6. make_unique"></a>6. make_unique</h2><p>用于unique_ptr</p><h2 id="7-读写锁shared-timed-mutex"><a href="#7-读写锁shared-timed-mutex" class="headerlink" title="7. 读写锁shared_timed_mutex"></a>7. 读写锁shared_timed_mutex</h2><p><code>shared_timed_mutex</code>为读写锁类型。</p><p><code>shared_lock&lt;shared_timed_mutex&gt;(mtx: shared_timed_mutex)</code>创建读锁。</p><p><code>unique_lock&lt;shared_timed_mutex&gt;(mtx: shared_timed_mutex)</code>创建写锁。</p><h2 id="8-integer-sequence"><a href="#8-integer-sequence" class="headerlink" title="8. integer_sequence"></a>8. integer_sequence</h2><p>模板参数传入类型与该类型的多个值，通过 <code>((std::cout &lt;&lt; ints &lt;&lt; &#39; &#39;), ...);</code>解包。</p><h2 id="9-exchange"><a href="#9-exchange" class="headerlink" title="9. exchange"></a>9. exchange</h2><ul><li>右边替换左边值，返回左边旧值。</li><li>左边类型必须可用右边类型移动构造。</li></ul><h2 id="10-quoted"><a href="#10-quoted" class="headerlink" title="10. quoted"></a>10. quoted</h2><p>给字符串加双引号。</p><h1 id="8-C-17"><a href="#8-C-17" class="headerlink" title="8. C++ 17"></a>8. C++ 17</h1><p>比较熟悉的特性：结构化绑定、string_view</p><h2 id="1-构造函数模板自动推导"><a href="#1-构造函数模板自动推导" class="headerlink" title="1. 构造函数模板自动推导"></a>1. 构造函数模板自动推导</h2><p>pair、vector等。</p><h2 id="2-结构化绑定"><a href="#2-结构化绑定" class="headerlink" title="2. 结构化绑定"></a>2. 结构化绑定</h2><p>应用于public成员、C-Style数组、pair、tuple、array对象，通过 <code>auto [v1, v2] = p</code>获取值。</p><ul><li>不能加constexpr，可以通过引用直接改变被绑定的值。</li><li>不会发生类型退化，如char[]退化为char*。</li><li>用_跳过当前元素。</li><li>不适用于继承，所有非静态数据成员必须在一个类。</li></ul><p>要对自定义类型实现结构化绑定，需要实现类似tuple的get&lt;i&gt;API。</p><h2 id="3-折叠表达式"><a href="#3-折叠表达式" class="headerlink" title="3. 折叠表达式"></a>3. 折叠表达式</h2><p>用于可变参数模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ts ... ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ts + ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-has-include"><a href="#4-has-include" class="headerlink" title="4. __has_include"></a>4. __has_include</h2><p><code>#if __has_include(&lt;package&gt;)</code>判断是否有某个头文件。</p><h2 id="5-attribute"><a href="#5-attribute" class="headerlink" title="5. attribute"></a>5. attribute</h2><p>[[fallthrough]]，switch中代替break。</p><p>[[nodiscard]]，修饰内容不能被忽略，修饰函数表示返回值必须处理，否则warning。</p><p>[[maybe_used]]，提示编译器修饰的内容暂时没用，避免产生警告。</p><h2 id="6-字符串转换"><a href="#6-字符串转换" class="headerlink" title="6. 字符串转换"></a>6. 字符串转换</h2><p>from_chars</p><p>to_chars</p><h2 id="7-variant"><a href="#7-variant" class="headerlink" title="7. variant"></a>7. variant</h2><p>类似union，传入模板参数构造，可通过类型取值。</p><p>union的缺陷是，里面有析构函数的成员时，不会自动释放内存，所以引入variant，它会自动析构。</p><p>如何判断类型中所占最大的空间</p><ul><li>模板元，编译时期判断</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MaxSize&lt;Ts...&gt;  Ts... 最大的一个</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MaxSize</span> &#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(T) &gt; MaxSize&lt;Ts...&gt;::size ? <span class="keyword">sizeof</span>(T) : MaxSize&lt;Ts...&gt;::size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MaxSize</span>&lt;</span>T&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span>  size = <span class="keyword">sizeof</span>(T);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现类似tuple的get&lt;i&gt;：同样是模板元，找到下标为i的类型，然后get里reinterpret_cast即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> idx, <span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type_element</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span>  Type_element&lt;idx - <span class="number">1</span>, Ts...&gt;::Type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type_element</span>&lt;</span><span class="number">0</span>, T, Ts...&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>找到某个类型的下标：模板元</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> id, <span class="keyword">typename</span> U, <span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Position</span> &#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = is_same&lt;U, T&gt;::value ? id : Position&lt;id + <span class="number">1</span>, U, Ts...&gt;::pos;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> id, <span class="keyword">typename</span> U, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Position</span>&lt;</span>id, U, T&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法：</p><ul><li>get&lt;type&gt;(variant)：以type类型访问，如果variant没有该type抛出异常。</li><li>holds_alternative&lt;type&gt;(variant)：检查是否有type。</li><li>get_if&lt;type&gt;(variant)：以type类型访问，如果有该类型，返回type*，否则返回空指针。</li></ul><h2 id="8-optional"><a href="#8-optional" class="headerlink" title="8. optional"></a>8. optional</h2><p>传入模板参数，修饰函数返回值，可以返回该类型，也可以返回nullopt。</p><p>可通过make_optional创建。</p><p>示例：<code>optional&lt;A&gt;</code>可返回A类型实例，或nullopt。</p><p>方法：</p><ul><li>*op/op-&gt;：访问值</li><li>operator bool/has_value()：检查是否有值</li><li>value()：返回值</li><li>value_or(val)：有值则返回值，否则返回val</li></ul><p>目的：更优雅地进行异常处理。</p><p>C++ 23：引入了expected，可通过error()方法返回不期待的值（相当于把optional的nullopt用了个值代替）</p><h2 id="9-any"><a href="#9-any" class="headerlink" title="9. any"></a>9. any</h2><p>存储任何类型的单个值</p><ul><li>type().name()获取类型</li><li>hash_value()判断有没有值</li><li>any_cast&lt;type&gt;(a)转换到存储的类型</li></ul><p>简单实现：基类Base，模板派生类Derive存储T类型数据，Any类中保存Base的unique_ptr，运行时dynamic_cast转换成Derive*类get到T类型数据。</p><h2 id="10-make-from-tuple"><a href="#10-make-from-tuple" class="headerlink" title="10. make_from_tuple"></a>10. make_from_tuple</h2><p>展开tuple作为构造函数参数。</p><h2 id="11-string-view"><a href="#11-string-view" class="headerlink" title="11. string_view"></a>11. string_view</h2><p>传入const char*以及大小（可选）</p><ul><li>高效：不拷贝字符串，只保存字符串指针与看到的大小</li><li>分配在栈上</li><li>只读</li></ul><p>方法：</p><ul><li><p>常规string方法</p></li><li><p>没有c_str()，因为string_view可能只截取其中一端，而c语言风格的字符串要求尾部为\0；代替的，有data()，返回指向视图首字符的指针。</p><ul><li>cout该方法与直接cout视图不一定一样，因为data()直接到尾部，而string_view截取的可能是不到尾部的一段。</li></ul></li><li><p>重载了””sv操作符： <code>&quot;narrow string literal&quot;sv</code>作为一个匿名string_view对象。</p><ul><li>（另：C++17也对string重载了””s操作符，而且调用的是basic_string_view的构造函数，免去了构造时再一次获取字符串长度）</li></ul></li></ul><h2 id="12-monostate"><a href="#12-monostate" class="headerlink" title="12. monostate"></a>12. monostate</h2><p>空类型</p><h2 id="13-scoped-lock"><a href="#13-scoped-lock" class="headerlink" title="13. scoped_lock"></a>13. scoped_lock</h2><p>可一次包装多个锁，相当于多个锁的unique_lock。</p><h1 id="9-C-20"><a href="#9-C-20" class="headerlink" title="9. C++ 20"></a>9. C++ 20</h1><p>比较熟悉的特性：module、ranges</p><h2 id="1-module"><a href="#1-module" class="headerlink" title="1. module"></a>1. module</h2><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> m;</span><br><span class="line"><span class="keyword">namespace</span> m &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>引用：import</p><p>优点（相较于头文件）：</p><ul><li>不会有头文件重复include</li><li>模块间名称可以相同</li><li>模块只处理一次，编译更快（头文件每次include都要处理）</li></ul><p>更快：</p><ul><li>编译器缓存留下来，下次读取更快。</li><li>lazy loading：需要哪些定义/声明就加载哪些。</li><li>编译出object，只有链接的时候需要，不要再次处理、编译。</li></ul><p>module linkage：同一个module内部可见。</p><ul><li>对外export的名称按照平时方式name mangling</li><li>module内部需要module linkage的名称，使用_ZW开头的name mangling</li></ul><h2 id="2-ranges"><a href="#2-ranges" class="headerlink" title="2. ranges"></a>2. ranges</h2><p>range：有begin和end函数。</p><p>view：视图。对数据的遍历都是惰性求值，如views::iota(1)表示自然数序列，但是需要遍历时才往后加。</p><p>range adapter：将range或view转换为view。</p><p>管道运算符|：利用views namespace的范围适配器提供对range或view的变换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec3&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec3 | <span class="built_in">std</span>::views::elements&lt;<span class="number">1</span>&gt;)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>懒求值：v为一个view，不修改与复制vec的元素，只当其表示的一个元素被使用时才发生求值。（此处为cout）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">20</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> v = vec | filter(even) | transform([](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a) &#123;<span class="keyword">return</span> a * a; &#125;)| take(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *v.begin() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="3-协程coroutine"><a href="#3-协程coroutine" class="headerlink" title="3. 协程coroutine"></a>3. 协程coroutine</h2><p>协程是一个函数，可以暂停与恢复执行。其状态与任何线程都无关。</p><p>与普通函数的区别：堆上保存状态，调用时在栈上分配空间后，保存一个引用指向堆上的状态。协程暂停时，将当前执行的代码位置记录到堆的状态中，回收栈上的空间。</p><p>作用：解决用到回调函数的异步函数多层嵌套。</p><p>操作符：co_await、co_return、co_yield。</p><p><img src="https://img2022.cnblogs.com/blog/2250167/202204/2250167-20220416162134241-1573199389.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2250167/202204/2250167-20220416162134241-1573199389.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h3 id="1-co-await"><a href="#1-co-await" class="headerlink" title="1. co_await"></a>1. co_await</h3><p>暂停协程，等某个操作完成后再恢复。</p><p>传给该操作符的对象必须实现：</p><ul><li><code>bool await_ready()</code>：协程执行co_await前调用，询问”操作是否完成“，如果返回true则协程不暂停。</li><li><code>void/bool await_suspend(coroutine_handle&lt;&gt;)</code>：await_ready()返回false时调用，用于接收协程句柄（参数），在异步操作完成时通过句柄让协程恢复执行。<ul><li>一般返回void，返回bool时返回值用于控制协程是否真的要暂停，如果返回false则表示不暂停。</li></ul></li><li><code>void/other await_resume()</code>：返回值是co_await操作符的返回值。协程恢复执行或不需要暂停的时候调用。</li></ul><p>co_await完成：</p><ul><li>挂起协程</li><li>返回到caller</li><li>等待某个任务完成后返回的结果</li></ul><p>co_await expr生成的伪代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; value = &lt;expr&gt;;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; awaitable = get_awaitable(promise, <span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(value)&gt;(value));</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; awaiter = get_awaiter(<span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(awaitable)&gt;(awaitable));</span><br><span class="line">    <span class="keyword">if</span> (!awaiter.await_ready()) <span class="comment">//是否需要挂起协程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">handle_t</span> = <span class="built_in">std</span>::experimental::coroutine_handle&lt;P&gt;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">await_suspend_result_t</span> = <span class="keyword">decltype</span>(awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)));</span><br><span class="line"> </span><br><span class="line">    &lt;suspend-coroutine&gt; <span class="comment">//挂起协程</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_void_v&lt;<span class="keyword">await_suspend_result_t</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)); <span class="comment">//异步(也可能同步)执行task</span></span><br><span class="line">      &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt; <span class="comment">//返回给caller</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">static_assert</span>(</span><br><span class="line">         <span class="built_in">std</span>::is_same_v&lt;<span class="keyword">await_suspend_result_t</span>, <span class="keyword">bool</span>&gt;,</span><br><span class="line">         <span class="string">&quot;await_suspend() must return &#x27;void&#x27; or &#x27;bool&#x27;.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)))</span><br><span class="line">      &#123;</span><br><span class="line">        &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &lt;resume-point&gt; <span class="comment">//task执行完成，恢复协程，这里是协程恢复执行的地方</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> awaiter.await_resume(); <span class="comment">//返回task结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-co-return"><a href="#2-co-return" class="headerlink" title="2. co_return"></a>2. co_return</h3><p>协程的返回类型T要求：其中定义名为promise_type的内嵌类型。</p><p>promise_type要实现的函数：</p><ul><li><code>T get_return_object()</code>：创建协程的返回值。</li><li><code>void return_value(U u)</code>：传递返回数据给promise_type对象。</li><li><code>void return void()</code></li><li><code>suspend_never/suspend_always yield_value()</code></li></ul><p>co_return：从协程中返回数据。<code>co_return total</code>等价于 <code>promise_type.return_value(total)</code>。可以不带数据。需要根据其使用决定该在promise_type中定义哪个函数。</p><h3 id="3-co-yield"><a href="#3-co-yield" class="headerlink" title="3. co_yield"></a>3. co_yield</h3><p>在协程中多次返回数据而不结束协程。</p><p>返回一个数据，让协程暂停，等待下一次机会恢复执行。</p><p><code>co_yield val</code>等价于 <code>promise_type.yield_value(val)</code>。</p><h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><p>用户输入一次后，从协程中取一个值输出，生成下一个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntReader</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::thread <span class="title">thread</span><span class="params">([<span class="keyword">this</span>, handle]() &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">static</span> <span class="keyword">int</span> seed = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">            value_ = ++seed;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            handle.resume();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.detach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">promise_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> Task&#123; <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::suspend_always <span class="title">yield_value</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            value_ = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> value_&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Task(<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; handle) : coroutine_handle_(handle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coroutine_handle_.promise().GetValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        coroutine_handle_.resume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; coroutine_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        IntReader reader;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = GetInt();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; line) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; task.GetValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        task.Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-concept"><a href="#4-concept" class="headerlink" title="4. concept"></a>4. concept</h2><p>一个语法糖，用于对模板特例化做出约束。</p><p>相当于定义了一个别名，用来指代需要被特例化的某种类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个永远都能匹配成功的concept</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> always_satisfied = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个约束T只能是整数类型的concept，整数类型包括 char, unsigned char, short, ushort, int, unsinged int, long等。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> integral = <span class="built_in">std</span>::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个约束T只能是整数类型，并且是有符号的concept</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> signed_integral = integral&lt;T&gt; &amp;&amp; <span class="built_in">std</span>::is_signed_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意类型都能匹配成功的约束，因此mul只要支持乘法运算符的类型都可以匹配成功。</span></span><br><span class="line"><span class="keyword">template</span> &lt;always_satisfied T&gt;</span><br><span class="line"><span class="function">T <span class="title">mul</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整型才能匹配add函数的T</span></span><br><span class="line"><span class="keyword">template</span> &lt;integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有符号整型才能匹配subtract函数的T</span></span><br><span class="line"><span class="keyword">template</span> &lt;signed_integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">subtract</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mul(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 匹配成功, T =&gt; int</span></span><br><span class="line">    mul(<span class="number">1.0f</span>, <span class="number">2.0f</span>);  <span class="comment">// 匹配成功，T =&gt; float</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">-2</span>);  <span class="comment">// 匹配成功, T =&gt; int</span></span><br><span class="line">    add(<span class="number">1.0f</span>, <span class="number">2.0f</span>); <span class="comment">// 匹配失败, T =&gt; float，而T必须是整型</span></span><br><span class="line">    subtract(<span class="number">1U</span>, <span class="number">2U</span>); <span class="comment">// 匹配失败，T =&gt; unsigned int,而T必须是有符号整型</span></span><br><span class="line">    subtract(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 匹配成功, T =&gt; int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-requires"><a href="#5-requires" class="headerlink" title="5. requires"></a>5. requires</h2><p>可以与concept配合使用，也可以用在其他。</p><h3 id="1-简单约束"><a href="#1-简单约束" class="headerlink" title="1. 简单约束"></a>1. 简单约束</h3><p>要求requires后面的表达式是合法的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requires用在使用concept时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">requires</span> my_concept&lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requires用在concept的定义，它表达了类型T的参数f，必须符合大括号内的模式，也就是能被调用。</span></span><br><span class="line"><span class="comment">// 也就是它是一个函数或者一个重载了operator()的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> callable = <span class="keyword">requires</span> (T f) &#123; f(); &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">requires</span> (T x) &#123; x + x; &#125; <span class="comment">// 要求x重载了operator+</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类型约束"><a href="#2-类型约束" class="headerlink" title="2. 类型约束"></a>2. 类型约束</h3><p>typename后面接一个类型，要求该类型在concept进行evaluate时必须存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bar</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> value = <span class="keyword">int</span>;</span><br><span class="line">    value data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">baz</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> value = <span class="keyword">int</span>;</span><br><span class="line">    value data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用了SFINAE，要求T必须是baz类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_same_v&lt;T, baz&gt;&gt;&gt;</span><br><span class="line">struct S &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C = <span class="keyword">requires</span> &#123;</span><br><span class="line">    <span class="comment">// 对T的约束</span></span><br><span class="line">    <span class="keyword">typename</span> T::value;  <span class="comment">// A) 有成员value</span></span><br><span class="line">    <span class="keyword">typename</span> S&lt;T&gt;;     <span class="comment">// B) 有一个有效的S模板特例化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;C T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T a)</span></span>;</span><br><span class="line"></span><br><span class="line">g(foo&#123;&#125;); <span class="comment">// ERROR: Fails requirement A.</span></span><br><span class="line">g(bar&#123;&#125;); <span class="comment">// ERROR: Fails requirement B.</span></span><br><span class="line">g(baz&#123;&#125;); <span class="comment">// PASS.</span></span><br></pre></td></tr></table></figure><h3 id="3-嵌套约束"><a href="#3-嵌套约束" class="headerlink" title="3. 嵌套约束"></a>3. 嵌套约束</h3><p>requires嵌套requires</p><h2 id="6-同步库新增"><a href="#6-同步库新增" class="headerlink" title="6. 同步库新增"></a>6. 同步库新增</h2><h3 id="1-信号量semaphore"><a href="#1-信号量semaphore" class="headerlink" title="1. 信号量semaphore"></a>1. 信号量semaphore</h3><ul><li>多元信号量：非负值资源技术</li><li>二元信号量：只有两个状态</li></ul><p>方法</p><ul><li>release：增加内部计数器并对获取者解除阻塞</li><li>acquire：减少内部计数器或阻塞直至能获取</li><li>try_acquire：尝试减少内部计数器，不阻塞</li><li>try_acquire_for：尝试减少内部计数器，至多阻塞一段时长</li><li>try_acquire_until：尝试减少内部计数器，至多阻塞直到某个时间点</li></ul><h3 id="2-atomic新增"><a href="#2-atomic新增" class="headerlink" title="2. atomic新增"></a>2. atomic新增</h3><p>等待/阻塞在原子对象直到其值发生改变，然后通知函数发送通知，比自旋锁/轮询效率高。</p><p>方法</p><ul><li>wait：阻塞线程直到被提醒且原子值更改</li><li>notify_one：提醒至少一个在原子对象上的等待中阻塞的线程</li><li>notify_all：提醒所有在原子对象上的等待中阻塞的线程</li></ul><h3 id="3-锁存器latch"><a href="#3-锁存器latch" class="headerlink" title="3. 锁存器latch"></a>3. 锁存器latch</h3><p>只能减少的计数器，初值在创建时初始化，线程可以在上面阻塞，直到计数器归0。</p><p>一般用于同步线程。</p><p>因为只能减少，所以是一次性的。</p><p>方法</p><ul><li>用一个int初值初始化</li><li>赋值操作被delete</li><li>count_down：非阻塞减少计数器</li><li>try_wait：返回计数器是否为0</li><li>wait：阻塞到计数器归0</li><li>arrive_and_wait：减少计数器，并阻塞直到其归0</li></ul><p>官网的一段示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> product&#123;<span class="string">&quot;not worked&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread action&#123;&#125;;</span><br><span class="line">  &#125; jobs[] = &#123;&#123;<span class="string">&quot;annika&quot;</span>&#125;, &#123;<span class="string">&quot;buru&quot;</span>&#125;, &#123;<span class="string">&quot;chuck&quot;</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::latch work_done&#123;<span class="built_in">std</span>::size(jobs)&#125;;</span><br><span class="line">  <span class="built_in">std</span>::latch start_clean_up&#123;<span class="number">1</span>&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> work = [&amp;](job&amp; my_job) &#123;</span><br><span class="line">    my_job.product = my_job.name + <span class="string">&quot; worked&quot;</span>;</span><br><span class="line">    work_done.count_down();</span><br><span class="line">    start_clean_up.wait();</span><br><span class="line">    my_job.product = my_job.name + <span class="string">&quot; cleaned&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Work starting... &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; job : jobs) &#123;</span><br><span class="line">    job.action = <span class="built_in">std</span>::thread&#123;work, <span class="built_in">std</span>::ref(job)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  work_done.wait();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;done:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; job : jobs) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; job.product &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Workers cleaning up... &quot;</span>;</span><br><span class="line">  start_clean_up.count_down();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; job : jobs) &#123;</span><br><span class="line">    job.action.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;done:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; job : jobs) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; job.product &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-barrier"><a href="#4-barrier" class="headerlink" title="4. barrier"></a>4. barrier</h3><p>相较于latch，barrier功能相似，但是可复用。</p><p>相当于一个多阶段的任务，初值为参加任务的线程数</p><ul><li>每个阶段维护一个递减计数器，初始值为参加任务的线程数</li><li>线程通过arrive_and_wait减少计数器，并阻塞</li><li>当计数器为0时，表示该阶段完成，调用阶段完成时的回调函数</li><li>开启新一轮任务</li><li>线程不想参加当前以及后续任务了，可以通过arrive_and_drop跑路，把参加任务的线程数减去1，每阶段递减计数器的初值也永远减1</li></ul><p>方法：</p><ul><li>构造时两个参数：int型表示计数器初值，可调用对象表示所有阻塞线程运行完时，即一个阶段完成时的回调函数</li><li>赋值操作被delete</li><li>arrive：到达barrier，减少计数器</li><li>wait：阻塞，直到阶段完成时，回调函数被调用</li><li>arrive_and_wait：两个操作相加</li><li>arrive_and_drop：永久退出，意思是之后也不用算该线程了</li></ul><h3 id="5-jthread"><a href="#5-jthread" class="headerlink" title="5. jthread"></a>5. jthread</h3><p>jthread基于thread，其中包含一个thread成员，有thread的所有方法。可以用jthread替换所有thread。</p><p>jthread还封装了一个stop_token，可以通过stop_token控制线程结束</p><p>在thread的基础上，增加了功能：</p><ul><li>jthread对象析构时自动调用join，等待其所表示的执行流结束。RAII思想。</li><li>支持在线程外部主动停止线程执行（get_stop_source、get_stop_token 和 request_stop）。</li></ul><p>新方法：</p><ul><li>request_stop()：（线程外）将stop_token设置为结束标志。</li><li>get_stop_token()：获取stop_token</li><li>get_stop_token().stop_requested()：（线程内）通过stop_token的该方法确认是否结束。</li></ul><p>stop_callback：传入参数：stop_token、回调函数。request_stop()时当前线程执行注册的回调函数。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-操作系统</title>
      <link href="/2022/12/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-硬件结构"><a href="#1-硬件结构" class="headerlink" title="1. 硬件结构"></a>1. 硬件结构</h1><h2 id="1-冯诺依曼模型"><a href="#1-冯诺依曼模型" class="headerlink" title="1. 冯诺依曼模型"></a>1. 冯诺依曼模型</h2><p>冯诺依曼模型：运算器、控制器、存储器、输入设备、输出设备。对应于现代计算机的结构：</p><ul><li>存储器：内存</li><li>控制器：南桥，负责IO设备、外部存储设备与BIOS之间的通信；北桥，负责CPU和内存、显卡的数据传送</li><li>运算器：CPU</li><li>输入设备：键盘</li><li>输出设备：显示器、网卡</li></ul><p>运算器、控制器在中央处理器中，存储器就是常见的内存，输入输出设备是计算机外接设备。存储单元与输入输出设备通过控制总线、数据总线与地址总线与CPU以及其中的控制器、寄存器、逻辑运算单元连接。</p><h3 id="1-内存"><a href="#1-内存" class="headerlink" title="1. 内存"></a>1. 内存</h3><p>存储数据基本单位是字节，1字节=8位。</p><h3 id="2-中央处理器-CPU"><a href="#2-中央处理器-CPU" class="headerlink" title="2. 中央处理器/CPU"></a>2. 中央处理器/CPU</h3><p>32位CPU一次可以计算4个字节，64位则是8个。32位与64位通常称为位宽。</p><p>常用寄存器种类：</p><ul><li>通用寄存器：存放需要进行运算的数据。</li><li>程序计数器：存储CPU要执行下一条指令<strong>所在的内存地址</strong>。</li><li>指令寄存器：存放当前正在执行的指令。</li></ul><h3 id="3-总线"><a href="#3-总线" class="headerlink" title="3. 总线"></a>3. 总线</h3><p>负责通信，分为三种：</p><ul><li>地址总线：指定CPU将要操作的内存地址。</li><li>数据总线：读写内存数据。</li><li>控制总线：发送和接收信号。</li></ul><p>CPU读写内存数据时，先通过<strong>地址总线</strong>指定内存地址，然后通过<strong>控制总线</strong>控制读写命令，最后通过<strong>数据总线</strong>传输数据。</p><h3 id="4-输入输出设备"><a href="#4-输入输出设备" class="headerlink" title="4. 输入输出设备"></a>4. 输入输出设备</h3><p>输入设备向计算机输入数据，计算机计算后将结果交给输出设备。</p><p>如果输入设备是键盘，按下按键时需要与CPU交互，还需要用到控制总线。</p><h2 id="2-位宽"><a href="#2-位宽" class="headerlink" title="2. 位宽"></a>2. 位宽</h2><p>线路位宽：地址总线数目。每条地址总线能表示0或1，总共能表示0~2^n范围内的数据。</p><p>CPU位宽：CPU在一个时钟周期内能处理的二进制位数。</p><p>CPU位宽=数据总线位宽=CPU内部通用寄存器位宽=机器字长（计算机一次整数运算能处理的二进制数据的位数）</p><p>CPU位宽最好不要小于线路位宽。32位CPU最大只能操作4G内存，因此安装再大的内存也没用。</p><h2 id="3-指令周期"><a href="#3-指令周期" class="headerlink" title="3. 指令周期"></a>3. 指令周期</h2><p>一条指令通常分为4个阶段，称为四级流水线，或是<strong>指令周期</strong>。</p><ol><li>Fetch（取得指令）：CPU通过程序计数器读取对应内存地址的指令。<strong>控制器</strong>根据程序计数器的值，操作<strong>地址总线</strong>指定需要访问的指令；<strong>内存</strong>取出指令并通过<strong>数据总线</strong>传输回CPU，控制器将其放在指令寄存器中。程序计数器自增。</li><li>Decode（指令译码）：CPU对指令进行解码。由<strong>控制器</strong>进行。</li><li>Execution（指令解码）：CPU执行指令。一般由<strong>算术逻辑单元</strong>操作，如果是简单的无条件跳转则是由<strong>控制器</strong>完成。</li><li>Store（数据回写）：CPU将计算结果存回寄存器或将寄存器的值存入内存。</li></ol><p>指令通过功能可划分为5大类：数据传输、运算、跳转、信号（trap引起中断）、闲置。</p><p>1GHz的CPU指的是时钟频率1G，1秒产生1G次数的脉冲信号，每一次脉冲信号高低电平转换为一个周期，称为时钟周期。</p><p>程序CPU执行时间 = CPU时钟周期数 x 时钟周期时间 = 指令数 x CPI（每条指令平均时钟周期数） x 时钟周期时间</p><h2 id="4-64位和32位"><a href="#4-64位和32位" class="headerlink" title="4. 64位和32位"></a>4. 64位和32位</h2><p>64位CPU优势：</p><ul><li>可以一次计算超过32位的数字。</li><li>可以寻址更大的内存空间。</li></ul><p>硬件的64位与32位指CPU位宽，而软件指的是指令的位宽，也就是指令多少位（操作系统也是一种应用程序）。</p><h2 id="5-存储结构"><a href="#5-存储结构" class="headerlink" title="5. 存储结构"></a>5. 存储结构</h2><p>寄存器、CPU Cache（L1、L2、L3）、内存、硬盘。</p><p>存储器速度越快，能耗就越高，单位空间也越贵，所以容量一般越小。</p><p>每一种存储设备只与它相邻的存储器设备打交道。</p><h3 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1. 寄存器"></a>1. 寄存器</h3><p>32位/64位CPU中大多数寄存器可存储4/8个字节，一般要求在半个CPU时钟周期内完成读写。</p><h3 id="2-CPU-Cache"><a href="#2-CPU-Cache" class="headerlink" title="2. CPU Cache"></a>2. CPU Cache</h3><p>使用SRAM（Static Random-Access Memory，静态随机存储器）的芯片。“静态”是因为只要有电数据就在，一旦断电数据就丢失。一般分为三层：</p><ol><li>L1高速缓存：访问速度2~4个时钟周期，大小在几十KB到几百KB不等。每个CPU都有一块L1高速缓存，分为指令缓存和数据缓存。</li><li>L2高速缓存：访问速度10~20个时钟周期，大小在几百KB到几MB不等。每个CPU都有一块，比L1离CPU核心更远。</li><li>L3高速缓存：访问速度20~60个时钟周期，大小在几MB到几十MB不等。一般多个CPU核心公用，位置更远。</li></ol><h3 id="3-内存"><a href="#3-内存" class="headerlink" title="3. 内存"></a>3. 内存</h3><p>使用DRAM（Dynamic Random Access Memory，动态随机存取存储器）芯片。“动态”指需要定时刷新电容才能保证数据不丢失。访问速度200~300个时钟周期。</p><h3 id="4-SSD-HDD硬盘"><a href="#4-SSD-HDD硬盘" class="headerlink" title="4. SSD/HDD硬盘"></a>4. SSD/HDD硬盘</h3><p>固态硬盘（Solid-state disk）：比内存慢10~1000倍。</p><p>机械硬盘（Hard Disk Drive）：比内存慢10w倍左右。</p><h2 id="6-Cache映射方式"><a href="#6-Cache映射方式" class="headerlink" title="6. Cache映射方式"></a>6. Cache映射方式</h2><p>CPU Cache由很多个Cache Line（缓存块）组成，Cache Line由Tag + Data Block组成。</p><h3 id="1-直接映射"><a href="#1-直接映射" class="headerlink" title="1. 直接映射"></a>1. 直接映射</h3><p>CPU访问内存数据也是以块为单位读取的，称为内存块。直接映射把内存块的地址始终映射在一个CPU缓存块的地址，通过取模运算映射。所以，缓存块大小应与内存块大小保持一致。</p><p>有效位Valid bit：标记对应的缓存块数据是否有效。</p><p>组标记Tag：记录当前缓存块中存储的数据对应的内存块。</p><p>数据Data：存放缓存数据块。</p><p>内存地址可分为：Tag + Index + Offset。CPU根据该地址访问Cache的顺序为：</p><ol><li>先计算该内存在Cache中的索引，也就是Index。</li><li>判断有效位，如果无效需要重新加载。</li><li>对比Tag组标记，确实是否为需要访问的地址，否则重新加载。</li><li>根据Offset偏移量信息读取对应的字。</li></ol><h3 id="2-全相联映射"><a href="#2-全相联映射" class="headerlink" title="2. 全相联映射"></a>2. 全相联映射</h3><p>每个内存块映射到Cache的任意块中，有空位就放，靠Tag组标记来确认是否为需要的地址。</p><h3 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="3. 组相联映射"></a>3. 组相联映射</h3><p>每个内存块映射到Cache固定组的任意块中。内存块与组的映射关系与直接映射相同，而组中使用全相联映射。</p><h2 id="7-提升Cache命中率"><a href="#7-提升Cache命中率" class="headerlink" title="7. 提升Cache命中率"></a>7. 提升Cache命中率</h2><h3 id="1-数据缓存"><a href="#1-数据缓存" class="headerlink" title="1. 数据缓存"></a>1. 数据缓存</h3><p>多维数组占用的内存是连续的，尽量按照内存布局顺序访问。</p><h3 id="2-指令缓存"><a href="#2-指令缓存" class="headerlink" title="2. 指令缓存"></a>2. 指令缓存</h3><p>CPU有分支预测器，对于条件语句，如果可以预测到接下来执行哪个分支的指令，就提前将其放在指令缓存中。</p><p>可以在一段循环中尽量将同一个分支的语句放在一起，比如先排序再遍历条件处理。</p><h2 id="8-Cache写入内存"><a href="#8-Cache写入内存" class="headerlink" title="8. Cache写入内存"></a>8. Cache写入内存</h2><p>写直达：将更新的数据同时写入Cache和内存。</p><p>写回：只写Cache，并设置为脏。只有脏块被替换时才写内存。</p><h2 id="9-缓存一致性问题"><a href="#9-缓存一致性问题" class="headerlink" title="9. 缓存一致性问题"></a>9. 缓存一致性问题</h2><p>多核CPU具有各自的Cache，可能引起一致性问题。</p><p>要实现机制同步缓存数据，需要做到：</p><ol><li><strong>写传播</strong>：某个CPU核心的Cache数据更新时要传播到其他核心的Cache。</li><li><strong>事务串行化</strong>：某个CPU核心对数据的操作顺序在其他核心看起来顺序一样。</li></ol><p>实现机制：</p><h3 id="1-总线嗅探"><a href="#1-总线嗅探" class="headerlink" title="1. 总线嗅探"></a>1. 总线嗅探</h3><p>CPU修改后通过总线将事件广播给其他所有核心，每个CPU核心时刻监听总线上的广播事件。</p><p>缺点：需要每个CPU核心时刻监听，加重负载；不能保证事务串行化。</p><h3 id="2-MESI协议"><a href="#2-MESI协议" class="headerlink" title="2. MESI协议"></a>2. MESI协议</h3><p>Cache Line的四个状态：</p><ul><li>Modified，已修改。该缓存块的数据已更新，但还没有写到内存。</li><li>Exclusive，独占。该缓存块的数据与内存一致，但是只有这一个CPU核心中缓存。</li><li>Shared，共享。该缓存块的数据与内存一致，但是有其他CPU核心缓存。</li><li>Invalidated，已失效。该缓存块的数据已失效，不可读取。</li></ul><p>状态转换：</p><ul><li>已修改：<ul><li>本地读：从Cache中取数据，状态不变。</li><li>本地写：写入Cache中，状态不变。</li><li>远程读：Cache Line中的数据写入内存，状态变成共享。</li><li>远程写：Cache Line中的数据写入内存，状态变成已失效。（其他CPU读取后写入新的数据）</li></ul></li><li>独占：<ul><li>本地读：从Cache中取数据，状态不变。</li><li>本地写：写入Cache中，状态变成已修改。</li><li>远程读：状态变成共享。</li><li>远程写：状态变成已失效。（为啥独占还会被远程写？？？）</li></ul></li><li>共享：<ul><li>本地读：从Cache中取数据，状态不变。</li><li>本地写：写入Cache中，状态变成已修改。其他CPU核心共享的Cache Line状态变成已失效。</li><li>远程读：状态不变。</li><li>远程写：状态变成已失效。</li></ul></li><li>已失效：<ul><li>本地读：<ul><li>如果其他核心的Cache没有这份数据，本地核心Cache从内存中读取，状态变成独占。</li><li>如果其他核心中的Cache有这份数据，且状态为共享或独占，本地核心Cache从内存中读取，这些共享Cache Line状态变成共享。</li><li>如果其他核心中的Cache有这份数据，且状态为已修改，则其他核心Cache更新到内存，本地再从内存中读取，这两个Cache Line状态变成共享。</li></ul></li><li>本地写：先本地读，然后在Cache中更新数据，状态变成已修改。其他核心中Cache Line状态变成已失效。</li><li>远程写：已失效，所以其他核心操作与其无关。</li><li>远程读：已失效，所以其他核心操作与其无关。</li></ul></li></ul><h2 id="10-Cache伪共享"><a href="#10-Cache伪共享" class="headerlink" title="10. Cache伪共享"></a>10. Cache伪共享</h2><p>因为多个线程同时读写同一个Cache Line的不同变量时导致CPU Cache失效的现象。</p><p>避免的方法：通过对齐机制或字节填充等，让读写的变量不在一个Cache行中。</p><ol><li>__cacheline_alinged_in_smp宏定义：在多核系统中定义为__cacheline_alinged，Cache Line的大小。可以在结构体中将变量地址设置为Cache Line对齐地址，使不同的变量在不同Cache Line中。</li><li>RingBuffer（Java）：在结构前后各填充七个不会被读写的long变量。</li></ol><h2 id="11-Linux-Windows的线程调度"><a href="#11-Linux-Windows的线程调度" class="headerlink" title="11. Linux/Windows的线程调度"></a>11. Linux/Windows的线程调度</h2><h3 id="1-Linux"><a href="#1-Linux" class="headerlink" title="1. Linux"></a>1. Linux</h3><p>Linux中根据任务的优先级与响应要求分为两种，优先级数值越小优先级越高：</p><ul><li>实时任务：优先级0~99.</li><li>普通任务：优先级100~139.</li></ul><p>调度类分为三种：</p><p>Deadline和Realtime调度类应用于实时任务，其调度策略结合起来有三种。</p><ul><li>SCHED_DEADLINE：距离当前时间点最近的deadline任务优先调度。</li><li>SCHED_FIFO：相同优先级先来先服务，优先级更高可抢占。</li><li>SCHED_RR：相同优先级时间片轮转，优先级更高可抢占。</li></ul><p>Fair调度类应用于普通任务，由CFS调度器管理：</p><ul><li>SCHED_NORMAL：普通任务调度策略。</li><li>SCHED_BATCH：后台任务调度策略，可以适当降低优先级。</li><li>SCHED_IDLE：空闲时才跑的任务。</li></ul><p>Linux中实现了一个基于CFS的调度算法，完全公平调度。</p><ul><li>为每个任务维护一个虚拟运行时间，当逻辑时钟到来时增加所有正在运行的任务的虚拟时间。</li><li>调度时优先选择虚拟运行时间少的任务。</li><li>每个任务根据优先级获得权重，权重越大虚拟时间增加越慢，也就更容易获得调度。</li></ul><p>CFS：完全公平调度策略。试图模拟一个理想的、精确的多任务CPU，希望能将性能平分给所有并行的进程。</p><h3 id="2-Windows"><a href="#2-Windows" class="headerlink" title="2. Windows"></a>2. Windows</h3><p>windows调度器根据优先级采用抢占式调度策略，调度线程。</p><p>使用32个数字表示优先级。数字越高优先级越高。</p><ul><li>实时优先级16~31。</li><li>可变优先级1~15。</li><li>系统优先级0，用于内存页清零线程。</li></ul><p>创建线程时，在其优先级别上进一步赋予相对优先级：尽量实时、最高、高于一般、一般、低于一般、最低、空闲。</p><p>调度时参考：当前线程所在进程额基准优先级，与线程优先级。</p><p>可变优先级进入实时优先级，需要获得更高的调度优先级特权。</p><p>线程状态：</p><ul><li>就绪</li><li>预备：比就绪更接近运行。</li><li>运行</li><li>等待：等待系统资源。</li><li>过渡：线程已经准备就绪，但是运行它所需的核心栈暂时被分页调度到磁盘上。</li><li>终止</li><li>已初始化：刚创建</li></ul><p>调度机制：</p><ul><li>为每一个优先级别维护一个就绪等待队列。</li><li>线程运行时获得一个可运行的时间配额。每过一个时钟周期-1。</li><li>时间配额用完时调度下一个优先级最高的线程。基于优先级的抢占调度，有比运行线程更高优先级的线程进入等待队列时，可抢占。</li><li>运行线程需要等待某一对象时，主动让出CPU进入等待。</li><li>为每一个等待对象维护一个等待队列。</li><li>线程核心栈完成上下文切换，调度器将调出线程的上下文环境信息压入该线程的核心栈，并将栈指针保存到该线程的核心线程块。</li></ul><h2 id="12-中断"><a href="#12-中断" class="headerlink" title="12. 中断"></a>12. 中断</h2><p>Linux系统为了解决中断处理程序过长和中断丢失的问题，将中断过程分为两个阶段，分别是上半部和下半部</p><ul><li>上半部处理快速中断，一般暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。</li><li>下半部延迟处理上半部未完成的工作，一般以内核线程的方式运行。</li></ul><h2 id="13-操作系统的作用"><a href="#13-操作系统的作用" class="headerlink" title="13. 操作系统的作用"></a>13. 操作系统的作用</h2><p>作为应用程序和硬件之间的中间层，控制应用程序应用硬件的权限，并且提供统一机制控制复杂的底层硬件。</p><p>引入抽象概念：</p><ul><li>文件是对IO设备的抽象。</li><li>虚拟内存是对内存和磁盘IO的抽象。</li><li>进程是对处理器、内存与IO设备的抽象。</li></ul><h1 id="2-操作系统内核"><a href="#2-操作系统内核" class="headerlink" title="2. 操作系统内核"></a>2. 操作系统内核</h1><p>内核基本功能：</p><ul><li>进程调度：管理进程线程，决定哪个进程线程使用CPU。</li><li>内存管理：管理内存，决定内存分配与回收。</li><li>硬件通信：管理硬件设备，为进程与硬件设备之间提供通信能力。</li><li>系统调用：提供系统调用，让应用程序支持运行更高权限的服务。</li></ul><h2 id="1-Linux-1"><a href="#1-Linux-1" class="headerlink" title="1. Linux"></a>1. Linux</h2><p>Linux内核的设计理念：</p><ul><li>MultiTask多任务：并发/并行</li><li>SMP对称多处理：每个CPU地位相等，对资源的使用权限相同。</li><li>ELF可执行文件链接格式：Linux中可执行文件的存储格式。<ul><li>代码通过编译器编译成汇编代码，通过汇编器变成目标代码，最后通过连接器将多个目标文件以及调用的函数库链接，形成可执行文件。</li><li>ELF文件通过装载器装载到内存里，CPU读取指令和数据执行文件。</li></ul></li><li>Monolithic Kernel宏内核：Linux内核是一个完整的可执行程序且拥有最高权限<ul><li>微内核：内核只保留最基本的能力，如进程调度、中断等，将一些应用放到用户空间。服务之间隔离，单个服务出现故障不会导致整个操作系统挂掉；由于驱动程序不在内核中，与硬件设备交互需要频繁切换，带来性能损耗。</li><li>混合类型内核：宏内核包着一个微内核。</li></ul></li></ul><h2 id="2-Windows-1"><a href="#2-Windows-1" class="headerlink" title="2. Windows"></a>2. Windows</h2><p>混合型内核。</p><p>可执行文件叫PE可移植执行文件。</p><h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><p>程序使用的内存地址叫虚拟内存地址，实际存在硬件里的空间地址叫物理内存地址。进程持有的虚拟地址通过CPU中的内存管理单元MMU映射到物理地址，再通过物理地址访问内存。</p><p>虚拟内存的意义/为什么要虚拟内存：</p><ul><li>结合磁盘和物理内存的优势，为进程提供看起来速度足够快且容量足够大的独立存储。进程都有一样的虚拟内存，但页表不同，因此分配到的物理内存也就不同。</li><li>进程间可共享物理内存减少开销，也能简化程序的链接、装载与内存分配过程。</li><li>控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li></ul><h2 id="1-内存分段"><a href="#1-内存分段" class="headerlink" title="1. 内存分段"></a>1. 内存分段</h2><p>不同的段有不同的属性。虚拟地址由段选择因子和段内偏移量两部分组成。</p><ul><li>段选择因子保存在段寄存器中，有段号，用作段表索引。段表里保存段基地址、段的界限和特权等级。</li><li>段内偏移量位于0和段界限之间。段基地址加上段内偏移量得到物理内存地址。</li></ul><p>不足：</p><ul><li>内存碎片：分段管理不会出现内部内存碎片，但是多个段未必能恰好使用所有内存空间，会产生多个不连续的小物理内存，就是外部内存碎片。解决方法是内存交换。</li><li>内存交换效率低：外部内存碎片很容易产生，而每一次内存交换都需要把一大段连续的内存数据写到硬盘上，硬盘访问速度比内存慢太多。</li></ul><h2 id="2-内存分页"><a href="#2-内存分页" class="headerlink" title="2. 内存分页"></a>2. 内存分页</h2><p>将整个虚拟和物理内存空间切成固定大小，叫页。Linux每页4KB。虚拟地址与物理地址间通过页表映射。只有需要时触发缺页中断将页加载到物理内存中。</p><p>页与页之间紧密排列，不会有外部碎片。但是即使程序不足一页大小，也至少要分配一页，会产生内部内存碎片。</p><p>内存页面换入/换出使得<strong>一次性换入/换出磁盘的只有少数几页，提高了交换效率。</strong></p><p>虚拟地址分为页号与页内偏移：</p><ul><li>根据页号在页表中查询物理页号。</li><li>物理页号+偏移量得到物理内存地址。</li></ul><p>不足：</p><ul><li>内部内存碎片</li><li>页表项太大：多级页表，只在需要时创建多级页表。64位系统有4级目录。</li></ul><p>TLB：页表项Cache，存储程序最常访问的页。将虚拟地址直接映射到物理地址而不必访问页表。CPU中的内存管理单元完成地址转换与TLB的访问与交互。</p><h2 id="3-段页式内存管理"><a href="#3-段页式内存管理" class="headerlink" title="3. 段页式内存管理"></a>3. 段页式内存管理</h2><p>先将程序划分为多个有逻辑意义的段，再将每个段划分为多个页。地质结构由段号、段内页号和页内位移三部分组成。</p><p>段页式地址变换到物理地址需要经过三次内存访问：</p><ul><li>第一次访问段表，得到页表起始地址。</li><li>第二次访问页表，得到物理页号。</li><li>第三次将物理页号与页内位移结合，得到物理地址。</li></ul><h2 id="4-Linux虚拟内存布局"><a href="#4-Linux虚拟内存布局" class="headerlink" title="4. Linux虚拟内存布局"></a>4. Linux虚拟内存布局</h2><p>32位Linux系统每个段都是从0地址开始的整个4GB虚拟空间。相当于屏蔽了逻辑地址概念，只用页管理地址，段只用于访问控制和内存保护。内核空间占用最高的1G，用户最多可申请剩下的3G虚拟空间。</p><p>64位系统内核空间与用户空间都是128T，中间部分未定义。</p><p>32位空间用户内存从低到高分布：</p><ul><li>程序文件段（.text）:二进制可执行代码。</li><li>已初始化数据段（.data）：静态常量。</li><li>未初始化数据段（.bss）：未初始化的静态变量。</li><li>堆段：动态分配的内存，从低地址向上增长。</li><li>文件映射段：动态库、共享内存等，从低地址向上增长。</li><li>栈段：局部变量和函数调用的上下文等。栈大小固定。</li></ul><h2 id="5-动态分配内存"><a href="#5-动态分配内存" class="headerlink" title="5. 动态分配内存"></a>5. 动态分配内存</h2><p>mmap可以在文件映射段动态分配内存，malloc可以在堆段动态分配内存。</p><p>操作系统先在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目，指向硬盘上新创建的虚拟页），通过页表条目建立虚拟页和物理页的映射关系。</p><p>malloc有两种方式申请内存：具体看C++篇</p><ul><li>如果用户分配内存小于128KB，通过brk系统调用从堆分配。free释放内存时并不还给操作系统，而是缓存在malloc内存池中。</li><li>如果用户分配内存大于128KB，通过mmap系统调用在文件映射区分配。free释放内存时还给操作系统。</li></ul><p>为什么不全部用mmap：mmap每次释放内存都还给操作系统，所以分配的虚拟地址一定没有映射的物理地址，导致第一次访问一定会触发缺页中断，导致CPU消耗大。</p><p>为什么不全部用brk：容易出现内存碎片，导致内存泄漏。</p><p>malloc返回给用户态的内存起始地址比堆空间起始地址多了16字节：存储内存块描述信息，如内存块大小等。</p><h2 id="6-内存紧张的处理方式"><a href="#6-内存紧张的处理方式" class="headerlink" title="6. 内存紧张的处理方式"></a>6. 内存紧张的处理方式</h2><p>回收内存：</p><ul><li>后台内存回收（kswapd）：异步回收，物理内存紧张时唤醒kswapd内核线程来回收内存。</li><li>直接内存回收（direct reclaim）：同步回收，后台内存回收跟不上进程申请的速度，就会开始直接回收。</li><li>OOM（Out Of Memory）机制：直接内存回收后空闲内存仍然无法满足申请。OOM Killer机制根据算法不断选择一个占用物理内存较高的进程杀死，直到释放了足够的内存。可以通过调整oom_score_adj降低程序被杀死的优先级，-1000表示无论如何都不能被杀。</li></ul><p>可以被回收的内存：</p><ul><li>文件页：包括内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）。</li><li>匿名页：堆、栈数据等。通过Swap机制将不常访问的内存写入磁盘中，再次使用时再从磁盘读取。</li></ul><p>两种页的回收都是基于LRU算法，维护活跃内存页与不活跃内存页两个双向链表。</p><p>调整回收内存的性能影响：</p><ul><li>调整文件页和匿名页的回收倾向。应该优先回收文件页，因为文件页在磁盘中有备份，如果没有写入甚至可以直接覆盖，而匿名页需要先交换到磁盘进行备份。</li><li>尽早触发kswapd内核线程异步回收。</li></ul><h2 id="7-NUMA架构"><a href="#7-NUMA架构" class="headerlink" title="7. NUMA架构"></a>7. NUMA架构</h2><p>SMP架构：多个CPU处理器地位平等，共享电脑资源。也被称为一致存储访问结构NUMA。</p><p>但是随着CPU增多，多个CPU通过一个总线访问内核，总线带宽压力会越来越大，同时每个CPU可用带宽减少。</p><p>非一致存储访问结构NUMA：将CPU分组，每一组CPU表示为Node，每个Node有独立的资源（内存、IO），通过互联模块总线QPI通信。</p><p>NUMA架构下如果某个Node内存不足，可以在其他Node中寻找空闲内存，并且可以调整这个行为与在本Node回收内存的优先级。</p><h2 id="8-申请超出物理内存的虚拟内存"><a href="#8-申请超出物理内存的虚拟内存" class="headerlink" title="8. 申请超出物理内存的虚拟内存"></a>8. 申请超出物理内存的虚拟内存</h2><p>分别在32位、64位机器上申请8GB虚拟内存</p><ul><li>32位操作系统进程最大只能申请3GB虚拟内存，所以会申请失败。</li><li>64位操作系统进程最大可以申请128TB虚拟内存，所以会申请成功，即使物理内存小于8GB（申请的是虚拟内存）。如果物理页框全被分配完时，虚拟内存被访问，要看系统有无Swap分区。<ul><li>如果没有，因为物理空间不够，进程会因为内存溢出OOM被系统杀死。</li><li>如果有，只要申请的物理内存不高出实际物理内存太多，就能正常运行。</li></ul></li></ul><h2 id="9-改进LRU算法"><a href="#9-改进LRU算法" class="headerlink" title="9. 改进LRU算法"></a>9. 改进LRU算法</h2><p>传统LRU算法存在两个问题：</p><h3 id="1-预读失效，导致缓存命中率下降"><a href="#1-预读失效，导致缓存命中率下降" class="headerlink" title="1. 预读失效，导致缓存命中率下降"></a>1. 预读失效，导致缓存命中率下降</h3><p>出于空间局部性原理，会选择想要读取的数据块周围的几个数据块都加载到内存。</p><p>这些提前加载的页如果都没有被访问，就会白白浪费读取资源，而且将热点数据挤到队列末尾淘汰。</p><h4 id="1-Linux的处理方式"><a href="#1-Linux的处理方式" class="headerlink" title="1. Linux的处理方式"></a>1. Linux的处理方式</h4><p>分为活跃LRU链表和非活跃LRU链表，预读页进入非活跃LRU链表的头部，真正访问的页加入活跃LRU链表头部。活跃LRU链表淘汰的页，会被降级，插入到非活跃LRU链表的头部。</p><h4 id="2-MySQL的处理方式"><a href="#2-MySQL的处理方式" class="headerlink" title="2. MySQL的处理方式"></a>2. MySQL的处理方式</h4><p>与Linux类似，分为young区域与old区域，默认比例63：37。</p><h3 id="2-缓存污染，导致缓存命中率下降"><a href="#2-缓存污染，导致缓存命中率下降" class="headerlink" title="2. 缓存污染，导致缓存命中率下降"></a>2. 缓存污染，导致缓存命中率下降</h3><p>批量读取数据时很多的数据都只会读取一次，但是全部加入活跃LRU链表中，将热点数据全部淘汰。</p><h4 id="1-Linux处理方式"><a href="#1-Linux处理方式" class="headerlink" title="1. Linux处理方式"></a>1. Linux处理方式</h4><p>内存页被访问第二次时才升级到活跃LRU链表。</p><h4 id="2-MySQL处理方式"><a href="#2-MySQL处理方式" class="headerlink" title="2. MySQL处理方式"></a>2. MySQL处理方式</h4><p>内存页被访问第二次时，如果与上次访问时间超过1秒，就会升级到young区域。</p><h2 id="10-虚拟内存管理"><a href="#10-虚拟内存管理" class="headerlink" title="10. 虚拟内存管理"></a>10. 虚拟内存管理</h2><p>64位系统虚拟内存布局与32位系统的差异：</p><ol><li>用户空间与内核空间存在空洞（高16位既不全为0也不全为1）。</li><li>代码段跟数据段之间存在一段不可读写的保护段，防止越界。</li><li>用户态虚拟内存空间与内核态虚拟内存空间都占用128T。</li></ol><p>具体的数据结构组织方式：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d945d22667c4ea56dbd2f19677306a91.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/d945d22667c4ea56dbd2f19677306a91.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>内核态虚拟内存空间前896M区域是直接映射到物理内存前896M的区域，称为直接映射区。前1M在系统启动时被系统占用。后面存放内核代码段，数据段，BSS段，进程相关的描述符。</p><h2 id="11-内存碎片"><a href="#11-内存碎片" class="headerlink" title="11. 内存碎片"></a>11. 内存碎片</h2><p>外部碎片：内存中某些空闲区因为比较小而难以利用上，一般出现在内存动态分配方式中。可以通过紧凑技术解决外部碎片问题，即操作系统不时移动整理进程。但是需要动态重定位寄存器支持，且相对费时。</p><p>内部碎片：分配给某些进程的内存区域有些部分没用上，一般出现在固定分配方式中。</p><p>分段式分配是按需分配，所以有外部碎片无内部碎片；分页式分配是固定分配，所以有内部碎片无外部碎片。</p><h1 id="4-进程管理"><a href="#4-进程管理" class="headerlink" title="4. 进程管理"></a>4. 进程管理</h1><h2 id="1-进程状态"><a href="#1-进程状态" class="headerlink" title="1. 进程状态"></a>1. 进程状态</h2><ul><li>创建状态：进程正在被创建。</li><li>结束状态：进程正在从系统中消失。</li><li>运行状态：进程正在占用CPU。</li><li>就绪状态：进程可运行，由于其他进程处于运行状态而暂时停止运行。</li><li>阻塞状态：进程正在等待某一事件发生而暂时停止运行。</li><li>阻塞挂起状态：进程在外存并在等待某一事件发生。</li><li>阻塞就绪状态：进程在外存，但只要进入内存就立刻运行。</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="2-进程的控制结构"><a href="#2-进程的控制结构" class="headerlink" title="2. 进程的控制结构"></a>2. 进程的控制结构</h2><p>操作系统用进程控制块PCB描述进程，PCB是进程存在的唯一标识，包含如下信息：</p><ul><li>进程描述信息，包括进程标识符、用户标识符。</li><li>进程控制和管理信息，包括进程状态、优先级。</li><li>资源分配清单，有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的I/O设备信息。</li><li>CPU相关信息，包括CPU中寄存器的值。</li></ul><p>一般用链表的方式组织PCB，比如就绪队列、阻塞队列等，方便增删与管理。</p><h2 id="3-★-进程-线程的控制与切换"><a href="#3-★-进程-线程的控制与切换" class="headerlink" title="3. ★ 进程/线程的控制与切换"></a>3. ★ 进程/线程的控制与切换</h2><p>一般过程为创建/查找到PCB，（创建时需要初始化并分配资源），修改状态，并插入到就绪/阻塞队列。</p><p>终止进程时如果有子进程，需要交给1号进程托管。</p><p>进程上下文切换的场景：</p><ul><li>时间片耗尽</li><li>系统资源不足，需要等到资源满足才运行时</li><li>sleep主动挂起</li><li>优先级更高的进程抢占</li><li>硬件中断</li></ul><p><strong>抢占式调度会抢占CPU</strong></p><p>★ 切换步骤：</p><ul><li>进程：<ul><li>切换页目录，使用新的地址空间</li><li>切换内核栈和硬件上下文</li></ul></li><li>线程：只有第二步<ul><li>具体过程：<ul><li>保存CPU上下文：指令指针寄存器、栈顶位置、其他CPU中间状态</li><li>触发软中断转到内核态，恢复内核栈寄存器信息</li><li>内核调度一个线程，恢复其CPU上下文</li><li>转到用户态，开始执行新线程</li></ul></li></ul></li></ul><p>开销：</p><ul><li>保存寄存器中的内容</li><li>CPU高速缓存、快表失效</li><li>调度算法</li></ul><h2 id="4-★-线程"><a href="#4-★-线程" class="headerlink" title="4. ★ 线程"></a>4. ★ 线程</h2><p>fork与pthread底层实现都是调用同一个内核函数clone，如果复制地址空间则为fork，如果共享地址空间则为pthread。</p><p>Linux只在用户层面上区分进程和线程，所以pthread操作函数是库函数而非系统调用。</p><p>★ 与进程的区别：</p><ul><li>进程是资源分配的单位，线程是CPU调度的单位。</li><li>进程有完整的资源平台，而线程只独享必不可少的资源。</li></ul><p>线程减少开销体现在：</p><ul><li>创建比进程快，因为大部分资源共享，创建时不需要资源管理信息。<ul><li>线程共享所在进程的虚拟地址空间，切换时不用切换虚拟地址。</li><li>因此，切换线程时TLB和cache也都不会失效。</li></ul></li><li>终止比进程快，因为释放资源少。</li><li>同一个进程内的线程切换比进程快，因为他们共享资源多，切换的东西少。</li><li>线程间数据交互效率更高，因为不需要经过内核。</li></ul><p>线程共享资源：</p><ul><li>代码段、数据段</li><li>文件描述符表</li><li>信号处理函数</li><li>当前工作目录</li><li>用户ID和组ID</li></ul><p>独占资源：记前三点差不多了吧</p><ul><li>线程id</li><li>处理器现场和内核栈指针</li><li>独立的用户栈空间</li><li>errno</li><li>信号屏蔽字</li><li>调度优先级</li></ul><p>优点：</p><ul><li>提高程序并发</li><li>开销小</li><li>数据通信、共享方便</li></ul><p>缺点：</p><ul><li>库函数支持，不稳定</li><li>调试、编写困难，gdb不支持</li><li>对信号支持不好</li></ul><p>线程的实现：</p><ul><li><p>用户线程：用户空间实现的线程，由用户态的线程库管理。</p><ul><li>优点：<ul><li>进程私有TCB列表，由用户级线程库函数维护，可用于不支持线程技术的操作系统。</li><li>线程切换也是由线程库函数完成，速度快。</li></ul></li><li>缺点：<ul><li>如果一个线程发起系统调用而阻塞，那进程所包含的用户线程都不能执行。</li><li>一个进程中的线程无法互相抢占CPU，因为只有操作系统有这个特权，但操作系统不参与调度用户线程。</li><li>时间片只分配给进程，所以线程得到的时间片少。</li></ul></li></ul></li><li><p>内核线程：内核中实现的线程，由内核管理。</p><ul><li>优点：<ul><li>一个进程中某线程的阻塞不影响其他线程。</li><li>多线程的进程获得更多CPU运行时间。</li></ul></li><li>缺点：<ul><li>支持内核线程的操作系统中由内核维护TCB、PCB，占用内核空间。</li><li>线程创建终止和切换都是通过系统调用进行，系统开销大。</li></ul></li></ul></li><li><p>轻量级进程LWP：在内核中支持用户线程，每个LWP由一个内核线程支持（CPU资源分配、调度），由内核管理并像普通进程一样被调度，用户线程运行在LWP上。一个LWP可以对应一个或多个用户线程。</p></li></ul><h2 id="5-线程调度"><a href="#5-线程调度" class="headerlink" title="5. 线程调度"></a>5. 线程调度</h2><p>可以根据如何处理时钟中断分为非抢占式调度算法与抢占式调度算法。抢占式调度需要在时间间隔末端发生时钟中断，以便把CPU控制返回给调度程序。</p><p>调度原则：</p><ul><li>CPU利用率：确保CPU始终匆忙，提高CPU利用率。</li><li>系统吞吐量：单位时间内CPU完成进程的数量。</li><li>周转时间：进程运行+阻塞+等待事件总和。</li><li>等待时间：进程处于就绪队列的时间。</li><li>响应时间：用户提交到系统第一次产生相应花费的时间。</li></ul><p>FCFS先来先服务算法、SJF最短作业优先算法、HRRN高响应比优先算法、RR时间片轮转算法、HPF最高优先级算法。</p><p>多级反馈队列算法：</p><ul><li>多个队列，优先级由高到低，优先级越高时间片越短。</li><li>如果有新的进程加入优先级高的队列，立刻停止当前正在运行的进程转而运行优先级高的队列。</li><li>新进程加入第一级末尾，按FCFS等待调度，如果第一级队列的进程没有运行完，就加入第二级队列的末尾，以此类推。</li></ul><h2 id="6-★-进程-线程通信方式"><a href="#6-★-进程-线程通信方式" class="headerlink" title="6. ★ 进程/线程通信方式"></a>6. ★ 进程/线程通信方式</h2><p>进程：目的主要是为了交换数据</p><ul><li>匿名管道：通信数据是无格式的流且大小受限，单向通信，只能用于存在公共祖先关系的进程间通信。</li><li>命名管道：提供名称与之关联，不存在亲缘关系的进程只要能访问管道文件，也能相互通信。只读/只写管道不会单独存在，一旦被打开就会阻塞，直到另一个进程打开只写/只读管道。<ul><li>管道是半双工的，只有一方写一方读。</li><li>速度慢、传输消息少。</li><li>不用担心互斥问题。</li></ul></li><li>消息队列：保存在内核中的消息链表。消息不及时；不适合大文件传输，每条消息和队列总长度有上限；通信过程中存在内核态与用户态的数据拷贝开销。<ul><li>速度慢、传输消息少。</li><li>存在拷贝开销。</li></ul></li><li>共享内存：使一个磁盘文件与存储空间的一个缓冲区相映射。<strong>最快的通信方式</strong>，但多进程竞争同一资源会造成数据错乱。<ul><li>速度最快。</li><li>需要注意互斥。</li></ul></li><li>信号量：访问互斥与进程同步。<ul><li>只用于同步，传递消息需要结合其他机制。</li></ul></li><li>信号：异步通信机制，用于进程和内核间直接交互。简单；携带信息少；满足特定条件时发送。进程有三种方式响应信号：执行默认操作；捕捉；忽略。<ul><li>传输消息少。</li><li>用户态与内核态切换开销大。</li></ul></li><li>套接字：网络通信，也可以自连接。</li></ul><p>线程：目的主要是为了互斥/同步</p><ul><li>锁机制：互斥锁/条件变量/读写锁。</li><li>信号量。</li><li>volatile内存共享。</li></ul><h2 id="7-线程冲突问题"><a href="#7-线程冲突问题" class="headerlink" title="7. 线程冲突问题"></a>7. 线程冲突问题</h2><h3 id="1-生产者-消费者问题"><a href="#1-生产者-消费者问题" class="headerlink" title="1. 生产者-消费者问题"></a>1. 生产者-消费者问题</h3><h3 id="2-哲学家就餐问题"><a href="#2-哲学家就餐问题" class="headerlink" title="2. 哲学家就餐问题"></a>2. 哲学家就餐问题</h3><p>设计方案</p><ul><li>用叉子设置信号量，对某个哲学家必须同时P成功两边的信号量才能用餐，用餐完V。但是如果每个哲学家同时拿起自己左边的叉子，就会死锁。</li><li>在P叉子前加个互斥信号量上锁。但是同时只有一个哲学家能动。</li><li>在方案一的基础上做改进，奇数编号的哲学家先P左边的叉子，偶数编号的哲学家先P右边的叉子。</li><li>信号量表示哲学家，同时用一个数组表示哲学家状态。每位哲学家只有当两个邻居都没有进餐时才能进餐；每位哲学家进餐完毕时唤醒邻居。</li></ul><h3 id="3-读者-写者问题"><a href="#3-读者-写者问题" class="headerlink" title="3. 读者-写者问题"></a>3. 读者-写者问题</h3><ul><li>读者优先：有读者进入就试图P写者，最后一个读者出去时才V写者。</li><li>写者优先：有写者进入时P读者访问临界区的锁，保证后续不会有读者进入；写者写数据用另外的锁保证互斥。</li><li>公平：在读者优先的基础上，读者/写者进入时先P额外的共同信号量。</li></ul><h2 id="8-★-死锁"><a href="#8-★-死锁" class="headerlink" title="8. ★ 死锁"></a>8. ★ 死锁</h2><p>死锁的四要素：</p><ul><li>互斥条件：多个线程不能同时使用同一资源。</li><li>持有并等待：线程等待其他资源时不会释放已拥有的资源。</li><li>不可剥夺：线程持有资源时不能被其他线程获取。</li><li>环路等待：多个线程需求的资源被其他线程所持有，构成环形需求链。</li></ul><p>处理死锁问题：</p><ul><li>鸵鸟策略：因为解决死锁问题代价很高，所以不解决。</li><li>检测恢复：资源指向进程表示资源已分配给进程，进程指向资源表示进程请求获取资源。从一个结点开始dfs检测是否有环。如何恢复：<ul><li>抢占、回滚、杀死进程</li></ul></li></ul><p>要避免死锁问题，只要破坏前面的一个条件就行了。最常见且可行的方法是<strong>资源有序分配法</strong>，破坏环路等待条件。</p><p>资源有序分配法：将资源编号进行排序，所有线程获取资源必须按照相同的编号顺序获取。</p><p>操作系统检测死锁：</p><p>检测时机</p><ul><li>定时检索</li><li>进程阻塞时</li><li>系统资源利用率下降时</li></ul><p>检测方法：资源分配图法</p><ul><li>进程节点申请资源节点，资源-&gt;进程。</li><li>进程节点占有资源节点，进程-&gt;资源。</li><li>找到没有资源指向其的进程节点，释放其与其关联的边。</li><li>将相应资源分配给一个等待该资源的进程，即将其申请边变为占有边。</li><li>重复以上步骤，直到最后图中仍有边且不能再简化，此时即存在死锁。</li></ul><p>解决方法：</p><ul><li>撤销所有死锁进程</li><li>连续撤销死锁进程直到不再存在死锁</li><li>连续剥夺资源直到不再存在死锁</li></ul><h2 id="9-锁"><a href="#9-锁" class="headerlink" title="9. 锁"></a>9. 锁</h2><h3 id="1-互斥锁-自旋锁"><a href="#1-互斥锁-自旋锁" class="headerlink" title="1. 互斥锁/自旋锁"></a>1. 互斥锁/自旋锁</h3><p>互斥锁加锁失败后，线程会释放CPU给其他线程；自旋锁加锁失败后，线程会忙等待，直到拿到锁。</p><p>互斥锁加锁失败后，会有两次线程上下文切换的成本：把CPU切给其他线程运行；锁被释放时切给该线程运行。</p><p>自旋锁通过CPU提供的CAS函数在用户态完成加锁和解锁，CAS函数使用原子指令，查看锁状态，如果锁空闲则设置为当前线程持有。在单核CPU上需要有抢占式调度器，否则自旋线程永远不会放弃CPU导致死锁。</p><p>如果能确定被锁住的代码执行时间短（相对于上下文切换），就用自旋锁而不用互斥锁。</p><h3 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="2. 读写锁"></a>2. 读写锁</h3><p>在读多写少的场景有优势，可分为读优先锁和写优先锁：</p><ul><li>读优先锁：只要有读线程存在，写线程获取写锁就会被阻塞，而后面来的读线程依然可以获取读锁。</li><li>写优先锁：如果有写线程有写锁或被阻塞，后来的读线程要被阻塞。</li><li>公平：读写线程获取锁前都需要先在公共队列上排队（可通过信号量实现）。</li></ul><h3 id="3-乐观锁-悲观锁"><a href="#3-乐观锁-悲观锁" class="headerlink" title="3. 乐观锁/悲观锁"></a>3. 乐观锁/悲观锁</h3><p>乐观锁：先修改资源，再验证这段时间内有没有冲突，如果有冲突就放弃操作。使用CAS或版本号控制实现。CAS在硬件层面上保证原子性，由CPU支持。</p><p>悲观锁：先上锁再访问共享资源。</p><p>乐观锁重试成本很高，所以只有在冲突概率很低且加锁成本很高时才用乐观锁。</p><p>乐观锁/CAS应用：<strong>无锁队列</strong></p><p>ABA问题：</p><ul><li>进程P1在共享变量中读到值A。</li><li>P2抢占，将A改为B再改回A。</li><li>P1抢占，看到A没变，继续执行。（A如果是地址，其内的数据可能已改变）</li></ul><p>解决：计数/版本号</p><h3 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4. 条件变量"></a>4. 条件变量</h3><p>条件变量也是锁，能弥补互斥锁只有锁定和非锁定两种状态的缺点。当条件不满足时，线程揭开相应的互斥锁，等待条件发生变化。一旦某个线程改变了条件变量，就会通知相应的条件变量唤醒数个正被此条件变量阻塞的线程。</p><p>互斥锁是线程间互斥的机制，而条件变量是同步的机制。</p><h3 id="5-CAS是乐观锁，为什么基于CAS实现的自旋锁是悲观锁？"><a href="#5-CAS是乐观锁，为什么基于CAS实现的自旋锁是悲观锁？" class="headerlink" title="5. CAS是乐观锁，为什么基于CAS实现的自旋锁是悲观锁？"></a>5. CAS是乐观锁，为什么基于CAS实现的自旋锁是悲观锁？</h3><p>自旋锁基于CAS加了while或睡眠操作来实现自旋效果，需要事先拿到锁才能修改数据，所以算悲观锁。</p><h2 id="10-线程崩溃与进程崩溃"><a href="#10-线程崩溃与进程崩溃" class="headerlink" title="10. 线程崩溃与进程崩溃"></a>10. 线程崩溃与进程崩溃</h2><p>C/C++中由于非法访问内存导致的线程崩溃会引起进程崩溃。因为进程中线程的地址空间共享，某个线程的非法访问会导致内存的不确定性，进而影响到其他线程，操作系统认为可能导致严重后果。</p><p>是通过信号机制引起进程崩溃的。操作系统收到信号后执行相应的信号处理函数。</p><p>在Java中因为自定义了相应的信号处理函数，所以线程崩溃不会导致进程崩溃。虚拟机不选择退出，而是内部做了额外处理，恢复了线程执行，且抛出StackoverflowError和NPE。</p><h2 id="11-进程通信与线程通信"><a href="#11-进程通信与线程通信" class="headerlink" title="11. 进程通信与线程通信"></a>11. 进程通信与线程通信</h2><p>进程通信：</p><ul><li>管道：匿名、命名</li><li>消息队列</li><li>信号量</li><li>共享内存</li><li>信号</li><li>内存映射</li><li>Socket：更为通用，可用于不同机器</li></ul><p>线程通信：主要是为了线程同步，所以没有数据交换的通信机制。</p><ul><li>Linux<ul><li>信号</li><li>锁机制</li><li>条件变量</li><li>信号量</li></ul></li><li>windows<ul><li>全局变量</li><li>Message消息机制</li><li>CEvent对象</li></ul></li></ul><h2 id="12-协程"><a href="#12-协程" class="headerlink" title="12. 协程"></a>12. 协程</h2><h3 id="1-产生原因"><a href="#1-产生原因" class="headerlink" title="1. 产生原因"></a>1. 产生原因</h3><p>线程数量非常多，且需要等待IO时，会产生问题。系统线程占用非常多的空间；过多的线程切换会占用大量的系统时间。</p><ul><li>节省CPU，避免内核级线程的频繁切换造成CPU浪费。</li><li>节约内存。</li><li>稳定性，避免线程崩溃导致的同一进程内的所有线程崩溃。</li><li>开发效率，可方便地将一些耗时IO操作异步化。</li></ul><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h3><p>是一个函数，可以暂停与恢复执行。其状态与任何线程都无关。</p><p>与普通函数的区别：堆上保存状态，调用时在栈上分配空间后，保存一个引用指向堆上的状态。协程暂停时，将当前执行的代码位置记录到堆的状态中，回收栈上的空间。</p><p><strong>协作式调度</strong>的<strong>用户态线程。</strong></p><p>由开发人员决定协程的栈和上下文切换。</p><p>协作式调度：当前线程完全占用CPU时间且不可被抢占，与抢占式调度相对应。抢占式调度执行顺序无法确定，所以同步问题很麻烦，而协程不存在该问题。</p><p>协程运行在线程里，分时复用线程，不会增加线程的数量，且只在用户态切换。</p><p>协程在IO阻塞时再让出CPU，当IO就绪后主动占用CPU，牺牲任务执行的公平性换取吞吐量。协程能保留上一次调用时的状态。</p><p>优点：</p><ul><li>用户态：无需内核态切换，节省开销</li><li>非抢占：无需原子操作锁定与同步，不用担心资源共享的问题</li><li>单线程：单线程即可实现高并发</li></ul><p>缺点：</p><ul><li>用户态：协程的控制权由用户决定，不安全</li><li>非抢占：一个协程被阻塞，则整个线程都被阻塞，所以必须搭配非阻塞IO使用；容易导致饥饿问题</li><li>单线程：无法将一个线程的多个协程分摊到多核CPU</li></ul><h2 id="13-管程"><a href="#13-管程" class="headerlink" title="13. 管程"></a>13. 管程</h2><h3 id="1-提出原因"><a href="#1-提出原因" class="headerlink" title="1. 提出原因"></a>1. 提出原因</h3><p>采用信号量及PV同步机制编写并发程序，对于共享变量与信号量的操作将被分散于各个进程中，存在以下缺点：</p><ul><li>程序易读性差：判断对一组共享变量/信号量的操作是否正确，需要通读整个系统。</li><li>程序不利于修改和维护：任意代码的修改都可能影响全局。</li><li>正确性难以保证：并发程序通常很大，复杂系统很难没有逻辑错误。</li><li>同步操作不当可能导致死锁。</li></ul><h3 id="2-定义-1"><a href="#2-定义-1" class="headerlink" title="2. 定义"></a>2. 定义</h3><p>代表共享资源的数据结构和对该共享数据结构实施操作的一组过程，它们组成的资源管理程序。管程中多个子程序形成的多个工作线程互斥访问共享资源，且在一个时间点最多只有一个线程在执行管程的某个子程序。</p><p>翻译：定义管程类，封装临界区以及对临界区的操作。</p><p>管程有如下特征：</p><ul><li>模块化：一个管程是一个基本程序单位，可单独编译。</li><li>抽象数据类型：管程包含了数据以及对数据操作的方法，类似于类。</li><li>信息隐蔽：管程是半透明的，实现的功能在外部不可见。</li><li>使用的互斥性：任何时候，管程只能由一个线程使用，互斥性由编译器负责完成。</li></ul><h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3. 组成"></a>3. 组成</h3><ul><li>多个彼此可交互并共用资源的线程</li><li>多个与资源使用有关的变量</li><li>一个互斥锁</li><li>一个用来避免竞态条件的不变量</li></ul><h3 id="4-工作过程"><a href="#4-工作过程" class="headerlink" title="4. 工作过程"></a>4. 工作过程</h3><p>enter过程：一个进程进入管程前要提出申请。</p><p>leave过程：当一个进程离开管程时，如果紧急队列不为空，就必须唤醒其中一个进程。</p><p>条件型变量c：指向一个等待该条件的PCB队列的指针。</p><p>wait(c)：为进入管程的进程分配某种类型的资源，如果此时这种资源可用则进程使用，否则进程被阻塞，进入紧急队列。</p><p>signal(c)：进入管程的进程使用的某种资源要释放，进程会唤醒由于等待这种资源而进入紧急队列的第一个进程。</p><h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5. 优缺点"></a>5. 优缺点</h3><p>优点：</p><ul><li>可以以函数库的形式实现，比信号量好控制。</li><li>增强模块的独立性。</li><li>提高代码的可读性、可维护性。</li></ul><p>缺点：大多数编程语言没有实现管程。</p><h2 id="14-线程回收"><a href="#14-线程回收" class="headerlink" title="14. 线程回收"></a>14. 线程回收</h2><ul><li>等待线程结束：pthread_join，主线程调用后等待子线程退出并回收其资源</li><li>结束线程：pthread_exit，线程执行后不释放资源而直接结束。子线程执行，结束当前线程并传递返回值，可被pthread_join获得</li><li>分离线程：pthread_detach，主线程、子线程均可调用，主线程传入子线程id，子线程传入self，调用后和主线程分离，子线程结束时立刻回收自己资源。</li></ul><h2 id="15-特殊进程"><a href="#15-特殊进程" class="headerlink" title="15. 特殊进程"></a>15. 特殊进程</h2><h3 id="1-孤儿进程"><a href="#1-孤儿进程" class="headerlink" title="1. 孤儿进程"></a>1. 孤儿进程</h3><p>父进程先退出，子进程还没退出，子进程将成为孤儿进程，被init1号进程收养。</p><h3 id="2-僵尸进程"><a href="#2-僵尸进程" class="headerlink" title="2. 僵尸进程"></a>2. 僵尸进程</h3><p>子进程先退出，父进程还没退出，子进程必须等到父进程捕获到子进程的退出状态才真正结束，在这之前子进程成为僵尸进程。</p><p>僵尸态的目的是为了维护子进程的信息，以便父进程在以后某个时间获取。</p><p>这些僵尸进程将在父进程退出时被1号进程收养，然后被清理。</p><p>子进程停止在僵尸态会占据内核资源，需要避免僵尸进程产生或立即结束僵尸态。</p><h3 id="3-守护进程"><a href="#3-守护进程" class="headerlink" title="3. 守护进程"></a>3. 守护进程</h3><p><strong>在后台运行、没有控制终端与之相连</strong>的进程，周期性执行某种任务。Linux大部分服务器就是用守护进程的方式实现的，如web服务器进程http。</p><p>特殊的孤儿进程。</p><p>创建方式：</p><ol><li>让程序在后台运行：调用fork，然后父进程退出</li><li>摆脱父进程的控制终端、登录会话和进程组：调用setsid创建新对话期，使自己成为新的会话组长和进程组长。</li><li>禁止进程重新打开控制终端：再通过fork创建新的子进程，然后调用fork的进程退出。</li><li>关闭不需要的文件描述符：先获得最高文件描述符值，然后递减遍历，关闭所有文件描述符。</li><li>将当前目录更改为根目录。</li><li>进程从父进程继承了文件创建屏蔽字，可能修改守护进程创建的文件存取权限，所以unmask(0)清文件创建屏蔽字。</li><li>处理SIGCHLD信号，使得子进程结束时不会产生僵尸进程。</li></ol><h2 id="16-避免僵尸进程"><a href="#16-避免僵尸进程" class="headerlink" title="16. 避免僵尸进程"></a>16. 避免僵尸进程</h2><ul><li>signal(SIGCHLD, ISG_IGN)通知内核对子进程的结束不关心，由内核回收</li><li>waitpid传递WNOHANG使父进程不阻塞立即返回</li><li>如果父进程很忙，可用signal注册信号处理函数，在其中调用waitpid等待子进程退出</li><li>调用两次fork，子进程退出后孙进程由1号进程收养</li></ul><h2 id="17-子进程对父进程的继承"><a href="#17-子进程对父进程的继承" class="headerlink" title="17. 子进程对父进程的继承"></a>17. 子进程对父进程的继承</h2><p>继承：</p><p>进程的资格、环境、堆栈、内存、进程组号</p><p>独有：</p><p>进程号、父进程号、资源使用</p><h2 id="18-进程组与会话、作业"><a href="#18-进程组与会话、作业" class="headerlink" title="18. 进程组与会话、作业"></a>18. 进程组与会话、作业</h2><p>进程组：多个进程的集合，其中有一个组长，其进程PID等于进程组的PGID。只要组中有一个进程存在，该组就存在。</p><p>会话：一个或多个进程组的集合，可以有一个控制终端。在xshell或WinSCP中打开一个窗口就是新建一个会话。</p><p>前后台作业：可以由多个进程组成。只能运行一个前台作业，因为在前台新起一个作业时，shell就被提到后台，就没法再继续接受指令解析运行。</p><p>作业与进程的区别：如果作业中某个进程创建了子进程，该子进程不属于该作业。</p><h2 id="19-进程的终止"><a href="#19-进程的终止" class="headerlink" title="19. 进程的终止"></a>19. 进程的终止</h2><ol><li>main函数自然返回</li><li>C函数库中的exit</li><li>系统调用中的_exit（对比exit少了调用终止处理程序与清除IO缓冲两步，直接返回内核）</li><li>abort函数，异常程序终止，同时发送SIGABRT信号给调用进程</li><li>接受能导致进程终止的信号，如ctrlc、SIGINT</li></ol><h2 id="20-不可重入函数"><a href="#20-不可重入函数" class="headerlink" title="20. 不可重入函数"></a>20. 不可重入函数</h2><p>不同任务调用该函数时可能修改其他任务调用这个函数的数据。</p><p>特点：</p><ul><li>使用了静态数据结构。</li><li>操作了堆（malloc/free）</li><li>调用了标准IO函数。</li></ul><h2 id="21-线程的分离态"><a href="#21-线程的分离态" class="headerlink" title="21. 线程的分离态"></a>21. 线程的分离态</h2><p>在pthread_create创建线程后马上调用pthread_detach将线程设置为分离态，这样它运行结束后会自己终止线程并释放系统资源。</p><p>如果有线程运行非常快，可能在pthread_create返回前终止，并将线程号和系统资源移交给其他线程，从而导致pthread_create返回错误的线程号。</p><p>解决方法是使用同步措施，如在被创建的线程里调用pthread_cond_timedwait函数，让线程等待足够的时间直到pthread_create返回。</p><h2 id="22-多线程与多进程的比较"><a href="#22-多线程与多进程的比较" class="headerlink" title="22. 多线程与多进程的比较"></a>22. 多线程与多进程的比较</h2><p>多进程：</p><p>优点：</p><ul><li>进程相互独立，不影响主程序稳定性</li><li>可通过增加CPU扩充性能</li><li>尽量减少线程加锁解锁的影响</li><li>进程分配的时间与空间资源多</li></ul><p>缺点：</p><ul><li>逻辑控制复杂，需要与主程序交互</li><li>需要跨进程边界，不适合大数据传送，适合小数据传送、密集运算</li><li>进程通信、调度开销大</li></ul><p>多线程：</p><p>优点：</p><ul><li>无需跨进程边界</li><li>程序逻辑和控制方式简单</li><li>线程可直接共享内存和变量等</li><li>消耗总资源占优</li></ul><p>缺点：</p><ul><li>线程与主程序共用地址空间</li><li>线程同步与锁机制麻烦</li><li>一个线程崩溃影响同一进程下的所有线程</li><li>增加CPU数目能提升的总性能有限</li></ul><h2 id="23-用户态和内核态的切换"><a href="#23-用户态和内核态的切换" class="headerlink" title="23. 用户态和内核态的切换"></a>23. 用户态和内核态的切换</h2><p>分态的目的：保护操作系统安全，防止某些关键信息被修改。</p><p>切换场景：系统调用；异常；中断。本质上都是一样的步骤。</p><p>切换过程/开销：</p><ul><li>从当前进程描述符中取出内核栈信息。</li><li>用内核栈将当前进程的段信息、栈信息、状态保存，同时完成用户栈到内核栈的切换。</li><li>将中断向量检索得到的中断处理程序的段、代码起始位置装入寄存器，开始执行中断处理程序。这样就转到内核态的程序执行了。</li></ul><p>内核态回用户态：iret</p><ul><li>将压栈的用户态信息弹出，加载到对应位置。</li><li>切换成用户态，从上次中断处开始执行。</li></ul><h2 id="24-RingBuffer"><a href="#24-RingBuffer" class="headerlink" title="24. RingBuffer"></a>24. RingBuffer</h2><p>Linux内核kfifo实现方式为RingBuffer，即环形缓冲区。</p><p>通过镜像指示位来判断读写索引相同时是满还是空。（大小设置为2的幂时，下标最高位就能当指示位，不需要额外指示位）</p><p>多线程/进程对同一个环形缓冲区读写时，需要加锁，但只有一个读线程/进程和一个写线程/进程时，不用加锁。</p><p><img src="https://pic2.zhimg.com/80/v2-22cba7a9b8ff0746184d752a63621981_720w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-22cba7a9b8ff0746184d752a63621981_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="25-信号"><a href="#25-信号" class="headerlink" title="25. 信号"></a>25. 信号</h2><p>信号由操作系统发送给进程。</p><p>信号识别与信号处理函数写在进程源代码中。</p><h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><p>操作系统发来信号，进程保存信号。</p><ul><li>如果信号被阻塞，先保存。</li><li>如果信号不阻塞，在合适的时机递达信号。</li><li>递达信号后，进程可：<ul><li>执行默认信号处理函数。</li><li>忽略信号。</li><li>执行自定义信号处理函数。</li></ul></li></ul><h3 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h3><p>操作系统向进程控制块中的信号位图写入。</p><p>判断信号是否阻塞，同样也有一个对应的位图。</p><h1 id="5-调度算法"><a href="#5-调度算法" class="headerlink" title="5. 调度算法"></a>5. 调度算法</h1><h2 id="1-进程调度算法"><a href="#1-进程调度算法" class="headerlink" title="1. 进程调度算法"></a>1. 进程调度算法</h2><ul><li>先来先服务</li><li>最短作业优先/最短剩余时间优先（抢占式版）</li><li>高响应比优先：优先权=（等待时间+要求服务时间）/ 要求服务时间</li><li>时间片轮转</li><li>最高优先级</li><li>多级反馈队列</li></ul><h2 id="2-内存页面置换算法"><a href="#2-内存页面置换算法" class="headerlink" title="2. 内存页面置换算法"></a>2. 内存页面置换算法</h2><ul><li>最佳页面置换算法：置换在未来最长时间不访问，但是因为程序访问页面是动态的，无法预知所以无法实现。用于衡量算法效率，算法效率越接近该算法，说明越高效。</li><li>先进先出置换算法</li><li>最近最久未使用LRU</li><li>时钟页面置换：FIFO改进版，页面保存在环形链表中，指针指向的页访问位为1则清除访问位，为0则淘汰页。</li><li>改进时钟页面置换：考虑到如果页面没有被修改，就不需要写回，因此增加了修改位。优先淘汰未被修改的，在修改状态相同时优先淘汰未被访问的。</li><li>最不常用LFU：访问次数最少的页。会存在过去时间访问次数很高，但是近期不访问的页。改进：定期减少访问次数，比如在时钟中断时将访问次数除以2。</li></ul><p>belady异常：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象 。FIFO不考虑使用频率。</p><h2 id="3-磁盘调度算法"><a href="#3-磁盘调度算法" class="headerlink" title="3. 磁盘调度算法"></a>3. 磁盘调度算法</h2><ul><li>先来先服务</li><li>最短寻道时间优先：贪心，但可能存在饥饿问题。</li><li>扫描算法：一次只往一个方向扫描，直到到达最大/最小磁盘号再折返（最小是0而不是序列最小）。</li><li>循环扫描：按照特定方向扫描，扫描一遍后返回时直接复位而不处理任何请求。即只响应一个方向的请求。</li><li>LOOK：扫描算法的优化：移动到最远的请求（该方向上没有其他请求）就折返。</li><li>C-LOOK：循环扫描的优化。</li></ul><h2 id="4-动态分区分配算法"><a href="#4-动态分区分配算法" class="headerlink" title="4. 动态分区分配算法"></a>4. 动态分区分配算法</h2><p>找到一块适宜大小的内存，将用户程序装入其中</p><ul><li>首次适应算法：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。<ul><li>算法开销小</li><li>但是会使内存低地址部分产生很多碎片。</li></ul></li><li>最佳适应算法：空闲分区容量按次序递增，然后首次适应算法，保证大进程到来时有连续的大片空间。<ul><li>会产生很多难以利用的小碎片。</li><li>算法开销大，每次回收需要重新排序。</li></ul></li><li>最坏适应算法：空闲分区容量按次序递减，然后首次适应算法。解决最佳适应算法的碎片问题。<ul><li>但是无法满足可能的大进程需求。</li><li>算法开销大，每次回收需要重新排序。</li></ul></li><li>邻近适应算法：每次查找都从上次结束的位置，然后首次适应算法。</li></ul><h1 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6. 文件系统"></a>6. 文件系统</h1><p>磁盘划分分区，每个分区有一个独立的文件系统。</p><p>磁盘0号扇区为主引导记录MBR，MBR结尾是分区表，给出每个分区的起始结束地址。</p><p>计算机被引导时，BIOS读入并执行MBR，MDRB确定活动分区，读入其第一个块，称为引导块，并执行。引导块中的程序将装载该分区中的操作系统。</p><p>有两种数据结构可以代表一个文件：</p><ul><li><strong>索引节点inode</strong>：记录文件的元信息，如inode编号、文件大小、访问权限、创建修改时间、数组在磁盘的位置等。索引节点是文件的唯一标识。</li><li><strong>目录项dentry</strong>：记录文件的名字、索引节点指针以及其他与目录项的层级关联关系。目录项是由内核维护的，缓存在内存。</li></ul><p>一个索引节点可以对应一个或多个目录项。目录项相当于是文件在内存中的缓存。</p><p>磁盘读写的最小单位是扇区，最小512B，文件系统将多个扇区组成一个逻辑块，每次读写最小单位是逻辑块，Linux中为4KB。</p><p>磁盘格式化时会分成三个存储区域：</p><ul><li>超级块，存储文件的详细信息，如块个数、块大小、空闲块等。文件系统挂载时进入内存。</li><li>索引节点区，存储索引节点。文件被访问时进入内存。</li><li>数据块区，存储文件或目录数据。</li></ul><h2 id="1-虚拟文件系统VFS"><a href="#1-虚拟文件系统VFS" class="headerlink" title="1. 虚拟文件系统VFS"></a>1. 虚拟文件系统VFS</h2><p>大概分为三类，首先要挂载到某个目录才能正常使用：</p><ul><li>磁盘文件系统</li><li>内存文件系统</li><li>网络文件系统，用来访问其他计算机主机数据的文件系统。</li></ul><p>操作系统为每个进程维护一个打开文件表，文件表里每一项代表文件描述符，其中维护文件的状态和信息：</p><ul><li>文件指针：上次读写位置</li><li>文件打开计数器：可能有多个进程打开同一文件。计数为0时系统关闭文件，删除该条目。</li><li>文件磁盘位置</li><li>访问权限</li></ul><h2 id="2-文件存储"><a href="#2-文件存储" class="headerlink" title="2. 文件存储"></a>2. 文件存储</h2><ul><li>顺序分配<ul><li>访问磁盘1次。</li><li>优点：存取速度快，可随机访问</li><li>缺点：要求连续存储空间，会产生外部碎片，不方便动态扩充。</li></ul></li><li>链表分配<ul><li>访问磁盘n（文件占用的数据块个数）次。</li><li>优点：无外部碎片，动态扩充方便。</li><li>缺点：只能顺序访问，查找效率低，指针也要占额外空间。</li></ul></li><li>索引分配<ul><li>m级须访问m + 1次。</li><li>优点：可随机访问，易于增删</li><li>缺点：索引表占额外空间，索引表的查找策略影响文件系统效率。</li></ul></li></ul><h3 id="1-连续空间存放"><a href="#1-连续空间存放" class="headerlink" title="1. 连续空间存放"></a>1. 连续空间存放</h3><p>文件存放在连续的物理空间中，文件头指定起始块位置和长度。读写效率很高，但文件长度不易扩展，有磁盘空间碎片。</p><h3 id="2-非连续空间存放"><a href="#2-非连续空间存放" class="headerlink" title="2. 非连续空间存放"></a>2. 非连续空间存放</h3><h4 id="1-链表式"><a href="#1-链表式" class="headerlink" title="1. 链表式"></a>1. 链表式</h4><p>隐式链表：文件头包含首尾两块的位置，每个数据块中留出指针空间，存放下一块的位置。</p><p>缺点：无法直接访问某数据块，且指针占用空间。如果链表指针丢失，会导致文件数据丢失。指针占用使得每个磁盘块存储字节数不是2的整数次幂，降低运行效率。</p><p>显式链接：把用于链接文件各数据块的指针显式存放在一张链接表中，每个表项粗放链接指针指向下一个数据块号。称为文件分配表FAT。</p><p>缺点：整张表都要存放在内存中，读写速度快，但也因此不适用于大磁盘。</p><h4 id="2-索引式"><a href="#2-索引式" class="headerlink" title="2. 索引式"></a>2. 索引式</h4><p>为每个文件创建一个索引数据块，存放指向文件每个数据块的指针列表，文件头包含指向索引数据块的指针。</p><p>优点：文件修改方便、没有碎片问题、支持顺序读写和随机读写。</p><p>缺点：文件过小时，索引数据块浪费空间；文件过大，以至于一个索引块放不下所有指针。</p><h4 id="3-链式索引块"><a href="#3-链式索引块" class="headerlink" title="3. 链式索引块"></a>3. 链式索引块</h4><p>在索引数据块中留出一个存放下一个索引数据块的指针。</p><p>缺点：与链表一样，指针损坏导致无法读取后面数据。</p><h4 id="4-多级索引块"><a href="#4-多级索引块" class="headerlink" title="4. 多级索引块"></a>4. 多级索引块</h4><p>索引嵌套</p><h3 id="3-Unix文件实现方式"><a href="#3-Unix文件实现方式" class="headerlink" title="3. Unix文件实现方式"></a>3. Unix文件实现方式</h3><p>用于Linux Ext 2/3 文件系统中</p><p>根据文件大小存放方式变化：</p><ul><li>如果存放文件所需数据块小于10块，直接查找。</li><li>如果存放文件所需数据块大于10块，采用一级间接索引。</li><li>如果上面都不够放，采用二级间接索引。</li><li>如果上面都不够放，采用三级间接索引。</li></ul><p>Inode文件头包含13个指针：</p><ul><li>10个指向数据块</li><li>第11个指向索引块</li><li>第12个指向二级索引块</li><li>第13个指向三级索引块</li></ul><h2 id="3-空闲空间管理"><a href="#3-空闲空间管理" class="headerlink" title="3. 空闲空间管理"></a>3. 空闲空间管理</h2><h3 id="1-空闲表法"><a href="#1-空闲表法" class="headerlink" title="1. 空闲表法"></a>1. 空闲表法</h3><p>为所有连续空闲空间建立一张表，维护第一个空闲块号与空闲块个数。请求时顺序搜索直到找到第一个合适的空闲区与。</p><p>缺点：有大量小的空闲区时效率很低。</p><h3 id="2-空闲链表法"><a href="#2-空闲链表法" class="headerlink" title="2. 空闲链表法"></a>2. 空闲链表法</h3><p>每个空闲块有指针指向下一块。请求时从头部取空闲空间。</p><p>缺点：不能随机访问，在链上增加/移动空闲块时要做很多I/O操作，指针消耗空间。</p><h3 id="3-位图法"><a href="#3-位图法" class="headerlink" title="3. 位图法"></a>3. 位图法</h3><p>用二进制的一位表示一个块的使用情况。Linux用这种方法管理。</p><h2 id="4-文件系统结构"><a href="#4-文件系统结构" class="headerlink" title="4. 文件系统结构"></a>4. 文件系统结构</h2><p>Linux Ext2文件系统由1个引导块和后面的多个块组组成。</p><p>最前面的第一个块是引导块，在系统启动时用于启动引导。</p><p>块组内容如下：</p><ul><li>超级块：文件系统重要信息，如inode总个数、块总个数等。</li><li>块组描述符：文件系统中各个块组的状态。每个块组都包含了所有块组的组描述符信息。</li><li>数据位图和inode位图：表示对应数据块/inode是否空闲。</li><li>inode列表：块组中所有inode。</li><li>数据块：文件的有用数据。</li></ul><p>超级块和块组描述符都是全局信息，因为：</p><ul><li>作为冗余副本，在系统崩溃破坏这两个结构时进行恢复。</li><li>使文件和管理数据尽可能接近，减少磁头寻道和旋转。</li></ul><h2 id="5-目录的存储"><a href="#5-目录的存储" class="headerlink" title="5. 目录的存储"></a>5. 目录的存储</h2><p>普通文件块中保存的是文件数据，目录文件块中保存的是目录中的文件信息。</p><p>ext文件系统用哈希表保存文件inode号、文件类型与文件名</p><h2 id="6-★-链接"><a href="#6-★-链接" class="headerlink" title="6. ★ 链接"></a>6. ★ 链接</h2><h3 id="1-硬链接"><a href="#1-硬链接" class="headerlink" title="1. 硬链接"></a>1. 硬链接</h3><p>多个目录项中的索引节点指向一个文件，即同一个inode。由于inode无法跨越文件系统，所以硬链接同样无法跨越文件系统。只有删除文件的所有硬链接及源文件时，系统才会彻底删除文件。</p><h3 id="2-软链接"><a href="#2-软链接" class="headerlink" title="2. 软链接"></a>2. 软链接</h3><p>相当于重新创建一个有独立inode的文件，但是其内容是另外一个文件的路径，所以可以跨文件系统。目标文件被删除后链接文件仍然存在，只是指向的文件找不到。</p><h2 id="7-文件I-O"><a href="#7-文件I-O" class="headerlink" title="7. 文件I/O"></a>7. 文件I/O</h2><p>I/O分为两个过程：</p><ol><li>数据准备（从硬件拷贝到内核空间）</li><li>数据从内核空间拷贝到用户进程缓冲区</li></ol><p>缓冲与非缓冲I/O（是否利用<strong>标准库</strong>的缓存）</p><ul><li>缓冲I/O利用标准库缓存实现文件的加速访问，标准库再通过系统调用访问文件。</li><li>非缓冲I/O直接通过系统调用访问文件。</li></ul><p>直接与非直接I/O（是否利用<strong>操作系统</strong>的缓存）</p><ul><li>直接I/O直接经过文件系统访问磁盘。</li><li>非直接I/O利用内核缓存与用户程序交互，内核决定什么时候写回。<ul><li>调用write后内核缓存数据太多</li><li>主动调用fsync</li><li>内存十分紧张</li><li>数据缓存超过某个时间</li></ul></li></ul><p>阻塞与非阻塞I/O</p><ul><li>阻塞I/O：调用read后线程在过程1、2都一直阻塞，直到完成过程2。</li><li>非阻塞I/O：在数据未准备好时立刻返回，应用程序不断轮询内核直到过程1完成，最后一次获得数据的read需要等待过程2。</li></ul><p>I/O多路复用（select、poll）：通过I/O事件分发，当内核数据准备好后再以事件通知应用程序操作。当前线程阻塞，CPU切换其他线程执行任务，等内核发现有事件到来通知当前线程，遍历socket找到有数据到来的socket，并等待过程2。</p><p>优势在于，用户可以在一个线程内同时处理多个socket的IO请求。</p><p>阻塞、非阻塞、多路复用都是同步I/O，因为在过程2都需要等待。</p><p>异步I/O是过程1、2都不需要等待，应用程序调用read后继续运行，后续直接接到内核拷贝完成的通知，处理数据。</p><h2 id="8-Page-Cache"><a href="#8-Page-Cache" class="headerlink" title="8. Page Cache"></a>8. Page Cache</h2><p>write与read实际上都是与内核的Page Cache进行交互。</p><p>Linux上供用户可访问的内存分为两个类型：</p><ul><li>File-backed pages（Page Cache）：文件备份页，对应于磁盘上的若干数据块。<ul><li>内存回收代价较低。一方面，其通常对应一个文件的若干顺序块，可以通过顺序I/O的方式落盘；另一方面，因为其对应某个文件的缓存，如果没有写操作甚至不需要回盘。</li></ul></li><li>Anonymous pages：匿名页，进程的运行时内存空间（方法栈、局部变量表等）。<ul><li>内存回收代价较高：匿名页通常随机地写入持久化交换设备；为了确保数据不丢失，swap时必须持久化到磁盘。</li></ul></li></ul><p>SwapCached也是Page Cache：当匿名页先被交换到磁盘上再加载回内存中时，磁盘还有该匿名页的备份，所以它也可以认为是File-backed pages。</p><h3 id="1-Page-Cache与Buffer-Cache"><a href="#1-Page-Cache与Buffer-Cache" class="headerlink" title="1. Page Cache与Buffer Cache"></a>1. Page Cache与Buffer Cache</h3><ul><li>Page Cache缓存文件的页数据，页是逻辑上的概念，因此其与<strong>文件系统</strong>同级。在有文件系统的情况下对文件操作，数据缓存到Page Cache。<ul><li>Page Cache主要是为了给读文件操作提供缓冲。</li></ul></li><li>Buffer Cache缓存块设备的块数据，块是物理上的概念，因此其与<strong>块驱动设备</strong>同级。直接对磁盘读写，数据缓存到Buffer Cache。<ul><li>Buffer Cache主要是为了给写磁盘操作提供缓冲。</li></ul></li></ul><p>Linux 2.4版本内核后，如果一个文件的页加载到了Page Cache，那么Buffer Cache只需要维护块指向页的指针，两块缓存<strong>近似融合</strong>。</p><h3 id="2-优劣"><a href="#2-优劣" class="headerlink" title="2. 优劣"></a>2. 优劣</h3><p>优势：</p><ol><li>加快数据访问。</li><li>减少I/O次数，提高系统磁盘I/O吞吐量。（缓存、预读）</li></ol><p>劣势：</p><ol><li>占用额外物理内存。</li><li>对应用层没有提供很好管理的API。</li><li>在某些场景下比Direct I/O多一次磁盘读写。</li></ol><h2 id="9-文件系统性能"><a href="#9-文件系统性能" class="headerlink" title="9. 文件系统性能"></a>9. 文件系统性能</h2><ul><li>高速缓存：块高速缓存block cache或缓冲区高速缓存buffer cache</li><li>块提前读：读某个块时将其之后的几个块也读入缓存。只适合顺序读取的文件。</li><li>减少磁盘臂运动：可能顺序访问的块放一个柱面上。</li><li>磁盘碎片整理：移动文件让它们相邻。</li></ul><h1 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7. 设备管理"></a>7. 设备管理</h1><h2 id="1-设备控制器"><a href="#1-设备控制器" class="headerlink" title="1. 设备控制器"></a>1. 设备控制器</h2><p>CPU通过设备控制器来管理设备，设备控制器是为了屏蔽不同设备之间的差异。</p><p>设备控制器里有芯片，可执行自己的逻辑，也有自己的寄存器与CPU通信。</p><p>控制器有三类寄存器：</p><ul><li>数据寄存器，CPU向设备写入需要传输的数据。</li><li>命令寄存器：CPU发送命令告诉设备要进行什么操作，任务完成后会将状态寄存器里的状态标记为完成。</li><li>状态寄存器：告诉CPU现在已经在工作或者工作已完成。只有工作已完成CPU才能发送下一个字符和命令。</li></ul><p>输入输出设备分为两大类：</p><ul><li>块设备，将数据存储在固定大小的块中，每个块有自己的地址，如硬盘、USB。<ul><li>通常传输数据量很大，所以控制器设立了一个可读写的数据缓冲区。缓冲区屯够一部分时才让CPU读写数据，减少频繁操作。</li></ul></li><li>字符设备，以字符为单位发送或接收一个字符流，不可寻址也没有寻道操作，如鼠标。</li></ul><p>CPU用两种方式与控制寄存器和数据缓冲区通信：</p><ul><li>端口I/O，每个控制寄存器分配一个I/O端口，可通过特殊的汇编指令操作这些寄存器。</li><li>内存映射I/O，将所有控制寄存器映射到内存空间中。</li></ul><h2 id="2-I-O控制方式"><a href="#2-I-O控制方式" class="headerlink" title="2. I/O控制方式"></a>2. I/O控制方式</h2><h3 id="1-轮询等待"><a href="#1-轮询等待" class="headerlink" title="1. 轮询等待"></a>1. 轮询等待</h3><p>CPU一直查询寄存器状态直到标记完成。</p><h3 id="2-中断"><a href="#2-中断" class="headerlink" title="2. 中断"></a>2. 中断</h3><p>设备完成任务后触发中断到中断控制器，中断控制器再通知CPU暂停当前任务处理。硬中断就是硬件触发的。</p><h3 id="3-DMA"><a href="#3-DMA" class="headerlink" title="3. DMA"></a>3. DMA</h3><p>要求有DMA控制器的硬件支持。工作方式如下：</p><ul><li>CPU对DMA控制器下发指令，指示读取多少数据以及放在内存哪个地方。</li><li>DMA控制器向磁盘控制器发出指令，通知其从磁盘读数据到缓冲区，磁盘控制器将缓冲区数据传输给内存。</li><li>磁盘控制器传输完成后，在总线上发送确认成功的信号给DMA控制器。</li><li>DMA控制器收到信号后，通过中断通知CPU指令完成，CPU直接使用数据。</li></ul><p>在传送开始和结束仍需要CPU干预。</p><h2 id="3-设备驱动程序"><a href="#3-设备驱动程序" class="headerlink" title="3. 设备驱动程序"></a>3. 设备驱动程序</h2><p>为了屏蔽设备控制器的差异。属于操作系统的一部分，提供统一接口给操作系统。</p><p>设备驱动程序处理设备产生的中断，根据设备驱动初始化时注册的中断处理程序进行处理。</p><h2 id="4-通用块层"><a href="#4-通用块层" class="headerlink" title="4. 通用块层"></a>4. 通用块层</h2><p>减少不同块设备的差异带来的影响。</p><p>通用块层的功能：</p><ul><li>向上为文件系统和应用程序提供访问块设备的标准接口，向下把不同的磁盘设备抽象为统一的块设备，在内核层面提供框架管理驱动程序。</li><li>给文件系统和应用程序的I/O请求排队并调度。</li></ul><p>Linux内存支持5种I/O调度算法：</p><ul><li>没有调度（常出现在虚拟机，交由物理机系统负责调度）</li><li>先入先出</li><li>完全公平：按时间片均匀分布</li><li>优先级</li><li>最终期限：DDL，读写队列分开，适宜压力较大的场景，如数据库。</li></ul><h2 id="5-存储系统I-O软件分层"><a href="#5-存储系统I-O软件分层" class="headerlink" title="5. 存储系统I/O软件分层"></a>5. 存储系统I/O软件分层</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>文件系统层：向上为应用程序提供标准文件访问接口，向下通过通用块层存储和管理磁盘设备。</p><p>通用块层：调度I/O请求，选择其中一个发送给设备层。</p><p>设备层：包括硬件设备、设备控制器和驱动程序，负责最终物理设备的I/O操作。</p><p>提高I/O效率的措施：</p><ul><li>提高文件访问效率：使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，减少对块设备的直接调用。</li><li>提高块设备访问效率：缓冲区。</li></ul><h2 id="6-总体流程"><a href="#6-总体流程" class="headerlink" title="6. 总体流程"></a>6. 总体流程</h2><p>以键盘为例：</p><ul><li>输入字符后，键盘控制器产生扫描码数据，缓存在键盘控制器的寄存器中，并向CPU发送中断请求。</li><li>操作系统保存被中断进程的上下文，调用键盘的中断处理程序。</li><li>中断处理函数从寄存器缓冲区中读取扫描码，翻译成对应的字符。如果是显示字符，就翻译成ASCII码。</li><li>把ASCII码放入读缓冲区队列，显示设备的驱动程序定时从队列中读取数据放到写缓冲区队列，写入到显示设备的控制器的寄存器的数据缓冲区中，最后显示在屏幕上。</li><li>显示出结果后恢复被中断程序的上下文。</li></ul><h2 id="7-中断与异常"><a href="#7-中断与异常" class="headerlink" title="7. 中断与异常"></a>7. 中断与异常</h2><p>相同点：</p><ul><li>最终都由CPU发给内核处理</li><li>处理程序流程设计上相似</li></ul><p>不同点：</p><ul><li>中断由设备产生，异常由CPU产生</li><li>处理程序不同</li><li>中断不是时钟同步的，可以随时到来；异常是时钟同步的</li><li>处理中断时处于中断上下文，处理异常时处于异常上下文</li></ul><h1 id="8-网络系统"><a href="#8-网络系统" class="headerlink" title="8. 网络系统"></a>8. 网络系统</h1><h2 id="1-零拷贝"><a href="#1-零拷贝" class="headerlink" title="1. 零拷贝"></a>1. 零拷贝</h2><h3 id="1-DMA技术"><a href="#1-DMA技术" class="headerlink" title="1. DMA技术"></a>1. DMA技术</h3><p>Direct Memory Access直接内存访问技术。即在进行I/O设备和内存的数据传输时，数据搬运工作全部交给DMA控制器，CPU只在开始告知传输数据以及在结束时将数据从内核拷贝到用户空间。</p><h3 id="2-传统文件传输"><a href="#2-传统文件传输" class="headerlink" title="2. 传统文件传输"></a>2. 传统文件传输</h3><p>服务端提供文件传输功能时，先将磁盘上的文件read读出来，再write通过网络协议发送给客户端。</p><p>期间共发生4次用户态与内核态的上下文切换，read与write两次系统调用。每次都从用户态切换到内核态，等内核态完成任务后切回用户态。</p><p>发生4次数据拷贝，1次DMA控制器从磁盘到内核，1次CPU从内核缓冲区到用户缓冲区，1次CPU从用户缓冲区到内核socket缓冲区，1次DMA控制器从内核socket缓冲区到网卡缓冲区。</p><h3 id="3-优化文件传输"><a href="#3-优化文件传输" class="headerlink" title="3. 优化文件传输"></a>3. 优化文件传输</h3><h4 id="1-用户态与内核态上下文切换次数"><a href="#1-用户态与内核态上下文切换次数" class="headerlink" title="1. 用户态与内核态上下文切换次数"></a>1. 用户态与内核态上下文切换次数</h4><p>上下文切换是因为用户空间没有权限操作硬件，要减少系统调用的次数。</p><h4 id="2-数据拷贝次数"><a href="#2-数据拷贝次数" class="headerlink" title="2. 数据拷贝次数"></a>2. 数据拷贝次数</h4><p>如果不对数据再加工，数据实际上不用搬运到用户空间。</p><h3 id="4-零拷贝"><a href="#4-零拷贝" class="headerlink" title="4. 零拷贝"></a>4. 零拷贝</h3><h4 id="1-mmap-write"><a href="#1-mmap-write" class="headerlink" title="1. mmap + write"></a>1. mmap + write</h4><p>用mmap替换read，直接把内核缓冲区的数据映射到用户空间，可以减少一次read数据拷贝。但是系统调用还是2次，所以还是需要4次上下文切换。</p><h4 id="2-sendfile"><a href="#2-sendfile" class="headerlink" title="2. sendfile"></a>2. sendfile</h4><p>替换read + write，可以直接把内核缓冲区的数据拷贝到内核中的socket缓冲区。只有1次系统调用，2次上下文切换，3次数据拷贝（内核缓冲区到内核socket缓冲区还要一次）。</p><h4 id="3-sendfile-SG-DMA（网卡支持）"><a href="#3-sendfile-SG-DMA（网卡支持）" class="headerlink" title="3. sendfile + SG-DMA（网卡支持）"></a>3. sendfile + SG-DMA（网卡支持）</h4><p>数据拷贝到内核缓冲区后，缓冲区描述符和数据长度传到socket缓冲区，网卡的SG-DMA控制器可以直接将内核缓冲区数据拷贝到网卡缓冲区。只有1次系统调用，2次数据拷贝。</p><h4 id="4-零拷贝技术"><a href="#4-零拷贝技术" class="headerlink" title="4. 零拷贝技术"></a>4. 零拷贝技术</h4><p>3中的方式全程通过DMA传输，没有CPU搬运数据。只需要1次系统调用，2次上下文切换与2次数据拷贝，且都由DMA进行。</p><h3 id="5-大文件传输"><a href="#5-大文件传输" class="headerlink" title="5. 大文件传输"></a>5. 大文件传输</h3><h4 id="1-PageCache"><a href="#1-PageCache" class="headerlink" title="1. PageCache"></a>1. PageCache</h4><p>内核缓冲区实际上就是PageCache，通过缓存最近被访问的数据与预读，提高读写磁盘性能。</p><p>但是在传输GB级别的大文件时，PageCache会被迅速占满，而很多部分一般只会读取一次，会白白浪费DMA多做一次数据拷贝，所以不应使用零拷贝技术。</p><h4 id="2-大文件传输"><a href="#2-大文件传输" class="headerlink" title="2. 大文件传输"></a>2. 大文件传输</h4><p>高并发场景下，使用异步I/O + 直接I/O替代零拷贝技术。</p><p>由于直接I/O绕过了PageCache（发起中断信号后CPU直接将数据从磁盘控制器缓冲区拷贝到用户缓冲区），会无法享受优化：</p><ul><li>I/O调度算法缓存请求并合并，从而减少磁盘的寻址操作。</li><li>内核预读I/O请求。</li></ul><h2 id="2-I-O多路复用"><a href="#2-I-O多路复用" class="headerlink" title="2. I/O多路复用"></a>2. I/O多路复用</h2><h3 id="1-基本Socket模型"><a href="#1-基本Socket模型" class="headerlink" title="1. 基本Socket模型"></a>1. 基本Socket模型</h3><p>服务端：</p><ul><li>调用socket()创建网络协议IPv4，传输协议TCP的Socket。</li><li>调用bind()绑定一个IP地址和端口。</li><li>调用listen()监听。</li><li>调用accept()从内核获取客户端的连接，如果没有连接则会阻塞。（accept并不是接收连接，而只是从已经建立好的连接中选择一个）</li></ul><p>客户端：</p><ul><li>调用socket()创建Socket。</li><li>调用connect()指明服务端IP地址和端口号发起三次握手连接。</li></ul><p>服务器内核为每个Socket维护两个队列：</p><ul><li>TCP半连接队列，还没完成三次握手，服务端处于syn_rcvd状态。</li><li>TCP全连接队列，完成了三次握手，服务端处于established状态。</li></ul><p>监听的Socket与用来传数据的已连接Socket不是同一个。</p><h3 id="2-Socket结构"><a href="#2-Socket结构" class="headerlink" title="2. Socket结构"></a>2. Socket结构</h3><p>Socket也是文件，其inode中有发送队列和接收队列，保存sk_buff用链表穿起来。sk_buff在各个层表示不同，在应用层叫data，TCP层叫segment，IP层叫packet，数据链路层叫frame。</p><p>为了方便不同层之间传递数据且不发生拷贝，调整data的指针：</p><ul><li>接收报文时，通过协议栈层层往上传送数据包，通过增加data的值逐步剥离协议首部。</li><li>发送报文时，创建sk_buff结构体并为头部预留足够空间，向下层协议传递时通过减少data的值来增加协议首部。</li></ul><h3 id="3-多进程模型"><a href="#3-多进程模型" class="headerlink" title="3. 多进程模型"></a>3. 多进程模型</h3><p>父进程只需要关心监听Socket，子进程只需要关心已连接Socket。</p><p>客户端数量过多时，产生进程会占据一定的系统资源，且进程上下文切换消耗很大，影响性能。</p><h3 id="4-多线程模型"><a href="#4-多线程模型" class="headerlink" title="4. 多线程模型"></a>4. 多线程模型</h3><p>可通过线程池避免线程的频繁创建和销毁。已连接Socket放进一个队列里，线程池中的线程从队列中取出Socket进行处理。</p><h3 id="5-I-O多路复用"><a href="#5-I-O多路复用" class="headerlink" title="5. I/O多路复用"></a>5. I/O多路复用</h3><p>将进程处理每个请求的事件时间控制在1ms内，1s内就可以处理上千个请求，从时间拉长看，多个请求复用了一个进程。</p><h4 id="1-select-poll"><a href="#1-select-poll" class="headerlink" title="1. select/poll"></a>1. select/poll</h4><p>select：</p><ul><li>已连接的Socket放到一个文件描述符集合中，调用select函数将其拷贝到内核，让内核遍历检查是否有网络事件发生。</li><li>如果检测到，标记Socket为可读或可写，然后将整个文件描述符集合拷贝回用户态。</li><li>用户态还需要遍历一遍找到可读或可写的Socket再处理。</li><li>使用定长BitsMap表示文件描述符集合，只能监听0~1023文件描述符</li></ul><p>poll：用动态数组、链表形式组织，不受select文件描述符个数限制，但还是受系统文件描述符限制。</p><h4 id="2-epoll"><a href="#2-epoll" class="headerlink" title="2. epoll"></a>2. epoll</h4><p>步骤：</p><ul><li>epoll_create()创建一个epoll对象</li><li>epoll_ctl()将需要监听的socket添加到对象中</li><li>epoll_wait()等待数据。</li></ul><p>对前面两个函数的改进</p><ul><li>在内核中使用红黑树跟踪进程所有待检测字的文件描述字，而不需要每次拷贝。每次只需要传入一个待检测的socket。</li><li>使用事件驱动机制，维护一个链表记录就绪事件。如果某个socket有事件发生，内核通过回调函数将其加入就绪事件列表，用户调用epoll_wait()时只返回有事件发生的文件描述符个数。</li></ul><p>epoll没有使用共享内存，而是在epoll_wait()中将数据从内核空间拷贝到用户空间。</p><p>epoll支持边缘触发ET和水平触发LT两种事件触发模式。</p><p>ET：当被监控的Socket描述符上有可读事件发生时，服务器端只从epoll_wait苏醒一次。因此程序要保证一次性将内核缓冲区的数据读完。</p><p>一般会循环从文件描述符中读取，如果文件描述符是阻塞的，没有数据读写时进程会阻塞在读写函数，所以ET一般与<strong>非阻塞I/O</strong>搭配使用。</p><p>LT：当被监控的Socket描述符上有可读事件发生时，服务器端不断从epoll_wait中苏醒，直到内核缓冲区数据被读完。</p><p>多路复用API返回的事件并不一定可读写，所以多路复用最好都搭配<strong>非阻塞I/O</strong>。</p><h4 id="3-取舍"><a href="#3-取舍" class="headerlink" title="3. 取舍"></a>3. 取舍</h4><p>所有fd都是活跃连接，且fd少时，线性结构效率比红黑树高，且返回时线性结构约等于就绪队列，所以用select/poll效率更高。</p><h2 id="3-高性能网络模式"><a href="#3-高性能网络模式" class="headerlink" title="3. 高性能网络模式"></a>3. 高性能网络模式</h2><h3 id="1-Reactor模式"><a href="#1-Reactor模式" class="headerlink" title="1. Reactor模式"></a>1. Reactor模式</h3><p>对I/O多路复用进行了封装。收到事件后，根据时间类型分配给某个线程。</p><p>由Reactor和处理资源池两个核心部分组成。</p><ul><li>Reactor负责监听和分发事件，有连接事件、读写事件。</li><li>处理资源池负责处理事件，如read-&gt;业务逻辑-&gt;send。</li></ul><p>Reactor可以是一个，也可以是多个；处理资源池的线程也是如此。</p><h4 id="1-单Reactor单线程"><a href="#1-单Reactor单线程" class="headerlink" title="1. 单Reactor单线程"></a>1. 单Reactor单线程</h4><p>C语言一般是单进程，而Java语言一般是单线程，因为Java程序跑在Java虚拟机上，虚拟机中有很多线程。</p><p>具体方案：</p><ul><li>Reactor通过多路复用接口监听事件，收到事件后按类型分发。</li><li>如果是连接建立事件，交给Acceptor对象处理。Acceptor通过accept方法获取连接，创建一个Handler对象处理后续的响应事件。</li><li>如果不是连接建立事件，交由当前连接对应的Handler对象响应。Handler对象通过read-&gt;业务逻辑-&gt;send流程完成完整的业务流程。</li><li>全部工作在一个进程内完成。</li></ul><p>缺点：</p><ul><li>只有一个进程，无法利用多核CPU性能。</li><li>Handler对象处理业务时整个进程无法处理其他连接事件。</li></ul><p>只适用于业务处理快速的场景，而不适用于计算密集型场景。</p><h4 id="2-单Reactor多线程"><a href="#2-单Reactor多线程" class="headerlink" title="2. 单Reactor多线程"></a>2. 单Reactor多线程</h4><p>具体方案：</p><ul><li>分发步骤与1相同。</li><li>Handler对象只负责数据的接受和发送，通过read读取到数据后发给子线程的Processor对象处理业务。</li><li>Processor对象处理完后将结果发给主线程中的Handler对象。</li><li>Handler对象通过send方法将响应结果发给client。</li></ul><p>能够充分利用多核CPU性能。</p><p>缺点：一个Reactor对象承担所有事件的监听和响应，且只在主线程中运行。面对瞬间高并发场景易成为性能瓶颈。</p><h4 id="3-多Reactor多线程"><a href="#3-多Reactor多线程" class="headerlink" title="3. 多Reactor多线程"></a>3. 多Reactor多线程</h4><p>具体方案：</p><ul><li>主线程的MainReactor对象通过多路复用接口监听连接建立事件，收到事件后通过Acceptor对象的accept获取连接，将新连接分配给某个子线程。</li><li>子线程的SubReactor接收分配的连接，加入多路复用接口继续监听，并创建一个Handler处理连接的响应事件。</li><li>如果有新的事件发生，SubReactor调用当前连接对应的Handler响应。</li><li>Handler对象完成read-&gt;业务流程-&gt;send。</li></ul><p>优点：</p><ul><li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责后续业务处理。</li><li>主线程和子线程交互简单，主线程只需要将连接发给子线程，子线程直接将处理结果发给客户端。</li></ul><h3 id="2-Proactor"><a href="#2-Proactor" class="headerlink" title="2. Proactor"></a>2. Proactor</h3><p>异步网络模式，采用了aio_read异步I/O技术。</p><ul><li>Reactor是非阻塞同步网络模式，感知就绪可读写事件。每次感知到有事件发生，需要应用程序主动调用read方法完成数据读取。</li><li>Proactor是异步网络模式，感知已完成读写事件。操作系统读取完数据后主动通知应用程序。</li></ul><p>工作流程：</p><ul><li>Proactor initiator创建Proactor和Handler对象，将其通过Asynchronous Operation Processor注册到内核。（应用进程）</li><li>Handler负责<strong>业务处理</strong>。（应用进程）</li><li>Asynchronous Operation Processor负责<strong>处理注册请求与I/O操作</strong>，完成I/O操作后<strong>通知</strong>Proactor。（内核进程）</li><li>Proactor根据不同事件类型<strong>回调</strong>不同的Handler处理业务。（内核进程）</li></ul><p>Linux的异步I/O不完善，aio系列函数只是在用户空间模拟出的异步，且仅支持基于本地文件的aio异步操作，网络编程中的socket不支持。所以基于Linux的高性能网络程序都是用Reactor方案。</p><h2 id="4-一致性哈希"><a href="#4-一致性哈希" class="headerlink" title="4. 一致性哈希"></a>4. 一致性哈希</h2><p>负载均衡算法。一个分布式KV缓存系统，某个key应该到哪个或者哪些节点上获得，应该是确定的。</p><p>如果使用传统哈希算法，节点数量发生变化（扩容或缩容时）必须迁移改变了映射关系的数据，最坏情况下所有数据都要迁移。</p><p>一致性哈希对2^32进行取模运算，将结果组织成一个圆环，称为哈希环。</p><p>两步哈希：</p><ul><li>对存储节点哈希运算。</li><li>存储或访问数据时对数据哈希。</li><li>数据映射的结果值顺时针方向第一个节点就是存储该数据的节点。</li></ul><p>增加或移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点。</p><p>对节点分布不均匀问题的改进：把一个真实节点多复制几个副本作为虚拟节点，映射到哈希环上。</p><h1 id="9-杂七杂八的"><a href="#9-杂七杂八的" class="headerlink" title="9. 杂七杂八的"></a>9. 杂七杂八的</h1><h2 id="1-ASCII、Unicode和UTF-8编码"><a href="#1-ASCII、Unicode和UTF-8编码" class="headerlink" title="1. ASCII、Unicode和UTF-8编码"></a>1. ASCII、Unicode和UTF-8编码</h2><h3 id="1-ASCII"><a href="#1-ASCII" class="headerlink" title="1. ASCII"></a>1. ASCII</h3><p>只有127个字符，表示英文字母大小写、数字和一些符号，但是表示其他语言不够。一个字节表示一个字符。</p><h3 id="2-Unicode"><a href="#2-Unicode" class="headerlink" title="2. Unicode"></a>2. Unicode</h3><p>为了统一各个国家的编码格式，通常两个字节表示一个字符。</p><h3 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3. UTF-8"></a>3. UTF-8</h3><p>为了解决Unicode在编译全英文文本时，使用的空间比ASCII码多一倍的问题。UTF-8将Unicode字符按数字大小编码为1-6字节，英文字符编码为1字节，常用汉字编码为3字节。</p><h3 id="4-联系"><a href="#4-联系" class="headerlink" title="4. 联系"></a>4. 联系</h3><p>计算机内存中统一使用Unicode编码，保存到硬盘或传输时转换为UTF-8编码。</p><p>记事本编辑时，文件读取的UTF-8字符转换为Unicode字符到内存里，编辑完成后，保存时再转回UTF-8保存到文件。</p><p>浏览网页时，服务器把动态生成的Unicode内容转换为UTF-8再传输到浏览器。</p><h2 id="2-库函数与系统调用"><a href="#2-库函数与系统调用" class="headerlink" title="2. 库函数与系统调用"></a>2. 库函数与系统调用</h2><p>系统调用：操作系统提供给用户程序的程序接口，用于执行某些服务。</p><p>库函数：语言或应用程序的一部分，大部分封装了系统调用。</p><p>区别：</p><ul><li>移植性：系统调用依赖于内核，不保证移植性；库函数平台移植性好</li><li>执行区域：系统调用在内核空间执行；库函数在用户空间</li><li>开销：系统调用需要切换，开销大；库函数属于过程调用，开销小（仅对于没有封装系统调用的库函数）</li><li>应用场景：<ul><li>跟内核与操作系统特性相关联的服务，由系统调用提供。</li><li>具有共同特性的功能（如读写），由库函数提供。</li></ul></li></ul><h2 id="3-高并发服务器方案"><a href="#3-高并发服务器方案" class="headerlink" title="3. 高并发服务器方案"></a>3. 高并发服务器方案</h2><ul><li>应用程序与静态资源分离，将静态资源（图片、视频、js、css等）单独保存到专门的静态资源服务器</li><li>客户端缓存</li><li>反向代理与负载均衡：请求先经过反向代理服务器，它可以直接返回结果，也可以根据后端服务器的负载，将请求交给其中一台处理。感觉前三点Nginx都能做到。</li><li>集群和分布式。集群指所有服务器都有相同的功能，起分流作用；分布式将不同的业务放到不同服务器中，请求一个业务可能需要使用多台服务器，加快处理速度。它们的作用都是将原属于一台服务器的压力分散到多台，同时加快请求速度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-labuladong计算机技术</title>
      <link href="/2022/12/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-labuladong%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/12/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-labuladong%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-linux文件系统文件用途"><a href="#1-linux文件系统文件用途" class="headerlink" title="1. linux文件系统文件用途"></a>1. linux文件系统文件用途</h1><ul><li>/bin /sbin：存储可执行的二进制文件，如cp、chmod、ifconfig等命令。</li><li>/boot：存储系统启动需要的文件。</li><li>/dev：存放设备文件。</li><li>/etc：存放很多程序的配置信息，如apt。(在/etc/apt中更改镜像源)</li><li>/lib：包含bin和sbin中可执行文件的依赖，类似win中的dll文件库。</li><li>/media：有一个以用户名命名的文件夹，里面是自动挂载的设备，如U盘等。</li><li>/mnt：手动挂载设备的地方。</li><li>/opt：无特定用途。</li><li>/proc：全部正在运行程序的状态信息。有以PID命名的文件夹。</li><li>/root：root用户的home目录</li><li>/run /sys：存储某些程序的运行时信息和系统需要的一些信息。由于存储在内存，所以随着机器关闭而丢失。</li><li>/srv：存放服务数据。</li><li>/tmp：存储一些程序的临时文件。</li><li>/usr：存放一些非系统必须的资源，如用户安装的应用程序。/usr和/usr/local目录中也有bin和sbin，存放用户使用的工具。</li><li>/var：存储日志信息。</li><li>/home：普通用户的home目录</li></ul><h1 id="2-进程-线程-文件描述符"><a href="#2-进程-线程-文件描述符" class="headerlink" title="2. 进程-线程-文件描述符"></a>2. 进程-线程-文件描述符</h1><p>linux中进程就是一个数据结构task_struct，称为进程描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">    long state; &#x2F;&#x2F; 状态</span><br><span class="line">    struct mm_struct *mm; &#x2F;&#x2F;虚拟内存</span><br><span class="line">    pid_t pid; &#x2F;&#x2F; 进程号</span><br><span class="line">    struct task_struct __rcu *parent &#x2F;&#x2F; 指向父进程的指针</span><br><span class="line">    struct list_head children; &#x2F;&#x2F;子进程列表</span><br><span class="line">    struct fs_struct *fs; &#x2F;&#x2F;存放文件系统信息的指针</span><br><span class="line">    struct files_struct *files; &#x2F;&#x2F; 该进程打开的文件指针组成的数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1. 文件描述符"></a>1. 文件描述符</h2><p>一般一个进程会从files[0]读取输入，将输出写入files[1]，将错误信息写入files[2]。每个进程被创建时files的前三位分别被填入默认值标准输入流、标准输出流、标准错误流。文件描述符指的就是这个文件指针数组的索引。</p><p>一般的计算机输入流是键盘，输出流和错误流是显示器。</p><p>输入重定向：将files[0]指向一个文件，程序就会从这个文件中读取数据。</p><p>输出重定向：将files[1]指向一个文件，程序的输出就会写入到这个文件中。</p><p>错误重定向：与输出重定向一样。</p><p>管道符|：把一个进程的输出流和另一个进程的输入流连接起来，数据在其中传递。</p><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><p>linux中的线程和进程实际上都是用的task_struct表示，只有共享的数据区域不同。子进程的mm指针指向一片新的虚拟内存区域，而子线程的mm指针与其父进程共享。</p><h2 id="3-shell小技巧"><a href="#3-shell小技巧" class="headerlink" title="3. shell小技巧"></a>3. shell小技巧</h2><h3 id="1-标准输入和参数"><a href="#1-标准输入和参数" class="headerlink" title="1. 标准输入和参数"></a>1. 标准输入和参数</h3><p>标准输入：scanf、readline这种命令。可以通过管道传输给其他命令。</p><p>参数：main函数传入的args字符串组。可以通过$()传输给其他命令。</p><p>判断：如果命令能让终端阻塞，说明其接受标准输入。</p><h3 id="2-后台运行程序"><a href="#2-后台运行程序" class="headerlink" title="2. 后台运行程序"></a>2. 后台运行程序</h3><p>远程登陆服务器时，终端会一直阻塞。</p><p>在命令之后加&amp;：命令行不会阻塞，但是如果退出服务器登录就不能再访问该网页。</p><p>(cmd &amp;)：可以实现不阻塞且可以在shell关闭后访问web端。</p><p>原理：命令行终端实际上是shell进程，在其中执行的程序都是shell进程的子进程，所以终端关闭后其子进程都会退出。(cmd &amp;)是将cmd命令挂到一个systemd系统守护进程名下，与shell无关。</p><h3 id="3-单引号与双引号"><a href="#3-单引号与双引号" class="headerlink" title="3. 单引号与双引号"></a>3. 单引号与双引号</h3><p>对于$ ( )这些富豪，单引号包围的字符不会转义，而双引号会，所以如果其中有空格，应该用双引号括起来。</p><h3 id="4-sudo"><a href="#4-sudo" class="headerlink" title="4. sudo"></a>4. sudo</h3><p>有些脚本不用sudo能用，但是加了sudo反而用不了，因为这些脚本只存在于用户环境变量中，要用sudo运行必须使用绝对路径。</p><h3 id="5-相似文件名"><a href="#5-相似文件名" class="headerlink" title="5. 相似文件名"></a>5. 相似文件名</h3><p>可以用花括号括起来文件名组成部分，会自动组合。</p><p>比如{1,2,3}{4,5,6}，会自动组合成14、15、16、……（中间不能存在空格）</p><h3 id="6-输入路径"><a href="#6-输入路径" class="headerlink" title="6. 输入路径"></a>6. 输入路径</h3><p>cd -： 返回上一次在的目录</p><p>!$：替换成上一次命令最后的路径</p><p>!*：替换成上一次命令输入的所有文件路径</p><p>CDPATH：当cd命令在当前目录中找不到指定文件或目录时，会去CDPATH中的路径找</p><h3 id="7-输入重复命令"><a href="#7-输入重复命令" class="headerlink" title="7. 输入重复命令"></a>7. 输入重复命令</h3><p>!!：自动替换成上一次使用的命令</p><p>history | grep ‘condition’：搜索带有condition的历史命令</p><p>!id：上面指令搜索的每一条命令都带有独特id，通过id可以重新运行</p><h3 id="8-重定向符号"><a href="#8-重定向符号" class="headerlink" title="8. 重定向符号"></a>8. 重定向符号</h3><blockquote><p>：将标准输出重定向到文件中（清除原有文件中的数据）。</p></blockquote><blockquote><blockquote><p>：将标准输出重定向到文件中（在原有内容后追加）。</p></blockquote></blockquote><p><code>cat file.txt &gt; file.txt</code></p><p>最终会得到空文件，因为执行顺序是：重定向符号是&gt;，所以shell先打开file.txt清空内容，然后将cat的标准输出指向file.txt。</p><p><code>echo hello world &gt; file.txt</code><br><code>cat file.txt &gt;&gt; file.txt</code><br>最终会得到死循环，因为cat是逐行读取数据然后输出。</p><p>|：管道符的多个命令是并行执行的。</p><h3 id="9-session和cookie"><a href="#9-session和cookie" class="headerlink" title="9. session和cookie"></a>9. session和cookie</h3><p>cookie：HTTP是一种无状态的协议，如果需要进行连续操作，服务器就需要给用户贴个特定的标签，用户每次请求时加上标签让服务器认出来。</p><p>一个cookie相当于name=value的变量，而一个session是存储在服务器上的映射。</p><p>session具体由Manager、Provider与Session三个类配合实现：</p><ol><li>服务器接到浏览器的HTTP请求，Handler解析Header中的cookie，得到SessionID并发给Manager。</li><li>Manager存储了session存活时间、cookie名称等配置信息，所有的session存在Manager的Provider中，Manager把SID传递给Provider让他去找出对应的session。</li><li>Provider是一个容器，存储SID与session的映射，根据SID找到Session结构并返回。</li><li>Handler拿出Session中的具体信息，生成该用户的HTML网页并返回给客户端。</li></ol><h3 id="10-git"><a href="#10-git" class="headerlink" title="10. git"></a>10. git</h3><p>git的三个分区：</p><ul><li>工作目录working directory（肉眼可以看到的文件）</li><li>暂存区stage area/index area</li><li>提交历史commit history（HEAD指针指向的位置）</li></ul><p>分区转换：</p><ul><li>将work dir中的修改加入stage：git add</li><li>将stage中的修改还原到work dir：git checkout</li><li>将stage的文件添加到history：git commit</li><li>将history的文件还原到stage区：git reset</li><li>将work dir的修改提交到history区：先git add后git commit，或者git commit -a</li><li>将history区的历史提交还原到work dir中：git checkout HEAD .</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-MySQL</title>
      <link href="/2022/11/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MySQL/"/>
      <url>/2022/11/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MySQL/</url>
      
        <content type="html"><![CDATA[<p>大三上的数据库课，而且讲的很浅，感觉没记下些啥，可能很基础的也会记上来。。。</p><h1 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h1><h2 id="1-关系型数据库与非关系型数据库"><a href="#1-关系型数据库与非关系型数据库" class="headerlink" title="1. 关系型数据库与非关系型数据库"></a>1. 关系型数据库与非关系型数据库</h2><h3 id="1-关系型数据库"><a href="#1-关系型数据库" class="headerlink" title="1. 关系型数据库"></a>1. 关系型数据库</h3><p>关系模型：对关系的表述，二维表格模型。关系名即为表名。一般格式为关系名(属性1，属性2，……，属性N)。</p><p>关系型数据库：采用了关系模型组织数据的数据库。</p><p>优点：</p><ol><li>容易理解：使用了关系模型组织。</li><li>使用方便：通用SQL语言操作。</li><li>易于维护：丰富的完整性（实体完整性、参照完整性和用户定义的完整性）大大减低了数据冗余和不一致的概率。</li></ol><p>缺点：</p><ol><li>高并发时硬盘I/O成为瓶颈。</li><li>难以对数据库系统升级扩展，需要停机维护和数据迁移。</li><li>多表关联查询与复杂查询性能欠佳。</li></ol><h3 id="2-非关系型数据库NoSQL"><a href="#2-非关系型数据库NoSQL" class="headerlink" title="2. 非关系型数据库NoSQL"></a>2. 非关系型数据库NoSQL</h3><p>Not only SQL：不仅仅是SQL，不是“不是SQL”！</p><p>非关系型的、分布式的、一般不保证遵循ACID原则的数据存储系统。</p><p>结构不固定，键值对、宽列、文档、图表等结构。每个元组可以有不一样的字段。</p><p>优点：</p><ol><li>高可拓展性：使用分布式硬件集群横向扩展。</li><li>高性能：针对特定数据模型和访问模式进行了优化。</li><li>灵活架构</li><li>没有复杂的关系</li></ol><p>缺点：</p><ol><li>没有标准化</li><li>查询功能有限</li><li>最终一致性不直观</li></ol><p>BASE：NoSQL数据库对可用性及一致性的弱要求原则：（因为CAP的三点不能同时很好的满足）</p><ul><li>基本可用Basically Available</li><li>软状态/柔性事务Soft-state：无连接</li><li>最终一致性Eventually Consistency：ACID的最终目的</li></ul><h3 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h3><p>最大区别：是否支持外键</p><ol><li>数据存储模型：SQL结构化存储，具有固定行和列的表格；NoSQL非结构化存储，有文档、键值对等多种结构。</li><li>ACID属性：SQL提供；NoSQL通常不支持ACID事务，为了可扩展、高性能进行了权衡。</li><li>性能：SQL性能通常取决于磁盘子系统，为了最佳性能通常需要优化查询、索引和表结构；NoSQL性能通常取决于底层硬件、网络延迟以及应用程序。</li><li>扩展：SQL通常是垂直扩展，即使用性能更强大的服务器，此外读写分离、分库分表等；NoSQL通常是横向扩展，即增加服务器。</li><li>用途：SQL是普通企业级的项目数据存储；NoSQL用途随结构不同而变化，如图数据库分析数据见的关系。</li></ol><h2 id="2-SQL数据完整性"><a href="#2-SQL数据完整性" class="headerlink" title="2. SQL数据完整性"></a>2. SQL数据完整性</h2><p>数据库中数据在逻辑上的一致性、准确性、有效性和相容性。</p><p>包括实体完整性、参照完整性、用户自定义完整性。</p><p>SQL Server中分为实体完整性、域完整性和引用完整性。</p><h3 id="1-实体完整性"><a href="#1-实体完整性" class="headerlink" title="1. 实体完整性"></a>1. 实体完整性</h3><p>又叫行完整性，指表中每一个记录都能唯一标识，且不存在重复的记录。可通过主键约束和唯一性约束实现。</p><p>主键约束：主键列取值不能为空且不能重复。</p><p>唯一性约束：允许值为空，但不允许重复，包括空。</p><h3 id="2-域完整性"><a href="#2-域完整性" class="headerlink" title="2. 域完整性"></a>2. 域完整性</h3><p>又叫列完整性，指数据集对某一列是否有效和确定是否允许为空值。可通过空值约束、默认约束和检查约束实现。</p><p>空值约束：值是否可以为空。</p><p>默认约束：为列设置默认值。</p><p>检查约束：为列设置取值范围。</p><h3 id="3-引用完整性"><a href="#3-引用完整性" class="headerlink" title="3. 引用完整性"></a>3. 引用完整性</h3><p>又称参照完整性、外键约束。保证主键和外部键的关系得到维护。通过定义外键约束实现。</p><p>外键约束：定义任意个列，这些列可参照当前表或其他表的主键或UNIQUE约束列。</p><p>有更新规则与删除规则，共用四种模式：不执行任何操作、级联、置空、设置默认值。</p><p>不执行任何操作：默认值。外键列不能增改主键列没有的值（删除不受影响），主键表不能修改涉及外部键值记录的主键值，不能删除涉及外部键值的记录（插入不受影响）。</p><p>级联：外键列不能增改主键列没有的值（删除不受影响），外键值随主键值同步修改、删除（插入不受影响）。</p><p>置空：外键列不能增改主键列没有的值（删除不受影响），外键值随主键值改删置空（插入不受影响）。</p><p>设置默认值：外键列不能增改主键列没有的值（删除不受影响），外键值随主键值改删置为默认值（插入不受影响）。</p><h3 id="4-用户定义的完整性"><a href="#4-用户定义的完整性" class="headerlink" title="4. 用户定义的完整性"></a>4. 用户定义的完整性</h3><p>针对某一具体应用的数据必须满足的语义要求。</p><h2 id="3-MYSQL架构"><a href="#3-MYSQL架构" class="headerlink" title="3. MYSQL架构"></a>3. MYSQL架构</h2><p>MYSQL架构分为Server层和存储引擎层。存储引擎层只负责数据的存储和提取，其他所有功能都在Server层。InnoDB是MYSQL默认的存储引擎。</p><p>MYSQL基于TCP传输。</p><p>执行流程：</p><ol><li>连接器：通过TCP握手连接MYSQL服务。</li><li>查询缓存：查询Server层的k-v缓存（SQL查询语句-查询结果）。由于命中率很低且每更新数据库就需要清空，从MYSQL 8.0开始不用这个阶段。</li><li>解析SQL：解析器进行词法分析和语法分析<ol><li>词法分析：识别关键词，构建SQL语法树。</li><li>语法分析：根据语法规则判断输入的SQL语句是否符合语法。</li></ol></li><li>执行SQL：<ol><li>预处理阶段：预处理器检查SQL查询语句中的表或字段是否存在；将select *中的*展开为表上所有列。</li><li>优化阶段：优化器将SQL查询语句的执行方案确定下来。比如再表里有多个索引时，优化器基于查询成本决定选择哪个索引。</li><li>执行阶段：执行器和存储引擎交互（以记录为单位）<ol><li>主键索引查询：id = 1：查询条件用到了主键索引，而且是等值查询，同时主键id唯一。执行器将条件交给存储引擎，让存储引擎查询记录，存储引擎将结果发回给执行器，执行器判断记录是否符合查询条件，如果符合发送给客户端，否则跳过，直到找不到或者返回-1表示已查询完。</li><li>全表扫描：name = ‘xxx’：优化器选择访问类型为all。存储引擎从表中第一条记录读起，执行器判断是否符合条件，如果是则发给客户，否则跳过，直到存储引擎把表中所有记录读完并返回读取完毕。</li><li>索引下推：age &gt; 20 and reward = 100000，且对age和reward建立了联合索引：执行器调用接口定位到满足查询条件的第一条二级索引记录(age &gt; 20)；存储器在定位到二级索引后先不执行回表操作，而是先判断reward列条件是否成立，如果不成立直接跳过该索引，成立则回表；执行器再判断其他条件是否成立并决定发给客户端，然后继续向存储引擎索要下一条记录。即将部分条件交给存储引擎直接判断。</li></ol></li></ol></li><li>总体流程：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="MYSQL执行流程"></li></ol><h2 id="4-表空间文件结构"><a href="#4-表空间文件结构" class="headerlink" title="4. 表空间文件结构"></a>4. 表空间文件结构</h2><p>一张数据库表的数据保存在ibd文件中，也称为独占表空间文件。表空间由段、区、页、行组成，逻辑结构依次缩小。</p><h3 id="1-行"><a href="#1-行" class="headerlink" title="1. 行"></a>1. 行</h3><p>每一条记录都是按行存放。</p><h3 id="2-页"><a href="#2-页" class="headerlink" title="2. 页"></a>2. 页</h3><p>数据按页为单位读写，默认大小为16KB。</p><p>分页的原因：数据量过大，避免一次性将所有数据加载出来。</p><p>数据页中有一个页目录，起记录的索引作用。</p><ol><li>将所有记录划分成几个组。</li><li>每个记录组的最后一条记录是组内最大的记录，其头信息会存储该组记录数，作为n_owned字段。</li><li>页目录存储每组最后一条记录的地址偏移量，也被称为槽。</li></ol><h3 id="3-区"><a href="#3-区" class="headerlink" title="3. 区"></a>3. 区</h3><p>B+树中，每一层通过双向链表相连。链表中相邻的页的物理位置也相邻，方便使用顺序IO。</p><p>为某个索引分配空间按区为单位分配，一般1MB，从而使得物理位置相邻。</p><h3 id="4-段"><a href="#4-段" class="headerlink" title="4. 段"></a>4. 段</h3><ul><li>索引段：存储B+树的非叶子节点的区的集合。</li><li>数据段：存储B+树的叶子节点的区的集合。</li><li>回滚段：存储回滚数据的集合。</li></ul><h2 id="5-行格式"><a href="#5-行格式" class="headerlink" title="5. 行格式"></a>5. 行格式</h2><ul><li>Redundant：5.0前的老格式，现在没人用了。</li><li>Compact：5.0~5.7默认行格式。</li><li>Dynamic：5.7之后默认行格式</li><li>Compressed</li></ul><h3 id="1-Compact"><a href="#1-Compact" class="headerlink" title="1. Compact"></a>1. Compact</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>变长字段长度列表：逆序存储变长字段的长度。数据表中没有变长字段，则没有这段。</p><p>NULL值列表：每列对应一个二进制位，逆序表示是否为NULL值。数据表字段都定义成NOT NULL时，没有这段。</p><p>row_id：在没有指定主键与唯一约束时自动添加。如果指定了其中之一，则没有这段。</p><p>发生行溢出时，记录的真实数据处只会保留部分数据，用20字节存储指向溢出页的地址，剩余的数据放在溢出页。</p><h2 id="6-三大范式"><a href="#6-三大范式" class="headerlink" title="6. 三大范式"></a>6. 三大范式</h2><h3 id="1-第一范式"><a href="#1-第一范式" class="headerlink" title="1. 第一范式"></a>1. 第一范式</h3><p>对关系模式的基本要求，不满足则不是关系数据库。</p><p>1NF：无重复的列/字段不可分。</p><p><strong>原子性</strong>，字段不可再分。</p><h3 id="2-第二范式"><a href="#2-第二范式" class="headerlink" title="2. 第二范式"></a>2. 第二范式</h3><p>先要满足1NF。</p><p>2NF：有主键，非主键字段依赖于主键。</p><p><strong>唯一性</strong>，一个表只说明一个事务。</p><h3 id="3-第三范式"><a href="#3-第三范式" class="headerlink" title="3. 第三范式"></a>3. 第三范式</h3><p>先要满足2NF。</p><p>3NF：非主键字段不能相互依赖。不存在传递依赖。</p><h3 id="4-BCNF"><a href="#4-BCNF" class="headerlink" title="4. BCNF"></a>4. BCNF</h3><p>先要满足3NF</p><p>任何非主键字段不能对主键子集依赖。</p><h2 id="7-InnoDB与MyISAM"><a href="#7-InnoDB与MyISAM" class="headerlink" title="7. InnoDB与MyISAM"></a>7. InnoDB与MyISAM</h2><ol><li>应用层：外键、事务、行锁、是否可以没有主键。</li><li>并发：InnoDB支持行级锁，MyISAM不支持。</li><li>备份：InnoDB支持在线热备份。</li><li>崩溃恢复：MyISAM崩溃后损坏概率较InnoDB高，且恢复速度较慢。</li><li>索引：MyISAM树节点的data域只存放数据记录的地址，称为非聚簇索引。InnoDB树节点的data域保存了完整的数据记录，称为聚簇索引。其他索引的data域存储的是主键值而不是地址。</li><li>适用场景：MyISAM适合插入不频繁而查询非常频繁的场合，因为没有事务；InnoDB适合可靠性要求非常高、要求事务或插入相当频繁的场合。</li></ol><h2 id="8-数据库结构优化"><a href="#8-数据库结构优化" class="headerlink" title="8. 数据库结构优化"></a>8. 数据库结构优化</h2><ul><li>范式优化/反范式优化：消除冗余（节省空间）/增加冗余（减少join）</li><li>限定数据范围：查询时必须带上某些限制，尽量使用索引，避免全表扫描</li><li>读写分离：主库负责写，从库负责读</li><li>拆分表<ul><li>横向拆分：根据某个记录（如主键）哈希值的不同拆分表。</li><li>纵向拆分：将属性分为活跃字段（常用）与不活跃字段，拆成两张表。</li></ul></li></ul><h2 id="9-高并发优化"><a href="#9-高并发优化" class="headerlink" title="9. 高并发优化"></a>9. 高并发优化</h2><ul><li>加入缓存：web服务框架中、服务器与数据库层间。</li><li>增加数据库索引（但不能太多，否则每个索引维护的树都需要同步更新，同样会变慢）</li><li>主从读写分离</li><li>拆分表</li><li>分布式架构</li></ul><h2 id="10-游标与视图"><a href="#10-游标与视图" class="headerlink" title="10. 游标与视图"></a>10. 游标与视图</h2><p>游标：对<strong>查询出来的结果集</strong>作为一个单元处理。一般用于需要逐条记录（逐行）处理的场合。</p><p>视图：虚拟的表，和物理表相同的功能，对其修改不影响原表。相比于多表查询更容易获取数据。</p><p>作用：</p><ol><li>简化操作。把经常使用的数据定义为视图。</li><li>安全性。用户只能查询与修改能看到的数据。</li><li>逻辑上的独立性。屏蔽真实表结构的影响。</li></ol><p>比较：</p><ol><li>本质：游标作为指针操作，视图作为数据库对象展示给用户。</li><li>占用资源：游标占用资源大，视图占用资源小。</li><li>工作方式：游标针对行操作，视图针对基表的一个整体的查询。</li></ol><h2 id="11-LSM树"><a href="#11-LSM树" class="headerlink" title="11. LSM树"></a>11. LSM树</h2><p>日志结构合并树。</p><p>作为各种NoSQL的底层存储索引。</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul><li>横跨内外存，分为多个层，L0位于内存，L1-LN位于磁盘。</li><li>内存中一般采用<strong>有序、高性能查找的结构</strong>，如AVL树、红黑树、跳表等。</li><li>外存中每一层本质是多个<strong>文件</strong>，文件内是排序好的数据。</li><li>每一层树数据达到阈值后向下层compact。</li><li>增删改LSM树均在内存操作，归并时将修改刷盘。</li><li>特点：<strong>写性能强、读性能弱</strong>。</li></ul><p>与B+树都使用了WAL，但B+树增删改均是随机写，LSM树只是追加顺序写，而LSM树读操作最坏需要遍历所有层，所以读效率一般不如B+树。</p><h3 id="2-具体结构"><a href="#2-具体结构" class="headerlink" title="2. 具体结构"></a>2. 具体结构</h3><p>由memtable、immutable-memtable（内存）与SSTable（磁盘）组成。</p><h3 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h3><p>分为两步：</p><ol><li>WAL写日志</li><li>将待插入的数据定位到内存中待写入的位置，写入。（不在乎该数据是否在磁盘中）</li></ol><p>增删改操作在memtable中进行，memtable大小达到阈值后转变成immutable-memtable（即将刷盘的中间态），并新建一个memtable。后台线程将immutable-memtable写入磁盘L1层形成SSTable文件，随后销毁immutable-memtable。</p><p>SSTable不可修改，改删都是以顺序写入新记录的形式呈现。读取数据从新到旧读，所以先读到最新的数据。</p><p>单个SSTable不存在相同key的数据，而不同SStable可能存在。</p><h3 id="4-更新"><a href="#4-更新" class="headerlink" title="4. 更新"></a>4. 更新</h3><ol><li>在内存中找待更新的数据。</li><li>如果内存中找到，就更新。</li><li>否则将待更新的数据插入到本应存在的位置。</li></ol><h3 id="5-删除"><a href="#5-删除" class="headerlink" title="5. 删除"></a>5. 删除</h3><p>只是将更新改为打上delete标签。</p><h3 id="6-查找"><a href="#6-查找" class="headerlink" title="6. 查找"></a>6. 查找</h3><p>性能偏弱，按照层次增加依次查找，知道找到为止。</p><p>外存中每一层的多个SSTable配有布隆过滤器和索引。布隆过滤器快速判断block内部是否存在待查找的值，可能存在则通过索引加速查找。</p><p>最坏需要遍历所有层。</p><h3 id="7-合并"><a href="#7-合并" class="headerlink" title="7. 合并"></a>7. 合并</h3><p>将低级别多个SSTable文件中的数据放入高一级的SSTable文件，并清除这些低级别的文件。</p><p>三个问题：</p><ul><li>读放大：读取数据时实际读取量大于真正的数据量。如LSM读取数据时可能需要扫描多个SSTable。</li><li>写放大：写入数据时实际写入量大于真正的数据量。如LSM树写入触发Compact操作。</li><li>空间放大：数据实际占用的磁盘空间比数据真正大小更多。如LSM树存放的旧版冗余数据都是无效的。</li></ul><p>必要性：对一个数据增删改时，磁盘中可能存有其历史版本，而这些历史版本不会被读取到、没有任何作用，但是占着磁盘，需要清理。</p><p>两种广泛应用的策略</p><h4 id="1-STCS-Size-Tiered-Compaction-Strategy"><a href="#1-STCS-Size-Tiered-Compaction-Strategy" class="headerlink" title="1. STCS Size-Tiered-Compaction-Strategy"></a>1. STCS Size-Tiered-Compaction-Strategy</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772b1dc05459429ca9fd7c837d3dddfa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" class="lazyload placeholder" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772b1dc05459429ca9fd7c837d3dddfa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>保证<strong>同一层</strong>中所有SSTable大小相近。</p><p>某层SSTable数量达到阈值时，将其合成一个更大的SSTable，放入下一个level，且在合并过程中清理重复的、被删除的数据。</p><p>多路归并排序。</p><p>对三个问题的解决：</p><ul><li>读放大：<strong>存在</strong>。不知道要查找的key在哪个SSTable，还是需要从新到旧遍历所有SSTable。</li><li>写放大：<strong>存在</strong>。写时触发Compact。</li><li>空间放大：<strong>存在</strong>。这种策略只能保证每个SSTable不存在重复数据，但同一层多个SSTable依然可能有相同数据。</li></ul><h4 id="2-LCS-Leveled-Compaction-Strategy"><a href="#2-LCS-Leveled-Compaction-Strategy" class="headerlink" title="2. LCS Leveled-Compaction-Strategy"></a>2. LCS Leveled-Compaction-Strategy</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38fbb237a5654586a225f6237424fd94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" class="lazyload placeholder" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38fbb237a5654586a225f6237424fd94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>保证<strong>磁盘</strong>所有层SSTable大小一致。</p><p>每一层限制总文件大小，层内按序排列且无重复数据（SSTable之间也有序）。</p><p>某层总文件大小达到阈值时，在该层选择一个SSTable与下一层key范围有交集的SSTable合并。保证合并后单个SSTable大小不超过阈值，且层内有序。多个不相关Compact可并行。</p><p>对三个问题的解决：</p><ul><li>读放大：较小。层内SSTable也有序，所以可直接定位到可能存放key的SSTable。</li><li>写放大：存在。写时触发Compact。</li><li>空间放大：较小。层内无重复数据，compact时不创建临时文件。</li></ul><h3 id="8-MVCC在LSM树的应用"><a href="#8-MVCC在LSM树的应用" class="headerlink" title="8. MVCC在LSM树的应用"></a>8. MVCC在LSM树的应用</h3><p>问题：高频率读写时，一个连接读取的SSTable被其他连接写入时合并。</p><p>解决：</p><ul><li>悲观锁：效率过低</li><li>MVCC。</li></ul><p>MVCC：快照+对所有SSTable加上引用计数。某个版本的引用计数降为0时，清理版本内引用计数为0的SSTable。</p><h2 id="12-跳表skiplist"><a href="#12-跳表skiplist" class="headerlink" title="12. 跳表skiplist"></a>12. 跳表skiplist</h2><p>实现与红黑树、AVL树相似。用于Redis的Zset实现。</p><p>每个节点由key、value与level大小的指针数组组成。</p><h3 id="1-层数"><a href="#1-层数" class="headerlink" title="1. 层数"></a>1. 层数</h3><p>每个节点都会随机到一个不同的层数x，该节点0~X所有层都是同一数据。</p><p>计算方式：（Redis中p=1/4，MaxLevel=64）</p><ul><li>节点初始为第0层。</li><li>在有第i层的情况下，第i+1层出现概率为p。</li><li>最大为MaxLevel层。</li></ul><p>每层的指针连接到相同层下一个节点（相当于每一层构成一个链表）。</p><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h3><ul><li>从dummyhead的最高层level出发。</li><li>当前层key小于待查key<ul><li>当前层next节点为空，跳到下一层。</li><li>否则跳到当前层next节点。</li></ul></li><li>当前层key大于待查key<ul><li>当前层不为第0层，跳到下一层的上一个节点。（具体实现时可不用双向链表，而是直接与next的key比较）</li><li>当前层为第0层，查找失败。</li></ul></li><li>当前层key等于待查key，查找成功。</li></ul><h3 id="3-插入-1"><a href="#3-插入-1" class="headerlink" title="3. 插入"></a>3. 插入</h3><p><img src="https://pic4.zhimg.com/80/v2-6a28162637f7ec3496470aa8c2d73f6b_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-6a28162637f7ec3496470aa8c2d73f6b_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>先查询合适的插入位置。在查询的过程中记录每层最后一个遍历到的节点作为update数组。</li><li>创建新节点，随机生成待插入节点的level。如果level大于跳表当前最大层数，则将level设为跳表最大层数+1，update[level]更新为dummyhead。</li><li>用update连接上新节点，更新新节点各层的指针。</li></ul><h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h3><p><img src="https://pic4.zhimg.com/80/v2-41ed3ff71b11abc2e6aa79de40f6f95f_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-41ed3ff71b11abc2e6aa79de40f6f95f_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>与插入类似，记录update，移除时调整update中各节点指针指向。</p><p>删除后，跳表当前最大层数可能发生变化，需要调整。具体为dummyhead节点最高level向下查，看next指针是否为空，为空则将level-1。</p><h3 id="5-比较"><a href="#5-比较" class="headerlink" title="5. 比较"></a>5. 比较</h3><p>与哈希表：范围查找。</p><p>与平衡树：</p><ul><li>范围查找。</li><li>平衡树增删触发染色、旋转操作<ul><li>实现复杂</li><li>可能需要回溯，涉及节点多，并发时锁范围大，导致效率低。</li></ul></li><li>内存占用，平衡树每个节点至少需要两个指针，跳表p=1/4时平均每个节点只要1.33个指针。</li></ul><h1 id="2-索引篇"><a href="#2-索引篇" class="headerlink" title="2. 索引篇"></a>2. 索引篇</h1><h2 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1. InnoDB"></a>1. InnoDB</h2><ol><li><p>创建表的索引选择(聚簇索引)：只能有一</p><ol><li>如果有主键，默认用主键作为聚簇索引的索引键</li><li>如果没有主键，选择第一个不包含NULL值的唯一列作为聚簇索引的索引键</li><li>如果都没有，InnoDB自动生成一个隐式自增id列作为聚簇索引的索引键</li></ol></li><li><p>创建的主键索引和二级索引默认使用B+Tree索引</p><ol><li>B+Tree是一种多叉树，叶子节点存放数据，非叶子节点存放索引，每个节点里的数据按主键顺序存放，每个叶子节点都指向下一个叶子节点，形成一个链表。</li><li>二级索引：<ol><li>回表：二级索引的叶子节点中存放的是主键，所以在二级索引查询到后主键值后，还需要根据主键去主键索引的B+Tree再查询一次。</li><li>覆盖索引：需要查询的字段正好是索引字段。如果查询的数据就在二级索引的叶子节点中（比如主键），就不用再查。</li></ol></li><li>B+Tree的优势<ol><li>B Tree：<ol><li><strong>首要原因：B+ Tree的叶子节点使用了双链表连接，适合数据库中频繁的范围查询。</strong></li><li>B树叶子节点也会存储数据，所以数据量相同的情况下，B+Tree能存放更多索引，导致比B树更“矮胖”，磁盘I/O次数更少</li><li>B+ Tree增删节点时更为方便， B树还需要额外变形。</li></ol></li><li>二叉树：二叉树每个节点的子节点只能是两个，因此平均检索次数比B+ Tree更多。</li><li>Hash：<ol><li>哈希表不适合做范围查询</li><li>哈希表查询时需要将数据全部加载到内存中，而B+ Tree可以根据节点分段加载</li></ol></li></ol></li></ol></li><li><p>数据存储形式</p><ol><li>数据按照数据页为单位进行读写，默认大小16KB。由文件头、页头、最大最小记录、用户记录、空闲空间、页目录、文件尾七个部分组成。<ol><li>File Header文件头中有两个指针分别指向上一页与下一页</li><li>页中记录按照主键顺序组成单向链表，为提高检索效率，将所有数据分组（每组记录数有限制），每个组中最后一条记录为组内最大记录，在该记录的头信息中存储该组记录数，页目录存储每组组内最大记录的地址偏移量，称为槽。通过槽查找记录时可以使用二分法。</li></ol></li><li>InnoDB里的B+ Tree每个节点都是一个数据页</li></ol></li></ol><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><ol><li><p>索引分类</p><ol><li><p>按数据结构分类：</p><ol><li>B+Tree索引</li><li>HASH索引</li><li>全文索引：通过关键字匹配的方式进行全文过滤<ol><li>想对词语进行全文索引，它的长度必须满足在一个区间内（配置文件指定，一般为3~84）。</li><li>自然语言的全文索引：计算每一个文档对象和查询的相关度，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索。为了避免搜索语气词、助词这些没有意义的词。</li><li>在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性。</li><li><strong>比like%快，但是精度比它低</strong>。</li></ol></li></ol></li><li><p>按物理存储分类：</p><ol><li>主键索引/聚簇索引：InnoDB中，聚簇索引一般情况下等于主键索引。但是创建表时没有指定主键索引，会尝试第一个not null的唯一索引，如果还不行，那么就会自动生成隐藏的递增列作为聚簇索引。</li><li>二级索引 = 非聚簇索引</li><li>聚簇与非聚簇的重要区别：<strong>键的叶子节点是否存储了完整数据</strong>。<ol><li>MyISAM的主键叶子节点存储的是数据的地址，并非完整数据，所以仍是非聚簇索引。</li><li>InnoDB的主键叶子节点存储的是完整的数据，所以是聚簇索引。</li><li>InnoDB的非主键叶子节点存储的是对应的主键值，所以是非聚簇索引。</li></ol></li><li>聚簇索引优点：<ol><li>查询速度快：相较于非聚簇索引少一次回表查询。</li><li>适合排序查找和范围查找：叶子节点由二叉树连接。</li></ol></li><li>聚簇索引缺点：<ol><li>依赖于有序的数据：插入时需要数据是有序的。如果键是字符串这种难比较的键，插入与查找速度慢。</li><li>更新代价大：主键修改会涉及到树结构的变动，因此一般设置为主键不可修改。</li></ol></li></ol></li><li><p>按字段特性分类：</p><ol><li>主键索引：一张表最多只有一个，索引列的值不允许有空值</li><li>唯一索引：一张表可以有多个，索引列的值必须唯一，<strong>允许有空值</strong></li><li>普通索引</li><li>前缀索引：对字符类型字段的前几个字符建立索引，可以建立在字段类型为char、varchar、binary、varbinary的列上</li></ol></li><li><p>按字段个数分类；</p><ol><li>单列索引</li><li>联合索引：建立在多列上的索引。B+Tree先按照其中一列进行排序，相同时再按另一列排序。存在最左匹配原则，即按照最左优先的方式进行索引的匹配（以(a, b)建立联合索引，不能只查找where b = x）。<ol><li>如 select * from table where a &gt; 1 and b = 2。联合索引先按照a字段的值排序，所以搜索时可以定位到符合a &gt; 1的第一条记录，然后会沿链表向后扫描直到结束，但是在符合a &gt; 1的记录中b是无序的，所以只能逐条判断b = 2是否成立。因此，这条语句只有a字段使用了联合索引进行索引查询，而b字段没用到。</li><li>如果改成a &gt;= 1，则当a = 1时可以通过b = 2条件减少二级索引范围，当a &gt; 1时再逐条扫描所以这条语句a和b字段都用到了联合索引。</li><li>如果改成name like ‘j%’，则当name = j时可以通过b = 2条件检索二级索引范围，当name更长时则需要逐条扫描，所以name和b都用到了联合索引。</li><li>索引下推优化：可以在联合索引遍历过程中，先对联合索引包含的字段做判断，直接过滤掉不满足条件的记录，减少回表次数。</li><li>索引区分度：某个字段不同值的个数除以表的总行数。<ol><li>建立联合索引时，越靠前的字段被用于索引过滤的概率越高。如果索引区分度小且字段分布均匀，那么无论搜索哪个值都不能去掉很多数据。</li></ol></li></ol></li></ol></li></ol></li><li><p>索引的适用场合：</p><ol><li>索引需要有的特点：<ol><li>一般不能随便更新，因为更新代价很高。</li><li>能唯一标识一个记录。</li></ol></li><li>需要：<ol><li>字段唯一性限制、非空：身份证</li><li>频繁查询、条件查询：where</li><li>频繁排序：order、group</li><li>频繁连接：join</li></ol></li><li>不需要：<ol><li>上面关键字用不到的字段</li><li>字段中存在大量重复数据</li><li>表数据太少</li><li>经常更新的字段：余额</li></ol></li></ol></li><li><p>优化方法</p><ol><li><p>前缀索引优化：使用某个字段中字符串的前几个字符建立索引，从而减小索引字段大小。</p><ol><li>order by无法使用前缀索引</li><li>无法把前缀索引用作覆盖索引</li></ol></li><li><p>覆盖索引优化：将经常查询的关联字段建立联合索引，使得索引中存在这些数据，从而避免回表</p></li><li><p>主键索引最好是自增的（每次插入的都比当前最大值大）：插入新记录时都是追加操作，不需要重新移动数据；主键长度不要太大，因为二级索引存储的数据是主键值，主键长度小意味着二级索引的B+Tree耗费空间少。</p></li><li><p>索引最好设置为NOT NULL：</p><ol><li>索引列存在NULL使优化器做索引选择时更复杂</li><li>NULL无意义但会占用物理空间</li></ol></li><li><p>防止索引失效</p><ol><li>索引失效<ol><li>使用左或者左右模糊匹配<ol><li>例外：表中没有非索引项，且需要查询的键只包含主键与条件所在的键。由于二级索引树包含所需要查询的全部信息，并且二级索引树记录的东西比聚簇索引树少很多，所以全扫描二级索引树耗费的成本远小于全扫描聚簇索引树，优化器会选择全扫描二级索引树查询数据。（虽然也是全扫描，但是因为全扫描的是二级索引树，所以也算作索引没有失效？）</li></ol></li><li>对索引列做了计算、函数、类型转换等操作(如果操作是用在输入参数上，则仍可以用索引扫描)<ol><li>如，字符串转int，’10000’、’010000’、’10000e’都会转换成10000，这种情况下判断索引失效。</li></ol></li><li>联合索引没有遵循最左匹配原则</li><li>WHERE子句中在OR前的条件列是索引列，而OR后不是</li></ol></li><li>尽量避免全表扫描和全索引扫描</li><li>extra字段<ol><li>Using filesort：查询语句中包含group by而且无法利用索引完成排序，不得不选择算法排序。</li><li>Using temporary：使用临时表保存中间结果，常见于order by与group by</li></ol></li></ol></li></ol></li></ol><h2 id="3-count-函数"><a href="#3-count-函数" class="headerlink" title="3. count()函数"></a>3. count()函数</h2><ol><li>性能排序: count(*) = count(1) &gt; count(主键字段) &gt; count(字段)</li><li>count(1)：循环遍历索引（表中有二级索引则遍历二级索引，否则聚簇索引），将读到的记录返回给server层但不读取记录中任何字段的值（1不是任何字段），server层每读到一条记录count+1。</li><li>count(*)：等于count(0)，实际上与count(1)一样。</li><li>count(主键字段)：如果表里只有主键索引而没有二级索引，InnoDB循环遍历主键索引，将读取到的记录返回给server层并读取主键值，判断是否为NULL，不为NULL则count+1；如果存在二级索引，则会改为遍历二级索引表（遍历成本较聚簇索引低）。</li><li>count(字段)：全表扫描，执行效率差。</li><li>MyISAM引擎执行count只需要常数时间复杂度，因为每张数据表都有信息记录row_count值；但InnoDB支持事务，多版本并发控制，所以无法只维护一个变量查询。</li><li>优化：<ol><li>explain关键字，并不会真正查询而是估算</li><li>额外维护计数表</li></ol></li></ol><h2 id="4-键"><a href="#4-键" class="headerlink" title="4. 键"></a>4. 键</h2><p>超键：在关系中能唯一标识元组的属性集</p><p>候选键：不含有多余属性的超键（若从候选键中删除任意属性，就不再能唯一标识）</p><p>主键：用户选作元组标识的其中一个候选键。</p><p>外键：关系模式中某个属性是其他关系模式的主键，则称为本模式的外键。</p><h2 id="5-聚集索引与非聚集索引"><a href="#5-聚集索引与非聚集索引" class="headerlink" title="5. 聚集索引与非聚集索引"></a>5. 聚集索引与非聚集索引</h2><p>聚集索引/聚簇索引：存放的逻辑顺序和列中的顺序一样。一般设置主键索引为聚集索引。</p><p>一个表只能有一个主键与聚集索引，因为主键的作用就是将表的数据格式转换为索引的格式放置。</p><p>每次数据改变时，必须重新梳理树的结构以维持其正确性，带来不少的性能开销，所以会为查询以外的操作带来副作用。</p><p>非聚集索引/常规索引：即为二级索引。每个非聚集索引互相之间不存在关联。</p><p>区别：主键索引与二级索引的区别。</p><ul><li>非聚集索引查询一般需要回表，即第一次按照非聚集索引查询到对应的聚集索引，第二次根据聚集索引去聚集索引树种查询。</li><li>聚集索引一张表只能有一个，非聚集索引可以多个。</li></ul><h2 id="6-索引与主键"><a href="#6-索引与主键" class="headerlink" title="6. 索引与主键"></a>6. 索引与主键</h2><p>区别：</p><ol><li>主键用于唯一标识每一行，索引用于快速查找特定值的记录。</li><li>一个表只能有一个主键，但可以有多个候选索引。</li><li>主键列不允许空值，索引允许。</li><li>主键是逻辑键，索引是物理键。</li></ol><h2 id="7-AUTO-INCREMENT"><a href="#7-AUTO-INCREMENT" class="headerlink" title="7. AUTO_INCREMENT"></a>7. AUTO_INCREMENT</h2><p>字段被定义为自增键，表现如下：</p><ul><li>插入数据时id字段指定为0、null或未指定值，则将该表当前的自增值填到自增字段。</li><li>插入数据时id字段指定了具体值，则直接使用。如果指定值大于当前自增值，会将自增值修改为指定值的下一个值。</li></ul><p>自增值不连续的场景：</p><ul><li>自增初始值和步长不设置为1：分布式库为了避免主键冲突，一般让一个库自增id奇数，另一个库偶数，导致步长不为1。</li><li>自增键出现唯一键冲突，导致插入失败，但是自增值仍然会增加。</li><li>事务回滚，自增值不会随之回滚。</li><li>批量插入（insert … select）会批量分配自增值，但是这些值并不一定全部用到。</li></ul><h2 id="8-外键"><a href="#8-外键" class="headerlink" title="8. 外键"></a>8. 外键</h2><p>优点：</p><ul><li>能保证数据库一致性和完整性。</li><li>级联更新方便（更新主键会触发对应的外键更新）</li></ul><p>缺点：</p><ul><li>增加了复杂性：每次删改都要考虑外键约束。</li><li>对分库分表不友好：分库分表时外键无法生效。即对分布式支持不行。</li></ul><h2 id="9-快照读与锁定读"><a href="#9-快照读与锁定读" class="headerlink" title="9. 快照读与锁定读"></a>9. 快照读与锁定读</h2><p>事务篇与锁篇，一个解决快照读，一个解决锁定读。</p><p>快照读（一致性非锁定读）：单纯的SELECT语句，没有 <code>for update</code>、<code>lock in share mode</code>这些关键字。</p><ul><li>只有在读提交、可重复读隔离级别下，InnoDB才会使用快照读。</li><li>适用于对数据一致性要求不是特别高，且追求极致性能的业务场景。</li></ul><p>当前读（一致性锁定读）：给行记录加X锁或S锁。上面提到的两个例外、增删改语句都是。</p><h2 id="10-子查询"><a href="#10-子查询" class="headerlink" title="10. 子查询"></a>10. 子查询</h2><p>尽量转化为join操作。</p><p>性能差：结果集是临时表，无法使用索引；产生大量临时表，消耗过多的CPU和IO资源，产生大量的慢查询。</p><h1 id="3-事务篇"><a href="#3-事务篇" class="headerlink" title="3. 事务篇"></a>3. 事务篇</h1><p>一个事务是一个原子操作，要么事务中的操作全部执行成功，要么全部执行失败，不允许出现中间状态的数据。</p><h2 id="1-★-ACID"><a href="#1-★-ACID" class="headerlink" title="1. ★ ACID"></a>1. ★ ACID</h2><p>一致性是最终目的，原子性、隔离性、持久性都是为了保证一致性。</p><ol><li>Atomic原子性：一个事务中的所有操作要么全部完成，要么全部不完成。如果事务在执行过程中发生错误，会回滚到事务开始前的状态。通过undo log（回滚日志）来保证。</li><li>Consistency一致性：事务在操作前后，数据满足完整性约束，数据库保持一致性状态。通过持久性+原子性+隔离性来保证。</li><li>Isolation隔离性：防止多个事务并发执行时由于交叉执行导致数据不一致。通过MVCC（多版本并发控制）或锁机制来保证。</li><li>Durability持久性：事务处理结束后，对数据的修改是永久的。通过redo log（重做日志）保证。</li></ol><h2 id="2-★-并行事务引发的问题"><a href="#2-★-并行事务引发的问题" class="headerlink" title="2. ★ 并行事务引发的问题"></a>2. ★ 并行事务引发的问题</h2><ol><li>脏读：一个事务读到了另一个未提交事务修改过的数据，此时如果另一个事务触发回滚，那就读到了过期的数据。</li><li>不可重复读：在一个事务内多次读取同一数据，前后两次读到的数据不一样，即多次读取中有其他事务更新了该条数据。</li><li>幻读：在一个事务内多次查询某个符合查询条件的记录数量，出现前后两次查询到的记录数量不一样，即在多次查询中有其他事务增删了符合条件的记录。</li><li>严重性：脏读 &gt; 不可重复读 &gt; 幻读</li></ol><h2 id="3-★-隔离级别"><a href="#3-★-隔离级别" class="headerlink" title="3. ★ 隔离级别"></a>3. ★ 隔离级别</h2><p>隔离级别越高，性能效率越低</p><ol><li>读未提交：一个事务还没提交时，它的变更就能被其他事务看到。不能防止任何问题。</li><li>读提交：一个事务提交后，它的变更才能被其他事务看到。能防止脏读。通过在每个语句执行前生成一个Read View实现。</li><li>可重复读：一个事务执行过程中看到的数据，跟这个事务启动时看到的数据一致。MySQL InnoDB引擎的默认隔离级别。能防止脏读、不可重复读。通过在启动事务时生成一个Read View实现。</li><li>串行化：对记录加上读写锁，多个记录如果对同一条记录发生了读写冲突，后访问的事务必须等待前一个事务执行完成，才能继续操作。能防止三个问题。</li></ol><p>MYSQL InnoDB默认选择可重复读级别的原因：很大程度上避免了幻读，但并没有完全解决，为了避免性能受太大影响选择可重复读级别。</p><ol><li>快照读（普通select语句，只需要读取Read View处）：通过MVCC方式解决幻读。事务执行过程中看到的数据跟启动时一致，即使中途有其他事务插入了数据也查询不到。</li><li>当前读（select … for update、增删改等语句，需要读取到当前记录最新值）：通过临键锁（记录锁+间隙锁）解决幻读。执行时会上查询范围内的next-key lock，其他事务在锁范围内插入记录时，插入语句会被阻塞。</li><li><strong>幻读仍可能发生</strong>：<ol><li>其他事务插入并提交记录后，尽管当前事务<strong>看不到该条记录，但是仍然update该条记录</strong>，这样trx_id就会变成当前事务，当前事务也能利用Read View查询到该条记录。</li><li>执行快照读select后插入记录，然后执行当前读select for update。</li><li>为了避免特殊情况，应该在<strong>事务开启之后马上执行当前读语句</strong>，开启锁。</li></ol></li></ol><h2 id="4-隔离级别的实现机制"><a href="#4-隔离级别的实现机制" class="headerlink" title="4. 隔离级别的实现机制"></a>4. 隔离级别的实现机制</h2><ol><li>串行化：加读写锁</li><li>可重复读：启动事务时生成一个Read View（快照）。</li><li>读提交：每个语句执行前生成一个Read View。</li></ol><h2 id="5-开启事务命令"><a href="#5-开启事务命令" class="headerlink" title="5. 开启事务命令"></a>5. 开启事务命令</h2><ol><li>begin/start transaction：在执行该命令后执行增删改查的SQL语句时才真正启动事务。</li><li>start transaction with consistent snapshot：立即启动事务。</li></ol><h2 id="6-Read-View"><a href="#6-Read-View" class="headerlink" title="6. Read View"></a>6. Read View</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ol><li>字段结构：<ol><li>m_ids：创建Read View时当前数据库中活跃事务（启动但没提交）的事务id列表。</li><li>min_trx_id：m_ids的最小值。</li><li>max_trx_id：创建Read View时当前数据库中应该给下一个事务的id值，即全局最大事务id值+1.</li><li>creator_trx_id：当前事务id。</li></ol></li><li>聚簇索引记录的隐藏列：<ol><li>trx_id：<strong>记录改动该记录的事务id</strong>。</li><li>roll_pointer：每次对某条记录改动时，会将旧版本记录写入到undo日志中。该指针指向上一个旧版本记录。</li></ol></li><li>一个事务访问记录时，存在以下几种情况：（trx_id不是访问记录的事务id，而是产生这条记录的事务id）<ol><li>trx_id &lt; min_trx_id：该版本的记录是在创建Read View前已提交的事务生成，所以该版本记录对当前事务可见。</li><li>trx_id &gt;= max_trx_id：该版本的记录是在创建Read View后才启动的事务生成，所以该版本记录对当前事务不可见。</li><li>trx_id在之间：<ol><li>trx_id在m_ids里：生成该版本记录的活跃事务没有提交，所以不可见。</li><li>trx_id不在m_ids里：已被提交，可见。</li></ol></li><li>如果不可见，需要沿着roll_pointer找到最近一条可见的记录。</li></ol></li><li>这种通过版本链控制并发事务访问同一记录的行为就叫MVCC多版本并发控制。</li></ol><h1 id="4-锁篇"><a href="#4-锁篇" class="headerlink" title="4. 锁篇"></a>4. 锁篇</h1><h2 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1. 全局锁"></a>1. 全局锁</h2><p>flush tables with read lock</p><ol><li>作用：阻塞其他线程的增删改数据、更改表结构的操作。</li><li>应用场景：全库逻辑备份。</li><li>缺点：如果数据库过大，备份耗时过长，会造成业务停滞。</li><li>改进：可重复读级的隔离级别可以在备份期间对数据操作。</li></ol><h2 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2. 表级锁"></a>2. 表级锁</h2><p>表锁和行锁满足读读共享、读写互斥、写写互斥。</p><h3 id="1-表锁"><a href="#1-表锁" class="headerlink" title="1. 表锁"></a>1. 表锁</h3><p>lock tables t_xxx read/write</p><p>作用：除了限制别的线程读写，也会限制本线程读写。会话退出时自动释放所有表锁。</p><h3 id="2-元数据锁MDL"><a href="#2-元数据锁MDL" class="headerlink" title="2. 元数据锁MDL"></a>2. 元数据锁MDL</h3><p>对数据库表进行操作时会自动添加，在事务提交后释放。CRUD操作时加MDL读锁，结构变更操作时加MDL写锁。</p><p>缺点：申请MDL锁的操作会形成队列，队列中写锁优先级高于读锁，导致一旦出现MDL写锁等待，会阻塞该表后续所有CRUD操作。</p><h3 id="3-意向锁"><a href="#3-意向锁" class="headerlink" title="3. 意向锁"></a>3. 意向锁</h3><ol><li>作用：快速判断表里是否有记录被加锁。</li><li>应用场景：在使用InnoDB引擎的表里对某些记录加共享/独占锁前，需要先在表级别加上意向共享/独占锁。</li><li>说明：意向共享/独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁之间发生冲突。由于在对记录加独占锁前会先加上表级别的意向独占锁，那么后续加独占锁时直接查该表是否有意向独占锁，就可以避免遍历表里的记录查看是否存在独占锁。</li></ol><h3 id="4-自增锁"><a href="#4-自增锁" class="headerlink" title="4. 自增锁"></a>4. 自增锁</h3><ol><li>作用：如果不指定主键，在插入数据时自动给主键赋值递增的数。</li><li>应用场景：在插入数据时加一个表级别的自增锁，然后为被AUTO_INCREMENT修饰的字段赋值递增的数，等插入语句执行完后释放锁。保证插入数据时不会有其他事务插入，从而使得主键连续递增。</li><li>改进：给AUTO_INCREMENT赋值后立刻释放<ol><li>问题：搭配binlog的日志格式是statement一起使用时，在主从复制的场景中会发生数据不一致的问题。线程A创建完表后，线程B创建一个相同结构的表，然后A插入新的数据，B则插入A的表中存在的数据。B插入的数据id会不连续。如果主库发生这种情况，同样的语句拿去从库执行，且从库按照顺序执行语句的话，主从库会发生数据不一致。</li><li>解决：binlog_format = 2，在binlog里记录的是主库分配的自增值，拿去从库执行时自增值跟主库一样。</li></ol></li></ol><h2 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3. 行级锁"></a>3. 行级锁</h2><p>必须要有索引才能实现。</p><p>MyISAM不支持。</p><p>查询时对记录加锁会成为锁定读。</p><p>select语句后添加lock in share mode加共享锁（S锁），添加for update加独占锁（X锁），S型锁间可兼容，其他都不兼容。</p><h3 id="1-记录锁"><a href="#1-记录锁" class="headerlink" title="1. 记录锁"></a>1. 记录锁</h3><p>锁住一条记录。</p><h3 id="2-间隙锁"><a href="#2-间隙锁" class="headerlink" title="2. 间隙锁"></a>2. 间隙锁</h3><p>只存在于可重复读隔离级别（为了解决幻读），是开区间。</p><ol><li>作用：锁住一个范围内的记录，解决可重复度级别下的幻读现象。</li><li>说明：间隙锁的X锁与S锁都是兼容的，因为间隙锁只是为了防止区间被插入。</li></ol><h3 id="3-临键锁"><a href="#3-临键锁" class="headerlink" title="3. 临键锁"></a>3. 临键锁</h3><p>记录锁+间隙锁，是左开右闭区间。</p><p>如果只使用记录锁或间隙锁就能防止幻读，临键锁就会退化成该种锁。</p><p><strong>如果用二级索引进行锁定读查询，除了对二级索引加锁之外，还会对查询到的记录的主键索引项加记录锁。</strong></p><ol><li>作用：锁定一个范围，并且锁定记录本身，其他事务既不能在范围内插入记录，也不能修改范围内的记录。</li><li>说明：因为临键锁包含记录锁，所以X锁与S锁、X锁与X锁之间是不兼容的，但是如果区间一端为无穷，则两个事务可以同时持有这个区间的临键锁，因为无穷不是一个真实的记录。</li><li>唯一索引等值查询：如果只使用其中一种锁就能避免幻读，临键锁就会退化成该种锁。<ol><li>如果查询的记录存在，在索引树上定位到该条记录后，将该记录的索引中的临键锁退化成记录锁。<ol><li>如果其他事务插入等值的索引，因为主键冲突导致无法插入。</li><li>加了记录锁导致其他事务无法删除该记录。</li></ol></li><li>如果查询的记录不存在，在索引树找到第一条大于该查询条件的记录后，将该记录的索引中的临键锁退化成间隙锁。<ol><li>间隙锁的范围为第一条大于该查询条件的记录与该记录的上一条（开区间）。</li><li>因为查询的记录不存在，所以不能对不存在的记录加记录锁，但是需要保证下次相同查询的结果仍然是不存在，所以需要加间隙锁防止插入。</li></ol></li></ol></li><li>唯一索引范围查询：对每一个扫描到的索引加临键锁，范围为第一条大于该查询条件的记录与该记录的上一条（左开右闭）。<ol><li>大于等于的范围查询，因为存在等值查询，所以等值查询的记录存在表中时就会退化成记录锁。</li><li>小于或小于等于的范围查询<ol><li>条件值的记录不在表中时，扫描到终止范围的查询记录（不满足条件的第一条记录）时，该记录的索引退化成间隙锁。</li><li>条件值的记录在表中时，如果是小于的范围查询，扫描到终止范围的查询记录（不满足条件的第一条记录）时，该记录的索引退化成间隙锁。</li></ol></li></ol></li><li>非唯一索引等值查询：同时对两个索引加锁，但是只对满足查询条件的记录的主键索引加锁。<ol><li>查询的记录存在时，扫描到第一个不符合条件的二级索引记录。<ol><li>在扫描过程中对扫描到的二级索引记录加临键锁。</li><li>第一个不符合条件的二级索引记录退化成间隙锁：避免其他事务插入查询条件相同、主键大于当前查询记录的最大主键的记录，根据2.3的判断规则，如果没有这个间隙锁，是可以成功插入的，从而造成幻读。</li><li>在符合查询条件的记录的主键索引上加记录锁。</li></ol></li><li>查询的记录不存在时，扫描到第一个不符合条件的二级索引记录。<ol><li>该二级索引退化成间隙锁，范围为相邻两条记录组成的条件存在的区间（开区间）。如果没法扫描到第一个不符合条件的记录，即扫描到了表末尾，则不会退化。</li><li>不存在满足查询条件的记录，所以不会对主键索引加锁。</li><li>当其他事务需要插入记录时，需要考虑插入记录的主键值，以及插入位置的下一条记录是否有间隙锁，从而判断是否插入成功。</li></ol></li><li>由于索引不唯一，所以在边界插入时，要判断两个索引的大小关系，来决定是否能插入。</li></ol></li><li>非唯一索引范围查询：<strong>不会退化</strong></li><li>不加索引的查询：<strong>扫描时全表扫描，每一条记录的索引上都会加临键锁，相当于锁住全表</strong>。但是，有时候即使加索引，如果优化器优化成了全表扫描，依然会锁住全表。</li></ol><h3 id="4-插入意向锁"><a href="#4-插入意向锁" class="headerlink" title="4. 插入意向锁"></a>4. 插入意向锁</h3><ol><li>作用：判断插入位置是否被其他事务加了间隙锁，如果有则插入操作被阻塞直到拥有间隙锁的事务提交，在此期间生成插入意向锁，表明有事务想在区间内插入新记录，但是处于等待状态（锁状态为等待，只有锁状态为正常才代表事务成功获取到了锁）。</li><li>说明：插入意向锁实际并不是意向锁，而是特殊的行级别间隙锁。</li><li>与间隙锁的区别：<ol><li>插入意向锁只锁住一个点</li><li>不能与其他事务的间隙锁共存</li></ol></li></ol><h2 id="4-Insert语句加行级锁过程"><a href="#4-Insert语句加行级锁过程" class="headerlink" title="4. Insert语句加行级锁过程"></a>4. Insert语句加行级锁过程</h2><ol><li>正常执行不会生成锁结构，靠聚簇索引记录自带的trx_id隐藏列来作为隐式锁保护记录。</li><li>隐式锁：当事务需要加锁时，如果该锁不可能发生冲突，InnoDB会跳过加锁环节。为了减少锁的数量，提高系统整体性能。</li><li>隐式锁转换成显式锁场景：<ol><li>记录之间加有间隙锁。</li><li>Insert的记录和已有记录存在唯一键冲突：插入失败，对该条记录上S锁。<ol><li>主键重复：<ol><li>隔离级别为可重复度：插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加S型记录锁。</li></ol></li><li>唯一二级索引列重复：<ol><li>插入新记录的事务会给已存在的二级索引列重复的二级索引记录添加S型临键锁。</li></ol></li><li>场景：两个事务执行相同的insert语句添加重复的二级索引<ol><li>事务A先插入，插入成功，对应的唯一二级索引记录被隐式锁保护，但没有实际的锁结构。</li><li>事务B插入同样二级索引的记录，试图获取S型临键锁，但事务A并未提交，且该隐式锁会变为显式锁，类型为X型记录锁，所以事务B获取锁遇到锁冲突，被阻塞。</li></ol></li></ol></li></ol></li></ol><h2 id="5-避免死锁"><a href="#5-避免死锁" class="headerlink" title="5. 避免死锁"></a>5. 避免死锁</h2><p>死锁一般的出现原因：间隙锁相容导致不同事物持有同一范围的间隙锁，然后这些事务同时插入记录至该范围内，导致插入意向锁跟间隙锁冲突。</p><p>死锁的必要条件：互斥、占有且等待、不可剥夺、循环等待。</p><ol><li>设置事务等待超时时间，超过时间回滚。</li><li>开启主动死锁检测。</li></ol><h2 id="6-乐观锁"><a href="#6-乐观锁" class="headerlink" title="6. 乐观锁"></a>6. 乐观锁</h2><p>先进行业务操作，最后实际更新数据时检查数据是否被更新过，如果数据在业务操作期间被更新过则回滚业务操作，否则更新数据。</p><p>回滚操作十分耗费资源，只适用于读操作远大于写操作，且写操作竞争不激烈时使用。</p><h3 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h3><p>如果待写的内存值等于预期值，则更新为新值，否则不操作。</p><p>一般CAS操作会自旋。</p><p>CAS是由CPU支持的原子操作，其原子性由硬件层面保证。</p><p>缺点1：CAS只通过判断值相等来确认是否发生变化，但是在如栈的结构中，栈顶值相等，但数据可能已经发生变化。</p><p>解决：引入版本号，每次值发生变化版本号+1，CAS还需要判断版本号是否相等。</p><p>缺点2：高并发时CAS需要一直尝试，CPU开销大。</p><p>解决：重试一定次数后失败退出；高并发尽量不用CAS乐观锁。</p><p>限制：CAS只能保证单个内存值操作的原子性，而原子性不代表线程安全；多个变量无能为力。</p><h1 id="5-日志篇"><a href="#5-日志篇" class="headerlink" title="5. 日志篇"></a>5. 日志篇</h1><h2 id="1-日志类型"><a href="#1-日志类型" class="headerlink" title="1. 日志类型"></a>1. 日志类型</h2><ol><li>undo log回滚日志：存储引擎层生成的日志，实现事务中的原子性，主要用于事务回滚和MVCC。</li><li>redo log重做日志：存储引擎层生成的日志，实现事务的持久性，主要用于掉电等故障恢复。</li><li>binlog归档日志：Server层生成的日志，主要用于数据备份和主从复制。</li></ol><h2 id="2-Undo-log"><a href="#2-Undo-log" class="headerlink" title="2. Undo log"></a>2. Undo log</h2><ol><li><p>作用：</p><ol><li>回滚：MySQL会在执行每条语句时隐式开启事务，执行完毕自动提交。如果事务在执行过程中提交之前，MySQL崩溃，或者不打算提交了，就可以利用undo log进行回滚。</li><li>MVCC</li></ol></li><li><p>记录中的结构：一条记录的每次更新操作产生的undo log格式都有一个roll_pointer指针和trx_id事务id，通过指针将undo log串成版本链。</p></li><li><p>事务回滚工作方式：</p><ol><li>插入一条记录时，记录其主键值，回滚时查找主键值对应的记录删除。</li><li>删除一条记录时，记录该记录的内容，回滚时将这些内容组成的记录插入。</li><li>更新一条记录时，记录被更新的列旧值，回滚时再更新为旧值。</li><li>回滚：扫描日志，找出所有已开始但没有提交的事务。针对这些事务，使用undo log回滚。</li></ol></li><li><p>应用：MVCC（ReadView + undo log）：</p><ol><li>事务通过对比Read View里的字段与trx_id的字段，如果不满足可见行，就顺着undo log的版本链向上找到满足可见性的记录。</li></ol></li></ol><h2 id="3-Buffer-Pool"><a href="#3-Buffer-Pool" class="headerlink" title="3. Buffer Pool"></a>3. Buffer Pool</h2><ol><li>作用：<ol><li>读取数据时如果数据在Buffer Pool中，客户端直接读取其中的数据。</li><li>修改数据时如果数据在Buffer Pool中，直接修改Buffer Pool中数据所在的页，然后设置为脏页。</li></ol></li><li>结构：MySQL启动时，InnoDB会为Buffer Pool申请一片连续的内存空间，按照默认16KB大小划分出一个个页，称为缓存页。<ol><li>Undo页：开启事务后InnoDB层更新记录前要记录undo log，undo log写入Buffer Pool中的Undo页面。</li></ol></li><li>跟操作系统类似，查询一条记录是将整个页面加载到Buffer Pool中。</li></ol><h2 id="4-Redo-log"><a href="#4-Redo-log" class="headerlink" title="4. Redo log"></a>4. Redo log</h2><p>Buffer Pool是基于内存的，可能由于断电导致数据丢失问题。</p><ol><li><p>WAL技术：更新记录时InnoDB引擎先更新内存，然后将对该页的修改以redo log的形式记录下来，更新完毕；后续在适当的时候，后台线程将缓存在Buffer Pool的脏页刷新到磁盘。</p></li><li><p>实现方式：Redo log记录的是：对X表空间中Y数据页Z偏移量的位置做了A更新。事务提交时只需要先持久化Redo log到磁盘，系统崩溃时因为Redo log已持久化，所以可以根据Redo log的内容恢复数据。</p></li><li><p>修改Buffer Pool中的Undo页面也会记录对应的Redo log。</p></li><li><p>redo log也需要先写入redo log buffer中，后续再写到Page Cache、持久化到磁盘。</p></li><li><p>重做：扫描日志，找出所有已提交的事务。针对这些事务，使用redo log重做。</p></li><li><p>好处：</p><ol><li>实现事务的持久性，让MySQL有crash-safe的能力。</li><li>将写操作从随机写变成顺序写，效率更高。写入redo log是追加操作，是顺序写；写入数据需要先寻找数据位置，是随机写。</li></ol></li><li><p>刷盘时机：</p><ol><li><p>MySQL正常关闭。</p></li><li><p>redo log buffer记录写入量大于该buffer内存空间一半。</p></li><li><p>每隔1s。后台线程将redo log buffer写入page cache后调用fsync刷盘。</p></li><li><p>事务提交时。</p></li><li><p>innodb_flush_log_at_trx_commit</p><ol><li>0：事务提交时不主动写入磁盘</li><li>1：事务提交时直接持久化到磁盘</li><li>2：事务提交时写入redo log文件（写入文件系统的Page Cache）</li><li>数据安全性：1 &gt; 2 &gt; 0</li><li>写入性能：0 &gt; 2 &gt; 1</li></ol></li></ol></li><li><p>写满：</p><ol><li>重做日志文件组：由多个redo log文件组成，以循环写的方式工作在多个文件间切换，类似于RingBuffer。write post表示redo log当前记录写到的位置，check point表示当前要擦除的位置。</li><li>如果write post追上了check point，代表redo log文件已满，MySQL会被阻塞，停下来将Buffer Log中的脏页刷新到磁盘中，并标记redo log中哪些记录可以被擦除，然后擦除这些记录腾出空间，check point向后移动。</li></ol></li></ol><h2 id="5-binlog"><a href="#5-binlog" class="headerlink" title="5. binlog"></a>5. binlog</h2><ol><li><p>作用：MySQL完成一条<strong>更新</strong>操作后，Server层生成一条binlog，等之后事务提交，会将该事务执行过程中产生的所有binlog写入binlog文件。binlog文件不会记录查询类的操作。</p></li><li><p><strong>为什么有binlog还要redo log</strong>：server层和存储引擎层是解耦的。MySQL最初自带的引擎是MyISAM，但是它没有crash-safe能力，binlog只能用来归档。InnoDB作为插件形式引入MySQL，自带redo log实现crash-safe能力。</p></li><li><p>格式：逻辑日志</p><ol><li>STATEMENT（默认）：记录逻辑操作，即SQL语句。有动态函数问题（uuid、now），主库执行结果与从库并不一致。</li><li>ROW：记录行数据最终被修改成什么样。每行数据变化的结果都会被记录（如果批量update，每一更新的行都会记录一条），导致binlog文件过大。</li><li>MIXED：判断语句是否可能引起数据不一致，选用STATEMENT或ROW模式。</li></ol></li><li><p>主从复制：记录MySQL上所有变化并以二进制形式保存在磁盘上（binlog），复制时将binlog中的数据从主库传输到从库。</p><ol><li><p>异步：主库上执行事务操作的线程不会等待复制binlog的线程同步完成。</p></li><li><p>过程：</p><ol><li>主库收到请求，先写入binlog再提交事务，更新存储引擎中的数据，之后返回给客户端操作成功的响应。</li><li>从库创建一个专门的I/O线程，连接主库的log dump线程来接收binlog日志，再将binlog信息写入relay log的中继日志里，返回给主库复制成功的响应。</li><li>从库创建一个回访binlog的线程，去读relay log中继日志，然后回放binlog更新存储引擎中的数据。</li></ol></li><li><p>复制之后，可以写数据只写主库，读数据只读从库，写数据不影响读请求执行。</p></li><li><p>模型：</p><ol><li>同步复制：主库提交事务的线程要等到所有从库的复制成功响应，之后才返回客户端结果。性能差，要等所有从库复制完；可用性差，任何一个从库出问题都会影响业务。</li><li>异步复制：不等待就返回结果。一旦主库宕机，数据会发生丢失。</li><li>半同步复制：只需要一部分复制成功就返回结果。</li></ol></li></ol></li><li><p>刷盘：binlog先写到Server层中的binlog cache（每个线程一个），在事务提交时再写到binlog文件中（page cache，之后通过fsync持久化到磁盘）。一个事务的binlog不能被拆开。由sync_binlog控制刷盘时机：</p><ol><li>0：每次提交事务只write不fsync，持久化交由操作系统决定。</li><li>1：每次提交事务都会write然后fsync。</li><li>N：累计N个事务后fsync。</li></ol></li></ol><h2 id="6-redo-log-amp-binlog"><a href="#6-redo-log-amp-binlog" class="headerlink" title="6. redo log &amp; binlog"></a>6. redo log &amp; binlog</h2><ol><li>适用对象：<ol><li>binlog：Server层实现，数据库层面，所有存储引擎都能用。</li><li>redo log：InnoDB引擎作为存储引擎层实现，事务层面。</li></ol></li><li>文件格式：<ol><li>binlog：逻辑日志<ol><li>STATEMENT（默认）：记录逻辑操作，即SQL语句。有动态函数问题（uuid、now），主库执行结果与从库并不一致。</li><li>ROW：记录行数据最终被修改成什么样。每行数据变化的结果都会被记录（如果批量update，每一更新的行都会记录一条），导致binlog文件过大。</li><li>MIXED：根据情况选用STATEMENT与ROW模式</li></ol></li><li>redo log：物理日志<ol><li>记录在某个数据页进行了什么修改，即在X表空间中Y数据页Z偏移量的位置做了A更新。</li></ol></li></ol></li><li>写入方式：<ol><li>binlog：追加写，写满了就创建新文件而不会覆盖。</li><li>redo log：循环写，会覆盖。</li></ol></li><li>用途：<ol><li>binlog：备份恢复、主从复制。</li><li>redo log：故障恢复</li></ol></li></ol><h2 id="7-小结：update语句的执行过程"><a href="#7-小结：update语句的执行过程" class="headerlink" title="7. 小结：update语句的执行过程"></a>7. 小结：update语句的执行过程</h2><p>UPDATE t_user SET name = ‘xx’ WHERE id = 1</p><ol><li>cache：执行器调用存储引擎接口，通过主键索引树获取id=1记录<ol><li>如果该行所在的数据页在buffer pool中，直接返回给执行器。</li><li>否则从磁盘读到buffer pool中再返回记录。</li></ol></li><li>检查更新：执行器得到聚簇索引记录，看更新前后是否一样，一样则不再进行后续更新，否则将更新前后的记录都当作参数传给InnoDB层</li><li>undo log：开启事务，InnoDB层更新记录前先记录undo log，写入Buffer Pool中的Undo页面，在内存修改该Undo页面后记录对应的redo log。</li><li>redo log：InnoDB层开始更新记录，先更新内存，然后将记录写入redo log里。一条记录更新完毕</li><li>binlog：一条更新语句执行完成后，开始记录该语句对应的binlog。</li><li>两阶段提交。</li></ol><h2 id="8-两阶段提交"><a href="#8-两阶段提交" class="headerlink" title="8. 两阶段提交"></a>8. 两阶段提交</h2><ol><li>原因：在binlog和redo log刷盘的中间MySQl宕机，造成其中一个刷盘成功而另一个没有，会造成主从架构中主从库数据不一致。</li><li>两阶段：准备阶段与提交阶段。</li><li>简单概括：redo log准备写，然后确认bin log已提交后自己再提交。</li><li>具体过程：使用内部XA事务，由binlog作为协调者，存储引擎作为参与者。<ol><li>prepare：将XID（内部XA事务ID）写入到redo log，将redo log对应的事务状态设置为prepare，然后将redo log持久化。</li><li>commit：将XID写入binlog，然后将binlog持久化。调用引擎的提交事务接口，将redo log状态设置为commit，该状态不需要持久化到此案，只需要write到文件系统中的page cache。</li></ol></li><li>异常重启情况：MySQL重启后按顺序扫描redo log文件，如果碰到处于prepare状态的redo log，就拿着XID去binlog查看是否存在<ol><li>如果binlog中没有，说明redo log完成刷盘但binlog没有，回滚事务。</li><li>如果binlog中有，说明两个log都已完成刷盘，提交事务。</li></ol></li><li>redo log可以在事务没提交前持久化到磁盘，但是binlog必须在事务提交后才能持久化到磁盘。</li><li>问题：<ol><li>磁盘I/O次数高：每个事务提交都会进行两次刷盘(fsync)。<ol><li>sync_binlog = 1表示每次提交事务都会将binlog cache持久化到磁盘。</li><li>innodb_flush_log_at_trx_commit = 1表示每次提交事务都将redo log buffer持久化到磁盘。</li></ol></li><li>锁竞争激烈：只能保证单事务两个日志内容一致，但不能保证多事务两者提交顺序一致，所以还需要加一个锁保证提交的原子性。</li></ol></li></ol><h2 id="9-组提交"><a href="#9-组提交" class="headerlink" title="9. 组提交"></a>9. 组提交</h2><p>多个事务提交时将多个binlog刷盘操作合并成一个。prepare阶段不变，将commit阶段拆分成三个过程。</p><ol><li>commit：<ol><li>flush：多个事务按进入顺序将binlog从cache写入文件。用于支撑redo log的组提交。</li><li>sync：对binlog文件fsync。用于支持binlog的组提交。</li><li>commit：各个事务按顺序InnoDB commit。</li><li>每个阶段都有一个队列，且有锁进行保护。第一个进入队列的事务成为leader，领导所在队列所有事务并负责整队操作，完成后通知队内其他事务操作结束。锁的粒度减小到队列，使得多个阶段可以并发执行。</li></ol></li><li>MySQL5.7及以上有redo log组提交，在prepare阶段不再让事务各自执行redo log刷盘操作，而是推迟到flush阶段之中binlog写入文件前，由leader一次性将同组的redo log刷盘。</li></ol><h2 id="10-优化MySQL的磁盘I-O"><a href="#10-优化MySQL的磁盘I-O" class="headerlink" title="10. 优化MySQL的磁盘I/O"></a>10. 优化MySQL的磁盘I/O</h2><ol><li>组提交两个参数，延迟binlog刷盘时机<ol><li>binlog_group_commit_sync_delay = N表示等待Nms后，直接调用fsync将binlog持久化。</li><li>binlog_group_commit_sync_no_delay_count=N表示如果队列中事务数达到N，就忽略delay直接刷盘。</li></ol></li><li>sync_binlog=N，表示每次提交事务都write，但累计N个才刷盘，但是主机掉电会丢失N个事务的binlog日志。</li><li>innodb_flush_log_at_trx_commit=2，表示每次事务提交都只将redo log buffer中的log写到文件中，同样有主机掉电的风险。</li></ol><h1 id="6-内存篇"><a href="#6-内存篇" class="headerlink" title="6. 内存篇"></a>6. 内存篇</h1><h2 id="1-Buffer-Pool"><a href="#1-Buffer-Pool" class="headerlink" title="1. Buffer Pool"></a>1. Buffer Pool</h2><ol><li>默认配置为128MB，按页划分，每页大小默认16KB。在MySQL启动时，InnoDB会为Buffer Pool申请一片连续的内存空间并划分页，此时这些页都是空闲的，随着程序运行才有磁盘上的页被缓存。所以，MySQL刚启动时使用的虚拟内存很大，但是物理内存却很小，因为只有当这些虚拟内存被访问时，操作系统才会触发缺页中断，将虚拟地址与物理地址建立映射关系。</li><li>缓存内容：数据页、索引页、插入缓存页、undo页、自适应哈希索引、锁信息。</li><li>Buffer Pool为每一个缓存页创建了一个控制块，信息包括缓存页的表空间、页号、缓存页地址、链表节点等。控制块放在Buffer Pool最前面，之后有一块碎片空间（剩余的空间不足以分配一对控制块和缓存页），然后是缓存页。<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></li><li>内存管理：<ol><li>空闲页：将空闲缓存页的控制块作为链表节点连接，成为Free链表。Free链表有一个头节点，包含链表的头节点地址、尾节点地址以及链表中节点数量等信息。</li><li>脏页：Flush链表。</li><li>提高缓存命中率：young-old LRU算法+进入young区域条件判断。</li><li>脏页刷新：<ol><li>redo log日志满</li><li>Buffer Pool空间不足时需要淘汰一部分数据页，如果淘汰到脏页</li><li>MySQL认为空闲时后台线程定期将适量脏页刷新</li><li>MySQL正常关闭前刷新所有脏页</li></ol></li></ol></li></ol><h1 id="7-查漏补缺"><a href="#7-查漏补缺" class="headerlink" title="7. 查漏补缺"></a>7. 查漏补缺</h1><h2 id="1-分库分表"><a href="#1-分库分表" class="headerlink" title="1. 分库分表"></a>1. 分库分表</h2><p>原因：</p><ul><li>单库太大：数据库里的表太多，所在服务器磁盘空间装不下，且IO次数多CPU繁忙。</li><li>单表太大：一张表字段太多、数据太多。每次需要加载、查询大量数据。</li></ul><p>场景：</p><ul><li>单表数据达到千万级，数据库读写速度缓慢。</li><li>数据库中的数据占用空间大，备份时间长。</li><li>应用并发量大。</li></ul><p>常用算法：哈希、范围、地理位置、以上混合。</p><h3 id="2-主从架构"><a href="#2-主从架构" class="headerlink" title="2. 主从架构"></a>2. 主从架构</h3><p>主库读写，从库只负责读，从库与主库同步更新数据。</p><p>问题：</p><ul><li>写操作拓展困难，因为需要保证多个主库与主从一致性。</li><li>复制延时。</li><li>表变大，缓存命中率下降，导致查询性能降低。</li></ul><h3 id="3-分表"><a href="#3-分表" class="headerlink" title="3. 分表"></a>3. 分表</h3><p>垂直分表：拆分字段。一般把不常用的、数据较大、长度较长的字段拆分。</p><p>水平分表：按照某一字段值进行分割（哈希等）。这些表还在同一个库中，库级别的数据表操作还是有IO瓶颈，而且随着数据增加还需要再切分，所以不建议使用。</p><h3 id="4-分库"><a href="#4-分库" class="headerlink" title="4. 分库"></a>4. 分库</h3><p>垂直分库：垂直分表后，如将不常用的字段拆分表放在单独数据库中。不同数据库放在不同服务器上。</p><p>水平分库：将单张表的数据切分到多个服务器上。能有效缓解单机和单库性能瓶颈压力，突破IO、连接数、硬件资源等的瓶颈，但是切分麻烦。</p><h3 id="5-分库分表的问题"><a href="#5-分库分表的问题" class="headerlink" title="5. 分库分表的问题"></a>5. 分库分表的问题</h3><ul><li>联合查询困难：两个相关联的表可能在不同数据库、服务器中。</li><li>需要支持分布式事务。需要自己编程支持，代码麻烦。</li><li>跨库join困难：无法join不同分库的表，导致可能需要多次查询、拷贝。</li><li>结果合并麻烦。</li><li>事务问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-计算机网络</title>
      <link href="/2022/11/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/11/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h1><h2 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h2><ul><li>物理层：在物理网络中传输数据帧。集线器。</li><li>数据链路层：数据的封帧和差错检测。交换机。</li><li>网络层：数据的路由、转发、分片。路由器。</li><li>传输层：端到端传输。TCP、UDP。</li><li>会话层：建立、管理和终止表示层实体之间的通信会话，为应用程序提供建立、维持会话的功能。RPC。</li><li>表示层：把数据转换成兼容另一个系统能识别的格式，即翻译成用户/计算机能看懂的格式。还有安全加密、压缩等功能。</li><li>应用层：给应用程序提供统一接口。</li></ul><p>与网络四层（应用层、传输层、网际层、网络传输层）的关系：</p><ul><li>七层是标准而非实现；四层是实现的应用模型</li><li>四层模型由七层模型简化合并而来</li></ul><p>分层的好处：</p><ul><li>耦合度低，方便更新维护的同时不影响其他层</li><li>灵活性高</li><li>能促进标准化工作</li></ul><h2 id="2-各层协议"><a href="#2-各层协议" class="headerlink" title="2. 各层协议"></a>2. 各层协议</h2><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><ul><li>HTTP超文本传输协议</li><li>HTTPS超文本传输安全协议</li><li>Telnet远程登录服务的标准协议<ul><li>建立在TCP上，通过一个终端登录到其他服务器。</li><li>缺点：所有数据均以明文形式发送。</li></ul></li><li>FTP文件传输协议。用并行的两条TCP连接，控制连接（端口21）与数据连接（端口20）。</li><li>TFTP简单文件传输协议</li><li>SMTP简单邮件传输协议（发送用）<ul><li>发送邮件</li><li>判断邮箱存在<ul><li>查询邮箱域名对应的SMTP服务器地址。</li><li>尝试与服务器建立连接。</li><li>连接成功后尝试向需要验证的邮箱发送邮件。</li><li>根据返回结果判断真实性。</li></ul></li></ul></li><li>POP3/IMAP邮件接收地协议（接收用）</li><li>DHCP动态主机配置协议<ul><li>客户端发起DHCP发现报文，使用UDP广播通信（因为客户端没有IP地址，也不知道DHCP服务器地址，没法建立连接），DHCP客户端传递给链路层，广播到所有网络设备。</li><li>DHCP服务器用DHCP提供报文响应，仍然使用广播。报文携带服务器提供可租约的IP地址、子网掩码、默认网关、DNS服务器以及租用期。</li><li>客户端收到多个服务器的提供报文，选择一个服务器，发送DHCP响应，回显配置的参数。</li><li>服务端用DHCP ACK报文回应，应答要求的参数。</li><li>客户端IP地址快到期时，客户端发送DHCP请求报文，服务器回复ACK/NACK报文表示是否同意租用。</li><li>广播需要服务器和客户端在一个局域网内，所以用DHCP中继代理中转。</li></ul></li><li>SSH：安全的网络传输协议。相较于Telnet，会对传输的数据加密。</li></ul><h3 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h3><p>TCP、UDP</p><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><ul><li>IP网际协议：定义数据传输的基本单元和格式，定义数据包的递交方法和路由选择</li><li>ICMP Internet控制报文协议：检测网路的连接状况，确保连线的准确性</li><li>RIP路由信息协议：使用条数衡量到达目标的路由距离</li><li>IGMP Internet组管理协议：实现组播、广播等通信</li></ul><h3 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h3><ul><li>ARP地址解析协议：根据IP地址获取MAC地址<ul><li>主机广播ARP请求，同个链路的设备收到ARP请求时拆开包查看，如果目标IP地址与自身一致，则将自己的MAC地址塞入ARP响应包返回给主机。</li></ul></li><li>RARP反向地址转换协议：根据MAC地址获取IP地址<ul><li>需要RARP服务器，在该服务器上注册设备的MAC地址与IP地址，然后RARP协议直接到服务器查询。</li></ul></li><li>PPP点对点协议：通过拨号或专线方式建立点对点连接发送数据</li></ul><h2 id="3-WWW万维网构建技术"><a href="#3-WWW万维网构建技术" class="headerlink" title="3. WWW万维网构建技术"></a>3. WWW万维网构建技术</h2><ol><li>HTML超文本标记语言</li><li>HTTP超文本传输协议</li><li>URL统一资源标识符：指定超文本文档所在地址</li></ol><h1 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2. HTTP"></a>2. HTTP</h1><h2 id="1-HTTP报文格式"><a href="#1-HTTP报文格式" class="headerlink" title="1. HTTP报文格式"></a>1. HTTP报文格式</h2><p>首部为名称-值的键值对。</p><p>每行以\r\n结束。（回车符+换行符）</p><h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1. 请求报文"></a>1. 请求报文</h3><p>第一行为请求行，包含请求方法、URL、协议版本</p><p>接下来多行都是请求头部，格式为“字段：值”。</p><p>一个空行分隔首部和内容主体。</p><p>最后是请求主体内容。</p><h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2. 响应报文"></a>2. 响应报文</h3><p>第一行为状态行，包含协议版本、状态码与描述</p><p>接下来多行都是响应头部，格式为“字段：值”。</p><p>一个空行分隔首部和内容主体。</p><p>最后是响应主体内容。</p><h2 id="2-HTTP缓存"><a href="#2-HTTP缓存" class="headerlink" title="2. HTTP缓存"></a>2. HTTP缓存</h2><p>可通过Cache-Control的no-store指令禁止缓存，no-cache指令强制确认缓存，即使用缓存必须向服务器确认效性而不允许直接用强制缓存。</p><p>HTTP缓存分为强制缓存与协商缓存。</p><p>强制缓存可以通过状态码200后是否有from disk cache判断，通过判断HTTP响应头部中的Cache-Control（相对时间，优先级高）和Expires（绝对时间）两个字段决定是否使用本地缓存。</p><p><strong>只有未能命中强制缓存时，才能发起带有协商缓存字段的请求</strong>。协商缓存响应状态码为304，表示与服务端协商后，通过协商结果判断是否用本地缓存。流程如图：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="协商缓存"></p><p>文字过程：</p><ol><li>浏览器第一次请求访问服务器资源时，服务器返回时在头部加上ETag唯一标识（根据请求的资源生成）</li><li>浏览器再次请求访问服务器该资源时，首先检查强制缓存是否过期<ol><li>如果没有过期，直接使用本地缓存</li><li>如果过期，在请求头部加上If-None-Match字段，该字段的值就是ETag唯一标识</li></ol></li><li>服务器再次收到请求后，根据If-None-Match值与请求资源的唯一标识比较：<ol><li>值相等，返回304且不返回资源</li><li>不相等，返回200且返回资源，并加上新的ETag</li></ol></li><li>浏览器如果收到304，则从本地缓存中加载资源，否则更新资源</li></ol><p>Etag基于文件唯一标识实现，而Last-Modified基于时间，所以Etag更能准确判断文件是否修改过。</p><p>Etag优先级高于Last-Modified的原因：</p><ol><li>即使没有修改文件内容，最后修改时间也可能改变。</li><li>有些文件的修改是1s内多次，而If-modified-since只能检测秒级粒度。</li><li>有些服务器不能精确获取最后修改时间。</li></ol><h2 id="3-HTTP1-1"><a href="#3-HTTP1-1" class="headerlink" title="3. HTTP1.1"></a>3. HTTP1.1</h2><p>相较于HTTP1.0</p><ul><li>连接方式：长连接改善了短连接造成的性能开销（HTTP1.0每次发送请求都要建立一次TCP连接）。Connection：Keep-Alive。</li><li>多了Host域，存放url。因为HTTP1.1时代一个物理主机上已经可以存在多个虚拟主机，且共享一个IP地址，要通过域名区分。</li><li>带宽优化：多了range域，支持只请求资源的某个部分。Content-Range中声明返回对象的偏移值和长度。服务器返回了该范围则返回206，防止Cache将响应误认为是完整对象。</li><li>多了100状态码。客户端可事先发送只带头域的请求，如果服务器因为权限拒绝，就返回401；如果接受就返回100，客户端可继续发送带实体的完整请求，在请求头包含Expect：100-continue。</li><li>缓存：引入Etag、If-None-Match等更多判断缓存是否过期的标准。</li></ul><p>1.1的特点</p><ol><li>优点：<ol><li><strong>简单</strong>：报文格式使用header+body，头部信息使用key-value，易于理解。</li><li><strong>可拓展性强</strong>：HTTP协议的每个组成部分都允许开发人员自定义，且允许第七层之下的层随意变化。</li><li><strong>应用广泛与跨平台</strong>。</li></ol></li><li>双刃剑：<ol><li><strong>无状态</strong>：服务器不需要额外信息记录状态，减轻压力；如果完成有关联的操作时很麻烦，需要借助Cookie技术，在第一次相应时附加Cookie信息，之后根据接收报文的Cookie信息判断是否关联。</li><li><strong>明文传输</strong>：方便阅读，从而方便调试工作；但是相当于信息裸奔，引发诸多<strong>不安全</strong>，如<strong>通信内容不完整、通信对象伪装、通信内容被窃听</strong>。</li><li><strong>队头阻塞</strong>：在同一个TCP连接中，如果先发送的HTTP请求没有响应，后面的HTTP请求也不会响应。<ol><li>HTTP请求和响应没有序号标识，无法关联乱序响应与请求，所以只能按序接收，导致后面的响应阻塞在缓冲区。</li><li>解决：多个并发TCP长连接，但是对服务器性能要求高。</li></ol></li></ol></li><li>特点：<ol><li>长连接/持久连接：只要任意一端没有明确提出断开连接，则保持TCP连接。</li><li>管道网络传输：允许连续发出报文而不必等待ACK；但是会造成响应端的队头阻塞，而且该功能默认关闭，实际上并没有使用。</li></ol></li><li>缺陷：高延迟<ol><li>并发连接有限</li><li>队头阻塞</li><li>HTTP头部巨大且重复（HTTP协议的无状态导致）</li><li>不支持服务器主动推送</li></ol></li></ol><h2 id="4-HTTPS"><a href="#4-HTTPS" class="headerlink" title="4. HTTPS"></a>4. HTTPS</h2><ol><li><p>特点：在TCP与HTTP层之间加入了SSL（Secure Socket Layer，安全套接字）/TLS（Transport Layer Security，安全传输层协议）安全协议，在三次握手后还需要进行SSL/TLS握手。HTTPS实现了信息加密（防窃听）、校验机制（防篡改）与身份证书（防冒充）。</p></li><li><p>SSL与TLS：TLS1.0是SSL3.0的升级版，没太大区别。</p></li><li><p>优点：</p><ol><li>信息加密：交互信息无法被窃听。</li><li>校验机制：无法篡改通信内容。</li><li>身份证书：无法伪造身份，并能证明报文完整。</li></ol></li><li><p>缺点：</p><ol><li>效率低：通信前必须进行TLS四次握手，存在握手时延。</li><li>部署成本高：购买CA证书；加解密计算占用CPU，需要高服务器数目或配置。</li></ol></li><li><p>SSL/TLS安全协议：使用了对称加密与非对称加密的混合加密。</p><ol><li>对称加密：双方用同一把密钥加密与解密。但是密钥会在交换过程中被窃取。</li><li>非对称加密：接收方生成公钥与私钥，将公钥发给发送方。公钥加密的消息只有私钥能解密。但是速度慢。因为对称加密主要用的位运算，非对称加密主要用大数乘法、大数模。</li></ol></li><li><p>混合加密——保证信息加密：</p><ol><li>接收方生成公钥a和私钥，并发送给发送方公钥a。</li><li>发送方生成临时密钥公钥b作为对称加密的公钥，使用公钥b加密发送的信息，使用公钥a加密公钥b，并打包发送。</li><li>接收方使用私钥解密得到公钥b，然后用公钥b解密得到信息。</li></ol></li><li><p>摘要算法+数字签名——防篡改：</p><ol><li>摘要算法：发送方计算内容的哈希值，加密并发送给接收方，接收方接收后计算内容的哈希值并与解密的内容对比是否一致。</li><li>数字签名：使用非对称加密，私钥加密公钥解密，来确保发送者是私钥持有者。</li></ol></li><li><p>数字证书——防伪造：</p><ol><li><p>CA（数字证书认证机构）。CA的公钥已经事先设置在操作系统中</p></li><li><p>流程：</p><ol><li>服务器将自己的公钥上传到CA。</li><li>CA打包持有者的公钥、用途、颁发者、有效时间等信息，计算Hash值进行摘要，并用私钥给Hash值加密，生成Certificate Signature，最后将其添加在文件证书上，形成数字证书。</li><li>客户端接收到服务端的数字证书后，先用CA的公钥（操作系统内置）解密签名，并与自己用相同Hash算法算出的Hash值对照确认身份，并获得服务器的公钥。</li><li>客户端使用服务器的公钥加密发送。</li><li>服务器解密。</li></ol></li><li><p>信任链：证书存在层级关系。如果收到的不是根证书，客户端会逐级向上请求证书，直到根证书，再从根证书逐级向下查询下级证书是否可信。</p></li><li><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p></li></ol></li></ol><h2 id="5-TLS四次握手——RSA算法"><a href="#5-TLS四次握手——RSA算法" class="headerlink" title="5. TLS四次握手——RSA算法"></a>5. TLS四次握手——RSA算法</h2><p>注意：每一次一端发送信息，另一端都会回复ACK表示确认收到，步骤里就没有详细说明了。</p><ol><li>第一次：<ol><li>Client Hello消息：客户端给出自己的TLS版本号、支持的密码套件列表与生成的随机数。</li></ol></li><li>第二次：<ol><li>Server Hello：服务器确认是否支持TLS版本号，并选择一个密码套件，生成一个随机数，返回Server Hello消息。密码套件的基本形式是“<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>”。</li><li>Server Certificate：服务器发送含有数字证书的Server Certificate给客户端。</li><li>Server Hello Done：表示本次打招呼完毕。</li></ol></li><li>第三次：客户端验证证书确认是否可信。客户端生成新的随机数，用服务器的RSA公钥加密并通过Client Key Exchange消息传递给服务器。服务器用RSA私钥解密得到随机数。双方使<strong>用三个随机数生成会话密钥</strong>，客户端共发送：<ol><li>Client Key Exchange：第三个随机数</li><li>Change Cipher Spec：加密通信算法改变通知，表示之后的信息都用会话密钥加密通信</li><li>Finished：握手结束通知，把之前所有内容的发生数据做个摘要，供对方校验（加密通信是否可用、握手途中是否被篡改）</li></ol></li><li>第四次：服务器算出会话密钥后，返回3的后两种消息，双方验证无误后握手正式完成。<ol><li>Change Cipher Spec：加密通信算法改变通知，表示之后的信息都用会话密钥加密通信</li><li>Finished：握手结束通知，把之前所有内容的发生数据做个摘要，供对方校验（加密通信是否可用、握手途中是否被篡改）</li></ol></li><li>后续都使用会话密钥加密通信。</li><li>缺陷：不支持前向保密：客户端使用服务端的公钥加密随机数，服务端用私钥解密。一旦服务器的私钥泄露，过去被第三方结果的所有TLS通讯密文都会被破解，进而获得过去的会话密钥，进而破解过去的会话信息。</li></ol><h2 id="6-TLS四次握手——ECDHE算法"><a href="#6-TLS四次握手——ECDHE算法" class="headerlink" title="6. TLS四次握手——ECDHE算法"></a>6. TLS四次握手——ECDHE算法</h2><p>注意：每一次一端发送信息，另一端都会回复ACK表示确认收到，步骤里就没有详细说明了。</p><ol><li>离散对数：当模数p是一个很大的质数时，即使知道底数a和真数b，在现有计算机的水平下几乎无法计算出离散对数。<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="离散对数"></li><li>发展历程：基于离散对数的DH算法，分为两种实现：static DH算法中一方私钥是静态的，这样会导致随着时间延长，黑客截获海量的密钥协商过程并暴力破解私钥；DHE算法中双方的私钥都随机临时生成，但是因为需要做大量乘法导致计算性能不佳。</li><li>原理：双方事先确定使用的椭圆曲线以及基点G；随机生成私钥d并与G相乘得到公钥Q；双方交换公钥，与自己的私钥相乘得到坐标x，y，x相同，即为共享密钥。</li><li>第一次：与RSA相同。</li><li>第二次：与RSA相似，但是选择ECDHE作为密钥协商算法。<ol><li>Server Hello：服务器确认是否支持TLS版本号，并选择一个密码套件，生成一个随机数，返回Server Hello消息。</li><li>Server Certificate：服务器发送含有数字证书的Server Certificate给客户端。</li><li>Server Key Exchange：服务器选择椭圆曲线、基点，生成随机数服务器私钥保留在本地，并计算出来服务器公钥。</li><li>Server Hello Done。</li></ol></li><li>第三次：客户端验证证书确认是否可信。客户端生成随机数客户端私钥，然后根据服务器选择的椭圆曲线参数，计算出客户端公钥，用Client Key Exchange发送给服务端。双方计算出x，并使用客户端随机数+服务器随机数+x生成会话密钥。后续与RSA相同。</li><li>第四次：与RSA相同。</li><li>不同：使用ECDHE算法，客户端可以不等服务端最后一次TLS握手就能提前发送加密的HTTP数据，节省了一个消息往返的时间。</li><li>前向安全性：每一次的私钥都是独立生成的。</li></ol><h2 id="7-TLS其他"><a href="#7-TLS其他" class="headerlink" title="7. TLS其他"></a>7. TLS其他</h2><p>TLS在实现上分为握手协议和记录协议两层：</p><ul><li>握手协议即为四次握手的过程</li><li>记录协议负责保护应用程序数据并验证其完整性和来源，对HTTP数据加密时使用。<ul><li>消息被分割成多个较短的片段，分别进行压缩</li><li>每个被压缩的片段加上消息认证码（通过哈希算法生成的MAC值）。MAC值用于识别篡改，同时为了防止重放攻击，还加上了片段的编码。</li><li>通过对称算法（会话密钥）加密。</li><li>加上由数据类型、版本号、压缩后长度等信息组成的报头，组成最终的报文数据。</li></ul></li></ul><p>中间人服务器攻击：截取握手信息并分别对客户端/服务端伪造服务端/客户端。但是需要用户接受中间人服务器的证书，而<strong>浏览器能识别出非法证书</strong>并提醒。</p><p>抓包工具：抓包工具类似中间人服务器攻击，但是先在客户端安装了其根证书，相当于抓包工具给自己创建了认证中心CA。</p><p>此外，可以通过双向认证来避免中间人截取。</p><h2 id="8-HTTP1-1优化"><a href="#8-HTTP1-1优化" class="headerlink" title="8. HTTP1.1优化"></a>8. HTTP1.1优化</h2><ol><li><p>尽量避免发送HTTP请求：缓存技术。</p></li><li><p>减少HTTP请求次数：</p><ol><li>减少重定向请求次数：将重定向工作交由代理服务器完成。</li><li>合并请求：将小图片拼成大图片、打包资源等。</li><li>延迟发送请求：进入页面时只获取用户能看到的页面资源。</li></ol></li><li><p>压缩：</p><ol><li>无损压缩：用在文本文件、代码文件、可执行文件中，去除换行符、空格之后用霍夫曼编码压缩（gzip等）。</li><li>有损压缩：用在多媒体数据。</li></ol></li></ol><h2 id="9-HTTPS优化"><a href="#9-HTTPS优化" class="headerlink" title="9. HTTPS优化"></a>9. HTTPS优化</h2><ol><li>硬件优化、软件优化：升级。</li><li>软件优化：Linux内核、OpenSSL。</li><li>协议优化：<ol><li>密钥交换算法优化：ECDHE</li><li>TLS优化：升级到1.3。<ol><li>把Hello和公钥交换合并成一个消息，将握手时间减少到1RTT。客户端在Hello消息中带上支持的椭圆曲线与对应的公钥，服务端选定一个曲线，回复时带上自己计算出的公钥。</li><li>减少密码套件，废除不支持前向安全的RSA与DH算法，防止降级攻击。</li></ol></li></ol></li><li>证书优化：<ol><li>传输：选择椭圆曲线（ECDSA）证书而不是RSA证书，因为在相同安全强度下ECC密钥长度远小于RSA。</li><li>验证：<ol><li>证书吊销列表CRL：CA定期更新维护被撤销信任的证书序号。实时性较差；随证书增多列表变大，下载速度变慢。</li><li>在线证书状态协议OCSP：向CA发送查询请求证书的有效状态。受制于网络状态与CA服务器繁忙。</li><li>OCSP Stapling：服务器向CA周期性查询证书状态，获得带有时间戳和签名的响应结果并缓存。</li></ol></li></ol></li><li>会话复用：<ol><li>Session ID：首次握手后用Session ID标识会话密钥。服务器内存压力大；客户端不一定连接到同一台服务器。</li><li>Session Ticket：服务器加密会话密钥作为Ticket发送给客户端缓存。不具备前向安全性；应对重放攻击困难。</li><li>Pre-shared Key：TLS1.3，只需要0RTT就能恢复会话。将Ticket与HTTP请求一同发送给服务端。同样有重放攻击危险。</li><li>应对重放攻击：设定合理的过期时间；只对安全的HTTP请求使用会话复用。</li></ol></li></ol><h2 id="10-HTTP2-0-Chrome默认的版本"><a href="#10-HTTP2-0-Chrome默认的版本" class="headerlink" title="10. HTTP2.0 Chrome默认的版本"></a>10. HTTP2.0 Chrome默认的版本</h2><ol><li>新特性：<ol><li>传输格式：从基于文本变为基于二进制。1.x以换行符作为纯文本分隔符，2将传输的信息分割为更小的消息和帧，并对其采用二进制格式编码。</li><li>多路复用：连接共享。每条Stream为一个请求，多个Stream共享一条连接，且不同Stream可以乱序到达，效率大大提高。<ol><li>HTTP1.1在没收到上一次的响应前没法进行下一步动作。</li></ol></li><li>头部压缩：避免重复header传输，减少包大小，提高效率。</li><li>服务端推送：把客户端需要的资源伴随index.html一起发送过去，省去客户端重复请求。</li></ol></li><li>HPACK算法头部压缩：压缩的是Frame帧数据，包括原HTTP1.1的头部和包体<ol><li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E5%A4%B4%E9%83%A8.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E5%A4%B4%E9%83%A8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="头部"></li><li>静态字典：为高频出现在头部的字符串和字段建立了一张静态表，使用huffman编码压缩（频率越高，huffman编码越短）。</li><li>动态字典：为不在静态表范围内的头部字符串构建，在发送完某字段数据后，双方同步更新动态表，从index=62开始添加，这样在下次发送只需要发送1个字节的index号。</li></ol></li><li>二进制帧：将响应报文划分为10种类型的帧，分为数据帧和控制帧，并采用二进制编码。<ol><li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="帧"></li><li>标志位携带简单的控制信息，如END_HEADERS表示头数据结束标志，END_Stream表示单方向数据发送结束，PRIORITY表示流的优先级。</li><li>流标识符标识该Frame属于哪个stream。</li><li>帧数据存放通过HPACK算法压缩过的HTTP头部和包体。</li></ol></li><li>并发传输：多个Stream复用一条TCP连接达到并发。<ol><li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Stream"></li><li>从大到小：<ol><li>一个TCP连接中有多个Stream</li><li>一个Stream里有多个Message，Message相当于HTTP1中的请求或相应，由HTTP头部和包体构成。</li><li>一条Message里包含多个Frame，它是HTTP2的最小单位，以二进制压缩格式存放HTTP1中的内容。HTTP1.1的首部信息封装到headers帧，request body封装到data帧。</li></ol></li><li>同一个HTTP请求与响应跑在一个Stream中，一个Frame由多个TCP报文构成。</li><li>不同Stream帧可以乱序发送，由帧头部的流标识符区分并有序组装，因此可以通过并发Stream实现并发请求；同一Stream内部的帧必须严格有序。</li><li>可以根据控制位对每个Stream设置不同优先级。</li><li>双方都可以建立Stream，客户端建立的Stream必须是奇数号，而服务端必须是偶数号。</li><li>通过Stream实现并发，在HTTP1.1中实现多少个并发Stream就要建立多少次TCP连接，而在HTTP2.0中只需要建立一次。</li></ol></li><li>主动推送资源：<ol><li>旧版本：浏览器收到html文件后，发现包含CSS样式表文件、PNG图片文件等文件时，还需要对每个文件发出一条请求，请求该资源。</li><li>问题：请求时延；收到资源前网页显示空白，影响用户体验。</li><li>主动推送：客户端访问HTML时，服务器可以主动推送CSS、PNG等文件。服务器通过PUSH_PROMISE帧传输HTTP头部，并通过Promised Stream ID字段告知客户端将会在哪个偶数号Stream中发送包体。</li></ol></li><li>特点：压缩算法、Stream并发、服务器主动推送</li><li>缺点：<ol><li>HTTP2基于TCP协议传递数据，TCP是字节流协议，必须保证收到的字节数据完整且连续，当前一个字节数据没有到达时，后收到的字节数据都会放在内核缓冲区，存在队头阻塞问题。即<strong>TCP丢包时，TCP中的所有Stream都要等待</strong>。</li><li>TCP与TLS的握手延迟。</li><li>网络迁移需要重新连接。</li></ol></li><li>与WebSocket：在消息推送上不如websocket<ol><li>2.0需要客户端发起请求后再附带推送，websocket不需要客户端请求就能推送。</li><li>2.0的推送内容放在浏览器缓存中，只有浏览器能感知；websocket可以拿到数据在代码中使用。</li><li>2.0连接不确定性会永远保持连接，websocket有onclose事件，在send不出消息时进行重连，对代码友好。</li></ol></li></ol><h2 id="11-HTTP3-0"><a href="#11-HTTP3-0" class="headerlink" title="11. HTTP3.0"></a>11. HTTP3.0</h2><ol><li><p>QUIC：基于UDP在应用层实现的协议。QUIC是传输层协议。</p><ol><li>无队头阻塞：底层UDP不关心数据包的顺序与丢失。为了保证可靠性，Stream中的一个数据包丢失了，该流的其他数据包无法被HTTP3读取直到QUIC重传丢失的报文；<strong>其他流的数据报文可以正常被读取</strong>。</li><li>更快的连接建立：QUIC内部包含TLS，在自己的帧里会携带TLS里的记录；QUIC使用的是TLS1.3，因此仅需1个RTT就可以同时完成连接建立与密钥协商；第二次连接时应用数据包可以和QUIC握手信息一起发送，达到0RTT。</li><li>连接迁移：通过头部的CID标识连接，双方在随机生成的CID列表上达成一致，列表上的CID映射到同一连接，切换环境时切换CID。（防止CID被窃取获得用户地址）迁移后双方都向对方发起路径验证，探测可达性。</li></ol></li><li><p>HTTP层</p><ol><li>帧头部：直接使用QUIC里的Stream，帧头部只有类型和长度两个字段。</li><li>头部压缩算法：QPACK<ol><li>静态表：扩大到91项</li><li>动态表：如果首次出现的请求丢包，后续收到请求时无法解码出HPACK头部；QUIC使用QPACK Encoder Stream传递键值对与QPACK Decoder Stream响应，进行动态表同步。</li></ol></li></ol></li></ol><h2 id="12-RPC远程过程调用"><a href="#12-RPC远程过程调用" class="headerlink" title="12. RPC远程过程调用"></a>12. RPC远程过程调用</h2><p>通过网络从远程计算机上请求服务，而不需要了解底层网络技术。简单来说，程序像调用本地方法一样调用远程方法。</p><ol><li>HTTP主要用于b(rowser)/s(erver)架构，而RPC主要用于c(lient)/s(erver)架构。因为之前的软件大部分作为客户端只需要跟自家的服务端建立连接，因此可以使用自家造的RPC协议，而浏览器需要访问不同公司的服务器，所以需要统一的标准，即HTTP。</li><li>两者区别：<ol><li>服务发现：找到服务对应的IP端口：HTTP通过DNS服务找IP地址，端口默认80（DNS也是一种服务发现）；RPC有专门的中间服务保存服务名和IP信息。</li><li>底层连接形式：都是建立长连接。HTTP通过keep alive保持连接并复用；RPC一般有连接池，复用连接。</li><li>传输消息：RPC采用体积更小的序列化协议保存结构体数据，因此性能比HTTP1.1更好一些。</li></ol></li></ol><h2 id="13-长轮询"><a href="#13-长轮询" class="headerlink" title="13. 长轮询"></a>13. 长轮询</h2><p>用于手机扫网页端二维码等场景。打开二维码时发送的HTTP请求增大超时延迟，在超时延迟内服务器只要收到扫码请求就立即返回给客户端网页，因此可以实现及时响应。</p><p>消息较少时使用，如果服务器想频繁主动推送大量消息，要用WebSocket。</p><h2 id="14-WebSocket"><a href="#14-WebSocket" class="headerlink" title="14. WebSocket"></a>14. WebSocket</h2><p>实现全双工连接。</p><ol><li>建立：在完成TCP握手与一次HTTP通信后，如果想建立WebSocket连接，就在HTTP header头中表示想升级成WebSocket协议，并附带一段随机生成的base64码。如果服务器支持升级，就用base64码用某个公开算法变成另一段字符串，同时带上101状态码（协议切换）返回给浏览器。浏览器使用同样的公开算法转换base64码来验证是否一致。</li><li>格式：<img src="https://img-blog.csdnimg.cn/img_convert/3a63a86e5d7e72a37b9828fc6e65c21f.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/3a63a86e5d7e72a37b9828fc6e65c21f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="WebSocket"></li><li>opcode：数据类型</li><li>payload长度：先读最开始的7位，如果是0-125表示payload全部长度；如果是126表示长度在126-65535之间，还会读取16bit；如果长度是127还会再读64bit。</li><li>使用场景：需要<strong>服务器和客户端频繁交互</strong>的场景，如游戏、网页聊天室、网页协同办公软件。</li><li>除了建立连接时通过http报文携带websocket升级信息外，工作时与http并没有关系。</li></ol><h2 id="15-GET与POST的区别"><a href="#15-GET与POST的区别" class="headerlink" title="15. GET与POST的区别"></a>15. GET与POST的区别</h2><p>本质实际上都是一样的，只是浏览器和客户端会对不同类型的HTTP包做出不同的限制，导致它们在应用过程中不同。</p><ol><li>操作：获取数据、修改数据</li><li>安全性：GET数据参数暴露在url中，安全性相对较低，POST把数据放在HTTP包体，相对安全</li><li>数据限制：GET最大为2K，POST理论上没有限制</li><li>GET请求会被浏览器主动缓存。</li><li>某些浏览器中POST会分请求头与数据两个数据包。</li><li>本质区别：GET幂等，而POST不是</li></ol><h2 id="16-DNS"><a href="#16-DNS" class="headerlink" title="16. DNS"></a>16. DNS</h2><p>域名解析服务器。</p><p>基于UDP实现，端口号为53。</p><p>查询方式：</p><ul><li>递归查询：如果询问的服务器上找不到对应IP地址，就由被询问的服务器发起下一步查询。</li><li>迭代查询：如果询问的服务器上找不到对应IP地址，会返回下一步查询应该访问的服务器。</li><li>非递归查询：发生在客户端与DNS服务器之间，指请求的DNS服务器已经知道答案，直接返回。可能为DNS服务器本机缓存了对应的IP地址，或缓存了对应域名的权威服务器（绕过了根域名服务器，再发一次请求即可拿到结果返回）。</li></ul><p>流程：</p><ul><li>检查浏览器缓存、系统hosts文件是否有域名对应的IP地址，没有则委托给本地配置的首选DNS服务器。</li><li>DNS服务器首先查看自己的缓存，若没有或已过期则向根域名DNS服务器请求。</li><li>根域名DNS服务器查看自己的缓存，若没有则返回对应的顶级域名服务器IP地址。</li><li>如此往复查询顶级域名服务器、权威域名服务器等，直到获取到IP地址。</li><li>如果查询不到，则浏览器显示页面无法打开。</li></ul><p>格式：<code>scheme://host.domain:port/path/filename</code></p><ul><li>scheme：协议类型</li><li>host：域主机（HTTP默认为www）</li><li>domain：域名</li><li>port：主机端口号</li><li>path：服务器上的路径</li><li>filename：文档/资源名称（省略则为服务器设置的默认文件）</li></ul><h2 id="17-DNS负载均衡"><a href="#17-DNS负载均衡" class="headerlink" title="17. DNS负载均衡"></a>17. DNS负载均衡</h2><p>DNS服务器为同一个主机名配置多个IP地址，在应答DNS查询时，根据每台机器的负载量、距离用户的位置等因素，将不同的用户引导到不同的机器。</p><p>详见25 Nginx</p><h2 id="18-Cookie与Session"><a href="#18-Cookie与Session" class="headerlink" title="18. Cookie与Session"></a>18. Cookie与Session</h2><p>共同点：跟踪浏览器用户身份的会话方式。</p><p>Cookie：浏览器第一次发送请求给服务端时，服务端创建包含用户信息的cookie，并发送给浏览器。浏览器再次访问时需要携带cookie，服务端就能识别不同的用户。</p><p>服务器使用Set-Cookie头，浏览器使用Cookie头。</p><p>Cookie保存在客户端，可存储的数据量有限，一般不超过4KB。</p><p>Session：浏览器第一次发送请求给服务端时，服务端创建一个Session，并创建一个特殊的Cookie（key为固定值JSESSIONID，value为session对象ID）发送给浏览器。浏览器再次访问时，服务端根据name为JSESSIONID的Cookie的value，即sessionID去查询Session对象，从而区分用户。Session对象记录用户的操作。</p><p>Session保存在服务端，较用户端更安全，但会占用服务器资源。</p><p>用户登录操作：</p><ul><li>用户提交包含用户名和密码的表单</li><li>服务器验证，如果正确就将信息存储到Redis中，其在Redis中的Key称为SessionID</li><li>服务器返回响应报文的Set-Cookie首部字段包含SessionID，客户端收到后将Cookie存入浏览器</li><li>客户端再次请求时包含该Cookie值，服务器收到后提取出SessionID，从Redis取出用户信息。</li></ul><p>存在安全性问题，需要生成不易被想到的ID、经常性重新生成ID、用其他方法额外验证。</p><p>比较：</p><ol><li>cookie数据保存在用户端浏览器，session数据保存在服务端</li><li>cookie数据不安全，可以被本地拷贝并进行cookie欺骗</li><li>cookie的value只能是字符串类型，而session是object类型</li></ol><h2 id="19-各种漏洞与攻击"><a href="#19-各种漏洞与攻击" class="headerlink" title="19. 各种漏洞与攻击"></a>19. 各种漏洞与攻击</h2><h4 id="1-XSS攻击"><a href="#1-XSS攻击" class="headerlink" title="1. XSS攻击"></a>1. XSS攻击</h4><p>跨站点脚本攻击：目标网站目标用户浏览器渲染HTML文档的过程中，出现了不被预期的脚本指令并执行。</p><p>反射型XSS（非持久型）：发出请求时XSS代码出现在URL中，作为输入提交到服务端，服务端响应后，XSS代码随相应内容传回给服务器，最后浏览器解析执行XSS代码。</p><p>存储型XSS（持久型）：提交的代码存储在服务器端，下次请求目标页面时不用再提交XSS代码。</p><p>DOM XSS：DOM XSS的代码不需要服务器参与，触发XSS靠浏览器端的DOM解析。</p><h4 id="2-CSRF攻击"><a href="#2-CSRF攻击" class="headerlink" title="2. CSRF攻击"></a>2. CSRF攻击</h4><p>跨站点请求伪造：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。</p><p>防范方式：</p><ul><li>安全框架：Spring Security</li><li>token机制：请求中如果没有token或内容不正确，则拒绝请求</li><li>验证码</li><li>referer识别：Referer字段记录HTTP请求的来源地址，如果是其他网站则拒绝请求</li></ul><h4 id="3-文件上传漏洞"><a href="#3-文件上传漏洞" class="headerlink" title="3. 文件上传漏洞"></a>3. 文件上传漏洞</h4><p>用户上传可执行的脚本文件，并通过脚本文件获得执行服务端命令的能力。</p><p>防范方式：</p><ul><li>文件上传的目录设置为不可执行</li><li>判断文件类型、对类型白名单校验</li><li>要求重新命名上传的文件</li><li>限制文件大小</li><li>单独设置文件服务器域名</li></ul><h2 id="20-HTTP状态码"><a href="#20-HTTP状态码" class="headerlink" title="20. HTTP状态码"></a>20. HTTP状态码</h2><ul><li>1XX：信息性状态码，表示接收的请求正在处理，还没有处理完，有后续报文。<ul><li>100 Continue：一切正常。</li></ul></li><li>2XX：成功状态码，表示请求正常处理完毕。<ul><li>200 OK</li><li>204 No Content：响应报文不包含实体的主体部分，一般在只需要从客户端向服务器发信息而不需要返回数据时使用。</li><li>206 Partial Content：客户端进行了范围请求，且服务器已经正确处理部分GET请求，实现断点续传或同时分片下载。响应报文包含由Content-Range指定范围的实体内容。</li></ul></li><li>3XX：重定向状态码，表示需要进行附加操作以完成请求。<ul><li>301 Moved Permanently：永久性重定向。搜索引擎抓取新内容的同时也将旧地址替换为重定向后的地址。</li><li>302 Found：临时性重定向。搜索引擎抓取新内容也会保留旧地址。</li><li>303 See Other：功能与302相同，但明确要求客户端用GET获取资源。</li><li>304 Not Modified：如果请求报文首部包含一些条件，且不满足条件，服务器返回304。</li><li>307 Temporary Redirect：临时重定向，与302含义类似，但要求浏览器不会把重定向请求的POST改成GET。</li></ul></li><li>4XX：客户端错误状态码，表示服务器无法处理请求。<ul><li>400 Bad Request：请求报文中存在语法错误。</li><li>401 Unauthorized：发送的请求中需要认证信息，如果之前已请求过则表示认证失败。</li><li>403 Forbidden：请求被拒绝。（无文件/目录读写权限等问题）</li><li>404 Not Found：请求的资源在服务器上不存在。</li></ul></li><li>5XX：服务器错误状态码，表示服务器处理请求出错。<ul><li>500 Internal Server Error：服务器执行请求时发生错误。</li><li>503 Service Unavailable：服务器超负荷/停机维护，暂时无法处理请求。</li></ul></li></ul><h2 id="21-中间人攻击"><a href="#21-中间人攻击" class="headerlink" title="21. 中间人攻击"></a>21. 中间人攻击</h2><p>中间人截取握手信息并分别对客户端/服务端伪造服务端/客户端。但是需要用户接受中间人服务器的证书，而浏览器能识别出非法证书并提醒。</p><h2 id="22-降级攻击"><a href="#22-降级攻击" class="headerlink" title="22. 降级攻击"></a>22. 降级攻击</h2><p>因为兼容性问题，浏览器进行高版本的HTTPS连接失败时，会尝试用旧的协议版本。攻击者通过旧的协议中存在的漏洞进行攻击。</p><p>通过禁止服务端对漏洞较多的旧版本协议支持可避免。</p><h2 id="23-前向安全性-重放攻击"><a href="#23-前向安全性-重放攻击" class="headerlink" title="23. 前向安全性/重放攻击"></a>23. 前向安全性/重放攻击</h2><p>前向安全性：当前时段的私钥泄露后不影响泄露以前时段的私钥与签名的安全。</p><p>重放攻击：窃听者窃取了作为身份证明的密码/哈希，并在被要求提供身份证明时提供该密码/哈希，并获得访问权限。如果窃听者截获了某个POST报文与Session ID或Session Ticket，就能不断发送该报文，在客户不知情的情况下改变数据库。</p><h2 id="24-安全和幂等"><a href="#24-安全和幂等" class="headerlink" title="24. 安全和幂等"></a>24. 安全和幂等</h2><p>安全：请求方法不会破坏服务器上的资源。<br>幂等：多次执行相同的操作获得的结果相同。<br>GET操作按RFC语义实现查操作，是安全且幂等的，因此可以对其请求的数据做缓存。<br>POST操作按RFC语义实现增删操作，既不安全也不幂等，因此浏览器一般不会缓存POST请求，也不能将其保存为书签。<br>如果不按照RFC规范定义语义实现GET与POST，那GET也可能实现增删，POST也可能实现查。</p><h2 id="25-Nginx与负载均衡"><a href="#25-Nginx与负载均衡" class="headerlink" title="25. Nginx与负载均衡"></a>25. Nginx与负载均衡</h2><p>高性能的HTTP和反向代理服务器，同时提供IMAP/POP3/SMTP服务。</p><p>特点：占有内存少，并发能力强。</p><p>功能：正向代理、反向代理、负载均衡、动静分离。</p><h3 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1. 负载均衡"></a>1. 负载均衡</h3><p>可工作在第四层或第七层。</p><p>分为两种：</p><ul><li>四层负载均衡：工作在传输层，通过修改IP+端口号转发到应用服务器。</li><li>七层负载均衡：工作在应用层，还可根据URL、浏览器类别、语言等信息决定是否负载均衡。</li></ul><p>服务器通常是多台形成分布式系统，并通过负载均衡器决定将请求报文分配到哪台服务器。</p><p>不同服务器配置不同，为了让性能高的服务器分配到更高的请求。</p><p>Nginx负载均衡有加权轮询（默认）、IP哈希、url哈希等方式。</p><h3 id="2-动静分离"><a href="#2-动静分离" class="headerlink" title="2. 动静分离"></a>2. 动静分离</h3><p>动静分离将网站静态资源（HTML、JavaScript、CSS、img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用的访问。</p><p>Nginx服务器将接收到的请求分为动态请求和静态请求。一种做法是静态资源部署在nginx上，后台项目部署到应用服务器上。静态请求直接去nginx设定的根目录取资源，动态请求转发给真实后台。</p><p>好处：</p><ul><li>api接口服务化：后端应用更为服务化，只需要提供api接口，可以被多个功能模块、多个平台的功能使用，有效节省后端人力，便于功能维护。</li><li>前后端开发并行：前后端只需要关心接口协议，各自开发可并行，有效提高开发效率、减少联调时间。</li><li>减轻后端服务器压力、提高静态资源访问速度：后端不必再将模板渲染为html返回，静态服务器可采取更专业的技术。</li></ul><h3 id="3-反向代理"><a href="#3-反向代理" class="headerlink" title="3. 反向代理"></a>3. 反向代理</h3><p>一般用在负载均衡中。</p><p>好处：</p><ul><li>隐藏：对客户端隐藏真实的服务器IP。</li><li>缓存：如果nginx服务器上有请求的数据缓存，可不必请求真实服务器，提高访问速度。</li><li>负载均衡</li><li>安全：代理服务器可提供防火墙功能，防止对服务器的直接访问。</li></ul><h3 id="4-正向代理"><a href="#4-正向代理" class="headerlink" title="4. 正向代理"></a>4. 正向代理</h3><p>好处：</p><ul><li>隐藏</li><li>缓存</li><li>突破访问控制：通过代理服务器访问客户端原本被禁止访问的网页。</li></ul><p>额外的问题：正向代理接到HTTPS报文时无法解密，从而无法得知服务器地址。</p><p>HTTP CONNECT隧道解决方案：7层</p><ol><li>客户端给代理发送HTTP CONNECT请求。</li><li>代理利用HTTP CONNECT请求的主机与端口与目的服务器建立TCP连接。</li><li>代理服务器返回客户端200。</li><li>客户端和代理服务器建立起HTTP CONNECT隧道，HTTPS流量到达代理服务器后，直接通过TCP透传给目的服务器。</li></ol><p>NGINX stream解决方案：4层</p><p>通过TLS/SSL四次握手中第一次的Client Hello报文中的扩展地址SNI（Server Name indication）来获取服务器地址。</p><h3 id="5-多进程结构"><a href="#5-多进程结构" class="headerlink" title="5. 多进程结构"></a>5. 多进程结构</h3><p>分为两类进程，通过IO多路复用epoll管理：</p><ul><li>master进程：管理worker进程。对外接收外部信号，对内转发，通过信号管理worker并监控其运行状态，如果worker异常终止则自动重启。</li><li>worker进程：处理网络请求。</li></ul><p>为什么不用多线程：</p><ul><li>Nginx最核心的一个目的是保证高可用性、高可靠性。多线程模型中，一个线程挂掉会导致整个Nginx进程全部挂掉。</li><li>Nginx是静态web服务器，处理http请求，连接之间一般没有关联，不对通信性有要求。</li></ul><h1 id="3-传输层"><a href="#3-传输层" class="headerlink" title="3. 传输层"></a>3. 传输层</h1><h2 id="1-基本特征"><a href="#1-基本特征" class="headerlink" title="1. 基本特征"></a>1. 基本特征</h2><h3 id="1-TCP三大特点"><a href="#1-TCP三大特点" class="headerlink" title="1. TCP三大特点"></a>1. TCP三大特点</h3><p>面向连接的（一对一）、可靠的（保证到达）、字节流（消息分组且有序）</p><h3 id="2-TCP与UDP的区别"><a href="#2-TCP与UDP的区别" class="headerlink" title="2. TCP与UDP的区别"></a>2. TCP与UDP的区别</h3><ul><li>面向连接：TCP使用前必须要建立连接，UDP不需要。UDP是面向报文的。</li><li>可靠性：TCP保证交付，能确认应答和重传，保证数据无重复、不丢失、按序到达，UDP尽最大努力交付，不保证可靠性，可能乱序、丢包。</li><li>传输方式：TCP基于字节流，没有边界，UDP继承IP层特性，基于数据包，有边界。</li><li>分片方式：TCP会对数据进行分片传输，有数据丢失只重传丢失的片，UDP交给IP层分片，有数据丢失需要重传所有的数据片。</li><li>服务对象：TCP一对一，UDP可一对多、多对一、多对多。</li><li>连接控制：TCP有拥塞控制、流量控制等机制，UDP没有。</li><li>首部开销：TCP一般是20个字节，UDP首部只有8个字节。</li></ul><h3 id="3-分片机制"><a href="#3-分片机制" class="headerlink" title="3. 分片机制"></a>3. 分片机制</h3><p>在已有IP分包机制的存在下，TCP仍然加入了自己的分片机制，是因为：IP层没有超时重传机制，如果一大份数据中的一个IP分片丢失，TCP需要重传这一大份数据的所有分片。所以由TCP事先分片，防止IP再进行分包，确保一个IP报文中最多只有一个TCP报文，这样即使丢失也可以只重传一个报文。</p><p>然而，各个网络层设备的MTU不同，如果进入到MTU较小的设备，可能还会进行分片。可以尝试获取整条路线的最小MTU值，来避免IP分包。</p><h3 id="4-TIME-WAIT状态"><a href="#4-TIME-WAIT状态" class="headerlink" title="4. TIME_WAIT状态"></a>4. TIME_WAIT状态</h3><p>主动断开连接的一方才有TIME_WAIT状态。</p><ol><li>TIME_WAIT时间为2MSL（报文最大生存时间），从客户端接收到FIN后发送ACK开始计时，在接到重发的FIN后会重新开始计时。</li><li>为什么是2MSL：一般认为网络中可能还存在来自发送方的数据包，发送方接收到这些数据包的ACK时最长需要一来一回的时间。</li><li>为什么需要TIME_WAIT状态：<ol><li>等待报文一来一回的时间，防止历史连接的数据被后续连接接收。</li><li>等待足够时间，以确保被动关闭连接的另一方能被正确关闭。</li></ol></li><li>优化：TIME_WAIT状态过多会占用系统资源、端口资源<ol><li>net.ipv4.tcp_tw_reuse与tcp_timestamps：复用处于TIME_WAIT的socket为新的连接，还需要时间戳的支持以判断过期的历史连接数据。</li><li>net.ipv4.tcp_max_tw_bucket：处于最大TIME_WAIT连接数时重置后面的TIME_WAIT连接状态。</li><li>SO_LINGER：设置socket选项来设置调用close关闭连接行为，比如直接发送RST异常关闭。</li></ol></li></ol><h3 id="5-三握四挥与socket函数"><a href="#5-三握四挥与socket函数" class="headerlink" title="5. 三握四挥与socket函数"></a>5. 三握四挥与socket函数</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdcCkcGmFlZmPvxKiaGGo1BX2Kg3WoeNrBLqgHapEN4kCuIf8eX3YBNV2efPmXf3tIUTn5ufcvuKLQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload placeholder" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdcCkcGmFlZmPvxKiaGGo1BX2Kg3WoeNrBLqgHapEN4kCuIf8eX3YBNV2efPmXf3tIUTn5ufcvuKLQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>" class="lazyload placeholder" data-srcset="" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp<img src="" alt="img"></p><h3 id="6-滑动窗口"><a href="#6-滑动窗口" class="headerlink" title="6. 滑动窗口"></a>6. 滑动窗口</h3><p><strong>累计确认</strong>：发送方收到ACK应答，就认为该ACK号之前的所有数据接收方都已收到。</p><p>无需等待ACK而可以继续发送数据的最大值。接收方通过头部的Window字段告知接收窗口大小，发送方维护滑动窗口。</p><ol><li><p>发送方的滑动窗口swnd：实际大小为拥塞控制窗口cwnd与接收窗口rwnd的最小值。</p><ol><li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="发送方滑动窗口"></li><li>SND.WND：发送窗口的大小，由接收方指定</li><li>SND.UNA：指向已发送但未确认（#2）的第一个字节的序列号</li><li>SND.NXT：指向未发送但可发送（#3）的第一个字节序列号</li><li>可用窗口大小=SND.WND - (SND.NXT - SND.UNA)</li></ol></li><li><p>接收方的滑动窗口rwnd</p><ol><li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="接收方的滑动窗口"></li><li>RCV.WND：接收窗口大小，会告知发送方</li><li>RCV.NXT：指向期望收到的下一个数据字节的序列号</li></ol></li><li><p>接收窗口大小约等于发送窗口大小，但不完全相等。</p></li></ol><h3 id="7-流量控制"><a href="#7-流量控制" class="headerlink" title="7. 流量控制"></a>7. 流量控制</h3><p>出现原因：发送速率长时间大于接收方处理速率时，会塞满接收方缓冲区，导致报文被丢弃，重传浪费资源。</p><p>发送方根据接收方的实际接收能力控制发送的数据量。</p><ol><li>应用程序读取能力不够时，会出现接收窗口收缩到0的死锁情况；如果操作系统直接减少接收缓冲区大小，甚至可能出现数据包丢失。TCP规定不允许同时减少缓存与收缩窗口，只能先收缩窗口。</li><li>窗口关闭：TCP一方收到另一方的零窗口通知时启动持续计时器，在超时时发送<strong>窗口探测报文</strong>。如果多次探测还是0则发送RST报文中断连接。</li><li>糊涂窗口综合症：TCP为了很少的数据就发送报文，导致资源浪费。<ol><li>接收方<strong>不通告小窗口</strong>：接收方窗口大小小于min(MSS, 缓存空间/2)时发送零窗口通知</li><li>发送方<strong>避免发送小数据</strong>：（需要1满足）发送方使用<strong>Nagle算法</strong>，只有满足窗口大小&gt;=MSS且数据大小&gt;=MSS、收到之前发送数据的ACK、是FIN报文时才发送数据，否则囤积数据。</li></ol></li></ol><h3 id="8-拥塞控制"><a href="#8-拥塞控制" class="headerlink" title="8. 拥塞控制"></a>8. 拥塞控制</h3><p>网络层同样参与了拥塞控制：</p><ul><li>根据网络负载动态调整不同线路权值，将流量引导到不同线路上。</li><li>准入控制。</li><li>调整发送速率。</li><li>有选择主动丢弃一些数据报。</li></ul><p>流量控制是避免发送方的数据填满<strong>接收方</strong>的缓冲区，而拥塞控制是避免发送方的数据填满整个<strong>网络</strong>。</p><p>实际发送窗口的大小取流量控制窗口和拥塞控制窗口的最小值。</p><ol><li>拥塞窗口cwnd=min(swnd, rwnd)</li><li>慢启动：发送方每收到一个ACK，++cwnd。变化趋势：1-&gt;2-&gt;4-&gt;8-&gt;……，呈指数型增长。慢启动门限ssthresh（一般为65535）。当cwnd&gt;=ssthresh时改为拥塞避免算法</li><li>拥塞避免：每收到一个ACK，cwnd+=1/cwnd。收到上一个cwnd发送的所有报文时，即增长1，变成线性增长。网络慢慢进入拥塞，最终在出现丢包需要进行重传时进入拥塞发生。</li><li>拥塞发生：<ol><li>超时重传：ssthresh=cwnd/2，cwnd重置为初始值（一般为1），重新开始慢启动。</li><li>快速重传：cwnd/=2，ssthresh=cwnd，进入快速恢复算法。</li></ol></li><li>快速恢复：认为能连续收到3个重复ACK时网络状况并不那么糟糕，所以不需要像超时重传那样反应剧烈。<ol><li>cwnd+=3（在快速重传的基础上），表示确认3个数据包被收到。</li><li>重传丢失的数据包</li><li>如果再收到重复的ACK，cwnd加1。加1代表每个收到的重复ACK包都已经离开了网络，是为了尽快重传丢失的数据包。</li><li>如果收到新数据的ACK，将cwnd设置为快速重传设置的ssthresh值（ACK确认新数据，说明重复ACK的数据都已经收到，恢复过程已经结束），进入拥塞避免状态。</li></ol></li><li>为什么是3个ACK：根据实践经验确定，两次duplicated ACK很可能是乱序造成的，而三次及以上的duplicated ACK很可能是丢包造成的。</li><li>慢与快指的是拥塞窗口的设定值，而不是增长速率。</li></ol><h3 id="9-TCP-Fast-Open"><a href="#9-TCP-Fast-Open" class="headerlink" title="9. TCP Fast Open"></a>9. TCP Fast Open</h3><ol><li>第一次建立连接时，服务端在第二次握手时产生一个加密Cookie与SYN+ACK包一起发送，客户端在第三次握手时将ACK与HTTP请求一起发送。</li><li>下次请求时客户端在SYN包中带上Cookie与应用数据，服务端能直接从Cookie获取TCP相关信息，跳过握手并返回SYN+ACK+数据，只需要一个RTT。</li><li>需要双方同时支持。</li></ol><h3 id="10-TCP小报文优化"><a href="#10-TCP小报文优化" class="headerlink" title="10. TCP小报文优化"></a>10. TCP小报文优化</h3><p>当TCP承载的数据很少，只有几个字节时，用一个20字节的报头发送这些数据效率很低。</p><h4 id="1-Nagle算法"><a href="#1-Nagle算法" class="headerlink" title="1. Nagle算法"></a>1. Nagle算法</h4><p><strong>发送方</strong>使用Nagle<strong>算法</strong>，发送前等待一段时间，只有满足其中之一</p><ul><li>窗口大小&gt;=MSS且数据大小&gt;=MSS</li><li>收到之前发送数据的ACK</li><li>含有FIN</li></ul><p>才发送数据，否则囤积数据直到算法超时。</p><h4 id="2-TCP延迟确认"><a href="#2-TCP延迟确认" class="headerlink" title="2. TCP延迟确认"></a>2. TCP延迟确认</h4><p><strong>接收方</strong>使用TCP延迟确认机制</p><ol><li>有响应数据发送时，ACK随响应数据一起发送</li><li>没有响应数据发送时，ACK等待一段时间</li><li>在等待期间对方第二个数据报文到达，则ACK立刻发送</li></ol><p>与Nagle算法一起使用可能会适得其反，反而使效率降低。</p><p>发送小数据时，接收方没有数据要发送，等待下一个报文到达或超时时再发送ACK，发送方等待当前报文的ACK再发送下一个数据，会造成额外时延。</p><h3 id="11-close与shutdown"><a href="#11-close与shutdown" class="headerlink" title="11. close与shutdown"></a>11. close与shutdown</h3><ol><li>close：完全断开连接，无法发送数据与传输数据，调用close一方的连接叫孤儿连接，进程名为空。只关闭该进程的套接字ID，如果有共享，相当于共享计数-1，不会触发四次挥手，其他进程仍能使用。</li><li>shutdown：比close多一个参数。切断进程共享的套接字的所有链接。<ol><li>SHUT_RD(0)：关闭连接的读方向。立即丢弃接收缓冲区的数据，并在之后有数据到来时返回ACK并丢弃。</li><li>SHUT_WR(1)：关闭连接的写方向。立即发送发送缓冲区未发送的数据，并发送FIN报文。</li><li>SHUT_RDWR(2)：1和2各执行一次。</li></ol></li></ol><h3 id="12-面向字节流-amp-面向报文"><a href="#12-面向字节流-amp-面向报文" class="headerlink" title="12. 面向字节流&amp;面向报文"></a>12. 面向字节流&amp;面向报文</h3><p>TCP是面向字节流的协议，而UDP是面向报文的协议.</p><ol><li>用户协议通过UDP协议传输时，操作系统不会对消息进行拆分，这意味着每个UDP报文代表一条完整的用户消息。</li><li>用户协议通过TCP协议传输时，消息可能会被分成多个TCP报文，而拆分方式不固定，不能认为一个用户消息对应一个TCP报文。（TCP协议传输的数据粒度比报文更细）</li><li>解决粘包：固定长度；特殊字符作为边界（如HTTP以回车+换行作为边界）；自定义消息结构（包头固定大小，在包头中记录数据大小）。</li></ol><h3 id="13-TCP时间戳"><a href="#13-TCP时间戳" class="headerlink" title="13. TCP时间戳"></a>13. TCP时间戳</h3><ol><li>精确计算RTT</li><li>防止序列号回绕（随机出相同的SYN）：判断新收到的数据包的时间戳是否在递增序列中，如果不在表示该数据包过期。</li></ol><h3 id="14-PAWS机制"><a href="#14-PAWS机制" class="headerlink" title="14. PAWS机制"></a>14. PAWS机制</h3><p>因为TCP包的seq号可能发生绕回，服务端无法分辨经过一个循环的seq号与本循环的seq号。</p><p>PAWS机制必须要开启tcp_timestamps选项，让所有TCP包带上时间戳，从而丢弃来自同一个客户端的、时间戳不是递增的数据包。</p><p>PAWS机制会放过过期的RST报文。</p><p>per-host：只通过IP区分不同客户端。</p><h3 id="15-时间戳"><a href="#15-时间戳" class="headerlink" title="15. 时间戳"></a>15. 时间戳</h3><p>tcp_timestamps：TCP时间戳（默认为1），开启后可开启如下两个功能</p><ol><li>tcp_tw_reuse：客户端在调用connect函数时，如果内核选择到的端口已被相同四元组的连接占用，且该连接处于TIME_WAIT状态超过1秒，那么就会重用该连接。<ol><li>如果开启，有可能导致历史RST报文到达重用的连接，从而强制断开该连接。（正常情况下认为TIME_WAIT持续的时间足够让连接中的报文在网络中自然消失）</li><li>如果第四次挥手的ACK丢失，可能被动关闭连接的一方无法正常关闭。（收到上一个连接重传的FIN的话，会直接回复RST让对方异常关闭）</li></ol></li><li>tcp_tw_recycle：允许处于TIME_WAIT状态的连接被快速回收。<ol><li>如果开启，会开启per-host的PAWS机制，对对端IP进行检查。</li><li>如果此时客户端环境使用了NAT网关，客户端环境的每一台机器通过NAT网关后都会是相同的IP地址</li><li>如果服务器主动关闭与客户端A的连接后，同一环境的客户端B通过相同的NAT网关与服务器建立连接，且其timestamp比A的小，由于服务端的per-host的PAWS机制作用，服务端会丢弃B发来的SYN包。</li></ol></li></ol><h3 id="16-TCP-Fast-Open-TLSv1-3"><a href="#16-TCP-Fast-Open-TLSv1-3" class="headerlink" title="16. TCP Fast Open + TLSv1.3"></a>16. TCP Fast Open + TLSv1.3</h3><p>TCP Fast Open：客户端和服务端同时支持的情况下，在第二次以后的通信过程中，客户端可携带第一次通信服务器发送的cookie直接发送数据，服务端收到cookie后直接建立连接并返回数据。</p><p>TLSv1.3：会话恢复机制：利用Session ID等，在第二次以后的通信过程中，实现0-RTT握手。</p><p>这两者同时使用的话，在第二次以后的通信过程中，可以同时进行，并且还能同时携带HTTP请求。</p><h3 id="17-TCP-keepalive与HTTP-keep-alive"><a href="#17-TCP-keepalive与HTTP-keep-alive" class="headerlink" title="17. TCP keepalive与HTTP keep-alive"></a>17. TCP keepalive与HTTP keep-alive</h3><ol><li>HTTP keep-alive：HTTP长连接：HTTP使用同一个TCP连接来发送和接收多个HTTP请求应答。由应用程序实现。</li><li>TCP keepalive：TCP保活机制：在没有数据交互时，内核的TCP协议栈会发送探测报文给对方，如果对方程序正常工作就会响应，TCP保活时间被重置；否则在达到保活探测次数后，TCP报告该连接已死亡。由内核实现。</li></ol><p>TCP缺陷：</p><ol><li>升级困难：TCP在内核中实现，升级内核很麻烦。并且很多新特性需要通信双方都支持。</li><li>建立连接延迟：握手延迟。</li><li>队头阻塞：字节流协议。</li><li>网络迁移需要重新建立TCP连接。</li></ol><h3 id="18-QUIC"><a href="#18-QUIC" class="headerlink" title="18. QUIC"></a>18. QUIC</h3><p>基于UDP在应用层实现的可靠传输。QUIC是传输层协议。</p><ol><li><p>三层Header：UDP头部与HTTP消息之间，由外到内依次为：</p><ol><li><p>Packet Header</p><ol><li>Long Packet Header用于首次建立连接，包含源连接ID和目标连接ID。</li><li>Short Packet Header用于日常传输连接，包含目标连接ID、编号和负载数据。</li><li>双方通过三次握手协商连接ID。编号严格递增（即使重传，编号也比丢失的要大）（为了去除TCP的ACK歧义，该ACK响应的是原始报文还是重传报文，从而避免RTT误判）</li><li>支持乱序确认，后续报文不必阻塞在缓冲区。</li></ol></li><li><p>QUIC Frame Header：一个Packet中可存放多个QUIC Frame。有包括Stream在内的多种类型</p><ol><li>通过该层的Stream ID+Offset字段信息确认重传报文与丢失报文的一致性。</li></ol></li><li><p>HTTP3 Frame Header</p></li></ol></li><li><p>TCP队头阻塞问题的解决</p><ol><li>HTTP2的队头阻塞：多个Stream在一条TCP连接上传输，也意味着共用一个TCP滑动窗口，发生数据丢失会阻塞所有的HTTP请求。</li><li>QUIC为每个Stream分配独立的滑动窗口。</li></ol></li><li><p>实现UDP没有的流量控制：分为每个Stream与总的Connection两个级别。</p><ol><li>通过window_update帧告诉对端自己可以接收的字节数，通过BlockFrame告诉对端被阻塞。</li><li>Stream级别：每个Stream有独立的滑动窗口，所以每个Stream都能做流量控制。</li><li>Connection流量控制：限制连接中所有Stream相加起来的总字节数。</li></ol></li><li><p>改进TCP拥塞控制算法，还支持其他多种算法：QUIC处于应用层，因此可以随浏览器更新，迭代速度很快，并且可以针对不同应用设置不同的算法。</p></li><li><p>QUIC不用四元组绑定连接，而是通过头部的CID标识连接，双方在随机生成的CID列表上达成一致，列表上的CID映射到同一连接，切换环境时切换CID。（防止CID被窃取获得用户地址）迁移后双方都向对方发起路径验证，探测可达性。</p></li><li><p>总之就是在应用层实现了绝大多数TCP提高效率的机制，如滑动窗口等，但是规避了TCP作为字节流协议的队头阻塞问题。</p></li></ol><h3 id="16-客户端connect选择端口的流程"><a href="#16-客户端connect选择端口的流程" class="headerlink" title="16. 客户端connect选择端口的流程"></a>16. 客户端connect选择端口的流程</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.jpg" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h3 id="17-半连接、全连接队列"><a href="#17-半连接、全连接队列" class="headerlink" title="17. 半连接、全连接队列"></a>17. 半连接、全连接队列</h3><p>全连接队列是链表，而半连接队列是哈希表</p><ol><li>accept前连接已经建立，accept只是从全连接队列中取出一条可用的连接。</li><li>链表与哈希表的设置：全连接队列中都是建立完成的连接，服务器只负责取出连接读写并处理业务，不关心取到哪条；而半连接队列中的连接需要等待第三次握手时，将相应的连接取出来，设置成哈希表方便查找对应的连接。</li></ol><h3 id="18-tcp-abort-on-overflow"><a href="#18-tcp-abort-on-overflow" class="headerlink" title="18. tcp_abort_on_overflow"></a>18. tcp_abort_on_overflow</h3><ol><li>0：全连接队列满了后会丢弃第三次握手的ACK包，并开启定时器重传SYN+ACK包。如果次数超过限制还会把对应半连接队列里的连接删除。</li><li>1：直接返回RST</li></ol><h3 id="19-cookies方案取代半连接队列"><a href="#19-cookies方案取代半连接队列" class="headerlink" title="19. cookies方案取代半连接队列"></a>19. cookies方案取代半连接队列</h3><ol><li>cookies信息实时计算，保存在TCP包头的seq里，所以如果信息丢失，服务器不会重发第二次握手信息。</li><li>编码解码cookies耗费CPU，同样可能被利用攻击，如编写大量无意义的cookie与SYN组成报文，让服务端解析从而耗费资源。</li></ol><h3 id="20-TCP丢包"><a href="#20-TCP丢包" class="headerlink" title="20. TCP丢包"></a>20. TCP丢包</h3><p>常见丢包情况：</p><ul><li>建立连接丢包：对方全连接队列已满。</li><li>流量控制丢包：滑动窗口与缓存空间同时缩小。</li><li>缓冲区丢包。</li><li>网络丢包。</li></ul><p>TCP在没收到对方的ACK确认时，会重传丢失的包。</p><p>TCP只保证到传输层的可靠性，不保证应用层的可靠性，因此还是可能丢失信息，比如应用在读取接收缓冲区的信息时崩溃。这些需要应用程序自己实现逻辑保证。</p><p>为了应对这种丢包情况，在两端通信引入第三端服务器：</p><ol><li>只需要跟服务器建立一个连接，耗费资源少</li><li>方便进行鉴权校验，防止信息泄露</li><li>软件版本兼容</li></ol><h3 id="21-★-拆包-粘包问题"><a href="#21-★-拆包-粘包问题" class="headerlink" title="21. ★ 拆包/粘包问题"></a>21. ★ 拆包/粘包问题</h3><p>本质原因：TCP协议数据传输基于字节流，需要<strong>应用层自行设计</strong>消息的边界。</p><p>UDP不会出现的原因：面向消息传输，有消息保护边界，接收方一次只接收一条独立的信息。</p><p>一个完整的业务可能被拆分成多个包发送，多个小的包可能封装成一个大的包发送</p><p>拆包：数据包大于缓冲区，在运输层将数据拆分。</p><p>原因：</p><ol><li>降低IP分片的压力</li><li>重传时只需传输丢失的分片，减少重传所需传输的数据。</li></ol><p>粘包：TCP连接复用、流量/拥塞控制、接收方不及时处理、Nagle算法、延迟确认</p><p>解决：</p><ol><li>消息定长，或标记数据长度（Content-length头部字段）</li><li>包尾增加特殊字符分割</li><li>将消息分为消息头和消息尾</li></ol><h3 id="22-数据包发送流程总结"><a href="#22-数据包发送流程总结" class="headerlink" title="22. 数据包发送流程总结"></a>22. 数据包发送流程总结</h3><p>假设是端到端服务且用TCP通信。</p><ol><li>三次握手建立TCP连接。</li><li>数据包从聊天框发出，从聊天软件所在的用户空间拷贝到内核空间的发送缓冲区。</li><li>数据包依次经过传输层、网络层进入数据链路层，经过流控，通过RingBuffer发送到物理层的网卡。</li><li>网卡将数据包发送到互联网中，经过路由器和交换机的跳转，到达目的机器的网卡。</li><li>网卡通知DMA将数据包信息放到RingBuffer中，再触发硬中断给CPU，CPU触发软中断让ksoftirqd线程去收包。</li><li>数据包经过多个层到达传输层，从内核空间拷贝到用户空间的聊天软件中。</li></ol><p>linux中用内核态中的sk_buff维护待发送的包。因为TCP协议支持丢失重传，所以sk_buff只是拷贝发送，直到收到ACK才删除。<br>各个层数据包叫法不同但用同一个结构体维护的原因：多次拷贝降低CPU效率，所以通过调整sk_buff-&gt;data指针来添加与剥离头部。</p><h3 id="23-MTU与MSS"><a href="#23-MTU与MSS" class="headerlink" title="23. MTU与MSS"></a>23. MTU与MSS</h3><p>MTU：一个网络包的最大长度，以太网中一般为1500字节（IP头部）<br>MSS：网络包所能容纳TCP数据的最大长度（TCP的数据部分，不包括TCP头部），一般为MTU-20（TCP头部大小）-20（IP头部大小）=1460</p><h3 id="24-RTO和RTT"><a href="#24-RTO和RTT" class="headerlink" title="24. RTO和RTT"></a>24. RTO和RTT</h3><p>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的间隔。即为<strong>重传间隔</strong>。RTO一般是根据网络状况动态计算的。</p><p>RTT：数据从发送到接受到对方相应之间的时间间隔，即数据包在网络中一个<strong>往返用时</strong>。</p><h3 id="25-TCP头部常用选项"><a href="#25-TCP头部常用选项" class="headerlink" title="25. TCP头部常用选项"></a>25. TCP头部常用选项</h3><p>TCP头部最后一个选项字段是可变长的可选信息，最多包含40字节，即TCP头部总共最多60字节。</p><p>第一个字段kind说明选项类型，第二个选项length（如果有）指定选项总长度，第三个字段info（如果有）为选项的具体信息。</p><p>kind=0：选项表结束EOP，一个报文段仅用一次，说明首部没有更多消息，应用数据放在下一个32位字开始处。</p><p>kind=1：空操作NOP，没有特殊含义，用于填充TCP选项总长度为4字节的整数倍。</p><p>kind=2：最大报文段长度MSS，TCP连接初始化时双方使用该字段协商MSS，一般为最大传输单元MTU-40字节，含义是20字节TCP头部与20字节IP头部，从而尽量避免发生IP分片。对以太网而言，MSS=1500-40=1460。</p><p>kind=4：选择性确认SACK，用在连接初始化时，告知是否支持SACK技术。</p><p>kind=5：SACK实际工作，告知对方提前收到或重复收到的报文序列号，帮助对方精准重传或得知哪些报文重复收到。</p><p>kind=8：时间戳RTT，提供较为准确的计算双方回路时间RTT的算法，为流量控制等提供信息。</p><h3 id="26-TCP如何保证可靠性？"><a href="#26-TCP如何保证可靠性？" class="headerlink" title="26. TCP如何保证可靠性？"></a>26. TCP如何保证可靠性？</h3><ol><li>检验和：头部的检验和字段，有差错直接丢弃重传。</li><li>序列号/确认应答：根据序列号排序、去重，根据ACK决定发送内容。</li><li>滑动窗口：提高传输报文的效率，也避免发送过多产生异常。</li><li>超时重传：防止包丢失，保证包交付。</li><li>拥塞控制：保证TCP可靠交付的同时提高性能。</li><li>流量控制：避免大量丢包，提高传输效率。</li></ol><h3 id="27-ARQ协议"><a href="#27-ARQ协议" class="headerlink" title="27. ARQ协议"></a>27. ARQ协议</h3><p>自动重传请求，通过使用确认和超时两个机制，在不可靠服务的基础上实现可靠的信息传输。</p><h4 id="1-停止等待ARQ协议"><a href="#1-停止等待ARQ协议" class="headerlink" title="1. 停止等待ARQ协议"></a>1. 停止等待ARQ协议</h4><p>每发完一个分组就停止发送，等待对方确认。如果过了一段时间没收到确认，说明没有发送成功，需要重新发送。直到收到确认再发下一个分组。</p><p>接收方如果收到重复分组，丢弃该分组，但是还要发确认。</p><h4 id="2-连续ARQ协议"><a href="#2-连续ARQ协议" class="headerlink" title="2. 连续ARQ协议"></a>2. 连续ARQ协议</h4><p>发送方维持一个发送窗口，窗口内的分组可连续发送而不必等待确认。接收方一般累计确认，只对按序到达的最后一个分组确认，表明这个分组为止的所有分组都已正确收到。</p><p>优点：信道利用率高，容易实现。</p><p>缺点：不能向发送方反映出接收方已正确收到的所有分组的信息，容易导致发送方上传冗余报文。</p><h3 id="28-TCP重传与SACK"><a href="#28-TCP重传与SACK" class="headerlink" title="28. TCP重传与SACK"></a>28. TCP重传与SACK</h3><ol><li>超时重传：动态计算超时重传时间RTO</li><li>快速重传：收到三个相同的ACK报文时重传丢失的报文段。</li><li>SACK选择性确认：在TCP头部<strong>选项</strong>字段中加入SACK，将已收到停留在缓冲区的数据信息告知发送方。发送方可以据此只重传丢失的数据。</li><li>Duplicate SACK（D-SACK）（net.ipv4.tcp_dsack）：告知发送方哪些信息被重复接收。<strong>SACK范围比ACK大表示已收到的信息，比ACK小表示重复收到的信息。</strong><ol><li>让发送方知道是发出去的包丢了还是ACK丢了</li><li>知道是不是发送方的数据包被网络延迟</li><li>知到网络中是不是把发送方的数据包复制了</li></ol></li></ol><h2 id="2-特殊情况"><a href="#2-特殊情况" class="headerlink" title="2. 特殊情况"></a>2. 特殊情况</h2><h3 id="1-握手与挥手为什么不x次？"><a href="#1-握手与挥手为什么不x次？" class="headerlink" title="1. 握手与挥手为什么不x次？"></a>1. 握手与挥手为什么不x次？</h3><p>第三次握手是可以携带数据的，而前两次不行。</p><p>不两次握手：无法阻止历史连接的建立，造成资源浪费；如果服务端的SYN+ACK报文丢失，会造成客户端与服务端的初始序列号无法同步；服务端需要确认客户端能正常收到报文，所以需要客户端的回复。</p><p>不四次握手：服务端的ACK与同步信号SYN明显可以合并</p><p>不三次挥手：要三次挥手只能将被动方的ACK与FIN合并，但是在被动方收到ACK时可能还有数据要收发，这种情况下不能立刻断开连接。</p><p>TCP挥手有时候是3次的原因：被动断开方没有数据要发送，且开启了TCP延迟确认机制，第二次与第三次挥手会合并。</p><h3 id="2-必须三次握手的原因-为什么不能两次握手"><a href="#2-必须三次握手的原因-为什么不能两次握手" class="headerlink" title="2. 必须三次握手的原因/为什么不能两次握手"></a>2. 必须三次握手的原因/为什么不能两次握手</h3><ol><li>防止历史连接初始化连接：如果有之前申请建立连接的报文由于网络拥堵未能到达，客户端再次发送建立连接的请求，但是之前的报文先到达，这就叫历史连接。客户端在第三次握手时根据序列号或超时时间确认连接是否为历史连接，如果是则发送RST终结历史连接。</li><li>同步双方初始序列号：双方发送的携带初始序列号的报文都需要得到应答，才能确保同步，从而根据序列号进行去重、顺序接收、重发等后续操作。四次握手的中间两次可以合并，而两次握手不能保证服务端的序列号得到应答。</li><li>避免资源浪费：历史连接建立会成为冗余的连接，造成资源浪费。</li></ol><h3 id="3-SYN攻击"><a href="#3-SYN攻击" class="headerlink" title="3. SYN攻击"></a>3. SYN攻击</h3><p>攻击者伪造不同IP发送SYN报文给服务端，占满服务端的半连接队列。</p><p>应对措施：</p><ol><li>增大半连接队列（还需要一同增大全连接队列）。</li><li>改用cookie绕过半连接队列。但服务端计算cookie会占用大量CPU时间。</li><li>减少SYN+ACK重传次数从而加快半连接断开。</li></ol><h3 id="4-FIN-WAIT2中收不到第三次挥手"><a href="#4-FIN-WAIT2中收不到第三次挥手" class="headerlink" title="4. FIN_WAIT2中收不到第三次挥手"></a>4. FIN_WAIT2中收不到第三次挥手</h3><p>主动关闭方收到对方的ACK报文后，就会进入FIN_WAIT2状态，这时如果不收到第三次挥手：</p><ul><li>如果使用close函数关闭连接，就无法再收发数据，FIN_WAIT2状态持续一段时间（tcp_fin_timeout，默认为60）后直接关闭。</li><li>如果使用shutdown函数关闭连接，指定只关闭发送方向而不关闭接收方向，那么就会一直处于FIN_WAIT2状态。</li></ul><h3 id="5-建立连接后某一方出现故障"><a href="#5-建立连接后某一方出现故障" class="headerlink" title="5. 建立连接后某一方出现故障"></a>5. 建立连接后某一方出现故障</h3><ol><li>客户端：服务端会通过保活机制探测客户端是否活动。<ol><li>客户端重启成功：因为连接数据已清除，所以收到保活报文时返回RST，服务端收到RST则主动关闭连接。</li><li>客户端没有重启：服务端发送保活报文次数达到上限仍没有收到回应，则主动关闭连接。</li></ol></li><li>服务端：如果是进程崩溃，进程的连接资源会交给内核回收，内核主动与客户端完成四次挥手。</li></ol><h3 id="6-Socket的accept与listen"><a href="#6-Socket的accept与listen" class="headerlink" title="6. Socket的accept与listen"></a>6. Socket的accept与listen</h3><p>服务端接收到FIN报文后会在缓冲区后插入文件描述符EOF，应用程序在read到EOF时调用close关闭套接字，使服务器发出FIN包。</p><p>没有accept可以建立连接：accept只是从已建立的连接中取出一个可用的。</p><p>没有listen可以建立连接：客户端可以形成TCP自连接。客户端在connect方法时，将自己的连接信息放入内核的一个全局hash表中，消息经过回环地址重新回到TCP传输层时，根据IP+端口信息从hash表中取出信息，成功建立连接。</p><h3 id="7-TCP全连接队列满"><a href="#7-TCP全连接队列满" class="headerlink" title="7. TCP全连接队列满"></a>7. TCP全连接队列满</h3><p>TCP全连接队列已满时，是否需要放弃连接：通过修改tcp_abort_on_overflow参数。</p><ol><li>0：如果队列已满，server扔掉client发过来的ack。</li><li>1：如果队列已满，server发送RST包给client，表示废除握手过程和连接。</li><li>一般应当设置为0，因为有时服务器只是短暂繁忙，当队列有空位时再次接收到ACK请求仍然能成功建立连接。</li></ol><h3 id="8-TCP连接双方同时关闭"><a href="#8-TCP连接双方同时关闭" class="headerlink" title="8. TCP连接双方同时关闭"></a>8. TCP连接双方同时关闭</h3><p>两方发送FIN报文后等待ACK，都等来了FIN报文，因此都进入CLOSING状态，之后双方回复ACK确认对方发送通道关闭，进入TIME_WAIT状态。</p><h3 id="9-第一次握手的SYN包被丢弃"><a href="#9-第一次握手的SYN包被丢弃" class="headerlink" title="9. 第一次握手的SYN包被丢弃"></a>9. 第一次握手的SYN包被丢弃</h3><ol><li>半连接队列已满，且没开syncookie或全连接队列也已满。</li><li>开启了tcp_rw_recycle（快速回收），且客户端在NAT环境。</li></ol><h3 id="10-处于ESTABLISH状态的服务端收到了客户端的SYN报文"><a href="#10-处于ESTABLISH状态的服务端收到了客户端的SYN报文" class="headerlink" title="10. 处于ESTABLISH状态的服务端收到了客户端的SYN报文"></a>10. 处于ESTABLISH状态的服务端收到了客户端的SYN报文</h3><p>客户端掉线，重新连接后发送SYN给服务端。此时客户端IP与服务端IP、端口都没有变。</p><ol><li>端口号与历史连接不同：服务端认为需要建立新的连接。如果服务端向旧连接发送了数据，因为客户端该连接已经被关闭，会返回RST报文强制关闭，否则旧连接在TCP保活机制下释放。</li><li>端口号与历史连接相同：服务端会回复一个携带了正确序列号和确认号的ACK（Challenge ACK）。客户端收到后发现序列号不是自己所期望的，就会返回RST报文。</li><li>可以利用这个性质强行关闭连接。</li></ol><h3 id="11-挥手时被动关闭端的FIN报文比发送的数据更早到达另一方"><a href="#11-挥手时被动关闭端的FIN报文比发送的数据更早到达另一方" class="headerlink" title="11. 挥手时被动关闭端的FIN报文比发送的数据更早到达另一方"></a>11. 挥手时被动关闭端的FIN报文比发送的数据更早到达另一方</h3><p>服务端接收到FIN报文后会将文件描述符EOF放在接收缓冲区的末尾，应用程序在read到EOF时调用close关闭套接字，使服务器发出FIN包。</p><h3 id="12-TIME-WAIT状态下的TCP连接收到SYN"><a href="#12-TIME-WAIT状态下的TCP连接收到SYN" class="headerlink" title="12. TIME_WAIT状态下的TCP连接收到SYN"></a>12. TIME_WAIT状态下的TCP连接收到SYN</h3><ol><li>合法SYN：SYN比期望收到的下一个SYN大，且时间戳比最后收到的报文时间戳大：重用该四元组连接，直接进入SYN_RECV状态并返回SYN+ACK。</li><li>非法SYN：上述两个条件一项不成立：回复一个与第四次挥手一样的ACK报文（Challenge ACK），客户端收到后发现与期望的ACK不同（此时客户端为SYN_SENT状态），于是回复RST。</li><li>TIME_WAIT下收到RST：如果net.ipv4.tcp_rfc1337=0，TIME_WAIT会直接结束，否则丢弃。</li></ol><h3 id="13-连接的一方进程崩溃与主机崩溃"><a href="#13-连接的一方进程崩溃与主机崩溃" class="headerlink" title="13. 连接的一方进程崩溃与主机崩溃"></a>13. 连接的一方进程崩溃与主机崩溃</h3><p>进程崩溃时，内核会与该进程连接的对方进行挥手并回收资源，所以连接会正常关闭。</p><p>如果是主机崩溃：</p><ol><li>对方没有开启keepalive机制：<ol><li>双方没有数据交互：对方的连接将一直是ESTABLISHED状态，直至对方内核重启。</li><li>迅速重启且对方发送了数据：回复RST。</li><li>一直没有重启且对方发送了数据：对方达到重传上限后主动断开。</li></ol></li><li>对方开启了：keepalive探测到主机崩溃，返回消息后对方主动断开。</li></ol><h3 id="14-考虑TCP连接是否断开一定要考虑有无数据传输与keepalive机制两个方面"><a href="#14-考虑TCP连接是否断开一定要考虑有无数据传输与keepalive机制两个方面" class="headerlink" title="14. 考虑TCP连接是否断开一定要考虑有无数据传输与keepalive机制两个方面"></a>14. 考虑TCP连接是否断开一定要考虑有无数据传输与keepalive机制两个方面</h3><h3 id="15-TCP与UDP可以绑定相同的端口"><a href="#15-TCP与UDP可以绑定相同的端口" class="headerlink" title="15. TCP与UDP可以绑定相同的端口"></a>15. TCP与UDP可以绑定相同的端口</h3><p>由主机根据<strong>IP包头的协议号字段</strong>判断将信息送给哪个模块处理。</p><h3 id="16-收到Seq号不符合期望的报文"><a href="#16-收到Seq号不符合期望的报文" class="headerlink" title="16. 收到Seq号不符合期望的报文"></a>16. 收到Seq号不符合期望的报文</h3><p>客户端：</p><ul><li>SYN-SENT状态：回复RST。</li><li>非SYN-SENT状态：丢弃。</li></ul><p>服务端：</p><ul><li>非LISTEN状态：回复Challege-ACK报文，指示期望收到的Seq号。</li><li>LISTEN状态：都还没收到过报文，当然直接接收并回复SYN+ACK了。</li></ul><p>客户端SYN-SENT回RST而不是丢弃的原因：</p><ul><li>服务端已经存在一个相同四元组的旧连接，如果不删除该连接，服务端无法确认新连接，只会一直回复旧连接的Challenge-ACK。</li><li>如果选择丢弃，双方都会触发超时重传，然后依然无法连接，直到最大重传次数后CLOSE，严重浪费时间。</li></ul><h3 id="17-客户端连接不存在的IP-端口"><a href="#17-客户端连接不存在的IP-端口" class="headerlink" title="17. 客户端连接不存在的IP/端口"></a>17. 客户端连接不存在的IP/端口</h3><p>TCP连接不存在的IP：</p><ul><li>目的IP与源IP在同一局域网：卡在本机数据链路层无法发送。因为ARP找不到IP对应的MAC，所以无法形成帧头部。</li><li>目的IP与源IP不在同一局域网：得不到ACK，超时重传到最大次数后释放连接。路由器会进行转发，但因为目标IP地址不存在，所以SYN报文最终在网络中消亡或被找不到转发端口的路由表丢弃。</li></ul><p>TCP连接不存在的端口：目标设备收到后，发现没有服务监听该端口，就回复RST，客户端收到RST后释放连接。</p><p>发送UDP到不存在的端口：目标设备<strong>网络层</strong>看到没有进程在监听指定的协议端口，由IP回复ICMP报文，告知“目标端口不可达”。</p><h3 id="18-常见网络攻击"><a href="#18-常见网络攻击" class="headerlink" title="18. 常见网络攻击"></a>18. 常见网络攻击</h3><h4 id="1-IP欺骗"><a href="#1-IP欺骗" class="headerlink" title="1. IP欺骗"></a>1. IP欺骗</h4><p>伪造某台主机的IP地址，清空已经建立好的连接。</p><p>缓解：入口过滤，检查传入的IP数据包并确认其源标头。</p><h4 id="2-SYN洪泛攻击"><a href="#2-SYN洪泛攻击" class="headerlink" title="2. SYN洪泛攻击"></a>2. SYN洪泛攻击</h4><p>发送海量SYN报文，塞满服务器半连接队列，耗尽系统资源。</p><p>攻击者还可伪造SYN报文IP地址，阻止服务器屏蔽单一源地址。</p><p>缓解：</p><ul><li>增大半连接、全连接队列。</li><li>减少重传次数。</li><li>cookie。</li></ul><h4 id="3-UDP洪泛攻击"><a href="#3-UDP洪泛攻击" class="headerlink" title="3. UDP洪泛攻击"></a>3. UDP洪泛攻击</h4><p>发送海量UDP报文，让服务器利用资源检查是否有程序在端口接收数据包、用ICMP响应，耗尽系统资源。</p><p>缓解：操作系统限制ICMP报文响应速率。</p><h4 id="4-HTTP洪泛攻击"><a href="#4-HTTP洪泛攻击" class="headerlink" title="4. HTTP洪泛攻击"></a>4. HTTP洪泛攻击</h4><p>利用大量HTTP请求使目标达到饱和，无法响应正常流量，出现拒绝服务。</p><p>防护：</p><ul><li>对发出请求的设备询问。</li><li>防火墙</li><li>管理IP信誉数据库。</li></ul><h4 id="5-DNS洪泛攻击"><a href="#5-DNS洪泛攻击" class="headerlink" title="5. DNS洪泛攻击"></a>5. DNS洪泛攻击</h4><p>利用大量DNS请求中断该域的DNS解析。</p><h4 id="6-TCP重置攻击"><a href="#6-TCP重置攻击" class="headerlink" title="6. TCP重置攻击"></a>6. TCP重置攻击</h4><p>攻击者伪造消息断开连接。利用Challenge ACK。</p><h4 id="7-中间人攻击"><a href="#7-中间人攻击" class="headerlink" title="7. 中间人攻击"></a>7. 中间人攻击</h4><p>对通信双方冒充对方，充当第三方分别与双方通信。</p><p>防范：CA证书</p><h4 id="8-DDOS"><a href="#8-DDOS" class="headerlink" title="8. DDOS"></a>8. DDOS</h4><p>分布式拒绝服务。</p><p>即处于不同位置的多个攻击者通过大量的流量淹没服务器，消耗带宽与系统资源，最终导致网络瘫痪，停止提供正常服务。</p><p>洪泛攻击都是DDoS攻击。</p><p>应对：</p><ul><li>高防服务器</li><li>黑名单</li><li>DDoS清洗：对用户请求数据实时监控，及时发现异常流量并清理。</li><li>CDN加速：将流量分散到各个节点，隐藏真实IP，同时降低负载。</li></ul><h4 id="9-前向攻击"><a href="#9-前向攻击" class="headerlink" title="9. 前向攻击"></a>9. 前向攻击</h4><p>故意拒绝高版本的TLS，让对方改为使用低版本的TLS通信，从而利用低版本TLS中的漏洞。</p><p>应对：删除对低版本TLS的支持。</p><h4 id="10-重放攻击"><a href="#10-重放攻击" class="headerlink" title="10. 重放攻击"></a>10. 重放攻击</h4><p>截取发送方的报文，然后原样发送给接收方。接收方会以为攻击者才是发送方，将响应报文发送给攻击方。</p><p>应对：</p><ul><li>发送方对时间戳签名，接收方接收时先验证签名。</li><li>加递增的流水号。</li></ul><h2 id="19-出现大量TIME-WAIT状态的连接"><a href="#19-出现大量TIME-WAIT状态的连接" class="headerlink" title="19. 出现大量TIME_WAIT状态的连接"></a>19. 出现大量TIME_WAIT状态的连接</h2><ul><li>没有开启HTTP长连接。</li><li>HTTP长连接超时或设有请求次数限制，导致到达超时时间或规定次数时，服务端主动断开大量连接。</li></ul><h1 id="4-IP"><a href="#4-IP" class="headerlink" title="4. IP"></a>4. IP</h1><p>作用：实现主机与主机之间的点对点通信。</p><h2 id="1-与链路层"><a href="#1-与链路层" class="headerlink" title="1. 与链路层"></a>1. 与链路层</h2><p>MAC实现直连的两个设备之间的通信，而IP负责在没有直连的两个网络之间通信传输。</p><h2 id="2-地址分类"><a href="#2-地址分类" class="headerlink" title="2. 地址分类"></a>2. 地址分类</h2><ol><li>A类地址：0.0.0.0 ~ 127.255.255.255。私有IP：10.0.0.0 ~ 10.255.255.255</li><li>B类地址：128.0.0.0 ~ 191.255.255.255。私有IP：172.16.0.0 ~ 172.31.255.255</li><li>C类地址：192.0.0.0 ~ 223.255.255.255。私有IP：192.168.0.0 ~ 192.168.255.255</li><li>D类地址：224.0.0.0 ~ 239.255.255.255：没有主机号，常被用于多播</li><li>E类地址：240.0.0.0 ~ 255.255.255.255：没有主机号，暂未使用</li></ol><h2 id="3-多播"><a href="#3-多播" class="headerlink" title="3. 多播"></a>3. 多播</h2><p>将包发送给特定组内的所有主机，与广播不同，多播可以穿透路由器。</p><h2 id="4-环回地址"><a href="#4-环回地址" class="headerlink" title="4. 环回地址"></a>4. 环回地址</h2><p>127.0.0.1/localhost主机名。使用该IP地址或主机名时，数据包不会流向网络。</p><h2 id="5-IPv6"><a href="#5-IPv6" class="headerlink" title="5. IPv6"></a>5. IPv6</h2><ol><li>特点：<ol><li>可分配地址大大增加</li><li>可自动配置，即使没有DHCP服务器也可以自动分配IP地址</li><li>包头长度固定40字节，去掉包头校验和，简化首部结构，大大提高传输性能</li><li>能应对伪造IP地址的网络安全功能以及防止线路窃听功能</li></ol></li><li>首部改进：<ol><li>取消了首部校验和字段（因为数据链路层和传输层都会校验）</li><li>取消了分片重组相关字段，只允许在源与目的主机分片重组，提高了转发速度</li><li>取消选项字段从而固定头部长度，选项字段可能出现在IPv6首部的“下一个首部”指出的位置上</li></ol></li></ol><h2 id="6-其他协议"><a href="#6-其他协议" class="headerlink" title="6. 其他协议"></a>6. 其他协议</h2><h3 id="1-RARP"><a href="#1-RARP" class="headerlink" title="1. RARP"></a>1. RARP</h3><p>已知MAC地址求IP地址，通常需要架设RARP服务器，并在服务器上注册设备的MAC地址及其IP地址。</p><h3 id="2-DHCP"><a href="#2-DHCP" class="headerlink" title="2. DHCP"></a>2. DHCP</h3><p>动态获取IP地址。客户端进程监听68号端口，服务端进程监听67号端口。</p><ol><li>客户端发起DHCP DISCOVER的IP数据包，使用UDP广播通信，0.0.0.0作为源IP地址，广播地址作为目标地址。</li><li>DHCP服务器用DHCP OFFER响应，广播地址作为目标地址，报文信息携带服务器提供的可租约IP地址、子网掩码、默认网关、DNS服务器以及IP地址租用期。</li><li>客户端收到多个服务器的DHCP OFFER后选择一个，发送DHCP REQUEST回显配置的参数。</li><li>服务端用DHCP ACK响应，应答要求的参数。</li><li>租约的DHCP IP地址快到期时，客户端会发送DHCP请求报文<ol><li>如果服务器同意继续租用，就回应DHCP ACK并延长租期</li><li>如果服务器不同意，回应DHCP NACK，客户端停止使用IP地址</li></ol></li><li>DHCP交互中全程使用UDP广播通信。为了解决<strong>DHCP服务器和客户端不在一个局域网内</strong>的问题，需要由<strong>DHCP中继代理交互</strong>。中继代理之间以及与服务器之间采用单播的方式。</li></ol><h3 id="3-NAT"><a href="#3-NAT" class="headerlink" title="3. NAT"></a>3. NAT</h3><p>网络地址转换</p><p>改进：网络地址与端口转换NAPT：将IP地址+端口号一起转换，这样可以只用一个全球IP地址。</p><ol><li>缺点：<ol><li>外部无法主动与NAT内部服务器建立连接</li><li>转换表的生成与转换操作都会产生性能开销</li><li>通信过程中如果NAT重启，所有TCP连接都会重置</li></ol></li><li>解决：<ol><li>改用IPv6，每台设备配置一个公有地址</li><li>NAT穿透技术：客户端主动获得NAT设备公有IP并建立端口映射条目，然后用该条目对外通信。</li></ol></li></ol><h3 id="4-ICMP"><a href="#4-ICMP" class="headerlink" title="4. ICMP"></a>4. ICMP</h3><p>互联网控制报文协议</p><p>确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。如果某个IP包未能达到目标地址，由ICMP负责通知。</p><ol><li><p>查询报文类型：回送消息：类型0和8：可以向对端主机发送回送请求消息（8），也可以接收对端主机发回的回送应答消息（0）</p></li><li><p>差错报文类型</p><ol><li><p>目标不可达消息（3）：IP路由器无法将IP数据包发送给目标地址，同时在消息中显示不可达的具体原因</p><ol><li>0：网络不可达；1；主机不可达；2：协议不可达；3：端口不可达；4：需要分片但设置了未分片</li></ol></li><li><p>原点抑制消息（4）：当路由器向低速线路发送数据时，其发送队列的缓存变为0而无法发送出去，可以向IP包源地址发送一个ICMP原点抑制消息。收到包的主机了解在整个项目的某一处发生了拥堵，从而增大IP包传输间隔。可能引起不公平的网络通信。</p></li><li><p>重定向消息（5）：路由器发现发送端主机使用了不是最优的路径发送数据，它会返回ICMP重定向消息，包含最合适的路由信息和源数据。</p></li><li><p>超时消息（11）：TTL=0时路由器发送ICMP超时消息给发送端主机</p></li></ol></li></ol><h3 id="5-IGMP"><a href="#5-IGMP" class="headerlink" title="5. IGMP"></a>5. IGMP</h3><p>因特网组管理协议</p><p>工作在主机（被组播对象）和最后一跳路由之间</p><ol><li>功能：向路由器申请加如何退出组播组，然后路由器就会记录IGMP路由器表。</li><li>版本：IGMPv1、IGMPv2、IGMPv3.</li><li>常规查询与响应工作机制：<ol><li>路由器周期性发送目标地址为224.0.0.1（同一网段内所有主机和路由器）的IGMP常规查询报文</li><li>主机收到查询，启动报告延迟计时器，超时后就发送IGMP成员关系报告报文（目标IP地址为组播地址）；如果超时前收到了同一组内其他成员的报告报文，就不再发送。</li><li>路由器收到报告报文后在IGMP路由表中加入该组播组</li></ol></li><li>离开组播组工作机制：<ol><li>主机发送IGMPv2离组报文，目标地址224.0.0.2（网段内所有路由器）</li><li>路由器收到后，以1s为间隔连续发送IGMP特定组查询报文，以确认该网络是否还有组的其他成员。</li><li>如果还有主机是成员，则立即响应，路由器知道还有组后会继续转发组播数据包；否则不再转发。</li></ol></li></ol><h2 id="7-ping"><a href="#7-ping" class="headerlink" title="7. ping"></a>7. ping</h2><p>ping基于ICMP，使用查询报文类型：回送消息：类型0和8：可以向对端主机发送回送请求消息（8），也可以接收对端主机发回的回送应答消息（0）。</p><h2 id="8-traceroute"><a href="#8-traceroute" class="headerlink" title="8. traceroute"></a>8. traceroute</h2><ol><li>故意设置特殊TTL追踪去往目的地时沿途经过的路由器：利用TTL，从1开始按照递增顺序发送UDP包，强制接收ICMP超时消息；路径上的路由器依次接收到TTL=0的报文，就会返回ICMP差错报文，类型是时间超时；发送UDP包时会填入不可能的端口号33434，这样到达目的地时返回的就是“端口不可达”的ICMP。</li><li>故意设置不分片从而确认路径MTU：每次收到ICMP就减少包的大小，来定位一个合适的MTU。</li></ol><h1 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h1><h2 id="1-RDMA"><a href="#1-RDMA" class="headerlink" title="1. RDMA"></a>1. RDMA</h2><p>远程直接内存访问技术。</p><p>相对于DMA技术。DMA技术可以让外部设备绕过CPU直接访问主存，而RDMA技术还能让外部设备访问另一台远端主机上用户态的主存。</p><p>与传统的基于socket的通信：基于socket的通信通过特定API管理程序行为，RDMA技术仅使用操作系统建立一个通道，就能在不需要操作系统干预的情况下进行应用程序间消息传递。</p><p>通过网络把资料直接传入计算机的存储区，将数据从一个系统快速移动到远程系统存储器，而不影响操作系统。消除了外部存储器复制和上下文切换的开销，能解放内存带宽和CPU周期。</p><p>特点：</p><ul><li>无需CPU干预</li><li>内核旁路：应用程序可绕过内核，在用户态传输数据</li><li>零拷贝：每个应用程序能直接访问集群中设备的虚拟内存。数据能直接在缓冲区接收与发送，不必复制到网络层。</li><li>异步接口：实现计算与通信分离。</li></ul><p>InfiniBand（IB）、以太网RoCE、以太网iWARP支持RDMA。</p><h3 id="1-传统TCP-IP通信的问题"><a href="#1-传统TCP-IP通信的问题" class="headerlink" title="1. 传统TCP/IP通信的问题"></a>1. 传统TCP/IP通信的问题</h3><p>I/O瓶颈问题：高速网络环境下与网络I/O相关的主机处理的高开销（数据移动和复制操作）限制了机器间的传输带宽。</p><ul><li>低性能：通过内核发送消息，内核态与用户态的切换，以及内核中的封装与解包造成大量开销。</li><li>低灵活性：内核很难更新，导致难以支持新的网络协议和消息通信协议。</li></ul><h3 id="2-一些前置技术"><a href="#2-一些前置技术" class="headerlink" title="2. 一些前置技术"></a>2. 一些前置技术</h3><p>TCP Offloading：将主机封装多层网络协议的工作转移到网卡。</p><p>U-Net Networking：移动协议栈到用户空间，并从数据通信路径中彻底删除内核。</p><ul><li>带来了高性能与高灵活性。</li><li>为每个进程提供了一种拥有网络接口的错觉。</li></ul><h3 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h3><p>Memory verbs：多用于数据类报文</p><ul><li>read：从远程主机读取部分内存。<ul><li>调用前，远程主机提供适当权限。</li><li>调用者指定远程虚拟地址，像本地内存地址一样拷贝。可以在不通知远程主机的情况下执行。</li></ul></li><li>write：与read相对应。带即时数的写操作会将即时数通知给远程主机</li><li>atomic：原子取、加、比较和交换</li></ul><p>Messaging verbs：多用于连接控制类报文</p><ul><li>send：把数据发送到远程QP的接收队列。<ul><li>接收端事先注册接收缓冲区，负责其维护和发布。</li><li>发送方可选择使用即时数，用于发送到接收端作为接收的通知。</li></ul></li><li>receive：与发送操作相对应。</li></ul><h3 id="4-传输模式"><a href="#4-传输模式" class="headerlink" title="4. 传输模式"></a>4. 传输模式</h3><ul><li>可靠连接RC：QP一对一相连，消息从一个QP发送队列发送到另一个的接收队列。数据包按序交付，类似TCP。</li><li>不可靠连接UC：QP一对一相连，数据包可能丢失。传输层出错的消息不重传，需要高层协议处理。</li><li>不可靠数据包UD：一个QP可与其他任意UD、QP传输，不保证按序交付，交付的数据可能被丢弃。支持多播，类似UDP。</li></ul><h3 id="5-工作过程"><a href="#5-工作过程" class="headerlink" title="5. 工作过程"></a>5. 工作过程</h3><ul><li>一个应用执行RDMA读/写请求时，不执行任何复制，不需要任何内核内存参与，RDMA请求从用户空间应用发到本地网卡。</li><li>网卡读取缓冲内容，通过网络传送到远端网卡。</li><li>网络上传输的RDMA信息包括目标虚拟地址、内存钥匙和数据本身。请求可完全在用户空间中处理，也可以在应用一直睡眠到请求完成的情况下通过系统中断处理。</li><li>远程网卡确认内存钥匙，直接将数据写入本地应用缓存。</li></ul><h3 id="6-消息队列"><a href="#6-消息队列" class="headerlink" title="6. 消息队列"></a>6. 消息队列</h3><p>提供基于消息队列的点对点通信。</p><p>应用需要通信时，创建一条Channel连接，其首尾断点是队列对QP，每个QP由发送队列SQ和接收队列RQ。QP映射到应用的虚拟地址空间，因此应用可通过其直接访问远程网卡。</p><p>工作队列WQ：SQ/RQ，根据当前应用是发送/接收数据。</p><p>完成队列CQ：知会用户WQ上的消息已经被处理完。</p><p>一个工作队列的元素WQE对应一个完成队列的元素CQE</p><p>提供了一套软件传输接口，方便用户创建传输请求WR。</p><ul><li>WR中描述应用希望传输到Channel对端的消息。</li><li>WR通知QP中的某个WQ。</li><li>WQ中用户的WR被转换为工作队列元素WQE，等待远程网卡的异步调度解析，并从WQE指向的buffer中拿到真正的消息发送到Channel对端。</li></ul><h3 id="7-RDMA-READ"><a href="#7-RDMA-READ" class="headerlink" title="7. RDMA READ"></a>7. RDMA READ</h3><ol><li>A、B建立链接，初始化QP</li><li>数据存储在B的buffer地址VB，VB提前注册到B的网卡，拿到内存钥匙。</li><li>B把VB、key封装成报文传送到A，同时在WQ中注册一个WR，用于接收数据传输的A返回的状态。</li><li>A收到B的报文后，网卡将VB、key连同VA封装到RDMA READ请求，发送给B。AB两端不需要任何软件参与，就能将B的数据存储到A的虚拟地址。</li><li>A存储完后向B返回整个数据传输的状态信息。</li></ol><p>只需要提供远程访问的虚拟地址，不需要应用参与，适用于批量数据传输。</p><h3 id="8-RDMA-WRITE"><a href="#8-RDMA-WRITE" class="headerlink" title="8. RDMA WRITE"></a>8. RDMA WRITE</h3><ol><li>A、B建立链接，初始化QP</li><li>数据要存储在B的buffer地址VB，VB提前注册到B的网卡，拿到返回的内存钥匙。</li><li>B把VB、key封装成报文传送到A，同时在WQ中注册一个WR，用于接收数据传输的A返回的状态。</li><li>A收到B的报文后，网卡将VB、key连同VA封装到RDMA WRITE请求，发送给B。AB两端不需要任何软件参与，就能将B的数据存储到A的虚拟地址。</li><li>A发送数据完后向B返回整个数据传输的状态信息</li></ol><h3 id="9-RDMA-SEND-RECIEVE"><a href="#9-RDMA-SEND-RECIEVE" class="headerlink" title="9. RDMA SEND/RECIEVE"></a>9. RDMA SEND/RECIEVE</h3><p>双边操作必须要远端应用感知才能完成收发。</p><p>A向B发送数据</p><ul><li>AB各自创建并初始化QP、CQ</li><li>AB分别向WQ中注册WQE。A的WQ=SQ，WQE描述指向一个等待被发送的数据；B的WQ=RQ，WQE描述指向一块用于存储数据的buffer。</li><li>A的网卡异步调度到A的WQE，解析到SEND消息，从buffer直接向B发送数据。</li><li>数据流到B的网卡后，B的WQE被消耗，将数据直接存储到WQE指向的存储位置。</li><li>AB通信完成后，A的CQ产生一个完成消息CQE表示发送完成，B的CQ产生一个完成消息CQE表示接收完成。每个WQE处理完成都会产生一个CQE。</li></ul><p>与传统通信的区别在于零拷贝、绕过内核。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-网络是怎样连接的6</title>
      <link href="/2022/11/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%846/"/>
      <url>/2022/11/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%846/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的-读书笔记6"><a href="#网络是怎样连接的-读书笔记6" class="headerlink" title="网络是怎样连接的 读书笔记6"></a>网络是怎样连接的 读书笔记6</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>突然发现45章有一大半都是讲运营商的，感觉看了跟没看似的……</p><p>不过终于快把这本书啃完了，后续的计划大概是操作系统、计网方面复习，然后MYSQL和Redis得学习一下，毕竟时间不多了。</p><h2 id="6-1-服务器概述"><a href="#6-1-服务器概述" class="headerlink" title="6.1 服务器概述"></a>6.1 服务器概述</h2><h3 id="6-1-1-与客户端的区别"><a href="#6-1-1-与客户端的区别" class="headerlink" title="6.1.1 与客户端的区别"></a>6.1.1 与客户端的区别</h3><p>服务器端的硬件与操作系统与客户端有所不同，但网络相关的部分功能规格都是统一的。</p><p>服务器在连接过程中是等待连接的一方，因此调用的Socket库不同。</p><p>此外，服务器的程序可以同时和多台客户端进行通信。</p><h3 id="6-1-2-服务器程序的结构"><a href="#6-1-2-服务器程序的结构" class="headerlink" title="6.1.2 服务器程序的结构"></a>6.1.2 服务器程序的结构</h3><p>服务器程序的结构可分为两个模块，等待连接模块和负责通信的模块。</p><ol><li>服务器程序启动并初始化，运行等待连接模块。</li><li>等待连接模块创建套接字，然后进入等待连接的暂停状态。</li><li>监听到客户端发起的连接，恢复运行并接受连接，然后启动客户端通信模块，并移交完成连接的套接字。</li><li>客户端通信模块使用已连接的套接字与客户端通信，并在通信结束后退出。</li></ol><p>也可以事先启动多个通信模块，在有连接到来时从空闲的模块中选择一个处理。</p><h3 id="6-1-3-服务端的套接字和端口号"><a href="#6-1-3-服务端的套接字和端口号" class="headerlink" title="6.1.3 服务端的套接字和端口号"></a>6.1.3 服务端的套接字和端口号</h3><p>服务端的具体工作流程：</p><ol><li>协议栈调用socket创建套接字。</li><li>调用bind将端口号写入套接字中。具体的端口号根据服务器程序的种类，按照规则确定。</li><li>协议栈调用listen向套接字写入等待连接状态这一控制信息，套接字进入等待连接状态。</li><li>协议栈调用accept等待并接受客户端的连接，然后返回响应包，给等待连接的套接字复制一个副本，将连接对象等控制信息写入新的套接字中。原来的套接字仍然以等待连接的状态继续存在。</li><li>等待连接模块启动客户端通信模块，将连接好的新套接字转交给通信模块，由其负责通信操作。</li></ol><p>为了客户端能判断收到的包是由连接对象返回的，新套接字和原来的套接字共享一个端口号。</p><p>这样会导致一个端口号对应多个套接字，为了判断具体对应的套接字，在确定套接字时要使用客户端、服务端的IP地址、端口号4个信息判断。</p><p>使用描述符指代套接字的原因：等待连接的套接字中没有客户端的信息；描述符信息更为简单。</p><h2 id="6-2-服务器的接收操作"><a href="#6-2-服务器的接收操作" class="headerlink" title="6.2 服务器的接收操作"></a>6.2 服务器的接收操作</h2><h3 id="6-2-1-网卡的信息转换"><a href="#6-2-1-网卡的信息转换" class="headerlink" title="6.2.1 网卡的信息转换"></a>6.2.1 网卡的信息转换</h3><ol><li>网卡接收到电信号，转换为数字信息。</li><li>根据包末尾的帧校验序列FCS校验错误，如果产生错误需要丢弃。</li><li>检查MAC头部的接收方MAC地址，如果接收者不是自己需要丢弃，否则保存在网卡内部的缓冲区中，并通过中断事件将网络包到达的事件告知CPU。</li><li>CPU暂停当前工作并切换到网卡任务，读取缓冲区中的包，根据据MAC头部的以太类型字段判断协议种类，并调用负责处理该协议的软件。</li></ol><h3 id="6-2-2-IP模块的接收操作"><a href="#6-2-2-IP模块的接收操作" class="headerlink" title="6.2.2 IP模块的接收操作"></a>6.2.2 IP模块的接收操作</h3><p>如果处理的是TCP/IP协议栈：</p><ol><li>检查IP头部格式是否规范，检查接收方IP地址是不是自己，不是则像路由器一样根据路由表转发。</li><li>检查IP头部看包是否分片，如果分片则将包暂存在内存中，等所有分片到达之后组装还原。</li><li>检查IP头部的协议号字段，并将包转交给相应的模块。</li></ol><h3 id="6-2-3-TCP模块处理连接包"><a href="#6-2-3-TCP模块处理连接包" class="headerlink" title="6.2.3 TCP模块处理连接包"></a>6.2.3 TCP模块处理连接包</h3><p>如果TCP头部中SYN=1，表示这是一个发起连接的包。</p><ol><li>检查包的接收方端口号，确认在该端口上有没有与接收方端口号相同且处在等待连接状态的套接字，如果没有则向客户端返回错误统治的包。</li><li>为该套接字复制一个副本并为其初始化与分配发送缓冲区与接收缓冲区的内存空间，然后生成TCP头部，委托IP模块发送给客户端。</li></ol><h3 id="6-2-4-TCP模块处理数据包"><a href="#6-2-4-TCP模块处理数据包" class="headerlink" title="6.2.4 TCP模块处理数据包"></a>6.2.4 TCP模块处理数据包</h3><ol><li>检查收到的包对应的套接字，找到4个信息全部匹配的套接字。</li><li>对比套接字中保存的数据收发状态与收到的包中TCP头部的信息是否匹配。如果无异常则将收到的数据放入接收缓冲区。</li><li>生成确认应答的TCP头部，委托IP模块发送给客户端。</li><li>应用程序调用read获取缓冲区的数据。</li><li>控制流程转移到服务器程序，对收到的数据进行处理并返回。</li></ol><h3 id="6-2-5-TCP模块断开"><a href="#6-2-5-TCP模块断开" class="headerlink" title="6.2.5 TCP模块断开"></a>6.2.5 TCP模块断开</h3><p>断开操作可以由客户端与服务端任意一方发起。在HTTP 1.0中由服务端发起。</p><ol><li>服务器程序调用close，TCP模块生成FIN=1的TCP头部，委托IP模块发送给客户端。</li><li>客户端收到后返回ACK号，并调用close生成一个FIN=1的TCP头部发给服务器。</li><li>服务器返回ACK。</li><li>套接字经过一段时间后被删除。</li></ol><h2 id="6-3-Web服务器程序解释与相应请求消息"><a href="#6-3-Web服务器程序解释与相应请求消息" class="headerlink" title="6.3 Web服务器程序解释与相应请求消息"></a>6.3 Web服务器程序解释与相应请求消息</h2><h3 id="6-3-1-url转化为实际文件名"><a href="#6-3-1-url转化为实际文件名" class="headerlink" title="6.3.1 url转化为实际文件名"></a>6.3.1 url转化为实际文件名</h3><p>如果完全按照URI中的路径和文件名读取，意味着Web服务器上所有资源都可访问，十分危险。</p><p>因此，Web服务器公开的目录是虚拟目录，在读取文件时首先需要查询虚拟目录与实际目录之间的对应关系，转换成实际的文件名才能读取。</p><p>如果文件名省略，一般会读取默认文件名index.html。</p><h3 id="6-3-2-运行CGI程序"><a href="#6-3-2-运行CGI程序" class="headerlink" title="6.3.2 运行CGI程序"></a>6.3.2 运行CGI程序</h3><p>如果URI指定的内容是一个程序，服务器需要运行该程序，将输出数据返回。</p><p>服务器收到请求消息之后，先判断URI指定的文件是否为程序。如果为程序，Web服务器委托操作系统运行程序，然后从请求消息中取出数据交给程序。如果方法为GET则将URI后面的参数传递给程序，如果方法为POST则将消息体中的数据传递给程序。</p><h3 id="6-3-3-访问控制"><a href="#6-3-3-访问控制" class="headerlink" title="6.3.3 访问控制"></a>6.3.3 访问控制</h3><p>Web服务器的访问控制规则主要有：</p><ol><li>客户端IP地址。</li><li>客户端域名：首先使用DNS服务器，根据客户端IP地址查询域名（为了防止假域名还会用域名反查IP地址）。如果两者一致则检查相应的访问控制规则，判断是否允许访问。</li><li>用户名和密码：Web服务器向客户端发送一条响应消息，告诉用户需要输入用户名和密码。服务器收到后检查是否与设置好的一致。</li></ol><h3 id="6-3-4-返回响应消息"><a href="#6-3-4-返回响应消息" class="headerlink" title="6.3.4 返回响应消息"></a>6.3.4 返回响应消息</h3><p>web服务器调用write，将响应消息交给协议栈，让协议栈根据描述符发送。</p><h2 id="6-4-浏览器接收响应消息并显示内容"><a href="#6-4-浏览器接收响应消息并显示内容" class="headerlink" title="6.4 浏览器接收响应消息并显示内容"></a>6.4 浏览器接收响应消息并显示内容</h2><h3 id="6-4-1-判断内容"><a href="#6-4-1-判断内容" class="headerlink" title="6.4.1 判断内容"></a>6.4.1 判断内容</h3><p>根据响应消息开头的content-type头部字段的值判断数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure><p>左边的部分为主类型，表示数据的大分类；右边的子类型表示及具体的数据分类。如果数据类型为文本，charset表示文本编码信息的方式。</p><p>有时候还需要结合其他信息综合判断数据类型。</p><h3 id="6-4-2-浏览器显示网页内容"><a href="#6-4-2-浏览器显示网页内容" class="headerlink" title="6.4.2 浏览器显示网页内容"></a>6.4.2 浏览器显示网页内容</h3><p>HTML文档通过标签表示文档的布局和字体等样式信息，浏览器需要解释这些标签的含义，按照指定的样式显示文档内容。</p><p>HTML文档中只有表示图片引用的标签，在读取到时会向服务器请求其中的图片文件，然后将图片嵌入到标签所在的位置。</p><p>对于文字处理、幻灯片等浏览器无法自行显示的数据，浏览器会调用相应的程序，被调用的程序负责显示相应的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习-线段树</title>
      <link href="/2022/10/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/10/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线段树-学习笔记"><a href="#线段树-学习笔记" class="headerlink" title="线段树 学习笔记"></a>线段树 学习笔记</h1><h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>树状数组无法满足求给定区间的最大最小值，或是将给定区间全部修改为某一个值的操作。</p><p>思想：</p><ul><li>分治：某一段区间的问题可分割为更小区间的子问题求解。</li><li>完全二叉树：子节点的下标可由父节点计算得到。</li></ul><p>以求区间和的线段树为例，代表区间 [l, r] 的结点 tree[i]，其左子结点 tree[2 * i] 表示区间 [l, (l + r) / 2)] 的区间和；其右子结点 tree[2 ∗ i + 1] 表示区间 [(l + r) / 2 + 1, r] 的区间和。</p><h2 id="2-初始化-单点修改-区间查询"><a href="#2-初始化-单点修改-区间查询" class="headerlink" title="2. 初始化/单点修改/区间查询"></a>2. 初始化/单点修改/区间查询</h2><p>一般初始化为4 * n大小</p><h3 id="2-1-单点修改"><a href="#2-1-单点修改" class="headerlink" title="2.1 单点修改"></a>2.1 单点修改</h3><p>总体为后序遍历。</p><p>将要修改的值沿树一路传递下去，直到到达叶子节点实现单点修改。</p><p>在返回值时，需要更新父节点的值为两个子节点的值的和。</p><h3 id="2-2-区间查询"><a href="#2-2-区间查询" class="headerlink" title="2.2 区间查询"></a>2.2 区间查询</h3><p>如果目前找到的线段树表示的区间是待查询区间的子集，则直接返回当前节点的值。</p><p>否则，将当前表示的区间折半分为两部分，分别对左区间与右区间递归查询，最后将递归查询的结果汇总。</p><p>求区间和/区间最值时，只需要将父节点的更新行为更改成求和/求最值即可。</p><p>同样是<a href="">LeetCode 307. 区间和检索-数组可修改</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">         tree[i] = tree[i * <span class="number">2</span>] + tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">         n = nums.size();</span><br><span class="line">         tree = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span> * n, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">             update(i, nums[i]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">             tree[i] = val;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span> (mid &gt;= index) update2(index, val, l, mid, i * <span class="number">2</span>);</span><br><span class="line">         <span class="keyword">else</span> update2(index, val, mid + <span class="number">1</span>, r, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">         pushUp(i);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">         update2(index, val, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">sumRange2</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (left &lt;= l &amp;&amp; r &lt;= right) <span class="keyword">return</span> tree[i];</span><br><span class="line">         <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span> (left &lt;= mid) sum += sumRange2(left, right, l, mid, i * <span class="number">2</span>);</span><br><span class="line">         <span class="keyword">if</span> (right &gt; mid) sum += sumRange2(left, right, mid + <span class="number">1</span>, r, i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> sumRange2(left, right, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">     &#125; </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h2 id="3-区间修改"><a href="#3-区间修改" class="headerlink" title="3. 区间修改"></a>3. 区间修改</h2><p>引入与线段树数组同等大小的<strong>懒惰标记</strong>数组。</p><p>要修改某一区间时，按照区间查询那样分治到待查询区间的子集。</p><p>按照该子集的大小修改当前线段树节点的值，并在该节点的子节点上打上懒惰标记，表示需要修改的值，暂时不作修改。</p><p>在下次遍历到含有懒惰标记的节点时，同样修改当前节点的值并向下传递懒惰标记。</p><h2 id="4-离散化"><a href="#4-离散化" class="headerlink" title="4. 离散化"></a>4. 离散化</h2><p>特征：数据范围过大，但是存在很多重复的点/无意义的点。</p><p>做法：先遍历数据去重，并根据map建立映射。</p><h2 id="5-动态开点"><a href="#5-动态开点" class="headerlink" title="5. 动态开点"></a>5. 动态开点</h2><p>结点数组法：将左右节点的下标记录在父节点中，而不是直接计算。</p><p>结点引用法：直接按照二叉树那样建树。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习-树状数组</title>
      <link href="/2022/10/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2022/10/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组学习笔记"><a href="#树状数组学习笔记" class="headerlink" title="树状数组学习笔记"></a>树状数组学习笔记</h1><h2 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h2><p>在O(logn)时间复杂度下实现数组的单点查询与修改、区间和查询与修改。</p><h2 id="2-lowbit"><a href="#2-lowbit" class="headerlink" title="2. lowbit"></a>2. lowbit</h2><p>lowbit即为某个数二进制表示种最低位上的1，如n = 3，二进制表示为11，则lowbit(3) = 1；n = 6，二进制表示为110，则lowbit(6) = 10。</p><p>lowbit的便捷求法为lowbit(i) = i &amp; -i。</p><p>想法：</p><p>为方便表述理解，设数组为nums[1……8]，树状数组为tree[1……8]。</p><p>单点修改：我们需要更新nums[3]的值，可以不断让3加上它的lowbit，并更新路径上的tree数组的值，即更新tree数组上下标为3、4、8的值。可以看作沿着树的叶子节点一路向上修改。</p><p>区间查询：我们需要求nums[1……7]区间和，可以通过lowbit将区间和分割为若干个子区间和，7的二进制表示为111，可以分割为7(111)、6(110)、4(100)这样几个区间，分别存储[7, 7]、[5, 6]、[1, 4]区间内的元素和，并进行累加。</p><h2 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3. 具体实现"></a>3. 具体实现</h2><p><a href="https://leetcode.cn/problems/range-sum-query-mutable/submissions/">LeetCode 307.区间和检索-数组可修改</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, tree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = nums.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: nums) <span class="keyword">this</span>-&gt;nums.push_back(i);</span><br><span class="line">        tree = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            add(i + <span class="number">1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= n; i += (i &amp; -i)) &#123;</span><br><span class="line">            tree[i] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        add(index + <span class="number">1</span>, val - nums[index + <span class="number">1</span>]);</span><br><span class="line">        nums[index + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">prefix</span><span class="params">(<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; <span class="number">0</span>; i -= (i &amp; -i)) &#123;</span><br><span class="line">            res += tree[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix(right + <span class="number">1</span>) - prefix(left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于C++数组下标从0开始，为方便理解，创建大小为n+1的树状数组来储存。</p><h2 id="4-区间修改与单点查询"><a href="#4-区间修改与单点查询" class="headerlink" title="4. 区间修改与单点查询"></a>4. 区间修改与单点查询</h2><p>这里实现的是支持单点修改与区间查询的PURQ(Point Update Range Query)树状数组，此外还有支持区间修改与单点查询的RUPQ树状数组，以及区间修改与区间查询的RURQ树状数组。</p><h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff[1] &#x3D; nums[1]</span><br><span class="line">diff[n] &#x3D; nums[n] - nums[n - 1]</span><br></pre></td></tr></table></figure><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums &#x3D; &#123;4, 2, -2, 7, 8&#125;, diff &#x3D; &#123;4, -2, -4, 9, 1&#125;</span><br></pre></td></tr></table></figure><p>此时将区间[2, 4]范围内的元素加3，只需要执行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff[2] +&#x3D; 3</span><br><span class="line">diff[4 + 1] -&#x3D; 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums &#x3D; &#123;4, 5, 1, 10, 8&#125;, diff &#x3D; &#123;4, 1, -4, 9, -2&#125;</span><br></pre></td></tr></table></figure><p>实际不需要修改nums数组的元素。</p><h3 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h3><p>可以观察到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums[n] &#x3D; nums[n] - nums[n - 1] + nums[n - 1] - nums[n - 2] + ... + nums[1]</span><br><span class="line">&#x3D; diff[n] + diff[n - 1] + ... + diff[0]</span><br></pre></td></tr></table></figure><p>因此，针对差分数组diff建立树状数组，就能得到O(logn)时间内完成区间修改与单点查询的树状数组。</p><h2 id="5-区间修改与区间查询"><a href="#5-区间修改与区间查询" class="headerlink" title="5. 区间修改与区间查询"></a>5. 区间修改与区间查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">preSum(k) &#x3D; nums[1] + nums[2] + ... + nums[k] </span><br><span class="line">  &#x3D; diff[1] + (diff[1] + diff[2]) + ... + (diff[1] + diff[2] + ... + diff[k])</span><br><span class="line">  &#x3D; k * diff[1] + (k - 1) * diff[1] + ... + diff[k]</span><br><span class="line">  &#x3D; k * (diff[1] + diff[2] + ... + diff[k]) - (1 * diff[1] + 2 * diff[2] + ... + k * diff[k])</span><br></pre></td></tr></table></figure><p>所以，只需要在RUPQ的基础上额外维护数组helperArr = {i * diff[i]} 。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-网络是怎样连接的4</title>
      <link href="/2022/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%844/"/>
      <url>/2022/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%844/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的-读书笔记4"><a href="#网络是怎样连接的-读书笔记4" class="headerlink" title="网络是怎样连接的 读书笔记4"></a>网络是怎样连接的 读书笔记4</h1><h2 id="4-1-ADSL"><a href="#4-1-ADSL" class="headerlink" title="4.1 ADSL"></a>4.1 ADSL</h2><h3 id="4-1-1-互联网的基本结构"><a href="#4-1-1-互联网的基本结构" class="headerlink" title="4.1.1 互联网的基本结构"></a>4.1.1 互联网的基本结构</h3><p>互联网与家庭、公司网络之间最主要的两个不同：距离和路由方式。</p><h3 id="4-1-2-连接用户与用户的接入网"><a href="#4-1-2-连接用户与用户的接入网" class="headerlink" title="4.1.2 连接用户与用户的接入网"></a>4.1.2 连接用户与用户的接入网</h3><p>互联网路由器按照接入网规则发送包，接入网即为连接互联网与家庭、公司网络的通信线路。</p><h3 id="4-1-3-ADSL-Modem"><a href="#4-1-3-ADSL-Modem" class="headerlink" title="4.1.3 ADSL Modem"></a>4.1.3 ADSL Modem</h3><p>用户端路由器发出的网络包通过ADSL Modem和电话线到达电话局，然后到达ADSL网络运营商。</p><p>具体流程：</p><ol><li>添加IP头部</li><li>添加MAC头部并发送</li><li><strong>互联网接入路由器</strong>接受包</li><li>取出IP包</li><li>添加MAC头部、PPPoE头部、PPP头部</li><li>ADSL Modem接收包</li><li>拆分为ATM信元</li><li>转换成电信号并发送</li><li>DSLAM接收电信号</li><li>还原成ATM信元并发送</li><li>BAS接收ATM信元</li><li>还原为网络包</li><li>取出PPP包</li><li>添加隧道头部并发送</li><li>隧道专用路由器接收隧道包</li><li>取出IP包</li><li>发送到互联网内部</li></ol><p>ADSL Modem将包拆分成信元，并转换成电信号发送给分离器。</p><h3 id="4-1-4-信元到电信号"><a href="#4-1-4-信元到电信号" class="headerlink" title="4.1.4 信元到电信号"></a>4.1.4 信元到电信号</h3><p>调制：用正弦波对信号进行合成来表示0和1的技术。</p><p>振幅调制ASK：用信号的大小对应0与1。</p><p>相位调制PSK：根据波振动的起始位置（相位）对应0与1。</p><p>正交振幅调制QAM：组合两种调制方式。</p><h3 id="4-1-5-多个波提高速率"><a href="#4-1-5-多个波提高速率" class="headerlink" title="4.1.5 多个波提高速率"></a>4.1.5 多个波提高速率</h3><p>通过多个波增加能表示的比特数来提高速率。</p><p>ADSL使用间隔为4.3125kHZ的上百个不同频率的波进行合成，每个波都采用正交振幅调制。</p><p>噪声小的频段可以给波分配更多的比特，噪声大的频段则相反。</p><p>每个频段表示的比特数加起来，决定了整体的传输速率。</p><p>上行方向（用户到互联网）使用的频段小于下行方向。</p><h3 id="4-1-6-分离器"><a href="#4-1-6-分离器" class="headerlink" title="4.1.6 分离器"></a>4.1.6 分离器</h3><p>电信号进入一个叫分离器的设备，与电话的语音信号混合从电话线传输出去。</p><p>在信号从电话线传入时，分离器负责将两个信号分离。具体做法是将一定频率以上的信号过滤掉，也就是过滤掉ADSL使用的高频信号，防止相互干扰。</p><h3 id="4-1-7-从用户到电话局"><a href="#4-1-7-从用户到电话局" class="headerlink" title="4.1.7 从用户到电话局"></a>4.1.7 从用户到电话局</h3><p>信号从该分离器出来，到达插电话线的接口，通过室内电话线到达大楼的IDF和MDF，通过配线盘到达保安室，之后进入电话电缆。进入电话局后，电缆逐根连接到电话局的MDF上。</p><h3 id="4-1-8-噪声"><a href="#4-1-8-噪声" class="headerlink" title="4.1.8 噪声"></a>4.1.8 噪声</h3><p>ADSL信号受到干扰后，和噪声频率相同的信号会受到影响无法读取，造成可用信号减少，速率下降。</p><h3 id="4-1-9-通过DSLAM到达BAS"><a href="#4-1-9-通过DSLAM到达BAS" class="headerlink" title="4.1.9 通过DSLAM到达BAS"></a>4.1.9 通过DSLAM到达BAS</h3><p>信号到达电话局后，经过配线盘、分离器到达DSLAM，被还原为信元。</p><p>DSLAM相当于将很多个ADSL Modem的功能集中起来的设备。不同的是，用户端ADSL Modem具备以太网接口，而DSLAM具有ATM接口，后后方路由器收发数据时使用的是原始网络包拆分后的ATM信元形式。</p><p>信元从DSLAM出来后，到达BAS包转发设备，BAS负责将ATM信元还原为网络包并转发到互联网内部。</p><h2 id="4-2-光纤接入网FTTH"><a href="#4-2-光纤接入网FTTH" class="headerlink" title="4.2 光纤接入网FTTH"></a>4.2 光纤接入网FTTH</h2><h3 id="4-2-1-基本知识"><a href="#4-2-1-基本知识" class="headerlink" title="4.2.1 基本知识"></a>4.2.1 基本知识</h3><p>光纤由一种双层结构的纤维状透明材质构成。外围的薄层折射率低，内层的纤芯折射率高，用于传导光线。</p><p>数字信息需要先转换成电信号然后再转换成光信号。</p><h3 id="4-2-2-单模与多模"><a href="#4-2-2-单模与多模" class="headerlink" title="4.2.2 单模与多模"></a>4.2.2 单模与多模</h3><p>光也是一种波，有相位的区别，并且在被纤芯和包层边界反射时，相位会发生变化。</p><p>在特定的角度下，向反射面前进的光和反射回来的光相位相同，只有以这些角度反射的光才能继续向前传导。</p><p>纤芯的直径就是根据这些角度确定。</p><p>单模纤芯只允许相位一致的最小角度的光传播。对光源和光敏元件的性能要求高，信号失真小，因此传播距离更长，用于FTTH。</p><p>多模纤芯允许多个相位一致的角度的光传播。对光源和光敏元件的性能要求低，信号失真大，因此传播距离短。</p><p>多模纤芯失真原因：反射角越小的光反射次数越多，走过的距离越长，而反射角越大的光相反，多条光线到达的时间不同，信号的宽度被拉伸。</p><h3 id="4-2-3-光纤分路"><a href="#4-2-3-光纤分路" class="headerlink" title="4.2.3 光纤分路"></a>4.2.3 光纤分路</h3><p>FTTH可分为直连和分路两种方式。</p><p>直连指用一根光纤直接从用户连接到最近的电话局。</p><p>分路使用分光器，让光纤分路同时连接多个用户。</p><h2 id="4-3-PPP和隧道"><a href="#4-3-PPP和隧道" class="headerlink" title="4.3 PPP和隧道"></a>4.3 PPP和隧道</h2><h3 id="4-3-1-用户认证和配置下发"><a href="#4-3-1-用户认证和配置下发" class="headerlink" title="4.3.1 用户认证和配置下发"></a>4.3.1 用户认证和配置下发</h3><p>ADSL和FTTH接入网都需要先登录才能访问互联网，BAS就是登录操作的窗口，使用PPPoE实现该功能。</p><p>PPP拨号连接操作：</p><ol><li>用户向运营商接入点拨打电话</li><li>输入用户名和密码登录</li><li>通过RADIUS协议从BAS发送到认证服务器进行校验</li><li>确认无误后返回IP地址等配置信息并下发给用户</li><li>用户根据信息配置，完成TCP/IP收发网络包的准备工作</li></ol><h3 id="4-3-2-在以太网上传输PPP"><a href="#4-3-2-在以太网上传输PPP" class="headerlink" title="4.3.2 在以太网上传输PPP"></a>4.3.2 在以太网上传输PPP</h3><p>PPP协议中没有定义以太网中的包头、FCS等元素与信号的格式，因此无法直接将PPP消息转换成信号。</p><p>在拨号接入中，PPP借用HDLC协议包装进行传输。</p><p>ADSL和FTTH无法借用HDLC，所以用以太网包代替HDLC装载PPP协议，重新设计了一个新的规格PPPoE。</p><p>依次在PPP消息前加上PPPoE头部与MAC头部进行传输。</p><h3 id="4-3-3-隧道"><a href="#4-3-3-隧道" class="headerlink" title="4.3.3 隧道"></a>4.3.3 隧道</h3><p>在BAS和运营商路由器之间的ADSL/FTTH接入服务商的网络中建立一条隧道，就形成了一条从用户一直到运营商路由器的通道。</p><p>隧道有几种实现方式，只要能将包原封不动搬运到另一端，就能在理论上建立隧道。</p><p>TCP方式：先在两台隧道路由器之间建立TCP连接，然后将连接两端的套接字当作路由器的端口，并从端口收发数据。</p><p>基于封装：将包含头部在内的整个包装入另一个包中传输到另一端。</p><h3 id="4-3-4-接入网的整体工作过程"><a href="#4-3-4-接入网的整体工作过程" class="headerlink" title="4.3.4 接入网的整体工作过程"></a>4.3.4 接入网的整体工作过程</h3><p>接入网的工作从用户端的互联网接入路由器进行连接操作开始。</p><ol><li>接入路由器种需要配置运营商分配的用户名密码，随后根据PPPoE的发现机制广播寻找BAS。</li><li>用户认证和配置下发：用户名和密码可通过加密的CHAP方式与不加密的PAP方式发送给BAS；BAS校验完毕密码后下发配置信息，包括分配给上网用户的IP地址、DNS服务器的IP地址以及默认网关的IP地址，这些会被配置到互联网接入路由器的BAS端的端口上。</li><li>客户端和BAS之间通过PPPoE通信，BAS将PPPoE的MAC头部与PPPoE头部去掉后，通过隧道机制发送给网络运营商的路由器。</li></ol><h3 id="4-3-5-不分配IP地址的无编号端口"><a href="#4-3-5-不分配IP地址的无编号端口" class="headerlink" title="4.3.5 不分配IP地址的无编号端口"></a>4.3.5 不分配IP地址的无编号端口</h3><p>当采用一对一连接，即两台路由器的端口用一根直线直接连起来时，可以不分配IP地址。</p><h3 id="4-3-6-互联网接入路由器的地址转换"><a href="#4-3-6-互联网接入路由器的地址转换" class="headerlink" title="4.3.6 互联网接入路由器的地址转换"></a>4.3.6 互联网接入路由器的地址转换</h3><p>如果使用路由器上网，BAS的配置信息会被配置到路由器上，因此计算机没有公有地址，需要转换。</p><p>计算机也可以不用路由器，直接接收来自BAS的PPPoE信息。</p><h3 id="4-3-7-除PPPoE的其他方式"><a href="#4-3-7-除PPPoE的其他方式" class="headerlink" title="4.3.7 除PPPoE的其他方式"></a>4.3.7 除PPPoE的其他方式</h3><p>使用PPPoA方式的ADSL接入网：不添加MAC头部和PPPoE头部，而是直接将包装入信元之中。</p><p>由于没有MAC头部，因此需要和BAS收发PPP消息的设备，即计算机和路由器必须和ADSL Modem一体，一体化方式为将计算机和ADSL Modem用USB接口连接起来，或将路由器和ADSL Modem整合成一台设备。</p><p>PPPoA优势：少了两种头部，MTU变大，网络效率变高。</p><p>使用DHCP协议：DHCP协议经常用于通过公司网络向客户端计算机下发TCP/IP配置信息，不需要验证，因此意味着无法通过用户名切换运营商网络。</p><p>采用DHCP协议运营商使用的ADSL Modem不使用信元，而是直接将以太网包调制成ADSL信号，因此没有ADSL Modem和路由器无法分离的问题。</p><h2 id="4-4-网络运营商"><a href="#4-4-网络运营商" class="headerlink" title="4.4 网络运营商"></a>4.4 网络运营商</h2><h3 id="4-4-1-POP和NOC"><a href="#4-4-1-POP和NOC" class="headerlink" title="4.4.1 POP和NOC"></a>4.4.1 POP和NOC</h3><p>POP：Point of Presence（接入点）。与ADSL、FTTH等接入网相连的与用户签约的运营商设备。</p><p>POP中包括各种类型的路由器，包括专线、RAS、PPPoE等。</p><p>NOC：Network Operation Center（网络运行中心），集中从POP传过来的网络包并转发到离目的地更近的POP。实际上就是规模扩大后的POP。</p><h3 id="4-4-2-室外通信线路"><a href="#4-4-2-室外通信线路" class="headerlink" title="4.4.2 室外通信线路"></a>4.4.2 室外通信线路</h3><p>使用光纤连接距离较远的NOC和POP。</p><h2 id="4-5-跨越运营商的网络包"><a href="#4-5-跨越运营商的网络包" class="headerlink" title="4.5 跨越运营商的网络包"></a>4.5 跨越运营商的网络包</h2><h3 id="4-5-1-运营商之间的连接"><a href="#4-5-1-运营商之间的连接" class="headerlink" title="4.5.1 运营商之间的连接"></a>4.5.1 运营商之间的连接</h3><p>NOC和POP本质上是路由器的集合，因此只要路由表中能查到目的地，无论是否是同一家运营商都能转发到。</p><h3 id="4-5-2-运营商之间的路由信息交换"><a href="#4-5-2-运营商之间的路由信息交换" class="headerlink" title="4.5.2 运营商之间的路由信息交换"></a>4.5.2 运营商之间的路由信息交换</h3><p>BGP：Border Gateway Protocol（边界网关协议）。相邻的路由器互相告知对方自己的路由信息。</p><p>互联网内部使用BGP机制在运营商之间交换路由信息。</p><h3 id="4-5-3-与公司内部的区别"><a href="#4-5-3-与公司内部的区别" class="headerlink" title="4.5.3 与公司内部的区别"></a>4.5.3 与公司内部的区别</h3><p>运营商之间使用BGP机制交换信息存在局限：</p><p>如果都采用同一条最短路由，会导致无法区分允许哪些运营商通过。所以，运营商之间的路由交换只发生在特定路由器之间。</p><p>此外，除了判断最短路由之外，还会设置一些其他判断因素。</p><h3 id="4-5-4-IX"><a href="#4-5-4-IX" class="headerlink" title="4.5.4 IX"></a>4.5.4 IX</h3><p>IX：Internet eXchange（互联网交换中心）。所有的运营商用通信线路连接到IX中心设备，来避免所有运营商之间互相连接，从而减少通信数量。</p><h3 id="4-5-6-IX连接方式"><a href="#4-5-6-IX连接方式" class="headerlink" title="4.5.6 IX连接方式"></a>4.5.6 IX连接方式</h3><p>IX核心是具有大量高速以太网端口的二层交换机。因此，其工作方式与一般交换机没有区别。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-网络是怎样连接的5</title>
      <link href="/2022/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%845/"/>
      <url>/2022/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%845/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的-读书笔记5"><a href="#网络是怎样连接的-读书笔记5" class="headerlink" title="网络是怎样连接的 读书笔记5"></a>网络是怎样连接的 读书笔记5</h1><h2 id="5-1-Web服务器"><a href="#5-1-Web服务器" class="headerlink" title="5.1 Web服务器"></a>5.1 Web服务器</h2><h3 id="5-1-1-amp-5-1-2-服务器部署方式"><a href="#5-1-1-amp-5-1-2-服务器部署方式" class="headerlink" title="5.1.1 &amp; 5.1.2 服务器部署方式"></a>5.1.1 &amp; 5.1.2 服务器部署方式</h3><p>有三种方式部署服务器</p><ul><li>服务器部署在公司网络上，并可以从互联网直接访问。现在已经不是主流方式，主要因为公网IP地址不足，以及安全问题。</li><li>公司内网、服务器与外网之间用防火墙隔开</li><li>将Web服务器部署在数据中心，数据中心与运营商核心NOC直接相连。这样部署访问速度很快，安全性也更高</li></ul><h2 id="5-2-防火墙"><a href="#5-2-防火墙" class="headerlink" title="5.2 防火墙"></a>5.2 防火墙</h2><h3 id="5-2-1-主流的包过滤方式"><a href="#5-2-1-主流的包过滤方式" class="headerlink" title="5.2.1 主流的包过滤方式"></a>5.2.1 主流的包过滤方式</h3><p>防火墙的基本思路就是，只允许发往特定服务器中的特定应用程序的包通过，屏蔽其他的包。</p><h3 id="5-2-2-amp-5-2-3-包过滤规则"><a href="#5-2-2-amp-5-2-3-包过滤规则" class="headerlink" title="5.2.2 &amp; 5.2.3 包过滤规则"></a>5.2.2 &amp; 5.2.3 包过滤规则</h3><p>可以通过接收方和发送方的IP地址设置包过滤规则，来限制接收方、发送方以及应用程序。</p><h3 id="5-2-4-通过控制位判断连接方向"><a href="#5-2-4-通过控制位判断连接方向" class="headerlink" title="5.2.4 通过控制位判断连接方向"></a>5.2.4 通过控制位判断连接方向</h3><p>TCP三步握手时，第一个包的SYN=1，ACK=0，其他的包中这些值都不同，所以可以对控制位设置防护墙，防止Web服务器主动与外界建立连接。</p><h3 id="5-2-5-amp-5-2-6-公司内网与外部网"><a href="#5-2-5-amp-5-2-6-公司内网与外部网" class="headerlink" title="5.2.5 &amp; 5.2.6 公司内网与外部网"></a>5.2.5 &amp; 5.2.6 公司内网与外部网</h3><p>同之前的笔记。</p><h3 id="5-2-7-通过防火墙"><a href="#5-2-7-通过防火墙" class="headerlink" title="5.2.7 通过防火墙"></a>5.2.7 通过防火墙</h3><p>如果包被防火墙拦截，这个包会被丢弃并记录，通过分析这些包能搞清楚入侵者使用的手法。</p><h3 id="5-2-8-防火墙无法抵御的攻击"><a href="#5-2-8-防火墙无法抵御的攻击" class="headerlink" title="5.2.8 防火墙无法抵御的攻击"></a>5.2.8 防火墙无法抵御的攻击</h3><p>如果Web服务器在收到特定数据时会宕机，这样的包防火墙无法发现。</p><p>存在两个方法应对：</p><ul><li>修复Web服务器中的Bug</li><li>在防火墙之外部署检测包内容的设备或软件</li></ul><h2 id="5-3-平衡负载"><a href="#5-3-平衡负载" class="headerlink" title="5.3 平衡负载"></a>5.3 平衡负载</h2><h3 id="5-3-1-服务器性能不足"><a href="#5-3-1-服务器性能不足" class="headerlink" title="5.3.1 服务器性能不足"></a>5.3.1 服务器性能不足</h3><p>换一台性能更好的服务器；采用多台服务器，并在每次查询DNS服务器时按一定顺序返回不同的地址，以平均分配访问。</p><h3 id="5-3-2-负载均衡器"><a href="#5-3-2-负载均衡器" class="headerlink" title="5.3.2 负载均衡器"></a>5.3.2 负载均衡器</h3><p>负载均衡器需要代替Web服务器被注册到DNS服务器中。</p><p>封装所有的服务器，让外界以为负载均衡器就是一台服务器，并在接收到包后判断并转发给特定服务器。</p><p>在操作不横跨多个页面时，一般按照Web服务器的负载情况判断，定期采集服务器CPU、内存使用率或发送测试包。</p><p>在操作横跨多个页面时，需要在发送表单数据时加入额外信息，或者对HTTP规格进行扩展，以使得负载均衡器能判断是否需要发送到同一台Web服务器。</p><h2 id="5-4-缓存服务器"><a href="#5-4-缓存服务器" class="headerlink" title="5.4 缓存服务器"></a>5.4 缓存服务器</h2><h3 id="5-4-1-大致工作"><a href="#5-4-1-大致工作" class="headerlink" title="5.4.1 大致工作"></a>5.4.1 大致工作</h3><p>缓存服务器通过代理机制对数据进行缓存，介于Web服务器和客户端之间。它可以将Web服务器返回的数据保存在磁盘中，代替Web服务器将数据返回给客户端。</p><p>它比Web服务器少了检查网址和访问权限，以及在页面上填充数据等内部操作过程，所以节省了时间。</p><h3 id="5-4-2-更新时间"><a href="#5-4-2-更新时间" class="headerlink" title="5.4.2 更新时间"></a>5.4.2 更新时间</h3><p>缓存服务器需要代替Web服务器被注册到DNS服务器中。</p><p>缓存服务器接受客户端的HTTP请求消息，并检查请求的数据是否已保存。</p><ul><li>如果不存在缓存数据，缓存服务器在HTTP头部添加一个Via字段，表示这条消息经过缓存服务器转发，然后根据请求消息的URI判断并转发给对应的Web服务器（判断规则需要事先设置）。在这个过程中，缓存服务器会以客户端的身份请求消息。之后收到来自Web服务器的响应消息，加上Via头部字段，表示该消息经过缓存服务器中转。最后以Web服务器的身份向客户端发送响应消息，同时将响应消息与保存的时间记录在缓存中。</li><li>如果命中缓存数据，缓存服务器添加一个If-Modified-Since头部字段并将请求转发给Web服务器，询问请求数据是否发生变化。Web服务器会将If-Modified-Since值与服务器上页面数据的最后更新时间进行比较，判断数据是否变化。如果没有变化Web服务器只需要响应无变化，否则与不存在缓存数据的情况相同。</li></ul><h3 id="5-4-3-正向代理"><a href="#5-4-3-正向代理" class="headerlink" title="5.4.3 正向代理"></a>5.4.3 正向代理</h3><p>正向代理是部署在客户端一侧的缓存服务器。</p><p>使用正向代理时，一般需要在浏览器的设置窗口设置代理服务器为正向代理的IP地址。之后浏览器便会忽略网址栏的内容并直接将所有请求发给正向代理。</p><p>使用正向代理时，因为URI部分为完整网址，因此可以转发给任意Web服务器而不需要事先设置规则。</p><h3 id="5-4-4-反向代理"><a href="#5-4-4-反向代理" class="headerlink" title="5.4.4 反向代理"></a>5.4.4 反向代理</h3><p>反向代理：通过将请求消息中的URI中的目录名与Web服务器进行关联，使得代理能转发一般的不包含完整网址的请求消息。</p><h3 id="5-4-5-透明代理"><a href="#5-4-5-透明代理" class="headerlink" title="5.4.5 透明代理"></a>5.4.5 透明代理</h3><p>透明代理：查看请求消息包头部，判断用户要访问的服务器。</p><p>透明代理不需要设置在浏览器中，也不能像反向代理一样通过DNS服务器解析引导（因为要根据接收方IP地址来判断），所以必须被放置在请求消息从浏览器传输到Web服务器的路径中，当消息经过时进行拦截。</p><p>可以在接入网的入路口处放置透明代理。大家更倾向于将透明代理称为缓存。</p><h3 id="5-5-内容分发服务"><a href="#5-5-内容分发服务" class="headerlink" title="5.5 内容分发服务"></a>5.5 内容分发服务</h3><h3 id="5-5-1-利用内容分发分担负载"><a href="#5-5-1-利用内容分发分担负载" class="headerlink" title="5.5.1 利用内容分发分担负载"></a>5.5.1 利用内容分发分担负载</h3><p>缓存服务器放在服务器端时，无法减少互联网中的流量，且互联网中存在的拥塞点会浪费时间；如果在客户端直接部署服务器，Web服务器的运营者无法控制。</p><p>因此，Web服务器运营者和网络运营商签约，将可以自己控制的缓存服务器放在客户端的运营商处。</p><p>但是，互联网上公开的服务器任何人都可访问，因此必须在所有运营商POP中布置缓存服务器，这个数据太大；Web服务器也没法与所有运营商签约并部署服务器。</p><p>内容分发服务（CDSP）：一些专门从事相关服务的厂商，部署缓存服务器，并租借给Web服务器和运营商。</p><h3 id="5-5-2-找到最近的缓存服务器——DNS分配访问"><a href="#5-5-2-找到最近的缓存服务器——DNS分配访问" class="headerlink" title="5.5.2 找到最近的缓存服务器——DNS分配访问"></a>5.5.2 找到最近的缓存服务器——DNS分配访问</h3><p>首先，需要事先从缓存服务器部署地点的路由器收集路由信息。</p><p>DNS服务器根据路由表查询本机到客户端DNS服务器的路由信息，大致估算距离并比较。</p><p>客户端DNS服务器不一定和客户端在同一位置，因此可能无法得出准确距离。</p><h3 id="5-5-3-找到最近的缓存服务器——重定向"><a href="#5-5-3-找到最近的缓存服务器——重定向" class="headerlink" title="5.5.3 找到最近的缓存服务器——重定向"></a>5.5.3 找到最近的缓存服务器——重定向</h3><p>HTTP头部中有一个Locatino字段，当Web服务器数据被转移到其他服务器时使用这个字段，将客户端访问引导到另一台Web服务器。</p><p>首先将重定向服务器注册到Web服务器端的DNS服务器上，重定向服务器与DNS分配访问中的方法一样找到最近的缓存服务器，放在Location字段中返回响应。</p><p>这种方法增加了HTTP的交互次数，增大开销，但它根据客户端发送来的HTTP消息的发送方IP地址来估算距离，相对更精确。</p><p>此外，也可以通过一个网络包往返时间来估算距离。</p><h3 id="5-5-4-缓存更新方法"><a href="#5-5-4-缓存更新方法" class="headerlink" title="5.5.4 缓存更新方法"></a>5.5.4 缓存更新方法</h3><p>Web服务器在原始数据更新时立刻通知缓存服务器，让其保持最新状态，从而无需确认是否变化。</p><p>对于收到请求后用CGI程序生成的动态页面，可以将动态部分与静态部分分离，只将静态部分保存在缓存中。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大致了解-Java项目入门</title>
      <link href="/2022/10/14/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-Java%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8/"/>
      <url>/2022/10/14/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-Java%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java项目入门"><a href="#Java项目入门" class="headerlink" title="Java项目入门"></a>Java项目入门</h1><p>秒杀商城架构和依赖都看不懂。。。先回来学学基础知识吧。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven是一个Java项目管理构建工具，主要为Java提供了：</p><ul><li>一套标准化的项目结构</li><li>一套标准化的构建流程（编译，测试，打包，发布）</li><li>一套依赖管理机制</li></ul><h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a-maven-project</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   └── resources</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       └── resources</span><br><span class="line">└── target</span><br></pre></td></tr></table></figure><ul><li>pom.xml是项目描述文件</li><li>src/main/java存放Java源码</li><li>src/main/resources存放资源文件</li><li>src/test/java存放测试源码</li><li>src/test/resouces存放测试资源文件</li><li>所有编译、打包生成的文件都放在target里</li></ul><p>依赖由groupId、artifactId、version唯一确定，由标签表示。</p><ul><li>groupId：类似Java的包名，通常是公司或组织名称</li><li>artifactId：类似Java的类名，通常是项目名称</li><li>version</li></ul><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>Maven会自动将声明依赖所需的全部上游依赖加入项目依赖之中。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>Maven定义了四种依赖关系（scope）：</p><ul><li>compile：编译时需要用到该jar包，为默认依赖关系，如commons-logging</li><li>test：编译Test时需要用到该jar包，如junit</li><li>runtime：编译时不需要，但运行时需要用到，如mysql</li><li>provided：编译时需要用到，但运行时由JDK或某个服务器提供，如servlet-api（运行时Servlet服务器内置了相关的jar）</li></ul><h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><p>Maven的lifecycle由一系列phase构成。</p><p>使用mvn命令时，后面跟随的参数指定phase，Maven就会自动根据生命周期运行到指定的phase。经常用到的phase有clean清理、compile编译、test运行测试、package打包。</p><p>执行一个phase会触发一个或多个goal，以abc:xyz形式命名。</p><p>类比：</p><ul><li>lifecycle相当于package，包含一个或多个phase。</li><li>phase相当于class，包含一个或多个goal。</li><li>goal相当于class里的method，执行实际功能。</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>执行phase实际上通过插件来执行，Maven只是负责找到对应的插件，然后执行默认的goal。</p><p>Lifecycle相当于一个抽象父类，而插件是其子类，插件执行的goal就相当于子类中重写的方法。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>中央仓库：由Maven社区提供的一种特殊远程仓库。本地仓库中没有Maven所需的构件时，默认首先尝试从中央仓库下载。</p><p>私有仓库：通常设立在局域网，是一种特殊的中央仓库。</p><p>本地仓库：存储本地所有项目所需的构件。</p>]]></content>
      
      
      <categories>
          
          <category> 大致了解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-网络是怎样连接的3</title>
      <link href="/2022/10/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%843/"/>
      <url>/2022/10/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%843/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的-读书笔记3"><a href="#网络是怎样连接的-读书笔记3" class="headerlink" title="网络是怎样连接的 读书笔记3"></a>网络是怎样连接的 读书笔记3</h1><h2 id="3-1-信号在集线器和网线的传输"><a href="#3-1-信号在集线器和网线的传输" class="headerlink" title="3.1 信号在集线器和网线的传输"></a>3.1 信号在集线器和网线的传输</h2><h3 id="3-1-1-独立传输"><a href="#3-1-1-独立传输" class="headerlink" title="3.1.1 独立传输"></a>3.1.1 独立传输</h3><p>转发设备在转发时不看数据的内容。</p><p>所有的包在传输到目的地的过程中都是独立传输，项目没有任何关联。</p><h3 id="3-1-2-网线中的信号衰减"><a href="#3-1-2-网线中的信号衰减" class="headerlink" title="3.1.2 网线中的信号衰减"></a>3.1.2 网线中的信号衰减</h3><p>信号随着网线传输会逐渐损失能量，信号变弱且拐角变圆。</p><h3 id="3-1-3-双绞线"><a href="#3-1-3-双绞线" class="headerlink" title="3.1.3 双绞线"></a>3.1.3 双绞线</h3><p>双绞线以两根信号线为一组缠绕在一起，目的是为了抑制噪声。</p><p>噪声产生原因：网线周围存在电磁波，当其接触到金属等导体时，在其中会产生与原本信号不一样的电流，与信号混杂在一起。</p><p>影响网线的电磁波分为两种：</p><p>1、网线之外的设备：电磁波接触到信号线时，会沿着电磁波传播的右旋方向产生电流，双绞线两根电线中的电流方向相反从而互相抵消；</p><p>2、相邻信号线：串扰。在一根网线中，每一对信号线的扭绞间隔（节距）存在差距，使得某些地方正信号线距离近，某些地方负信号线距离近，两者相互抵消，从网线整体来看正负分布保持平衡。</p><h3 id="3-1-4-集线器"><a href="#3-1-4-集线器" class="headerlink" title="3.1.4 集线器"></a>3.1.4 集线器</h3><p>信号到达集线器后，会被广播到整个网络。</p><h2 id="3-2-交换机"><a href="#3-2-交换机" class="headerlink" title="3.2 交换机"></a>3.2 交换机</h2><h3 id="3-2-1-交换机的工作原理"><a href="#3-2-1-交换机的工作原理" class="headerlink" title="3.2.1 交换机的工作原理"></a>3.2.1 交换机的工作原理</h3><p>交换机的端口相当于一块没有MAC地址的网卡。</p><p>交换机将接收到的包存入缓冲区后，需要查询其接收方MAC地址是否在MAC表中有记录，并根据MAC表中记录的MAC地址与端口将包转发到相应的端口。</p><h3 id="3-2-2-MAC地址表的维护"><a href="#3-2-2-MAC地址表的维护" class="headerlink" title="3.2.2 MAC地址表的维护"></a>3.2.2 MAC地址表的维护</h3><p>1）收到包时，将发送方MAC地址与接收端口填入MAC表中。</p><p>2）记录一段时间没有使用后，将其从MAC表中移除。</p><h3 id="3-2-3-特殊操作"><a href="#3-2-3-特殊操作" class="headerlink" title="3.2.3 特殊操作"></a>3.2.3 特殊操作</h3><p>如果MAC表中查询到的目标端口与源端口是同一个：直接丢弃，因为到达交换机之前的集线器已经通过广播传达到了这个包。</p><p>地址表中查询不到MAC地址对应的端口：转发到除源端口外的所有端口。</p><h3 id="3-2-4-全双工模式"><a href="#3-2-4-全双工模式" class="headerlink" title="3.2.4 全双工模式"></a>3.2.4 全双工模式</h3><p>交换机使用全双工模式，可以同时发送和接收信号而不用担心碰撞。</p><h3 id="3-2-5-自动协商"><a href="#3-2-5-自动协商" class="headerlink" title="3.2.5 自动协商"></a>3.2.5 自动协商</h3><p>自动切换工作模式：相互连接的双方探测对方是否支持全双工模式，并自动切换相应的工作模式。</p><p>自动协商：利用网络中存在的脉冲信号，将自己能支持的工作模式和传输速率告诉对方，并从中选择最优组合。</p><h3 id="3-2-6-交换机可执行多个转发操作"><a href="#3-2-6-交换机可执行多个转发操作" class="headerlink" title="3.2.6 交换机可执行多个转发操作"></a>3.2.6 交换机可执行多个转发操作</h3><h2 id="3-3-路由器"><a href="#3-3-路由器" class="headerlink" title="3.3 路由器"></a>3.3 路由器</h2><h3 id="3-3-1-基本知识"><a href="#3-3-1-基本知识" class="headerlink" title="3.3.1 基本知识"></a>3.3.1 基本知识</h3><p>路由器分为转发模块和端口模块两个部分。转发模块负责判断包的转发目的地，端口模块负责包的手法操作。</p><p>路由器的各个端口都有MAC地址和IP地址。</p><p>交换机在转发包时自己不会成为接收方或发送方，而路由器会接收转发给自己的以太网包，并由相应的端口作为发送方将以太网包发送出去。</p><h3 id="3-3-2-路由表"><a href="#3-3-2-路由表" class="headerlink" title="3.3.2 路由表"></a>3.3.2 路由表</h3><p>交换机通过MAC头部的接收方MAC地址判断转发目标，而路由器根据IP头部的IP地址来判断。</p><p>路由表的组成部分：</p><ul><li>目标地址：只包含表示子网的网络号部分，主机号部分为全0</li><li>子网掩码：通过子网掩码判断网络号的比特数并进行匹配</li><li>网关、接口：匹配完目标地址后，路由器将网络包交给接口列中指定的网络接口，转发到网关列中指定的IP地址</li><li>跃点计数：表示距离目标IP地址的远近</li></ul><p>路由聚合：路由器会将多个前缀相同的子网合并为一条记录，并更改相应的子网掩码与目标地址。</p><p>交换机在包转发操作中对MAC地址表进行维护，而路由器维护路由表与转发操作之间相互独立。</p><p>路由表可由人手动维护路由记录，或根据路由协议机制，通过路由器之间的信息交换由路由器自行维护（RIP、OSPF、BGP等）。</p><h3 id="3-3-3-接收包"><a href="#3-3-3-接收包" class="headerlink" title="3.3.3 接收包"></a>3.3.3 接收包</h3><p>路由器的端口只接收MAC地址匹配的包，否则直接丢弃。</p><h3 id="3-3-4-确定输出端口"><a href="#3-3-4-确定输出端口" class="headerlink" title="3.3.4 确定输出端口"></a>3.3.4 确定输出端口</h3><p>接收包后，路由器丢弃MAC头部，并根据后方IP头部中的IP地址转发包。</p><p>匹配路由表时：</p><ul><li>如果存在多条匹配的记录，取网络号比特最长的一条记录。</li><li>如果存在多条网络号最长的匹配记录，取跃点计数最小的一条。</li><li>如果无法匹配，路由器会丢弃包，并通过ICMP消息告知发送方。（因为路由器在互联网中工作，而互联网规模远大于交换机连接的网络）</li></ul><h3 id="3-3-5-默认路由"><a href="#3-3-5-默认路由" class="headerlink" title="3.3.5 默认路由"></a>3.3.5 默认路由</h3><p>路由表中子网掩码为0.0.0.0的记录表示默认路由。如果路由器找不到其他可以匹配的目标，就将包转发到默认路由对应的默认网关中。</p><h3 id="3-3-6-有效期"><a href="#3-3-6-有效期" class="headerlink" title="3.3.6 有效期"></a>3.3.6 有效期</h3><p>查找到转发目标后，路由器需要更新IP头部的TTL。</p><p>每经过一个路由器的转发，TTL-1，当TTL=0时丢弃包。</p><h3 id="3-3-7-分片"><a href="#3-3-7-分片" class="headerlink" title="3.3.7 分片"></a>3.3.7 分片</h3><p>1.IP分片产生的原因是网络层的MTU；TCP分段产生原因是MSS.</p><p>2.IP分片由网络层完成，也在网络层进行重组；TCP分段是在传输层完成，并在传输层进行重组. //透明性</p><p>3.对于以太网，MSS为1460字节，而MTU往往会大于MSS.</p><p>故采用TCP协议进行数据传输，是不会造成IP分片的。若数据过大，只会在传输层进行数据分段，到了IP层就不用分片。</p><p>而我们常提到的IP分片是由于UDP传输协议造成的，因为UDP传输协议并未限定传输数据报的大小。</p><h3 id="3-3-8-发送包"><a href="#3-3-8-发送包" class="headerlink" title="3.3.8 发送包"></a>3.3.8 发送包</h3><p>判断MAC头部的MAC地址，首先需要根据网关判断IP地址，如果网关为空则目标地址为IP头部的接收方IP地址。</p><p>之后根据ARP查询MAC地址，并填写MAC头部。</p><h3 id="3-3-9-路由器与交换机的关系"><a href="#3-3-9-路由器与交换机的关系" class="headerlink" title="3.3.9 路由器与交换机的关系"></a>3.3.9 路由器与交换机的关系</h3><p>路由器（IP）负责将包送达对象这一整体过程，而交换机（以太网）负责将包传输到下一个路由器的实际过程。</p><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>路由器与交换机的差异总结：</p><p>路由器：</p><ol><li>接收/发送方：路由器会接收转发给自己的以太网包，并由相应的端口作为发送方发送以太网包。</li><li>判断转发目标：路由器根据IP头部的IP地址来判断转发目标。</li><li>维护转发表：路由器维护路由表与转发操作之间相互独立。</li><li>无法匹配：路由器丢弃包并通过ICMP消息告知发送方，或是转发到默认网关。</li></ol><p>交换机：</p><ol><li>接收/发送方：交换机在转发包时自己不会成为接收方或发送方。</li><li>判断转发目标：交换机通过MAC头部的接收方MAC地址判断转发目标。</li><li>维护转发表：交换机在包转发操作中对MAC地址表进行维护。</li><li>无法匹配：交换机转发到除源端口外的所有端口。</li></ol><h2 id="3-4-附加功能"><a href="#3-4-附加功能" class="headerlink" title="3.4 附加功能"></a>3.4 附加功能</h2><h3 id="3-4-1-路由器的地址转换"><a href="#3-4-1-路由器的地址转换" class="headerlink" title="3.4.1 路由器的地址转换"></a>3.4.1 路由器的地址转换</h3><p>产生背景：随着接入互联网的设备数目快速增长，无法在将来保证每台设备有一个唯一不重复的地址；不同公司/家庭内部的客户端之间不会进行通信，因此IP地址可以重复。</p><p>规定用于内网的地址称为私有地址，原来的固定地址称为公有地址。</p><p>私有地址的范围为（制定私有地址规则时，尚未分配的一部分公有地址拿出来作为私有地址）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.0 ~ 10.255.255.255</span><br><span class="line">172.16.0.0 ~ 172.31.255.255</span><br><span class="line">192.168.0.0 ~ 192.168.255.255</span><br></pre></td></tr></table></figure><h3 id="3-4-2-地址转换的原理"><a href="#3-4-2-地址转换的原理" class="headerlink" title="3.4.2 地址转换的原理"></a>3.4.2 地址转换的原理</h3><p>基本原理：路由器在转发操作时对IP头部中的IP地址与端口号进行改写。</p><p>路由器中保存一张表，记录改写前的私有地址、端口号与改写后的私有地址、端口号的对应关系。</p><h3 id="3-4-3-改写端口号"><a href="#3-4-3-改写端口号" class="headerlink" title="3.4.3 改写端口号"></a>3.4.3 改写端口号</h3><p>（只改写私有地址有什么意义吗……需要的IP地址又没有变少）</p><h3 id="3-4-4-从互联网访问内网"><a href="#3-4-4-从互联网访问内网" class="headerlink" title="3.4.4 从互联网访问内网"></a>3.4.4 从互联网访问内网</h3><p>从互联网访问公司内网的包，如果在对应表中没有记录就无法转发。</p><p>除非公司主动允许，否则无法主动从互联网向公司内部发送包，有防止非法入侵的效果。</p><p>如果需要主动访问，可以手动添加地址转化表。</p><h3 id="3-4-5-路由器的包过滤功能"><a href="#3-4-5-路由器的包过滤功能" class="headerlink" title="3.4.5 路由器的包过滤功能"></a>3.4.5 路由器的包过滤功能</h3><p>路由器在对包进行转发时，根据MAC头部、IP头部、TCP头部的内容，按照事先设置的规则决定转发还是丢弃这个包。</p><p>防火墙设备或软件大多利用这个原理。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-网络是怎样连接的2</title>
      <link href="/2022/09/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/"/>
      <url>/2022/09/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的-读书笔记2"><a href="#网络是怎样连接的-读书笔记2" class="headerlink" title="网络是怎样连接的 读书笔记2"></a>网络是怎样连接的 读书笔记2</h1><p>还是决定一章一个文件了，不然太大了看着很散，这个文件讲的是第二章的内容，关于协议栈内部如何跟服务器通讯的。</p><h2 id="2-1-套接字创建"><a href="#2-1-套接字创建" class="headerlink" title="2.1 套接字创建"></a>2.1 套接字创建</h2><h3 id="2-1-1-协议栈的层次"><a href="#2-1-1-协议栈的层次" class="headerlink" title="2.1.1 协议栈的层次"></a>2.1.1 协议栈的层次</h3><p>与TCP/IP五层一致。最上层的是应用层，应用层上层包含各种网络应用程序，下层为Socket库，包含向DNS服务器发出查询的解析器等。</p><p>协议栈在应用层下面的操作系统内部层，分为两个部分。上半部分分为两块，分别用TCP协议与UDP协议收发数据。下半部分用IP协议控制网络包收发操作。</p><p>IP下方为网卡驱动程序，负责控制网卡硬件。</p><p>最下方的网卡负责完成实际的收发操作，即对网线中的信号执行发送和接收操作。</p><h3 id="2-1-2-套接字的实体"><a href="#2-1-2-套接字的实体" class="headerlink" title="2.1.2 套接字的实体"></a>2.1.2 套接字的实体</h3><p>协议栈内部存放了控制信息，记录通信对象的IP地址、端口号、通信操作的运行状态等，套接字实际上只是一个概念，其实体可视为存放了这些控制信息的内存空间。</p><p>协议栈根据套接字中记录的控制信息来进行工作。</p><h3 id="2-1-3-调用socket的操作"><a href="#2-1-3-调用socket的操作" class="headerlink" title="2.1.3 调用socket的操作"></a>2.1.3 调用socket的操作</h3><p>协议栈分配存放一个套接字所需的内存空间，并写入初始状态的控制信息，并将描述符告知应用程序。</p><h2 id="2-2-连接服务器"><a href="#2-2-连接服务器" class="headerlink" title="2.2 连接服务器"></a>2.2 连接服务器</h2><h3 id="2-2-1-连接"><a href="#2-2-1-连接" class="headerlink" title="2.2.1 连接"></a>2.2.1 连接</h3><p>连接实际上是通信双方交换控制信息，在套接字中记录必要信息并准备数据收发的一系列操作。</p><h3 id="2-2-2-头部"><a href="#2-2-2-头部" class="headerlink" title="2.2.2 头部"></a>2.2.2 头部</h3><p>控制信息大体上分为两类</p><p>1）客户端和服务器互相联络交换的控制信息：位于网络包开头，被称为头部。</p><p>2）保存在套接字中用来控制协议栈操作的信息。</p><h3 id="2-2-3-实际的连接操作"><a href="#2-2-3-实际的连接操作" class="headerlink" title="2.2.3 实际的连接操作"></a>2.2.3 实际的连接操作</h3><p>1）创建TCP头部，设置发送端、接收端的端口号、SYN=1等信息。通过TCP头部发送方和接收方的端口号可以找到要连接的套接字。</p><p>2）将信息传递给IP模块委托发送，随着网络到达服务器，并由服务器的IP模块传递给TCP模块。</p><p>3）服务器的TCP模块根据TCP头部信息找到对应的套接字，套接字写入信息，并将状态改为正在连接。</p><p>4）服务器的TCP模块按照1）中所示创建头部，同时设置ACK=1表示已收到网络包，并委托IP模块发送。</p><p>5）客户端的TCP模块根据头部信息确认SYN=1表示连接成功，向套接字中写入服务器的IP、端口号等信息，同时将状态改为连接完毕，并按照4）中所示发送包回服务器告诉服务器已收到，完成连接。</p><h2 id="2-3-收发数据"><a href="#2-3-收发数据" class="headerlink" title="2.3 收发数据"></a>2.3 收发数据</h2><h3 id="2-3-1-协议栈的收发控制"><a href="#2-3-1-协议栈的收发控制" class="headerlink" title="2.3.1 协议栈的收发控制"></a>2.3.1 协议栈的收发控制</h3><p>协议栈将应用程序委托发送的数据存储到缓冲区，根据数据大小和时间两个要素来决定什么时候发送：</p><p>1）数据大小：MTU代表一个数据包最大长度，在以太网中一般为1500字节，MSS为去除头部后一个网络包能容纳的最大数据长度.</p><p>2）时间：只考虑数据大小可能使得小包等待时间过长，并且某些数据包也有快速发送的需求。</p><p>两者的权衡是由协议栈的开发者设置的，应用程序也可以通过设置某些字段来控制发送方式。</p><h3 id="2-3-2-拆分数据"><a href="#2-3-2-拆分数据" class="headerlink" title="2.3.2 拆分数据"></a>2.3.2 拆分数据</h3><p>如果数据的总长度超过了MSS，协议栈就会对数据进行拆分，在每一块数据前加上头部并交由IP模块发送。</p><h3 id="2-3-3-ACK"><a href="#2-3-3-ACK" class="headerlink" title="2.3.3 ACK"></a>2.3.3 ACK</h3><p>1）客户端计算出随机ACK初始值发送给服务端。</p><p>2）服务端根据客户端的初始值计算出ACK号并返回给客户端以确认收到；同时，服务端计算另一个随机ACK初始值发送给客户端。</p><p>3）客户端根据服务端的初始值计算出ACK号并返回给服务端以确认收到。</p><p>4）客户端和服务端可以进入数据收发阶段了。以客户端到服务端为例，客户端向服务端发送数据包，记录了数据包序号与总长度，服务端收到后确认序号是否为上次的ACK号。如果确认成功，服务器根据本次数据包序号与总长度计算出下一次期望的数据包序号，作为ACK号返回客户端。</p><p>TCP根据这种方式保证通信双方能收到数据。因此，网卡、集线器与路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。</p><p>但是，如果重传几次都无效，TCP会强制结束通信并向应用程序报错。</p><h3 id="2-3-4-ACK等待时间"><a href="#2-3-4-ACK等待时间" class="headerlink" title="2.3.4 ACK等待时间"></a>2.3.4 ACK等待时间</h3><p>即为等待ACK号返回的时间，如果超过时间则重传。</p><p>TCP采用动态调整方法，在发送数据过程中持续测量等待时间，如果ACK号返回变慢说明网络拥挤，则延长等待时间；反之亦然。</p><h3 id="2-3-5-滑动窗口"><a href="#2-3-5-滑动窗口" class="headerlink" title="2.3.5 滑动窗口"></a>2.3.5 滑动窗口</h3><p>发送数据时实际上不等待ACK返回连续发送。</p><p>接收方存在数据缓冲区，在发送数据之前告诉发送方自己的缓冲区大小，并在每次数据处理完毕后都告知发送方当前缓冲区大小，发送方计算窗口大小，并在窗口大小为0时停止发送，直到接收到接收方的窗口大小通信。</p><h3 id="2-3-6-ACK与接收窗口"><a href="#2-3-6-ACK与接收窗口" class="headerlink" title="2.3.6 ACK与接收窗口"></a>2.3.6 ACK与接收窗口</h3><p>更新窗口大小的时机：接收方从缓冲区取出数据并传递给应用程序。</p><p>ACK确认时机：接收方接收到数据并确认无误。</p><p>如果单独发送，则数据包太多，因此在发送ACK号和更新窗口时，都会等待一段时间，如果出现了其他的通知操作就合并在一个包里发送。也可以连续发送多个ACK号时，只发送最后一个ACK号，以报告在这之前的数据都成功收到了。</p><h3 id="2-3-7-接收消息"><a href="#2-3-7-接收消息" class="headerlink" title="2.3.7 接收消息"></a>2.3.7 接收消息</h3><p>浏览器委托协议栈读取返回信息，如果响应消息尚未到达，则委托会被暂时挂起，并在收到信息时，根据上述接收方的操作还原数据，将数据交由应用程序。</p><h2 id="2-4-断开连接"><a href="#2-4-断开连接" class="headerlink" title="2.4 断开连接"></a>2.4 断开连接</h2><h3 id="2-4-1-断开连接"><a href="#2-4-1-断开连接" class="headerlink" title="2.4.1 断开连接"></a>2.4.1 断开连接</h3><p>完成数据发送的一方会发起断开过程。服务器和客户端双方都可以主动断开。</p><p>1）服务器生成含断开信息的TCP头部，将FIN比特设置为1，向客户端发送数据并在套接字中记录断开相关信息。</p><p>2）客户端收到数据时，将套接字标记为进入断开操作状态，返回确认FIN=1的ACK包。</p><p>3）应用程序在缓冲区取走数据后，客户端也生成FIN=1的包，服务器返回ACK包，通信结束。</p><h3 id="2-4-2-删除套接字"><a href="#2-4-2-删除套接字" class="headerlink" title="2.4.2 删除套接字"></a>2.4.2 删除套接字</h3><p>通信结束后经过一段时间才会删除套接字，为了防止丢包之类的误操作。</p><h3 id="2-4-3-数据收发小结"><a href="#2-4-3-数据收发小结" class="headerlink" title="2.4.3 数据收发小结"></a>2.4.3 数据收发小结</h3><p>1）创建套接字。</p><p>2）确认连接。</p><p>3）数据收发。</p><p>4）断开连接。</p><h2 id="2-5-IP与以太网的收发"><a href="#2-5-IP与以太网的收发" class="headerlink" title="2.5 IP与以太网的收发"></a>2.5 IP与以太网的收发</h2><h3 id="2-5-1-包的基本知识"><a href="#2-5-1-包的基本知识" class="headerlink" title="2.5.1 包的基本知识"></a>2.5.1 包的基本知识</h3><p>路由器根据目标地址判断下一个路由器的位置。</p><p>集线器在子网中将网络包传输到下一个路由。</p><h3 id="2-5-2-包的收发操作"><a href="#2-5-2-包的收发操作" class="headerlink" title="2.5.2 包的收发操作"></a>2.5.2 包的收发操作</h3><p>1）TCP将网络包传递给IP模块，指定接收方并委托IP模块传输。</p><p>2）IP加上IP头部与MAC头部进行封装。</p><p>3）将封装好的包传递给网卡。</p><p>4）网卡将数字信息转化为电信号或光信号，通过网线或光纤发送出去。</p><h3 id="2-5-3-IP头部"><a href="#2-5-3-IP头部" class="headerlink" title="2.5.3 IP头部"></a>2.5.3 IP头部</h3><p>发送方IP地址需要判断发送所使用的网卡，并填写对应网卡的IP地址。</p><p>根据路由表判断交给的网卡，根据要到达的目标地址与子网掩码来查找下一跳的网关。</p><h3 id="2-5-4-MAC头部"><a href="#2-5-4-MAC头部" class="headerlink" title="2.5.4 MAC头部"></a>2.5.4 MAC头部</h3><p>MAC头部由接收方MAC地址、发送方MAC地址与以太类型（与IP头部中的协议号类似）三部分组成。</p><h3 id="2-5-5-ARP"><a href="#2-5-5-ARP" class="headerlink" title="2.5.5 ARP"></a>2.5.5 ARP</h3><p>ARP向同一以太网中的所有设备广播查询接收方的IP地址所对应的MAC地址，并在查询到之后写入ARP缓存之中，后续如果要向同一MAC地址发送就不需要发送ARP了。</p><h3 id="2-5-6-以太网"><a href="#2-5-6-以太网" class="headerlink" title="2.5.6 以太网"></a>2.5.6 以太网</h3><p>以太网三个性质：</p><p>1）将包发送到MAC头部的接收方MAC地址代表的目的地。</p><p>2）用发送方MAC地址识别发送方。</p><p>3）用以太类型识别包的内容。</p><h3 id="2-5-7-网卡"><a href="#2-5-7-网卡" class="headerlink" title="2.5.7 网卡"></a>2.5.7 网卡</h3><p>网卡组成部分</p><ul><li>缓冲区：用于临时保存要收发的包的内存空间。</li><li>ROM：存放唯一MAC地址。</li><li>MAC：控制碰撞检测、重发等以太网收发操作的部分。</li><li>PHY（MAU）：发送和接受信号的电路。</li><li>RJ-45接口：连接网线的插座。</li></ul><h3 id="2-5-8-信号转换"><a href="#2-5-8-信号转换" class="headerlink" title="2.5.8 信号转换"></a>2.5.8 信号转换</h3><p>1）MAC模块将包从缓冲区取出，在开头加上报头和起始帧分界符，在末尾加上用于检测错误的FCS（帧校验序列）。</p><p>2）为防止时钟信号传递太远时产生偏差，将数据信号与时钟信号叠加在一起。</p><p>3）FCS用于检验在传递过程中因噪声导致的波形紊乱、传递错误。</p><h3 id="2-5-9-向集线器发送网络包"><a href="#2-5-9-向集线器发送网络包" class="headerlink" title="2.5.9 向集线器发送网络包"></a>2.5.9 向集线器发送网络包</h3><p>发送信号分为半双工（发送信号与接收信号不能同时进行）与全双工（发送信号与接收信号可以同时进行）。</p><p>在半双工模式下发送信号先要监听网线中是否有其他设备正在发送信号，以避免发生碰撞。</p><p>PHY（MAU）接收MAC模块产生的信号，并再将其转换为网线上可以传输的形式。</p><h3 id="2-5-10-接收返回包"><a href="#2-5-10-接收返回包" class="headerlink" title="2.5.10 接收返回包"></a>2.5.10 接收返回包</h3><p>1）在半双工模式中，接收网线中的全部信号。</p><p>2）与之前步骤反过来进行信息转换，FCS校验是否发生错误，如果发生则丢弃。</p><p>3）MAC判断MAC地址是否一致，如果不一致则丢弃，否则通知计算机收到了一个包。</p><p>4）计算机接到中断信号，CPU挂起正在处理的任务，切换到操作系统的中断处理程序并控制网卡执行相应的接收操作。</p><h3 id="2-5-11-IP到TCP"><a href="#2-5-11-IP到TCP" class="headerlink" title="2.5.11 IP到TCP"></a>2.5.11 IP到TCP</h3><p>如果接受到接收方IP地址不是自己的包，IP模块通过ICMP消息将错误告知发送方。</p><p>如果接收到的包经过了分片，IP模块将其还原为完整的包，并交给TCP模块。</p><h2 id="2-6-UDP"><a href="#2-6-UDP" class="headerlink" title="2.6 UDP"></a>2.6 UDP</h2><h3 id="2-6-1-适用情形"><a href="#2-6-1-适用情形" class="headerlink" title="2.6.1 适用情形"></a>2.6.1 适用情形</h3><p>TCP为了实现高效的传输，需要避免重发已送达的包，而只重发出错的或未送达的包，但是当数据很短时全部重发也没关系。</p><p>可以将回复的数据当作确认包，就不需要额外的控制包了。</p><h3 id="2-6-2-控制用的短数据"><a href="#2-6-2-控制用的短数据" class="headerlink" title="2.6.2 控制用的短数据"></a>2.6.2 控制用的短数据</h3><p>DNS查询等交换控制信息的操作使用UDP。</p><p>UDP没有接受确认、窗口等机制，在应用程序没有收到回复时就重发。</p><p>UDP头部只有8字节大小。</p><h3 id="2-6-3-音视频数据"><a href="#2-6-3-音视频数据" class="headerlink" title="2.6.3 音视频数据"></a>2.6.3 音视频数据</h3><p>音视频数据必须在规定时间内送达，否则会错过播放时机导致卡顿，并且缺少部分包不会导致太大问题，最多出现失真与卡顿。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-网络是怎样连接的1</title>
      <link href="/2022/09/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/"/>
      <url>/2022/09/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/</url>
      
        <content type="html"><![CDATA[<h1 id="网络是怎样连接的-读书笔记1"><a href="#网络是怎样连接的-读书笔记1" class="headerlink" title="网络是怎样连接的 读书笔记1"></a>网络是怎样连接的 读书笔记1</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想卷进外企只能提前多准备点东西了，正好计网学的也不是很行，先整两本入门书看看吧。后续可能还会更《图解TCP/HTTP》。</p><h2 id="1-1-生成HTTP请求消息"><a href="#1-1-生成HTTP请求消息" class="headerlink" title="1.1 生成HTTP请求消息"></a>1.1 生成HTTP请求消息</h2><h3 id="1-1-1-输入网址"><a href="#1-1-1-输入网址" class="headerlink" title="1.1.1 输入网址"></a>1.1.1 输入网址</h3><p>网址全称为URL(Uniform Resource Locator), 网络资源定位符.</p><p>URL开头的文字, 如”http:”, “ftp:”, “file:”, “mailto:”等, 表示浏览器应当使用的访问方法, 或者说访问时使用的协议类型. 如访问Web服务器时应当采用HTTP协议, 访问FTP服务器时应当采用FTP协议.</p><p>URL根据使用的协议不同包含了不同的信息, 如访问Web服务器或FTP服务器时, 应当包含服务器域名和访问的文件路径名, 而发邮件时应该包含收件人的邮件地址. 此外还可能包含用户名密码, 服务器端口号等.</p><p>示例如下(其中用户名, 密码, 端口号, 文件名通常省略, 形成我们平时看到的URL样式):</p><p><code>http://user:password@www.glasscom.com:80/dir/file1.htm</code></p><h3 id="1-1-2-解析URL"><a href="#1-1-2-解析URL" class="headerlink" title="1.1.2 解析URL"></a>1.1.2 解析URL</h3><p>浏览器的第一部工作就是对URL进行解析, 来获得应该访问的目标位置. 浏览器对URL解析时, 先将上个示例的URL拆分成几个元素</p><ul><li>http: : 访问使用到的协议</li><li>// : 后面的字符串代表服务器名称</li><li><a href="http://www.glasscom.com/">www.glasscom.com</a> : 服务器名称</li><li>后续: 文件路径名</li></ul><h3 id="1-1-3-省略文件名"><a href="#1-1-3-省略文件名" class="headerlink" title="1.1.3 省略文件名"></a>1.1.3 省略文件名</h3><p><code>http://www.lab.glasscom.com/dir/</code></p><p>服务器上会事先设置好省略文件名时应该访问的文件,通常为index.html或default.htm</p><p><code>http://www.lab.glasscom.com/dir</code></p><p>根据dir在目录下到底是文件还是目录来分别当作文件或目录处理.(无法创建两个名称相同的文件或目录)</p><h3 id="1-1-4-HTTP基本思路"><a href="#1-1-4-HTTP基本思路" class="headerlink" title="1.1.4 HTTP基本思路"></a>1.1.4 HTTP基本思路</h3><p>HTTP协议传递过程：</p><ul><li>客户端向服务器发送请求消息，包含信息“对什么”和“进行怎样的操作”。“对什么”即为URI包含的信息，“什么操作”有以下几种：<ul><li>GET：获取URI指定的信息</li><li>POST：从客户端向服务器发送表单中填写的数据（需要用户输入）</li><li>HEAD：和GET基本相同，不过只返回HTTP消息头，用于获取文件最后更新的时间等属性信息</li><li>OPTIONS：通知或查询通信选项</li><li>PUT：替换URI指定的服务器上的文件</li><li>DELETE：删除URI指定的服务器上的文件</li><li>TRACE：将服务器收到的请求和头部直接返回给客户端。用于在使用代理的环境中检查改写请求</li><li>CONNECT：使用代理传输加密消息</li></ul></li><li>Web服务器对其中的内容进行解析，完成相应的工作，并将结果放在响应消息中。响应消息头有一个状态码，表示操作的执行结果是成功还是发生了错误。</li><li>客户端收到后，浏览器读出所需的信息并显示在屏幕上。</li></ul><p>由于网络安全等问题，实际上广泛普及的只有GET与POST。</p><h3 id="1-1-5-生成HTTP请求消息"><a href="#1-1-5-生成HTTP请求消息" class="headerlink" title="1.1.5 生成HTTP请求消息"></a>1.1.5 生成HTTP请求消息</h3><p>请求消息第一行为请求行，通过这一行可以大致了解请求的内容</p><p>GET请求消息示例</p><p><code>GET /cgi/sample.cgi?Field1=ABCDEFG&amp;SendButton=SEND HTTP/1.1</code></p><p><code>若干行头字段</code></p><p>POST请求消息示例</p><p><code>POST /cgi/sample.cgi HTTP/1.1</code></p><p><code>若干行头字段</code></p><p><code>Field1=ABCDEFG&amp;SendButton=SEND</code></p><p>头字段包含额外的详细信息，如日期、客户端支持的数据类型、语言等。</p><p>消息体包含需要发送的数据（GET请求由于不需要发送数据，因此消息体中不需要填写数据）</p><h3 id="1-1-6-服务器的响应消息"><a href="#1-1-6-服务器的响应消息" class="headerlink" title="1.1.6 服务器的响应消息"></a>1.1.6 服务器的响应消息</h3><p>响应消息格式：</p><p><code>HTTP/1.1 200 OK</code></p><p><code>Date: Wed, 21 Feb 2007 09: 19: 14 GMT</code></p><p><code>...</code></p><p><code>&lt;空行&gt;</code></p><p><code>&lt;html&gt;</code></p><p><code>&lt;head&gt;</code></p><p><code>&lt;消息体&gt;</code></p><p>第一行为状态码和响应短语，用来表示请求执行结果是成功还是出错，下面是状态码表示的大致结果：</p><ul><li>1xx：告知请求的处理结果和情况</li><li>2xx：成功</li><li>3xx：需要进一步操作</li><li>4xx：客户端错误</li><li>5xx：服务器错误</li></ul><p>网页中包含图片时，会在网页相应位置嵌入表示图片文件的标签的控制信息，浏览器在显示文字时搜索相应的标签，在屏幕上留出相应的空间并再次访问Web服务器请求图片文件。</p><p>一条URL只能获取一个文件。如果需要获取多个文件，必须对每个文件单独发送一条URL。</p><h2 id="1-2-向DNS服务器查询IP地址"><a href="#1-2-向DNS服务器查询IP地址" class="headerlink" title="1.2 向DNS服务器查询IP地址"></a>1.2 向DNS服务器查询IP地址</h2><h3 id="1-2-1-IP地址"><a href="#1-2-1-IP地址" class="headerlink" title="1.2.1 IP地址"></a>1.2.1 IP地址</h3><p>IP地址被子网掩码分为网络号与主机号两个部分。</p><p>主机号全0：表示整个子网。</p><p>主机号全1：表示向整个子网发送包，即“广播”。</p><h3 id="1-2-2-IP地址与域名并用的理由"><a href="#1-2-2-IP地址与域名并用的理由" class="headerlink" title="1.2.2 IP地址与域名并用的理由"></a>1.2.2 IP地址与域名并用的理由</h3><p>单用IP地址：难以让人记住</p><p>单用域名：字符串相比比特串更难储存，并且对路由器负担更大</p><h3 id="1-2-3-查询IP地址"><a href="#1-2-3-查询IP地址" class="headerlink" title="1.2.3 查询IP地址"></a>1.2.3 查询IP地址</h3><p>域名解析：使用本机上的DNS客户端，调用Socket包的解析器方法向DNS服务器请求解析域名获取IP地址。</p><h3 id="1-2-4-通过解析器向DNS服务器查询"><a href="#1-2-4-通过解析器向DNS服务器查询" class="headerlink" title="1.2.4 通过解析器向DNS服务器查询"></a>1.2.4 通过解析器向DNS服务器查询</h3><h3 id="1-2-5-解析器内部原理"><a href="#1-2-5-解析器内部原理" class="headerlink" title="1.2.5 解析器内部原理"></a>1.2.5 解析器内部原理</h3><p>第一步：解析器生成查询消息。</p><p>第二步：委托给操作系统内部的协议栈发送消息给DNS服务器。</p><p>第三步：DNS进行查询并将返回结果返回给解析器。（DNS的IP地址由用户在电脑里手动设置或自动获取）</p><h2 id="1-3-DNS查询"><a href="#1-3-DNS查询" class="headerlink" title="1.3 DNS查询"></a>1.3 DNS查询</h2><h3 id="1-3-1-DNS查找方式"><a href="#1-3-1-DNS查找方式" class="headerlink" title="1.3.1 DNS查找方式"></a>1.3.1 DNS查找方式</h3><p>来自客户端的查询消息所包含的信息：域名、邮件服务器名称（@后面的部分）；Class（网络类型，现在因为只剩下互联网所以弃用，只有IN）；记录类型（域名对应何种类型的记录）（A表示域名对应IP地址，MX表示域名对应邮件服务器）</p><p>DNS通过在记录中查表并对比上述三个项目的方式来找到对应的返回值。</p><h3 id="1-3-2-域名层次结构"><a href="#1-3-2-域名层次结构" class="headerlink" title="1.3.2 域名层次结构"></a>1.3.2 域名层次结构</h3><p>以<a href="http://www.lab.glasscom.com为例,层次结构大小从com到www依次递减./">www.lab.glasscom.com为例，层次结构大小从com到www依次递减。</a></p><p>一个域的信息作为一个整体存放在DNS服务器中，而一台DNS服务器可能存放多个域的信息。</p><p>在com、jp等域的最上层还有一个根域，域名应为<a href="http://www.lab.glasscom.com.但是最后的点经常省略./">www.lab.glasscom.com.但是最后的点经常省略。</a></p><p>上级DNS服务器保存着所有下级DNS服务器的信息。</p><p>每台DNS服务器都保存了根域的DNS服务器信息。</p><h3 id="1-3-3-DNS查询"><a href="#1-3-3-DNS查询" class="headerlink" title="1.3.3 DNS查询"></a>1.3.3 DNS查询</h3><ol><li>客户端访问最近的一台DNS服务器，请求查询信息<a href="http://www.lab.glasscom.com./">www.lab.glasscom.com。</a></li><li>DNS服务器本地没有保存与该域名对应的信息，因此向根域服务器发送查询消息。</li><li>根域根据域名结构解析出该域名属于com域，因此返回其所管理的com域的DNS服务器的IP地址。</li><li>DNS服务器重复3步骤，直到最终获得<a href="http://www.lab.glasscom.com域的ip地址./">www.lab.glasscom.com域的IP地址。</a></li><li>DNS服务器将查询到的IP地址返回给客户端。</li></ol><h3 id="1-3-4-缓存"><a href="#1-3-4-缓存" class="headerlink" title="1.3.4 缓存"></a>1.3.4 缓存</h3><p>DNS服务器有缓存，可以记住一定时间内访问过的域名的信息，如果没找到域名，也会将“域名不存在”作为信息记录。</p><p>由于域名信息可能会更新，因此每条缓存都有时间限制，超过时限则会消失。</p><h2 id="1-4-协议栈"><a href="#1-4-协议栈" class="headerlink" title="1.4 协议栈"></a>1.4 协议栈</h2><h3 id="1-4-1-数据收发流程"><a href="#1-4-1-数据收发流程" class="headerlink" title="1.4.1 数据收发流程"></a>1.4.1 数据收发流程</h3><p>浏览器委托协议栈与Web服务器通信同样使用Socket库。</p><p>收发数据的操作大致分为四个阶段：1）创建套接字；2）将管道连接到服务器端的套接字上；3）收发数据；4）断开管道并删除套接字</p><h3 id="1-4-2-创建套接字"><a href="#1-4-2-创建套接字" class="headerlink" title="1.4.2 创建套接字"></a>1.4.2 创建套接字</h3><p>应用程序调用Socket库的socket函数，协议栈返回一个描述符，它用来识别不同的套接字。</p><h3 id="1-4-3-连接管道"><a href="#1-4-3-连接管道" class="headerlink" title="1.4.3 连接管道"></a>1.4.3 连接管道</h3><p>应用程序调用Socket库的connect函数与服务器进行连接，需要指定描述符、服务器IP地址与端口号三个参数。</p><p>描述符与端口号的区别是，描述符是告诉本机的协议栈使用哪一个套接字与服务端的套接字进行连接，而端口号是告诉网络连接的另一方自身的套接字。</p><p>服务器所使用的端口号一般是事先规定好的。</p><p>本机使用的端口号在创建套接字时随机分配，并在连接时发送给服务器。</p><h3 id="1-4-4-传递消息"><a href="#1-4-4-传递消息" class="headerlink" title="1.4.4 传递消息"></a>1.4.4 传递消息</h3><p>应用程序调用Socket库的write与read函数与服务器传递消息。</p><h3 id="1-4-5-断开连接"><a href="#1-4-5-断开连接" class="headerlink" title="1.4.5 断开连接"></a>1.4.5 断开连接</h3><p>两边都可以主动断开连接。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/09/21/hello-world/"/>
      <url>/2021/09/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大致了解-java4</title>
      <link href="/2021/09/20/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-java4/"/>
      <url>/2021/09/20/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-java4/</url>
      
        <content type="html"><![CDATA[<p>这期学一学java核心类</p><h2 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h2><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>为了高效拼接字符串，防止直接使用临时对象导致的内存与效率浪费，使用StringBuilder类通过append与toString进行拼接。</p><p>StringBuilder还能进行链式操作。</p><h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h3><p>用指定的分隔符、开头和结尾拼接字符串。</p><h2 id="Record记录类"><a href="#Record记录类" class="headerlink" title="Record记录类"></a>Record记录类</h2><p>通过使用recoder关键字，除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString()、equals()和hashCode()方法。</p><p>也就是说，使用recoder可以自动生成不变类。</p>]]></content>
      
      
      <categories>
          
          <category> 大致了解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大致了解-java3</title>
      <link href="/2021/09/19/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-java3/"/>
      <url>/2021/09/19/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-java3/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数用类型…定义，可变参数相当于数组类型。</p><p>相比于数组类型来说，可变参数不需要构造数组，只需要将单个元素作为参数传入，并且可变参数可以保证不会传入null。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Java使用extends关键字来实现继承。</p><p>super关键字表示父类（超类）。子类引用父类的字段时，可以用super.fieldName。</p><p>从Java 15开始，允许使用sealed修饰class，并通过permits明确写出能够从该class继承的子类名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public sealed class Shape permits Circ, Tria, Rect&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="上下转型"><a href="#上下转型" class="headerlink" title="上下转型"></a>上下转型</h3><p>为了避免向下转型出错，Java提供了instanceof操作符，可以先判断一个实例究竟是不是某种类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; &quot;hello&quot;;</span><br><span class="line">if (obj instanceof String s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 可以直接使用变量s:</span><br><span class="line">    System.out.println(s.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>加上@Override可以让编译器帮助检查是否进行了正确的覆写。</p><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>用于父类不希望任何子类覆写它的某个方法，或者一个类不希望任何类继承它。</p><h4 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h4><p>因为所有的class最终都继承自Object，而Object定义了几个重要的方法：</p><ul><li>toString()：把instance输出为String；</li><li>equals()：判断两个instance是否逻辑相等；</li><li>hashCode()：计算一个instance的哈希值。</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。这个类也必须申明为抽象类（abstract class）。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>如果一个抽象类没有字段，且所有方法都是抽象方法，就可以把它改写成一个接口，用interface关键字表示。</p><p>当一个具体的class去实现一个interface时，需要使用implements关键字。一个类可以实现多个interface。</p><p>一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法。</p><h4 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h4><p>实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><p>由于interface没有字段，所以default方法只能通过调用其他方法获取信息。</p><h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p>interface可以拥有静态字段，但是因为它的字段只能是public static final类型，所以可以将这些修饰符省略直接定义静态字段，编译器会自动把该字段变为public static final类型。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>定义在一个class内部的class称为嵌套类（nested class），嵌套类拥有访问private的权限。</p><p>内部类不能单独存在，必须在实例化外部内后调用其new方法创建自身实例。</p><p>Java的内部类可分为Inner Class、Anonymous Class和Static Nested Class三种：</p><ul><li>Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有Outer.this实例，并拥有Outer Class的private访问权限；</li><li>Static Nested Class是独立类，但拥有Outer Class的private访问权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大致了解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大致了解-java2</title>
      <link href="/2021/09/19/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-java2/"/>
      <url>/2021/09/19/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-java2/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>Arrays.toString()可以将数组转换为string，从而快速打印数组内容。<br>Arrays.deepToString()可以将多维数组转换为string。</p><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>Arrays.sort()可以对数组进行排序。</p>]]></content>
      
      
      <categories>
          
          <category> 大致了解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大致了解-java1</title>
      <link href="/2021/09/18/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-java1/"/>
      <url>/2021/09/18/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-java1/</url>
      
        <content type="html"><![CDATA[<p>软件分析课程需要，提前熟悉下java，也不知道学多久太监。</p><h2 id="基本结构与类型"><a href="#基本结构与类型" class="headerlink" title="基本结构与类型"></a>基本结构与类型</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类 (class) 与方法 (method)。</p><p>类名：类名必须以英文字母开头，后接字母，数字和下划线的组合。习惯以大写字母开头。</p><p>Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。</p><p>注释：</p><ul><li><code>//</code> 单行注释</li><li><code>/*...*/</code> 多行注释</li><li><code>/**...*/</code> 写在类和方法定义处，用于创建文档</li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>整数类型：byte，short，int，long</li><li>浮点数类型：float，double</li><li>字符类型：char</li><li>布尔类型：boolean</li></ul><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>int i = 2147483647;<br>int i2 = -2147483648;<br>int i3 = 2_000_000_000; // 加下划线更容易识别<br>int i4 = 0xff0000; // 十六进制表示的16711680<br>int i5 = 0b1000000000; // 二进制表示的512<br>long l = 9000000000000000000L; // long型的结尾需要加L</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>float f1 = 3.14f;<br>float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38<br>double d = 1.79e308;</p><p>float型必须加f后缀</p><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>单引号，可表示一个unicode字符</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>除以上三种类型外都是引用类型</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>final修饰符，只可初始化赋值，不能更改其值</p><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>使用var代替类型名，让编译器自动推断</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>如果用+连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串</p><p>从Java 13开始，字符串可以用”””…”””表示多行字符串（Text Blocks）了</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>println是print line的缩写，表示输出并换行。因此，如果输出后不想换行，可以用print()<br>格式化输出使用System.out.printf()，通过使用占位符%?，printf()可以把后面的参数格式化成指定格式</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>首先通过import语句导入java.util.Scanner；之后创建Scanner对象并传入System.in；最后，通过Scanner类的nextLine、nextInt等方法来读取输入并传输到String、Int等类型的变量中。</p><h3 id="判断引用类型相等"><a href="#判断引用类型相等" class="headerlink" title="判断引用类型相等"></a>判断引用类型相等</h3><p>==：用于判断两个引用类型指向的对象是否为同一个<br>equals方法：用于判断两个引用类型指向的对象值是否相等</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>java12开始的新语法：-&gt;，用于替代case后面的:。<br>新语法没有穿透效应（所以不用在case末尾添加break），并且还可以通过switch语句直接返回值（而不需要在每个分支给同一个变量赋值）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int opt &#x3D; switch (fruit) &#123;</span><br><span class="line">    case &quot;apple&quot; -&gt; 1;</span><br><span class="line">    case &quot;pear&quot;, &quot;mango&quot; -&gt; 2;</span><br><span class="line">    default -&gt; 0;</span><br><span class="line">&#125;; &#x2F;&#x2F; 注意赋值语句要以;结束</span><br></pre></td></tr></table></figure><p>如果需要复杂的语句，我们也可以写很多语句，放到{…}里，然后，用yield返回一个值作为switch语句的返回值.</p>]]></content>
      
      
      <categories>
          
          <category> 大致了解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大致了解-kframework3</title>
      <link href="/2021/07/18/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-kframework3/"/>
      <url>/2021/07/18/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-kframework3/</url>
      
        <content type="html"><![CDATA[<p>本学习笔记从tutorial 2-1开始记录。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>关键词 <code>configuration</code>：编写配置（作用类似于帮你标识语句块中的各种属性，并划分为一个个单元？）。</li><li><code>$PGM:Pgm</code>；捕获经过.k文件中的语法解释后的语句。</li></ul><p>此外，还可以通过html形式来设置各单元的字符颜色等。</p><pre><code>configuration`&lt;T color=&quot;yellow&quot;&gt;`                `&lt;k color=&quot;green&quot;&gt;` $PGM:Pgm `&lt;/k&gt;`                `&lt;state color=&quot;red&quot;&gt;` .Map `&lt;/state&gt;`            `&lt;/T&gt;`</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大致了解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大致了解-kframework2</title>
      <link href="/2021/07/17/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-kframework2/"/>
      <url>/2021/07/17/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-kframework2/</url>
      
        <content type="html"><![CDATA[<p>本笔记开始于tutorial lesson 1-5.</p><h1 id="添加整数、布尔值运算与条件操作"><a href="#添加整数、布尔值运算与条件操作" class="headerlink" title="添加整数、布尔值运算与条件操作"></a>添加整数、布尔值运算与条件操作</h1><p>新增操作符 <code>&gt;</code>，表示该符号前面的语法比后面的语法绑定更为紧密。</p><p>添加方式：通过syntax定义运算的语法，并通过rule将syntax定义的语法替换为k语言的内置Int四则运算语法。</p><h1 id="添加条件运算"><a href="#添加条件运算" class="headerlink" title="添加条件运算"></a>添加条件运算</h1><p>添加方式与上文类似。</p><h1 id="structural-rules-结构化规则"><a href="#structural-rules-结构化规则" class="headerlink" title="structural rules 结构化规则"></a>structural rules 结构化规则</h1><p>与宏类似？</p><h1 id="递归-letrec"><a href="#递归-letrec" class="headerlink" title="递归 ( letrec )"></a>递归 ( letrec )</h1><p>lambda 不动点定理：对所有lambda项f，都存在一个不动点fix f，使得fix f = f (fix f)。</p><p>在定义递归函数的语法时，不能像编写c++程序一样，在其未定义完成之前就进行使用，因此需要引入不动点fix。</p><p>fix对于任意函数都是一样的</p><pre><code>let fix = lambda f . (        (lambda x . (f (lambda y . (x x y))))        (lambda x . (f (lambda y . (x x y)))))in let f = fix (lambda f . lambda x .                (if x &lt;= 1 then 1 else (x * (f (x + -1)))))    in (f 10)</code></pre><p>将其改为使用letrec定义规则，可以得到如下形式：</p><pre><code>syntax KVar ::= &quot;$x&quot; [token] | &quot;$y&quot; [token]rule letrec F:KVar X:KVar = E in E&#39;    =&gt; let F =        (lambda $x . ((lambda F . lambda X . E)(lambda $y . ($x $x $y))))        (lambda $x . ((lambda F . lambda X . E)(lambda $y . ($x $x $y))))    in E&#39;</code></pre><p>之后在.lambda文件中，使用如下的简单格式即可编写递归函数</p><pre><code>letrec f x = if x &lt;= 1 then 1 else (x * (f (x + -1)))in (f 10)</code></pre><h1 id="递归-mu"><a href="#递归-mu" class="headerlink" title="递归 ( mu )"></a>递归 ( mu )</h1><p>关键词 <code>mu</code>语法规则与 <code>lambda</code>一致，只需要将所有 <code>lambda</code>替换为 <code>mu</code>即可。</p><p>编写 <code>mu</code>的rule为</p><pre><code>mu X . E =&gt; E[(mu X . E) / X]</code></pre><p>与beta-归约类似，将E中所有的X替换为mu X . E。</p><p>.lambda文件中的语句编写如下</p><pre><code>(mu f . lambda x . if x &lt;=1 then x else ((f (x + -1)) + (f (x + -2)))) 7</code></pre><h1 id="在k定义中添加注释"><a href="#在k定义中添加注释" class="headerlink" title="在k定义中添加注释"></a>在k定义中添加注释</h1><ul><li>普通注释：<code>//</code>与 <code>/* ... */</code>。这类注释会被完全忽略。</li><li>文档注释：在 <code>//</code>或 <code>/*</code>后面使用 <code>@</code>。</li><li>头部注释：在 <code>//</code>或 <code>/*</code>后面使用 <code>!</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大致了解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大致了解-kframework1</title>
      <link href="/2021/07/16/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-kframework1/"/>
      <url>/2021/07/16/%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3-kframework1/</url>
      
        <content type="html"><![CDATA[<p>暑假跟着导师提前做项目，需要学个这东西。因为官方tutorial很多东西讲得很隐晦（并且作者用的纯正的罗马尼亚口音英语根本听不懂），所以开个学习笔记防止自己忘了。</p><h1 id="kframework基本概念"><a href="#kframework基本概念" class="headerlink" title="kframework基本概念"></a>kframework基本概念</h1><p>kframework的编写分为两类文件，.k文件与.lambda文件。.k文件主要负责语法的编写，主要用类似lambda表达式的形式实现，而.lambda文件主要写入待进行语法解析的句子，通过使用.k文件中规定的语法对其进行解析.</p><h1 id="基本关键词一览"><a href="#基本关键词一览" class="headerlink" title="基本关键词一览"></a>基本关键词一览</h1><p>.k文件的基本组成包括以下几种关键词。</p><ul><li><code>module ... endmodule</code>: 加入一个新的k模块, 可以类比c++中的函数这种形式.</li><li><code>syntax</code>: 为模块中添加一条新的语法, 使用类似<a href="https://www.zhihu.com/question/27051306">BNF范式</a>的形式.</li><li>终结符: 一般由双引号括起来, 类似于c++中string的形式.</li><li><code>|</code>: 为同一个非终结符定义多条不同的展开形式.</li><li><code>imports</code>: 类似于include和import，引入预定义的模块或其他自定义模块.</li><li><code>rule</code>: 定义替换规则，使用改写符号 <code>=&gt;</code>。</li></ul><p>此外，每一条语法都可以拥有属性，通过 <code>[]</code>括起来附加在语法后面。</p><ul><li><code>left</code>：要求本条语法左结合，例如 <code>a b c d</code>会被解释为 <code>(((a b) c) d)</code>。</li><li><code>bracket</code>：希望解释器不要为圆括号 <code>()</code>提供显式语义。（意思是单纯作为终结符来使用？）</li><li><code>binder</code>：告诉解释器某一条语法中所有变量都将被用于绑定与替换，通过使用 <code>KVar</code>等关键词告诉解释器哪些变量需要被替换。</li><li><code>strict</code>：告诉解释器在求解该条表达式之前，必须先对子表达式进行求值。</li><li><code>latex</code>：在文档中将语句替换为latex形式，例如 <code>latex(\lambda&#123;#1&#125;.&#123;#2&#125;)</code>。</li></ul><h1 id="Beta-归约与绑定关系"><a href="#Beta-归约与绑定关系" class="headerlink" title="Beta-归约与绑定关系"></a>Beta-归约与绑定关系</h1><p>beta-归约使用k语言定义为</p><p><code>rule (lambda X:KVar . E:Exp) V:Val =&gt; E[V / X]</code></p><p>用自然语言解释为：将表达式E中的X全部用V来替换。简单理解为，可将E视为函数，X为形式参数，而V则为实际参数。beta-归约有一个重要原则：不能增加新的绑定关系。</p><p>绑定关系类似于离散数学里全称量词与存在量词的作用域。lambda X . E V中，X的作用域只有E，而与E之外的X不是同一个X。</p><h1 id="call-by-value"><a href="#call-by-value" class="headerlink" title="call by value"></a>call by value</h1><p>类似于C++中，对于add(f1(), f2())这条语句，需要先计算出f1()与f2()的值，它们才会被传入add函数中，即参数需要先计算成值才能被继续传递。</p>]]></content>
      
      
      <categories>
          
          <category> 大致了解 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习-背包问题与滚动数组思想</title>
      <link href="/2021/03/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%8E%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E6%80%9D%E6%83%B3/"/>
      <url>/2021/03/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%8E%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、主要思想"><a href="#一、主要思想" class="headerlink" title="一、主要思想"></a>一、主要思想</h2><p>利用大多数dp问题往往具有：根据上一个或者上几个状态来决定当前状态，的特点，而只针对这几个状态进行存储，不断地用新生成的数据覆盖不使用的旧数据空间，以达到降低空间利用的目的。</p><h2 id="二、举例说明"><a href="#二、举例说明" class="headerlink" title="二、举例说明"></a>二、举例说明</h2><p>以经典的01背包问题为例，dp[n][m]为动态规划数组dp，n代表物品的编号，m代表当前总共占的体积大小，而dp的值则代表了当前情况下所能获得的最大价值。<br>由于上面对dp数组与下标的定义，可以知道边界条件的初始化值：</p><ul><li>dp[0][j]代表了取第0件物品时所能产生的最大价值。显然当j大于等于第0件物品的体积时，dp[0][j]即为第0件物品的价值，否则为0。</li><li>dp[i][0]代表了背包为空时能产生的最大价值，显然背包为空时不能放入任何物品，最大价值为0。</li></ul><p>接下来确认递推关系，对于某位置dp[i][j]：</p><ul><li>我们可以不取第i号物品（或者已经放不下了），此时dp[i][j]=dp[i-1][j]。</li><li>我们也可以取第i号物品，此时dp[i][j]=dp[i-1][j-weight[i]]+value[i]。</li></ul><p>得到递推关系dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])。</p><p>从中我们可以看出的是，对于i这一层关系来说，dp[i]只与dp[i-1]的状态有关，也就意味着，在做dp[i-1]行到dp[i]行的状态转移时，i-2、……、0行的状态都是不被需要的。所以我们可以在状态转移时只用一维数组dp[j]记录状态，不断用新的值来覆盖旧的值。</p><h2 id="三、第二维j的遍历方向问题"><a href="#三、第二维j的遍历方向问题" class="headerlink" title="三、第二维j的遍历方向问题"></a>三、第二维j的遍历方向问题</h2><p>对于01背包问题来说，假设我们通过正序来遍历j，利用dp[4][9]得到了dp[5][10]的值，而下一步我们又需要利用到dp[4][10]的值，但是这个时候它的值已经被dp[5][10]覆盖了，所以无法再取到它的值。</p><p>而如果采用j倒序的方式来遍历，当某个位置的值将要更新时，它只会依靠位于其前面的位置的值来更新，而此时它的前面位置的值还处于上一层未被更新，它的后面位置的值均已被更新，但是在这一层不会被调用到，所以可以解决覆盖问题。</p><p>对于完全背包问题，由于物品可以取无限多次，所以可以采用正序进行遍历。</p><h2 id="四、求方式数"><a href="#四、求方式数" class="headerlink" title="四、求方式数"></a>四、求方式数</h2><p>在求装满背包有几种方法的情况下，递推公式一般为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] +&#x3D; dp[j - nums[i]];</span><br></pre></td></tr></table></figure><h2 id="五、两层循环嵌套顺序能否互换"><a href="#五、两层循环嵌套顺序能否互换" class="headerlink" title="五、两层循环嵌套顺序能否互换"></a>五、两层循环嵌套顺序能否互换</h2><p>01背包问题与完全背包问题都是可以替换的，因为在递推过程中，当前位置的值永远只会依赖当前位置左上方向上的值，而这些值无论以哪种循环嵌套顺序，都是先于当前位置被计算。一般为外层遍历物品，内层遍历背包</p><p>如果不是求组合数，而是需要求排列数，即{1,5}与{5,1}算作两种解答，这时候需要外层遍历背包，内层遍历物品。</p><h2 id="六、知识点总结"><a href="#六、知识点总结" class="headerlink" title="六、知识点总结"></a>六、知识点总结</h2><p>拿到动态规划问题的步骤：</p><ol><li>分析是否为背包问题</li><li>分析是哪种背包问题（下列三种分类）</li><li>分析是01还是完全</li><li>分析要求的答案是组合还是排列，即元素之间的顺序关系</li></ol><p>常见背包问题分类</p><h3 id="①-组合问题："><a href="#①-组合问题：" class="headerlink" title="① 组合问题："></a>① 组合问题：</h3><ol><li>377.组合总和 Ⅳ</li><li>494.目标和</li><li>518.零钱兑换 II</li></ol><p>通用公式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j]+&#x3D;dp[j-weight[i]]</span><br></pre></td></tr></table></figure><h3 id="②-True与False问题："><a href="#②-True与False问题：" class="headerlink" title="② True与False问题："></a>② True与False问题：</h3><ol><li>139.组合总和 Ⅳ</li><li>416.目标和</li></ol><p>通用公式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j]&#x3D;dp[j]|dp[j-weight[i]]</span><br></pre></td></tr></table></figure><h3 id="③-最大最小问题"><a href="#③-最大最小问题" class="headerlink" title="③ 最大最小问题"></a>③ 最大最小问题</h3><ol><li>474.一和零</li><li>322.零钱兑换</li></ol><p>通用公式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j]&#x3D;max&#x2F;min(dp[j],dp[j-weight[i]]+value[i])</span><br></pre></td></tr></table></figure><p>再分类</p><h3 id="①-01背包问题"><a href="#①-01背包问题" class="headerlink" title="① 01背包问题"></a>① 01背包问题</h3><p>数组中的元素不可重复使用，应该将物品放在外侧循环，体积放在内侧循环，并且对体积倒序遍历。</p><h3 id="②-完全背包问题"><a href="#②-完全背包问题" class="headerlink" title="② 完全背包问题"></a>② 完全背包问题</h3><p>数组中的元素可重复使用，应该将物品放在外侧循环，体积放在内侧循环，并且对体积正序遍历。</p><h3 id="③-需要考虑元素间的顺序"><a href="#③-需要考虑元素间的顺序" class="headerlink" title="③ 需要考虑元素间的顺序"></a>③ 需要考虑元素间的顺序</h3><p>应该将体积放在外侧循环，物品放在内侧循环。如果出现这种情况，在内侧循环赋值时记得将下标与体积进行比较，避免数组越界。</p><p>以上总结参考自：<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-动态规划</title>
      <link href="/2021/03/20/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2021/03/20/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><p>动态规划跟贪心的不同在于，其某一步得到的解法并不一定是当前的局部最优解，并且是根据之前步骤的状态推导而来</p><p>求解dp问题主要有以下几步：</p><ul><li>确定dp数组与其下标的含义</li><li>确定递推公式</li><li>dp数组初始化</li><li>遍历顺序</li><li>举例推导</li></ul><h2 id="二、空间优化-O-n-优化到O-1"><a href="#二、空间优化-O-n-优化到O-1" class="headerlink" title="二、空间优化-O(n)优化到O(1)"></a>二、空间优化-O(n)优化到O(1)</h2><p>以斐波那契数组为例，当前状态只与前面两个状态有递推关系，而与更前面的状态均无关系，这时可以只用空间存储前面两个状态，并在每次递推结束后更新这两个状态的值。</p><h2 id="三、不同的二叉搜索树"><a href="#三、不同的二叉搜索树" class="headerlink" title="三、不同的二叉搜索树"></a>三、不同的二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">leetcode 96：不同的二叉搜索树</a></p><p>这道题的难点在于递推公式的推导。当节点数为i时，除了根节点左右两边节点的总和为i-1，而因为左右子树是节点数小于i的二叉树，其可能出现的情况已经在之前推导出来，根据乘法原则与加法原则即可推导出递推公式。</p><h2 id="四、滚动数组思想"><a href="#四、滚动数组思想" class="headerlink" title="四、滚动数组思想"></a>四、滚动数组思想</h2><p>利用dp问题具有空间局部性的思想，将空间复杂度降低一个或多个量级。</p><p><a href="https://aobamoka.github.io/2021/03/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%AD%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%8E%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E6%80%9D%E6%83%B3/">动态规划中的背包问题与滚动数组思想</a></p><h2 id="五、01背包问题"><a href="#五、01背包问题" class="headerlink" title="五、01背包问题"></a>五、01背包问题</h2><p>难点在于如何把已知问题的各个参数转化为01背包问题中的参数，以及确定最终的返回值。</p><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">leetcode 416：分割等和子集</a>：物品的重量和价值都是数的大小。由于dp[i]是一定小于i的，其最大值也只能为i，所以最终返回值为dp[n] (n为总和的一半)。</p><p><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">leetcode 1049：最后一块石头的重量</a>：物品的重量和价值都是石头的重量。由于转化方式跟416一样，dp[i]仍是小于i的，我们的目的是将石头分为两组，让两组之间相撞，最后得到最小的差值即为结果，因此最终返回值为sum-dp[n]-dp[n]。</p><h2 id="六、爬楼梯的拓展"><a href="#六、爬楼梯的拓展" class="headerlink" title="六、爬楼梯的拓展"></a>六、爬楼梯的拓展</h2><p>爬楼梯问题不放链接都能背出来了吧。那么如果改成一次最多可以爬m个台阶，爬到第n个台阶有多少种方法呢？</p><p>① 为求组合方法数问题，通用公式为dp[j]+=dp[j-weight[i]]。</p><p>② 由于可以爬多个一层，所以为完全背包问题。</p><p>③ 如果爬到三层，先爬一层再爬两层与先爬两层再爬一层是两种不同的方案，所以是排列问题，应该将体积放在外侧循环（此题中为目标台阶数n），物品放在内侧循环（此题中为一次攀爬可选的台阶数1~m）。</p><p>做完这三个判断，问题便迎刃而解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n, int m) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1,0);</span><br><span class="line">        dp[0]&#x3D;1;</span><br><span class="line">        for(int i&#x3D;0;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">                if(i&gt;j)dp[i]+&#x3D;dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="七、多重背包简介"><a href="#七、多重背包简介" class="headerlink" title="七、多重背包简介"></a>七、多重背包简介</h2><p>多重背包问题就是在01背包问题的基础上由最多一件相同物品变成了最多k件相同物品。其处理方式有两种：</p><ul><li>将k-1件物品放进物品选择列表中，这样就变成了01背包问题。</li><li>再嵌套一层循环，遍历单个物品的个数。</li></ul><h2 id="八、打家劫舍系列"><a href="#八、打家劫舍系列" class="headerlink" title="八、打家劫舍系列"></a>八、打家劫舍系列</h2><p>打家劫舍III中，通过返回值分别记录选与不选该节点得到的最大值来进行递归。</p><h2 id="九、股票系列"><a href="#九、股票系列" class="headerlink" title="九、股票系列"></a>九、股票系列</h2><p>对每天的股票状态用一个vector数组来表示第i次购买后是否持有或不持有股票。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习-sort与priority_queue中的自定义排序</title>
      <link href="/2021/03/19/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-sort%E4%B8%8Epriority_queue%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/03/19/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-sort%E4%B8%8Epriority_queue%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="sort与priority-queue中的自定义排序"><a href="#sort与priority-queue中的自定义排序" class="headerlink" title="sort与priority_queue中的自定义排序"></a>sort与priority_queue中的自定义排序</h2><p>平时在使用c++的函数或者容器时经常会需要自定义比较函数来满足自己的需求，比如sort()以及priority_queue这些东西。但是这些的自定义比较函数感觉要求都不尽相同，每次还要上网搜索比较麻烦，那就简单总结一下吧。</p><p>系统默认为从小到大排列。</p><p>假设待排序容器为vector&lt;pair&lt;int,int&gt;&gt; v。</p><h3 id="系统自己给的"><a href="#系统自己给的" class="headerlink" title="系统自己给的"></a>系统自己给的</h3><p>greater&lt;type&gt;和less&lt;type&gt;</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>存在三种自定义排序函数的方法：</p><h4 id="①-自定义返回值为bool类型的比较函数并将该函数作为第三个参数传入"><a href="#①-自定义返回值为bool类型的比较函数并将该函数作为第三个参数传入" class="headerlink" title="① 自定义返回值为bool类型的比较函数并将该函数作为第三个参数传入"></a>① 自定义返回值为bool类型的比较函数并将该函数作为第三个参数传入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)&#123;</span><br><span class="line">    return b.second&lt;a.second||a.first&lt;b.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(v.begin(),v.end(),cmp);</span><br></pre></td></tr></table></figure><p>如果a={1,5},b={2,4}，有b.second&lt;a.second，由于系统默认从小到大排列，那么就会把a排列到b之前，这样就实现了根据second从大到小排列。</p><ul><li>这里特别需要注意的是，如果需要在类里定义这样一个比较函数，必须将其设置为静态成员函数，因为类会隐藏一个this指针，而sort在调用时又只传入两个参数，导致少一个参数而报错。</li></ul><h4 id="②-重载操作符"><a href="#②-重载操作符" class="headerlink" title="② 重载操作符"></a>② 重载操作符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool operator&lt;(const &amp;pair&lt;int, int&gt; a, const &amp;pair&lt;int, int&gt; b)&#123;</span><br><span class="line">    return b.second&lt;a.second||a.first&lt;b.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一样的意思啦，不过如果重载基本类型的操作符的话可能影响到其他地方的比较，所以还是尽量少用吧。<br>调用方式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(v.begin(),v.end());</span><br></pre></td></tr></table></figure><h4 id="③-声明比较类"><a href="#③-声明比较类" class="headerlink" title="③ 声明比较类"></a>③ 声明比较类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator()(const &amp;pair&lt;int, int&gt; a, const &amp;pair&lt;int, int&gt; b)&#123;</span><br><span class="line">        return b.second&lt;a.second||a.first&lt;b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用方式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(v.begin(),v.end(),cmp())</span><br></pre></td></tr></table></figure><p>重载的是()方法，所以要加上括号</p><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>使用声明比较类的方式来进行自定义排序。不同的是，priority_queue实际的排序结果跟自定义编写的逻辑是反过来的，也就是说，传入less <code>&lt;int&gt;</code>，priority_queue却会将最大元素排在队首。</p><p>原因是：sort是根据比较函数逻辑来直接对元素排序；而priority_queue底层实现为大根堆，默认使用less&lt;&gt;来进行比较。如果有a与b两个元素，a&lt;b为true，就会判定为b的优先级更高，所以b排在a前面。</p><p>注意priority_queue与我们一般使用的逻辑是反的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-贪心算法</title>
      <link href="/2021/03/19/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2021/03/19/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前驱"><a href="#一、前驱" class="headerlink" title="一、前驱"></a>一、前驱</h2><p>贪心与动态规划的使用区别：</p><p>贪心要求局部最优解能够推出全局最优解，而动态规划解决的问题一般无法通过局部最优解推出全局最优解。</p><p>简单的例子为：有一摞各种面值的钞票，要求从其中抽出10张且面值总和最大。我们通过常识就知道，只要抽出的每一张都是当前钞票堆里最大的那一张，抽出的10张面值总和肯定是最大的。这就是局部最优解推出全局最优解，所以可以用贪心算法解决这道题。</p><p>而以背包问题为例，假设背包大小为10，物品的体积为{8,5,4}。显然可以看出第一次取物品的局部最优解是8，但是全局最优解则是5+4=9&gt;8。这种情况就应该用动态规划。</p><p>由于贪心问题上述的特点，其解法一般也为，先将全局问题分解为若干子问题，选用合适的贪心策略求解子问题最优解，再综合为全局问题最优解。</p><p>感觉做了两三道题还是拿不准什么时候该用贪心算法，<del>大概只能多刷凭感觉了吧</del>。</p><h2 id="二、调用c-函数-模板类时的自定义比较函数"><a href="#二、调用c-函数-模板类时的自定义比较函数" class="headerlink" title="二、调用c++函数/模板类时的自定义比较函数"></a>二、调用c++函数/模板类时的自定义比较函数</h2><p>感觉还是挺重要的，所以单独发了一篇博客讲这个，这里就当插个眼吧。</p><p><a href="https://aobamoka.github.io/2021/03/19/sort%E4%B8%8Epriority-queue%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/">sort与priority_queue中的自定义排序</a></p><h2 id="三、加油站"><a href="#三、加油站" class="headerlink" title="三、加油站"></a>三、加油站</h2><p><a href="https://leetcode-cn.com/problems/gas-station/">leetcode 134：加油站</a></p><p>代码随想录给了两种方法：</p><ul><li>先计算总加油-总耗油是否大于0，并记录从0往前走的过程中最小的累加值。之后从后往前遍历，寻找到能填平这个累加值的第一个节点。</li><li>同样先计算总加油-总耗油大于0，之后从0开始遍历并进行累加。如果出现之前的累加值小于0，就从当前遍历到点作为起点继续往后累加。</li></ul><p>我一开始想到的是第二种方法，但是并不清楚该如何解释它的正确性。其实，由于已经计算过总加油是大于总耗油的，所以如果之前存在小于0的净加油量，则之后一定会存在大于0的净加油量，且其绝对值大于之前的绝对值，所以从当前遍历到的点开始是合理的。</p><h2 id="四、分糖果"><a href="#四、分糖果" class="headerlink" title="四、分糖果"></a>四、分糖果</h2><p><a href="https://leetcode-cn.com/problems/candy/">leetcode 135：分糖果</a></p><p>不会做。</p><p>大致思想是遍历两遍，从左到右只考虑右边比左边评分高，从右到左则相反。</p><p>官方的题解有种常数空间复杂度的算法，有时间再看看吧，学贪心为主。</p><h2 id="五、无重叠区间"><a href="#五、无重叠区间" class="headerlink" title="五、无重叠区间"></a>五、无重叠区间</h2><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">leetcode 435：无重叠区间</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">可以认为区间的终点总是大于它的起点。</span><br><span class="line">区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><p>本体难点在于遍历的方向。如果按左边界优先来进行排序且从左至右进行遍历，设想[1,4]与[2,3]这种情况，在遍历到[2,3]的时候由于2并未超过目前的局部右边界4，所以[2,3]区间会被舍弃，但是局部右边界未进行替换，而显然[2,3]才是局部最优解。</p><p>如果坚持从左到右进行遍历，局部右边界可取当前局部右边界与当前区间右边界的最小值。</p><p>所以如果按左边界优先来进行排列之后，需要从右开始向左遍历，因为越靠右的区间左边界越大，留给前面区间的空间也越大。按右边界优先来进行排列的话同理，需要从左向右开始遍历。</p><h2 id="六、单调递增的数字"><a href="#六、单调递增的数字" class="headerlink" title="六、单调递增的数字"></a>六、单调递增的数字</h2><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">leetcode 738：单调递增的数字</a></p><p>本体的关键在于局部最优该如何取。如果从后往前便利，遇到n[i-1]&gt;n[i]时，局部最优解应该是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n[i-1]--;</span><br><span class="line">n[i]&#x3D;&#39;9&#39;;</span><br></pre></td></tr></table></figure><p>实际实现时，可以记录最小的索引，其后面的元素都被设置为’9’。</p><h2 id="七、买卖股票的最佳时机（含手续费）"><a href="#七、买卖股票的最佳时机（含手续费）" class="headerlink" title="七、买卖股票的最佳时机（含手续费）"></a>七、买卖股票的最佳时机（含手续费）</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">leetcode 714：买卖股票的最佳时机含手续费</a></p><p>比之前的买卖股票多了个手续费。解法类似，需要记录局部最小值，不过这道题有三种情况：</p><ul><li><p>局部最小值小于当前值，则将局部最小值设为当前值。</p></li><li><p>局部最小值大于当前值但小于当前值与手续费之和。此时卖出一定会亏，所以不卖。</p></li><li><p>局部最小值大于当前值与手续费之和。此时可以卖，也可以不卖，等后面利润更多再卖，但是我们先将利润prices[i]-minp-fee加上。关键的一步在局部最小值的变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minp&#x3D;prices[i]-fee;</span><br></pre></td></tr></table></figure><p>这一步保证的是即使有多次加利润，但我们保证手续费只算了一次。</p></li></ul><h2 id="八、监控二叉树"><a href="#八、监控二叉树" class="headerlink" title="八、监控二叉树"></a>八、监控二叉树</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">leetcode 968：监控二叉树</a></p><p>本题实际上是状态转换的问题：每个节点的状态被分为三类：无摄像机覆盖、有摄像机覆盖（本身没有摄像机）与本身有摄像机。</p><p>另外一个需要注意的点是，由于叶节点的父节点放置的摄像头不仅能覆盖子节点，还能覆盖到其父节点，而叶节点放置的摄像头只能覆盖到其父节点，所以我们默认叶节点为已覆盖状态，而叶节点的父节点为放置摄像机状态。</p><p>接下来处理递归问题。父节点根据左右子节点的状态来确认自己的状态：</p><ul><li>左右子节点至少有一个为未覆盖，则父节点必须安装一个摄像机。</li><li>左右子节点均为已覆盖，父节点可以等着它的父节点安装摄像机，所以返回未覆盖。</li><li>其他情况表示左右子节点至少有一个摄像机，所以父节点返回已覆盖。<br>如果根节点的左右节点为已覆盖，根节点的状态将为未覆盖，而并没有父节点为它提供摄像机覆盖，所以最后判断根节点的状态：如果为未覆盖则需要多一个摄像机。</li></ul><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>做了这么多贪心题感觉是真的无规律可循，知道思路了就能很快想出解答，否则只会一直不知道。贪心算法的总结只有：多练、多总结做过的。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-回溯</title>
      <link href="/2021/03/18/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9E%E6%BA%AF/"/>
      <url>/2021/03/18/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简单的基础知识"><a href="#一、简单的基础知识" class="headerlink" title="一、简单的基础知识"></a>一、简单的基础知识</h2><p>回溯算法本质就是穷举，是一种低效的暴力解法。</p><p>回溯算法可以看作dfs，回溯的过程就是一种树形结构。</p><h3 id="①-回溯算法应用的一般场合"><a href="#①-回溯算法应用的一般场合" class="headerlink" title="① 回溯算法应用的一般场合"></a>① 回溯算法应用的一般场合</h3><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><h3 id="②-回溯函数怎么写"><a href="#②-回溯函数怎么写" class="headerlink" title="② 回溯函数怎么写"></a>② 回溯函数怎么写</h3><h4 id="Ⅰ、确立返回值与参数"><a href="#Ⅰ、确立返回值与参数" class="headerlink" title="Ⅰ、确立返回值与参数"></a>Ⅰ、确立返回值与参数</h4><p>返回值一般为void，一般通过传递引用类型的参数来记录回溯中寻找到的结果。</p><h4 id="Ⅱ、终止条件"><a href="#Ⅱ、终止条件" class="headerlink" title="Ⅱ、终止条件"></a>Ⅱ、终止条件</h4><p>到了dfs遍历的叶子节点，此时将符合条件的答案存进参数传递的记录容器之中，并且直接返回。</p><h4 id="Ⅲ、遍历过程"><a href="#Ⅲ、遍历过程" class="headerlink" title="Ⅲ、遍历过程"></a>Ⅲ、遍历过程</h4><p>对当前层的每种可能结果，将该结果添加进记录路径用的变量之中，之后对下一层进行递归调用；当从下一层返回时，在路径之中去除本次添加，以达到回溯的效果。</p><p>根据本人做题经验，存储符合要求的可能结果的、作为引用参数进行传递的容器一般为双层vector，或vector <code>&lt;string&gt;</code>；记录路径的引用参数一般为上述容器的子类型。（或者把这两个放进全局变量里也可以）</p><h2 id="二、组合问题"><a href="#二、组合问题" class="headerlink" title="二、组合问题"></a>二、组合问题</h2><p><a href="https://leetcode-cn.com/problems/combinations/">leetcode 77：组合</a></p><p>虽然这道题简单，但是剪枝挺值得一学。<br>剪枝思想为：当搜索到当前层时，如果发现当前层剩下的元素数目已经不足以填充path到k，则不需要继续搜索而是直接返回。</p><p>体现在i&lt;=n-(k-path.size())这一条语句上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;pos;i&lt;&#x3D;n-(k-path.size())+1;i++)&#123;</span><br><span class="line">    path.push_back(i);</span><br><span class="line">    backtracking(i+1,ans,path);</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据做了几道题的规律，在一层回溯中通过循环选取下一个元素，一般比决定选不选当前元素并进入下一层循环这种做法，空间效率要高不少。</p><p>例如<a href="https://leetcode-cn.com/problems/combination-sum/">leetcode 39：组合总数</a>中</p><p>第一种方法为，在当前层数中通过循环选取下一个开始的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;pos;i&lt;candidates.size();i++)&#123;&#x2F;&#x2F;直接选取下一个开始的元素</span><br><span class="line">    if(target&gt;&#x3D;candidates[i])&#123;</span><br><span class="line">        path.push_back(candidates[i]);</span><br><span class="line">        backtracking(i,target-candidates[i],candidates,ans,path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法为，在当前层数的元素有选与不选两个选项，并直接进入下一层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backtracking(pos+1,target,candidates,ans,path);&#x2F;&#x2F;不选当前层的元素而直接进入下一层</span><br><span class="line">if(target&gt;&#x3D;candidates[pos])&#123;</span><br><span class="line">    path.push_back(candidates[pos]);</span><br><span class="line">    backtracking(pos,target-candidates[pos],candidates,ans,path);&#x2F;&#x2F;由于可以选择重复元素，所以选择当前层元素并在该层保持</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然可知，第二种方法需要判断选不选每个元素，因此如果有多个元素都不选择，第二种方法还是只能一层层递归而下，而第一种方法可以直接跳到下一个选择的元素，这可能是导致第一种方法空间效率高于第二种的原因。</p><h2 id="3、分割问题"><a href="#3、分割问题" class="headerlink" title="3、分割问题"></a>3、分割问题</h2><p><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">leetcode 93：复原IP地址</a></p><p>本题值得学习的点在于，如果题目的解形式为对string字符的分割，路径用string表示较为方便，而string上对多个字符的删除又较为麻烦，可以考虑在string中插入单个字符的分割符，使用insert与erase方法来进行插入与删除。</p><h2 id="4、去重问题"><a href="#4、去重问题" class="headerlink" title="4、去重问题"></a>4、去重问题</h2><p><a href="https://leetcode-cn.com/problems/subsets/">leetcode 78：子集</a>与<a href="https://leetcode-cn.com/problems/subsets-ii/">leetcode 90：子集II</a></p><p>90题新增的情况是，原集合可能有重复的元素，而要求去除重复元素导致的相同的子集，例如[1,2,2]中1与第一个2和第二个2都得到子集[1,2]。但是[1,2,2]这种情况不应该被去除。</p><p>这样也就得到了思路，在遍历同一层时防止相同的元素多次进入下一层，但是不同层则允许相同元素。</p><p>在78题的基础上新增了used数组，来表示本次搜索中各元素的使用情况，而进行剪枝的条件是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1] &amp;&amp; used[i - 1] &#x3D;&#x3D; false) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nums[i]==nums[i-1]即表示相邻两元素相同（在进行回溯之前已对原数组排过序），used[i-1]==false表示相同元素并未在上一层被使用过，即表示该元素可能在当前层同一层被使用，这种情况是应该被删除的。</p><p>特别注意的是：used[i-1]==false表示的是在树的当前层（同一层内）进行去重，而used[i-1]==true则表示的是在同一路径上不同层内进行去重，一般为前者（false）效率更高，因为剪去的枝更多。</p><h2 id="5、排列问题"><a href="#5、排列问题" class="headerlink" title="5、排列问题"></a>5、排列问题</h2><p>排列与组合的区别就在于其中元素是有序的。</p><p>全排列的简化方法：将当前层的位置的元素与后面层的位置的元素交换，到最后一层时直接将经过交换处理的数组push到结果数组中。</p><h2 id="6、时空性能分析"><a href="#6、时空性能分析" class="headerlink" title="6、时空性能分析"></a>6、时空性能分析</h2><h3 id="①-子集问题"><a href="#①-子集问题" class="headerlink" title="① 子集问题"></a>① 子集问题</h3><p>每一种元素都有取与不取两种情况，且构造每一组子集时都需要填入数组，所以总的时间复杂度为O(n*2$^n$)。由于用到了辅助数组来记录路径，空间复杂度为O(n)。</p><h3 id="②-组合问题"><a href="#②-组合问题" class="headerlink" title="② 组合问题"></a>② 组合问题</h3><p>实际上就是一种子集问题</p><h3 id="③-排列问题"><a href="#③-排列问题" class="headerlink" title="③ 排列问题"></a>③ 排列问题</h3><p>通过排列的计算公式就容易得知，时间复杂度为O(n!)。同样使用了辅助数组，空间复杂度一般为O(n)。</p><h2 id="7、实际问题的应用"><a href="#7、实际问题的应用" class="headerlink" title="7、实际问题的应用"></a>7、实际问题的应用</h2><p><a href="https://leetcode-cn.com/problems/n-queens/">leetcode 51：N皇后</a></p><p>有一说一，看到判断皇后是否重复这个步骤特别繁琐以至于我一直多虑是不是会爆栈，但是好像是想多了。</p><h2 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h2><p>感觉没啥好讲的，换皮暴力搜索，记得考虑递归传递的参数的变化和可能存在的剪枝优化吧。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-二叉树2</title>
      <link href="/2021/03/17/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%912/"/>
      <url>/2021/03/17/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%912/</url>
      
        <content type="html"><![CDATA[<h2 id="1、二叉树最小深度"><a href="#1、二叉树最小深度" class="headerlink" title="1、二叉树最小深度"></a>1、二叉树最小深度</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">leetcode 111：二叉树的最小深度</a></p><p>简单题，但是有个坑，不能像求最大深度那么做。因为最小深度是到叶子节点的最小深度，而如果只有一个子节点为空，最大深度的算法就会把该节点最小深度设置为1，而这是不对的。</p><p>只有一个子节点为空时，应返回另一个子节点的最小深度+1。</p><h2 id="2、回溯"><a href="#2、回溯" class="headerlink" title="2、回溯"></a>2、回溯</h2><p>感觉这一章也没啥可讲的，都是考验基本功的</p><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">leetcode 513.：找树左下角的值</a></p><h2 id="3、二叉树递归函数返回值的取舍问题"><a href="#3、二叉树递归函数返回值的取舍问题" class="headerlink" title="3、二叉树递归函数返回值的取舍问题"></a>3、二叉树递归函数返回值的取舍问题</h2><p>总结：如果需要对二叉树进行遍历，那么无需返回值；如果需要搜索出一条符合要求的路径，那么需要返回值，因为如果搜索到了符合条件的路径就要及时返回。</p><p><a href="https://leetcode-cn.com/problems/path-sum/">leetcode 112：路径总和</a>与<a href="https://leetcode-cn.com/problems/path-sum-ii/">leetcode 113：路径总和II</a></p><p>可以对比一下两道题，112的目的是判断是否有一条根到叶节点的路径，使其和为指定值，这种情况下只需要找到一条符合要求的路径，就可以返回，所以需要返回值；而113的目的使找到所有符合条件的路径，所以需要对整棵树进行遍历，所以不要返回值。</p><h2 id="4、根据两序遍历来建立树"><a href="#4、根据两序遍历来建立树" class="headerlink" title="4、根据两序遍历来建立树"></a>4、根据两序遍历来建立树</h2><p>注意前面说到的“循环不变量”，在本题中表现为每次用来建立节点的数组区间开闭问题（不过一般不会出什么大问题）。</p><p>剩下的就是基本操作了，根据前序/后序中根节点在第一个/最后一个的特点，利用根节点对中序数组进行划分，之后利用中序数组的划分再划分前序/后序数组，之后对每一个划分后的子数组都做递归操作。</p><p>每次递归的时候可以不建立新的数组，而是在参数中引入下标来进行数组划分（不过我一直都是下标划分，所以貌似也没啥要注意的……）</p><p>用前序数组与后序数组是不能建立二叉树的，因为左右没法分开。</p><h2 id="5、二叉搜索树"><a href="#5、二叉搜索树" class="headerlink" title="5、二叉搜索树"></a>5、二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">leetcode 98：验证二叉搜索树</a></p><p>我一开始以为返回值记录区间的起终点，再将左右子节点的返回值与根节点作比较，最后得出合并后的区间并返回。结果是我想的太复杂了，其实可以很简单。</p><ul><li>方法一：因为中序遍历的顺序是左中右，所以对二叉搜索树进行中序遍历得到的就会是有序数组。</li><li>方法二：通过记录中序遍历中的上一个节点，实质跟方法一一样，只是节省了存储数组的空间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* pre &#x3D; NULL; &#x2F;&#x2F; 用来记录前一个节点 </span><br><span class="line">bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL) return true;</span><br><span class="line">    bool left &#x3D; isValidBST(root-&gt;left);</span><br><span class="line">    if (pre !&#x3D; NULL &amp;&amp; pre-&gt;val &gt;&#x3D; root-&gt;val) return false;</span><br><span class="line">    pre &#x3D; root; &#x2F;&#x2F; 记录前一个节点</span><br><span class="line">    bool right &#x3D; isValidBST(root-&gt;right);</span><br><span class="line">    return left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住这个通过记录前一个节点来遍历二叉树的方法，很多时候可以将二叉树问题转化为数组问题。</p><h2 id="6、删除二叉搜索树中某个节点"><a href="#6、删除二叉搜索树中某个节点" class="headerlink" title="6、删除二叉搜索树中某个节点"></a>6、删除二叉搜索树中某个节点</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">leetcode 450：删除二叉搜索树中的节点</a></p><p>考虑删除节点后其左右子节点该如何处理的问题：</p><ul><li>左右节点均为空，可以直接删除</li><li>左空右非空，可以用右节点代替删除节点</li><li>左非空右空，可以用左节点代替删除节点</li><li>左右皆非空，可以将左节点为根节点的二叉树作为一个整体，移到当前节点在中序遍历下的后继的左子节点上</li></ul><p><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">leetcode 669：修剪二叉搜索树</a></p><p>删除多个节点时，也是类似的思想</p><h2 id="7、简简单单总个结"><a href="#7、简简单单总个结" class="headerlink" title="7、简简单单总个结"></a>7、简简单单总个结</h2><p>做了这么多二叉树，人快做麻了。我认为对我来说，二叉树这一章关键的几个点在：二叉搜索树节点的删除，以及带返回值的二叉树递归方法。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-二叉树1</title>
      <link href="/2021/03/16/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/03/16/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简单知识"><a href="#一、简单知识" class="headerlink" title="一、简单知识"></a>一、简单知识</h2><p>一些概念：满二叉树、完全二叉树、二叉搜索树、平衡二叉搜索树</p><p>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树（红黑树）</p><p>存储方式：链式存储、数组存储（一般用于堆中）</p><p>遍历：DFS（前序遍历、中序遍历、后序遍历）、BFS</p><h2 id="二、递归步骤"><a href="#二、递归步骤" class="headerlink" title="二、递归步骤"></a>二、递归步骤</h2><h3 id="①「确定递归函数的参数和返回值：」"><a href="#①「确定递归函数的参数和返回值：」" class="headerlink" title="①「确定递归函数的参数和返回值：」"></a>①「确定递归函数的参数和返回值：」</h3><p>递归过程中要用到哪些变量，就加入到参数中；递归希望得到的是什么，就加入到返回值。如果同时需要这些，可以设为全局变量。</p><h3 id="②「确定终止条件：」"><a href="#②「确定终止条件：」" class="headerlink" title="②「确定终止条件：」"></a>②「确定终止条件：」</h3><p>注意边界条件，如nullptr或者0等情况，避免死循环。</p><h3 id="③「确定单层递归的逻辑：」"><a href="#③「确定单层递归的逻辑：」" class="headerlink" title="③「确定单层递归的逻辑：」"></a>③「确定单层递归的逻辑：」</h3><p>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p><h2 id="三、三序遍历"><a href="#三、三序遍历" class="headerlink" title="三、三序遍历"></a>三、三序遍历</h2><h3 id="三序遍历的迭代形式需要熟练"><a href="#三序遍历的迭代形式需要熟练" class="headerlink" title="三序遍历的迭代形式需要熟练"></a>三序遍历的迭代形式需要熟练</h3><p>前序：每次取栈首节点并弹出栈，如果为空则直接略过，否则输出其值，并将左右子节点压入栈中（因为要先左后右，所以先压右节点）。</p><p>中序：一直搜索当前节点的左子节点同时将当前节点压栈，直到为nullptr。之后从栈中弹出当前节点并输出，再令当前节点为当前节点的右节点，继续循环。</p><p>后序：<code>&lt;font color=blue&gt;</code>后序为左右中，而前序为中左右，所以将前序遍历的压栈顺序进行调整，使输出中右左，并在输出完毕之后对输出序列进行reverse，即可得到后序遍历的序列。<code>&lt;/font&gt;</code></p><h3 id="统一风格的迭代三序遍历代码"><a href="#统一风格的迭代三序遍历代码" class="headerlink" title="统一风格的迭代三序遍历代码"></a>统一风格的迭代三序遍历代码</h3><p><a href="https://mp.weixin.qq.com/s/WKg0Ty1_3SZkztpHubZPRg">https://mp.weixin.qq.com/s/WKg0Ty1_3SZkztpHubZPRg</a></p><p>在中间节点push后紧接着push一个nullptr节点来做标记。</p><h2 id="四、层次遍历"><a href="#四、层次遍历" class="headerlink" title="四、层次遍历"></a>四、层次遍历</h2><p>之前一直搞不太清该怎么算每一层的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        int n&#x3D;q.size();</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            auto j&#x3D;q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            if(j)&#123;</span><br><span class="line">                tmp.push_back(j-&gt;val);</span><br><span class="line">                q.push(j-&gt;left);</span><br><span class="line">                q.push(j-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tmp.size())ans.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历模板的应用：</p><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">leetcode 102：二叉树的层序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">leetcode 107：二叉树的层次遍历II</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">leetcode 199：二叉树的右视图</a></li><li><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">leetcode 637：二叉树的层平均值</a></li><li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">leetcode 589：N叉树的前序遍历</a></li></ul><p><del>得看毕业设计了，那么今天的二叉树就学到这里吧！</del></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-栈与队列</title>
      <link href="/2021/03/16/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2021/03/16/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><p>我们目前使用的c++STL，一般为SGI STL版本。</p><p>STL之中栈与队列往往不被归为容器，而被归为容器适配器。因为我们可以控制用何种容器来实现栈与队列的功能。(这也意味着无法确定栈与队列中的元素是否连续分布，但deque中的元素不是连续分布的)</p><p>SGI STL中 栈与队列底层实现缺省情况下使用deque实现的。</p><h2 id="二、栈实现队列"><a href="#二、栈实现队列" class="headerlink" title="二、栈实现队列"></a>二、栈实现队列</h2><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">leetcode 232：用栈实现队列</a></p><p>经典题目，懂得都懂。</p><h2 id="三、队列实现栈"><a href="#三、队列实现栈" class="headerlink" title="三、队列实现栈"></a>三、队列实现栈</h2><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">leetcode 225：用队列实现栈</a></p><p>别想太复杂了，就是单纯的用一个队列备份数据，每次pop都把所有元素复制一遍罢了。</p><h2 id="四、栈解决问题"><a href="#四、栈解决问题" class="headerlink" title="四、栈解决问题"></a>四、栈解决问题</h2><p>递归的底层实现就是通过栈，每一次递归调用将函数的局部变量、参数与返回值等压入函数调用栈之中，供被调用函数使用，同时返回时也将返回值放在栈中，并将被调用函数弹出栈，就能直接回到调用函数。</p><p>栈一般可以用来解决匹配问题。</p><p>逆波兰表达式。</p><h2 id="五、经典单调队列"><a href="#五、经典单调队列" class="headerlink" title="五、经典单调队列"></a>五、经典单调队列</h2><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">leetcode 239：滑动窗口最大值</a></p><p>双端队列实现单调队列，来维持滑动窗口中的最大值计算。</p><h2 id="六、优先级队列priority-queue"><a href="#六、优先级队列priority-queue" class="headerlink" title="六、优先级队列priority_queue"></a>六、优先级队列priority_queue</h2><p>几个需要注意的点</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在优先级队列中重载比较方法必须为一个结构类型或者为一个类，然后在其中重载public的()操作符来进行比较，且如果想得到递减的优先级队列，返回时应该返回&lt;的形式；递增的优先级队列则相反。</p><p>举个例子，我想得到自定义的pair排序，且为递减优先级队列时应该写的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Cmp&#123;</span><br><span class="line">    bool operator()(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)&#123;</span><br><span class="line">        return a.second&lt;b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>priority_queue的底层实现与堆类似，且没有迭代器。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-字符串</title>
      <link href="/2021/03/16/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/03/16/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、字符串反转"><a href="#一、字符串反转" class="headerlink" title="一、字符串反转"></a>一、字符串反转</h2><p>学会利用reverse函数：传入迭代器的起点与终点，对迭代器中元素排列进行翻转。reverse的参数为左闭右开区间，因此迭代器终点应该为 <code>&lt;font color=red&gt;</code>所求区间的下一个元素 <code>&lt;/font&gt;</code>。</p><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指offer 58.左旋转字符串</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure><p>原地翻转分为三步：</p><ul><li>翻转前k个字符</li><li>翻转后面的字符</li><li>翻转整个字符串</li></ul><h2 id="二、字符串填充"><a href="#二、字符串填充" class="headerlink" title="二、字符串填充"></a>二、字符串填充</h2><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指offer 05.替换空格</a></p><p>实现空间复杂度为O(1)的原地填充算法，可以考虑先计算出填充后的大小，然后将数组扩容并使用双指针，从后向前填充。</p><h2 id="三、kmp"><a href="#三、kmp" class="headerlink" title="三、kmp"></a>三、kmp</h2><p>一定要对这个算法的过程多加理解，特别是求解next数组。</p><p>特别的，为了保证前缀表回溯时不陷入循环，有两种next数组的处理方式</p><h3 id="①-整个next数组的值-1。例如，如果在下标为5的位置，最大匹配前缀长度为3，那么next-5-为3-1-2。"><a href="#①-整个next数组的值-1。例如，如果在下标为5的位置，最大匹配前缀长度为3，那么next-5-为3-1-2。" class="headerlink" title="① 整个next数组的值-1。例如，如果在下标为5的位置，最大匹配前缀长度为3，那么next[5]为3-1=2。"></a>① 整个next数组的值-1。例如，如果在下标为5的位置，最大匹配前缀长度为3，那么next[5]为3-1=2。</h3><p>实现代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void getNext(int* next, const string&amp; s) &#123;</span><br><span class="line">    int j &#x3D; -1;</span><br><span class="line">    next[0] &#x3D; j;&#x2F;&#x2F;此处初始化0位置为-1</span><br><span class="line">    for(int i &#x3D; 1; i &lt; s.size(); i++) &#123; &#x2F;&#x2F; 注意i从1开始</span><br><span class="line">        while (j &gt;&#x3D; 0 &amp;&amp; s[i] !&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 前后缀不相同了</span><br><span class="line">            j &#x3D; next[j]; &#x2F;&#x2F; 向前回溯</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; s[j + 1]) &#123; &#x2F;&#x2F; 找到相同的前后缀</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] &#x3D; j; &#x2F;&#x2F; 将j（前缀的长度）赋给next[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="②-回溯时取j-1进行回退。在进行匹配时也需取j-1来回退。（这种方式有点疑问）"><a href="#②-回溯时取j-1进行回退。在进行匹配时也需取j-1来回退。（这种方式有点疑问）" class="headerlink" title="② 回溯时取j-1进行回退。在进行匹配时也需取j-1来回退。（这种方式有点疑问）"></a>② 回溯时取j-1进行回退。在进行匹配时也需取j-1来回退。（这种方式有点疑问）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void getNext(int* next, const string&amp; s) &#123;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        next[0] &#x3D; 0;&#x2F;&#x2F;此处初始化0位置为0</span><br><span class="line">        for(int i &#x3D; 1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s[i] !&#x3D; s[j]) &#123; &#x2F;&#x2F; j要保证大于0，因为下面有取j-1作为数组下表的操作</span><br><span class="line">                j &#x3D; next[j - 1]; &#x2F;&#x2F; 注意这里，是要找前一位的对应的回退位置了</span><br><span class="line">            &#125;</span><br><span class="line">            if (s[i] &#x3D;&#x3D; s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-哈希表</title>
      <link href="/2021/03/15/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2021/03/15/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简单知识"><a href="#一、简单知识" class="headerlink" title="一、简单知识"></a>一、简单知识</h2><p>哈希表又称散列表，主要用途是能在近乎常数的时间内判断某元素是否出现在该集合里</p><ul><li>哈希函数：用于将键值转化为哈希表内部结构中的下标或地址</li><li>哈希碰撞：可能会将多个键值映射到同一个下标或者地址之中，这种情况称为哈希碰撞。主要解决方法为拉链法与线性探查法。</li><li>拉链法：在哈希表每个位置改为建立一个链表，映射到相同位置的键值都作为链表中的节点</li><li>线性探查法：使用一个新的哈希函数，从当前位置再寻找一个映射的下标或地址。</li><li>一般将哈希表的大小设置为质数，以减少冲突的出现</li></ul><p>实现哈希表的一般为三种结构：数组、set与map，这里引用大佬的表格。</p><table><thead><tr><th>名称</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr><tr><td>map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>set是只存储value，而map存储了key-value对，所以如果只需判断元素是否存在，使用unordered_set较好，而如果需要通过键值来判断，需要用unordered_map。<br>set、multiset 使用了哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。</p><h2 id="二、容量较小的哈希表"><a href="#二、容量较小的哈希表" class="headerlink" title="二、容量较小的哈希表"></a>二、容量较小的哈希表</h2><p>如果题目中对元素的限定为一个较小的范围，或者数据分布极为密集，例如只包含小写字母/大写字母/数字等，且要求的问题与计数有关，那么可以直接设置一个定长数组，来存储每个字符的出现次数。</p><h2 id="三、不易想到的哈希表"><a href="#三、不易想到的哈希表" class="headerlink" title="三、不易想到的哈希表"></a>三、不易想到的哈希表</h2><p><a href="https://leetcode-cn.com/problems/4sum-ii/">leetcode 454：四数相加II</a> \</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。</span><br><span class="line"></span><br><span class="line">为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">A &#x3D; [ 1, 2]</span><br><span class="line">B &#x3D; [-2,-1]</span><br><span class="line">C &#x3D; [-1, 2]</span><br><span class="line">D &#x3D; [ 0, 2]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题乍一看有点像在一个数组内寻找到n个数，使其相加之和为定值这种题，但是不一样。在同一数组内是使用多层循环+滑动窗口解题，而本题则更为简单。</p><p>思路：用ans初始化为0记录结果，将四个数组分为两两一组，对其中一组的元素两两相加，并用unordered_map作为hash存储下所有和以及出现的次数，之后对另一组元素同样两两相加，求出0与其和的差值，并在hash表中查询是否存在：如果存在，则将ans加上hash表中存储的该和出现的次数。最后返回ans。</p><h2 id="四、简单总结"><a href="#四、简单总结" class="headerlink" title="四、简单总结"></a>四、简单总结</h2><p>哈希表的一般应用场合：快速判断一个元素是否出现在集合里。</p><p>实现哈希表的数据结构有三种：数组、unordered_set与unordered_map，适用的场合有所不同：</p><ul><li>数组：<a href="https://leetcode-cn.com/problems/ransom-note/">leetcode 383：赎金信</a>。一般为集合大小受限时使用，说明只存在小写字母、数字时，暗示做题人用数组作为哈希表。</li><li>unordered_set：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">leetcode 349：两个数组的交集</a>。没有对集合大小进行限制，因此若使用数组无法判断该去多大，以及可能会溢出，且集合元素可能较为分散，浪费空间。但是set除了记录其存在外，不能附加额外的信息。要想附加额外的信息，就需要使用map。</li><li>unordered_map：<a href="https://leetcode-cn.com/problems/two-sum/">leetcode 1：两数之和</a>。除了记录元素的存在外，还在value中记录额外的信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-链表</title>
      <link href="/2021/03/15/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/03/15/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、一些简单的知识"><a href="#一、一些简单的知识" class="headerlink" title="一、一些简单的知识"></a>一、一些简单的知识</h2><ul><li>链表在内存中的存储位置并不连续</li><li>链表的长度不是固定的，且插入与删除操作（不计算找到元素的时间）为常数时间，而查找元素的时间为O(n)，因而比数组更适合增删元素操作较多的场合</li><li>想到什么再来加</li></ul><h2 id="二、虚拟头节点"><a href="#二、虚拟头节点" class="headerlink" title="二、虚拟头节点"></a>二、虚拟头节点</h2><p>在对头节点的操作与其他节点不同时用到，将头节点连接在一个新创建的“虚拟”头节点之后，并且暂时将它看作头节点，来使得头结点的操作与其他节点统一。<br>最后返回值的时候记得返回<strong>虚拟头节点的next节点</strong>。</p><h2 id="三、反转链表"><a href="#三、反转链表" class="headerlink" title="三、反转链表"></a>三、反转链表</h2><p>需要掌握递归法与迭代法</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>需要事先保存好head-&gt;next，否则对head-&gt;next调用递归函数后将无法得到。调用完递归函数后，将head-&gt;next节点的next连到head上，而将head的next设置为nullptr即可。</p><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>双指针，一个指向head，一个指向head上一个（初始化为nullptr），一遍遍历，最后返回指向上一个的指针即可。</p><h2 id="四、判断环"><a href="#四、判断环" class="headerlink" title="四、判断环"></a>四、判断环</h2><p>在第一篇里已经学习过了，不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记-leetcode-master-数组</title>
      <link href="/2021/03/15/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%A4%A7%E6%A6%82%E4%BC%9A%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2021/03/15/leetcode-master%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%A4%A7%E6%A6%82%E4%BC%9A%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在leetcode上陆陆续续也刷了有小几百道题了，但是感觉学习到的东西不够系统，很多刷的题也容易忘记，正好看到了这篇比较系统的github博客，试着跟它学习学习。<br>链接地址：<a href="https://github.com/youngyangyang04/leetcode-master">https://github.com/youngyangyang04/leetcode-master</a></p><h2 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h2><p>对于left&lt;=right还是left&lt;right，以及left=mid还是left=mid+1的问题。这个问题在我之前的刷题过程中出现的次数还挺多的，之前主要靠输出来一个个情况试进行解决。教程作者给出的方法是坚持 <code>&lt;font color=red&gt;</code>“循环不变量”<code>&lt;/font&gt;</code>.这里的循环不变量指，如果你设置的区间为闭区间，那么就一直使用闭区间对应的计算方法来计算值，而不使用半开半闭区间的计算方法。</p><h3 id="第一种情况：区间为-left-right"><a href="#第一种情况：区间为-left-right" class="headerlink" title="第一种情况：区间为[left, right]"></a>第一种情况：区间为[left, right]</h3><p>① 这种情况下，如果结束条件为left&lt;right，区间里还会剩下两个元素无法处理，因此结束条件应该为left&lt;=right；</p><p>② left与right这种边界所代表的元素也包含在区间内，因此区间缩小时应该写为left=mid+1与right=mid-1。</p><h3 id="第二种情况：区间为-left-right"><a href="#第二种情况：区间为-left-right" class="headerlink" title="第二种情况：区间为[left, right)"></a>第二种情况：区间为[left, right)</h3><p>① 这种情况下，结束条件为left&lt;right时，区间内只剩下一个元素；反之如果加上=则区间内没有元素，因此应该选用left&amp;&lt;right；</p><p>② left包含在区间内，而right没有，因此区间缩小的表达式为left=mid+1与right=mid。</p><h2 id="2、双指针法"><a href="#2、双指针法" class="headerlink" title="2、双指针法"></a>2、双指针法</h2><p>之前学习的双指针法主要应用于判断环、快排与二分，通过<a href="https://leetcode-cn.com/problems/remove-element/">leetcode 27：移除元素</a>这道题（虽然是简单难度但我还是想了一会）学习了双指针在删除元素的用法。</p><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><p>我们熟知的解法为快慢双指针，当其相遇则链表中有环。但是在知道有环之后怎么求环的位置呢？<br>我们设链表起点到环的入口距离为x，环的入口到相遇点距离为y，相遇点继续向前走到环的入口距离为z，由于快指针移动速度为慢指针的两倍，有如下方程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x+y+z+y&#x3D;2*(x+y)</span><br></pre></td></tr></table></figure><p>解得z=x，这意味着链表头到环的入口的距离与相遇点到环的入口的距离相等。所以我们再设置一个从头开始的指针，它与相遇点的指针同步移动，这两个指针相遇的新相遇点即为环的入口。</p><h2 id="3、滑动窗口"><a href="#3、滑动窗口" class="headerlink" title="3、滑动窗口"></a>3、滑动窗口</h2><p>求连续子数组时可以尝试用这种方法</p><h2 id="4、循环矩阵"><a href="#4、循环矩阵" class="headerlink" title="4、循环矩阵"></a>4、循环矩阵</h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">leetcode 59：螺旋矩阵II</a><br>一道很好的实践“循环不变量”理论的题目，做法也很简单，常见的对问题中行为的模拟。我的做法是每一层深度分为四个行列进行添加，在对每一行列进行添加时坚持不加最右元素与不加最下元素（否则会导致重复添加）。</p><h2 id="5、总结篇"><a href="#5、总结篇" class="headerlink" title="5、总结篇"></a>5、总结篇</h2><p>介绍了关于数组的基本概念，总结如下：</p><ul><li>数组是存放在连续内存空间上的相同类型数据的集合</li><li>数组下标都是从0开始的</li><li>数组内存空间的地址是连续的</li><li>数组的元素是不能删的，只能覆盖</li><li>二维数据在内存中不是m*n的连续地址空间，而是m条连续的地址空间组成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记-leetcode-master </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习-kmp算法</title>
      <link href="/2021/03/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-kmp%E7%AE%97%E6%B3%95/"/>
      <url>/2021/03/09/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-kmp%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="kmp算法的理解"><a href="#kmp算法的理解" class="headerlink" title="kmp算法的理解"></a>kmp算法的理解</h1><p>复试复习编译原理的时候，有一章正好讲到了字符串匹配问题kmp，正好自己一直以来虽然知道口头上的做法，但是next数组实际上求起来总是不太能理解，所以上网搜索了一下资料，最后终于把这块硬骨头啃了下来，希望后面刷算法题的时候不要再忘了。</p><h2 id="kmp算法的大致原理"><a href="#kmp算法的大致原理" class="headerlink" title="kmp算法的大致原理"></a>kmp算法的大致原理</h2><p>kmb算法求的是这一类经典问题：在一个较大的字符串s之中，是否存在一个子字符串等于较小的字符串k。这个题的直觉做法很简单，只要将从s每个位置开始与k都比对一次就能解决，这样我们得到了一种时间复杂度为O(n <code>&lt;sup&gt;</code>2 <code>&lt;/sup&gt;</code>)的算法。</p><p>后来人们发现，这种算法耗费时间的一个重要原因在，如果在s与k匹配了几个字符之后，发现失配了，s的字符串指针还需要回退到它上一个起点的下一个位置，再与k进行匹配。那么如果存在一种算法，使得s不需要回退字符串指针，就能将时间复杂度缩短为O(n)了。而kmp的思想正是这样。</p><p>kmp算法利用了匹配串k当前位置前的子字符串存在部分相等的特性，例如匹配串指针位置为j时，可能有k <code>&lt;sub&gt;</code>1 <code>&lt;/sub&gt;</code>k <code>&lt;sub&gt;</code>2 <code>&lt;/sub&gt;</code>…k <code>&lt;sub&gt;</code>i <code>&lt;/sub&gt;</code>=k <code>&lt;sub&gt;</code>j-i <code>&lt;/sub&gt;</code>k <code>&lt;sub&gt;</code>j-i+1 <code>&lt;/sub&gt;</code>…<code>&lt;sub&gt;</code>j-1 <code>&lt;/sub&gt;</code>。这种情况下，如果出现s当前位置t与k当前位置j失配，由于s在位置t前的部分字符串仍与k在位置j前的部分字符串匹配，且k字符串中又存在如上等式，所以可以直接将k的指针移到i的位置而不必移到1重新进行匹配。</p><h2 id="next数组求值的理解"><a href="#next数组求值的理解" class="headerlink" title="next数组求值的理解"></a>next数组求值的理解</h2><p>kmp算法的难点之处就在于如何求解每个字符串k每个位置的i值，这些i值组合起来也被人们称为next数组。下面先给出求解next数组的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Getnext(int next[],string k)</span><br><span class="line">&#123;</span><br><span class="line">   int j&#x3D;0, i&#x3D;-1;</span><br><span class="line">   next[0]&#x3D;-1;</span><br><span class="line">   while(j&lt;t.length())</span><br><span class="line">   &#123;</span><br><span class="line">      if(i &#x3D;&#x3D; -1 || k[j] &#x3D;&#x3D; k[i])</span><br><span class="line">      &#123;</span><br><span class="line">         j++;k++;</span><br><span class="line">         next[j] &#x3D; i;</span><br><span class="line">      &#125;</span><br><span class="line">      else i &#x3D; next[i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码初始化next[0]=-1，接下来，讨论通常情况：对应于上述代码if值为true的代码块部分， 如果字符串k在位置j时有k <code>&lt;sub&gt;</code>1 <code>&lt;/sub&gt;</code>k <code>&lt;sub&gt;</code>2 <code>&lt;/sub&gt;</code>…k <code>&lt;sub&gt;</code>i <code>&lt;/sub&gt;</code>=k <code>&lt;sub&gt;</code>j-i <code>&lt;/sub&gt;</code>k <code>&lt;sub&gt;</code>j-i+1 <code>&lt;/sub&gt;</code>…<code>&lt;sub&gt;</code>j-1 <code>&lt;/sub&gt;</code>，且k <code>&lt;sub&gt;</code>i+1 <code>&lt;/sub&gt;</code>=k <code>&lt;sub&gt;</code>j <code>&lt;/sub&gt;</code>，则next[j]=next[j-1]+1，这部分很好理解；而对应于if值为false的else代码块却只有k=next[k]，这部分教材上也写得很是含糊，下面通过画图的形式来帮助理解。</p><p>当前相等的串为1~i与j-i~j-1这两部分，当k[j]!=k[i+1]时，需要找到新的匹配串。i=next[i]这一句代码可以用图来表示出来。</p><p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAeAB4AAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCAKIBIADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiivlz9u3/AIK8/Cf/AIJ4fHL4U/D7x7F4sn134vX/ANh0ptI01bqCxBmigE1yTIrBDJMoxEsr8H5OmRazjTW8nZLu+wPSMpvaKu/JH1HRRRQAUV8ufFb/AIK8/Cf4O/8ABR7wZ+y7qsXiyT4i+N7Jb2zubXTVl0q13rM0cU0vmCQO4hYgpE6LkbmXnH1HRH3oe0jtdq/mnZr5A9Jcj30fyez+YUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRXhP/BRj9rTxT+xZ+zJe+NfBXwu134x+KBf2mnaf4W0eSRLq+eeQIWBjhmfagy5xGeFOSByInNQV35fi7IqMXJ2X9W1Z7tRX4HW/wC1L+2X4x/4Ls/sm6N+0ddaf4B0fxZcXGv6V8PPDl+ws9Mg8m9iQ3wVmE1zhCcvJJsDHAiLMlfvjWsY3oqt3lKNv8Nr/i7f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78C8aJ4m8LaglpfW6iTzVRt6OpCyfOrKFdW5DgEg1viX/wAEt9V07/gkn8SP2dfCfxA8SeNPEnjLSL+2h8TfEPV3vLq4urkg7rm4ihL+WuAq4R2VVUfNiuPERlPLZ4d/ElUt15uaUpL0+J381pe9zrjOP9oU8Qtv3aflyKzf9dPuN7/ghr/yiC/Z2/7Eiw/9F18P/wDBtn/yk3/4KKf9lBi/9OOtV+kH/BOH9m/XP2P/ANhH4U/C/wAS3WlX2v8Agbw5a6Rf3GmSyS2c0sS4ZomkRHKehZFPtXLfsRf8EtPh/wDsE/HX4z/EHwfrHjHUtZ+OesLrevQ6zd201raTLNdTBbVYoI2RN13IMSNIcKnPBJ9avUj9erVl8MozS9XODX4RZ5tCL/s2OHfxXpv/AMBTv+Z8mf8ABZf/AJTUf8E7f+xl1v8A9As6/UivjL9v7/gnb41/aq/4KE/sqfFnw9qnhaz8O/AzV9Rv9ettRuZ4727juFgCC1VIXR2HlNnzHjHIwT2+za48N7uDVN7+0qP5Nxs/mdNfXEcy25IL5pzuvxQUUUUCCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//2Q==" alt="avatar"></p><p>i取next[i]，由于next数组的性质，代表1~next[i]与i-next[i]~i-1这两段子字符串是相等的，而由于之前的结果，1~i与j-i~j-1这两段字符串相等，而i-next[i]~i-1为1~i尾部的一部分，因此这一部分也与j-i~j-1尾部相同长度的一部分j-next[i]~j-1相等，即为图中蓝色区域示意的部分（第三块蓝色区域包括j-1），等价关系为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1~next[i]&#x3D;i-next[i]~i-1&#x3D;j-next[i]~j-1</span><br></pre></td></tr></table></figure><p>我们得到了一对新的匹配的串，接下来还需要判断这对新匹配串的后一个字符是否相等，便又回到了上述循环之中。</p><p>当遍历完k字符串后，next数组也生成完毕，之后就能进行kmp算法匹配了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习-单调栈</title>
      <link href="/2021/02/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2021/02/17/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>学习单调栈是是因为刷到了下面这个题目：</p><p><code>&lt;font color=blue&gt;</code>907. 子数组的最小值之和 <code>&lt;/font&gt;</code></p><pre><code>给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。由于答案可能很大，因此 返回答案模 10^9 + 7 。</code></pre><p>我的思路是：</p><p>对于数组中某个元素，根据它在数组中的位置，可以同时向左或向右扩展，包含若干个大于它的元素。</p><p>由于这样扩展得到的每个子数组都是以该元素为最小值，所以可以保证得到的子数组不会重复。</p><p>再对向左/向右的扩展方法进行排列组合，并且对每个元素的排列组合进行计数，即可得到答案。</p><p>这样，问题就转化为了：</p><h3 id="对于数组中某个特定的元素，求其左边-右边第一个小于它的元素位置"><a href="#对于数组中某个特定的元素，求其左边-右边第一个小于它的元素位置" class="headerlink" title="对于数组中某个特定的元素，求其左边/右边第一个小于它的元素位置"></a>对于数组中某个特定的元素，求其左边/右边第一个小于它的元素位置</h3><p>百度搜索得知，这种问题有一个特定的解法：</p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>所谓单调栈，顾名思义，就是栈中的数据按照顺序或逆序进行排列，下面以求某个数据左边第一个小于它的元素为例，讲解单调栈：</p><p>（待处理数组为 <code>&lt;font color=red&gt;</code>arr <code>&lt;/font&gt;</code>， 大小为 <code>&lt;font color=red&gt;</code>n <code>&lt;/font&gt;</code>，记录数组为 <code>&lt;font color=red&gt;</code>dpl <code>&lt;/font&gt;</code>（记录arr该位置的元素左边第一个小于它的元素的位置，没有记为-1，且其中所有元素初始化为-1），单调栈 <code>&lt;font color=red&gt;</code>l <code>&lt;/font&gt;</code>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l.empty())&#123;</span><br><span class="line">            l.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;=arr[l.top()])&#123;</span><br><span class="line">        dpl[i]=l.top();</span><br><span class="line">        l.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!l.empty()&amp;&amp;arr[i]&lt;arr[l.top()])l.pop();</span><br><span class="line">        <span class="keyword">if</span>(!l.empty())&#123;</span><br><span class="line">            dpl[i]=l.top();</span><br><span class="line">        &#125;</span><br><span class="line">        l.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过自顶层元素top向下依次递减的单调栈来处理，大致算法如下：</p><ol><li>如果遍历到位置i时，arr[i]大于栈顶元素arr[l.top()]，即说明arr[i]左边第一个小于它的元素为arr[l.top()]，用dpl进行记录。并同时将i入栈。</li><li>如果遍历到位置i时，arr[i]不大于栈顶元素，则依次弹出栈顶元素直到arr[i]大于栈顶元素（因为元素在入栈时均已经在dpl中进行了记录，所以在出栈时无需再记录位置）。此时如果栈非空，说明arr[i]左边第一个小于它的元素即为栈顶元素，用dpl进行记录；否则，说明arr[i]左边没有小于它的元素，为了便于计算，使用默认值-1记录。最后再将i入栈。</li><li>从1与2的步骤中可知，如果当前栈为空，只可能是两种情况：起始位置，以及2中说明的另一种情况，而这两种情况应该在dpl中记录的值都为-1。所以应该在与栈顶元素比较之前先进行栈是否为空的判断，从而处理起始元素i=0这种情况。</li></ol><p>得到右边第一个小于的元素位置也是类似处理，最终的解答如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">9</span>)+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        vector&lt;int&gt; dpl(n,-1), dpr(n,n);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; l,r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l.empty())&#123;</span><br><span class="line">                l.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&gt;=arr[l.top()])&#123;</span><br><span class="line">                dpl[i]=l.top();</span><br><span class="line">                l.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!l.empty()&amp;&amp;arr[i]&lt;arr[l.top()])l.pop();</span><br><span class="line">                <span class="keyword">if</span>(!l.empty())&#123;</span><br><span class="line">                    dpl[i]=l.top();</span><br><span class="line">                &#125;</span><br><span class="line">                l.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r.empty())&#123;</span><br><span class="line">                r.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=arr[r.top()])&#123;</span><br><span class="line">                r.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!r.empty()&amp;&amp;arr[i]&lt;arr[r.top()])&#123;</span><br><span class="line">                    dpr[r.top()]=i;</span><br><span class="line">                    r.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                r.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!r.empty())&#123;</span><br><span class="line">            dpr[r.top()]=n;</span><br><span class="line">            r.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans+=(<span class="keyword">long</span> <span class="keyword">long</span>)arr[i]*(i-dpl[i])%m*(dpr[i]-i)%m;</span><br><span class="line">            ans%=m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，一定存在时间、空间的优化算法，使得该类解法可通过一遍遍历完成，也不需要开辟这么多容器来进行记录。该代码仅作提供解题思路用。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客时遇到的问题分享</title>
      <link href="/2021/01/22/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E4%BA%AB/"/>
      <url>/2021/01/22/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>10天前大致搭建好了个人博客，localhost也能正常显示，但是上传到github page上时出现了问题，<strong>仓库里没有html文件，github page自然也没有内容显示</strong>。</p><p>今天在跟群友闲聊时又讨论到博客的问题，于是经过研究与上网查阅资料成功解决了上述问题。</p><p>问题的根本原因在于<strong>github将主分支的名字由master改成了main</strong>，但是hexo貌似并没有对此进行更新，导致每次clean再进行deploy的时候，如果没有指定分支名称，总是新建一个名为“master”的分支并将内容push到该分支上，而并不是push到我们以为的“master”分支上（实际上名称已经变成了“main”）。</p><p>弄清楚问题原因后，解决方法也很简单了，<strong>在_config.yml的deploy字段后面指定分支名字即可解决</strong>。</p><p><code>  branch: main</code></p><p>之后clean+g+d，成功显示！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
