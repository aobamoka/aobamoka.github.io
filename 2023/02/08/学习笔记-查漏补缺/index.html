<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="referrer" content="no-referrer">
    <meta name="theme-color" content="#333333">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="google" content="notranslate">
    <meta name="format-detection" content="telephone=no">
    <meta name="keyword"  content="">
    <meta name="description" content="">
    <title>学习笔记-查漏补缺 - 青叶摩卡的博客</title>
    <base href="/">
    <link rel="preconnect" href="//cdn.bootcss.com">
    <link rel="manifest" href="/manifest.json">
    <link rel="shortcut icon" href="/icons/icon-72x72.png">
    <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/atom-one-light.min.css" rel="stylesheet">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/atom-one-dark.min.css" rel="stylesheet" media="screen and (prefers-color-scheme: dark)">
    <!-- UIkit CSS -->
    <link href="https://cdn.bootcss.com/uikit/3.2.0/css/uikit.min.css" rel="stylesheet">
    <!-- UIkit JS -->
    <script src="https://cdn.bootcss.com/uikit/3.2.0/js/uikit.min.js" async></script>
    <script src="https://cdn.bootcss.com/uikit/3.2.0/js/uikit-icons.min.js" async></script>
    
<link rel="stylesheet" href="/styles/cold-stone.css">

    <noscript>
      <p class="text-center">你的浏览器还没开启 Javascript 功能！</p>
    </noscript>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="aobamoka" type="application/atom+xml">
</head>

  <body>
    

    <header class="header" uk-sticky="top: 100; animation: uk-animation-slide-top; bottom: #sticky-on-scroll-up">
  <nav class="wrapper header-content">
    <div class="nav-overlay uk-navbar-left">
      <h1 class="title nav-list-item uk-logo" data-link="/">
        
        <a href="/" data-link="/">aobamoka</a>
        
      </h1>

      <ul class="nav-list">
        
        <li class="nav-list-item" data-link="/categories/">
          <a class="nav-list-link" href="/categories">CATEGORIES</a>
        </li>
        
        
        <li class="nav-list-item" data-link="/about/">
          <a class="nav-list-link" href="/about/">ABOUT</a>
        </li>
        
        <li class="nav-list-item" data-link="/rss/">
          <a class="nav-list-link" href="/atom.xml">RSS</a>
        </li>
        
      </ul>
    </div>

    
      <div class="uk-navbar-right translate-x">
        <a class="uk-navbar-toggle" href="#modal-full" uk-search-icon uk-toggle></a>
      </div>
    
  </nav>
</header>

<div id="modal-full" class="uk-modal-full uk-modal" uk-modal>
  <div class="uk-modal-dialog uk-flex uk-flex-center uk-flex-middle" uk-height-viewport>
    <button class="uk-modal-close-full" type="button" uk-close></button>
    <form class="uk-search uk-search-large search-form" action="//google.com/search" method="get" accept-charset="UTF-8"
      target="_blank">
      <input class="uk-search-input search-form-input" type="search" name="q" placeholder="Search"
        autofocus autocomplete="false">
      <input type="hidden" name="sitesearch" value="http://example.com">
    </form>
  </div>
</div>


    <main class="main wrapper"><article class="article slide-in-right uk-article">
  <section class="article-header">
    <h1 class="article-title uk-article-title">
      学习笔记-查漏补缺
    </h1>
    <p class="article-meta uk-article-meta">
      <span class="meta-info">
        <span>
          Last Update&#58;<time class="post-time"
            datetime="2023-03-17">2023-03-17</time>
        </span>
        <span>Reading Time&#58; 9 min</span>
        <span class="hide" id="busuanzi_container_page_pv">Readed&#58; <span
            id="busuanzi_value_page_pv"></span></span>
      </span>
    </p>
  </section>
  <section class="article-content"><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><ul>
<li>面试官您好，我的名字是黄逸维，今年23岁，湖南人。（基本信息）</li>
<li>我本科和硕士阶段都就读于南京大学的计算机科学与技术系，硕士阶段的主要研究方向是自动化单元测试。（学历）</li>
<li>实验室方面，目前主要在做有关于Python自动化单元测试工具的工作，就是输入待测文件，通过随机算法、遗传算法等自动测试生成算法获得随机生成的测试用例输出，以及对应的覆盖率。我的工作主要是对这个工具进行实证研究，以及在原有的基础上进行一些改进，比如测试生成算法、结合类型标注等。（科研）</li>
<li>项目方面，做了一个webserver，它的主要功能是，用户在浏览器端输入网址，登陆验证后可请求服务器端的资源。服务器端接受连接、解析报文并做出响应。（项目）</li>
<li>我对C++的语言特性、数据结构、算法与计算机网络方面的知识比较熟悉，目前主要使用C++来进行编程。（基础）</li>
</ul>
<h1 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h1><ul>
<li>我们这个部门主要做的业务是什么？</li>
<li>对我的建议？学习方向？</li>
</ul>
<h1 id="1-C-C"><a href="#1-C-C" class="headerlink" title="1. C/C++"></a>1. C/C++</h1><ol>
<li><p>epoll_wait可通过timeout参数空值是否阻塞。-1表示永远等待，0表示不等待直接返回，其他表示在超时事件内如果没有事件发生，返回0。</p>
</li>
<li><p>memcpy实现：满足四字节对齐时进行四字节拷贝，否则进行单字节拷贝。注意dst与src拷贝后是否有重叠。注意类型。</p>
</li>
<li><p>socket函数：socket是一种特殊的文件，socket函数就是对其进行的操作。</p>
<ol>
<li><code>int socket(int domain, int type, int protocol);</code><ol>
<li>domain：协议族。AF_INET、AF_INET6。用于本机通信的为AF_UNIX。</li>
<li>type：socket类型。SOCK_STREAM、SOCK_DGRAM。</li>
<li>protocol：指定协议。IPPROTO_TCP、IPPROTO_UDP。</li>
<li>返回值：<ol>
<li>非负：成功，代表文件描述符</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
</li>
<li><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><ol>
<li>sockfd：创建的socket描述字。</li>
<li>addr：指向绑定给sockfd的协议地址，储存了地址类型、IP地址和端口号。</li>
<li>addrlen：地址长度。</li>
<li>返回值：<ol>
<li>0：成功</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
</li>
<li><code>int listen(int sockfd, int backlog);</code><ol>
<li>sockfd：要监听的socket描述字。</li>
<li>backlog：全连接队列长度。</li>
<li>listen将socket变为被动类型，等待客户连接请求。</li>
<li>返回值：<ol>
<li>0：成功</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
</li>
<li><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); </code><ol>
<li>sockfd：客户端的socket描述字。</li>
<li>addr：服务器的socket地址。</li>
<li>addrlen：socket地址长度。</li>
<li>返回值：<ol>
<li>0：成功</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
</li>
<li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><ol>
<li>sockfd：服务器的socket描述字。</li>
<li>addr：返回客户端的协议地址。</li>
<li>addrlen：客户端协议地址的长度。</li>
<li>返回值：<ol>
<li>非负：成功，代表已连接套接字</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
</li>
<li><code>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</code><ol>
<li>sockfd：发送端套接字。</li>
<li>buf：存放要发送数据的缓冲区。</li>
<li>len：要发送的字节数。</li>
<li>flags：参数。</li>
<li>返回值：<ol>
<li>非负：成功拷贝至发送缓冲区的字节数</li>
<li>-1：出错并置错误号errno（len大于缓冲区长度、拷贝时出错、网络断开）</li>
</ol>
</li>
</ol>
</li>
<li><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</code><ol>
<li>返回值：<ol>
<li>非负：成功拷贝的字节数</li>
<li>-1：出错并置错误号errno（拷贝时出错、网络断开）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>write返回值：</p>
<ol>
<li>&gt;0且等于给定字节数：正常。</li>
<li>小于给定字节数：底层物理介质空间不够；文件大小不够；被中断信号打断。</li>
<li>0：<ol>
<li>有errno设定：相应的失败情况。</li>
<li>无：指定写入0字节。</li>
</ol>
</li>
<li>-1：出错，查看errno</li>
</ol>
</li>
<li><p>read返回值：</p>
<ol>
<li>&gt;0且等于给定字节数：正常。</li>
<li>小于给定字节数：读到EOF；被信号打断。</li>
<li>0：读到EOF，或socket对端关闭。</li>
<li>-1：出错，查看errno。</li>
</ol>
</li>
<li><p>内存对齐：计算机系统对基本类型在数据中的存放位置有限制，要求其首地址从某个数的倍数开始，一般是4或8.</p>
<ol>
<li>原因：<ol>
<li>平台原因：某些硬件平台只能在某些地址处取某些特定类型的数据。</li>
<li>性能原因：访问未对齐的内存需要通过其他的辅助手段来获得这个位置的具体类型，不仅耗时且可能还有额外空间消耗。</li>
</ol>
</li>
<li>规则：<ol>
<li>每个特定平台的编译器都有对齐系数，可通过pragma pack预编译命令改变。</li>
<li>有效对齐值：pragma和结构体最长数据类型中较小的那个。</li>
<li>结构体第一个成员的偏移量为0，所有成员的偏移量与结构体的总大小都是有效对齐值的整数倍。</li>
</ol>
</li>
</ol>
</li>
<li><p>pthread_cond_wait：内部会先有一个解锁操作。一般的流程为，线程获得互斥锁后判断条件是否满足，不满足则调用该函数阻塞自己。此时如果不解锁，那线程就会带着互斥锁阻塞，其他线程无法获得互斥锁。被唤醒后，会先获得互斥锁再返回。</p>
</li>
<li><p>epoll函数：</p>
<ol>
<li><p><code>int epoll_create(size_t size)</code>：这个参数不起作用，只需要大于0就可以，内核会自动调整大小。返回epdf，epoll文件描述符。</p>
</li>
<li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>：</p>
<ol>
<li><p>epfd：create创建的描述符</p>
</li>
<li><p>op：</p>
<ol>
<li>EPOLL_CTL_ADD：注册新的fd</li>
<li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件</li>
<li>EPOLL_CTL_DEL：删除fd</li>
</ol>
</li>
<li><p>event：待监听的事件，可用<strong>按位或</strong>表示监听多个事件 <code>struct epoll_event &#123; __uint32_t events;  epoll_data_t data; &#125;;</code></p>
<ol>
<li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>EPOLLOUT：表示对应的文件描述符可以写</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>EPOLLERR：表示对应的文件描述符发生错误</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ol>
</li>
</ol>
</li>
<li><p><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code>：返回就绪的文件描述符个数，时间到返回0，出错返回-1</p>
<ol>
<li>events：得到就绪事件集合。</li>
<li>maxevents：告知events有多大，不能大于size。</li>
<li>timeout：<ol>
<li>-1：阻塞</li>
<li>0：立即返回</li>
<li>&gt;0：等待timeout秒返回</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2. 操作系统"></a>2. 操作系统</h1><ol>
<li>惊群现象：多个线程等待同一资源时，只要有一个资源到来，所有线程都来竞争资源。<ol>
<li>后果：无效调度、上下文频繁切换，影响系统性能；为确保只有一个线程得到资源，需要加锁，产生额外开销。</li>
<li>典型：socket accept，多个用户线程监听同一个端口。</li>
<li>解决：<ol>
<li>Linux2.6前：监听同一个socket的线程挂在一个等待队列上，请求到来时唤醒所有子线程，使用锁解决。</li>
<li>后：引入标记位。<ol>
<li>进程加入等待队列时，如果有标记位，被添加到队列尾部，否则到队列首部。</li>
<li>wake唤醒第一个有标记的进程后停止。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>grep和find<ol>
<li>find：根据文件的属性进行查找</li>
<li>grep：根据文件的内容进行查找，对文件的每一行按照给定的模式进行匹配查找。</li>
</ol>
</li>
<li>Linux文件权限：针对三类对象：owner属主，group属组，other其他。每个文件针对每个访问者定义三种权限：read读、write写、execute执行。<ol>
<li>针对文件：读写、x为执行权限，对除二进制程序以外的文件没意义。</li>
<li>针对目录：r：查看目录下的文件列表、w：删除创建文件、x：cd、查看文件详细属性、访问目录下文件内容。</li>
<li>chmod XXX file：三个X分别对三类对象给的权限。X如果=7，二进制表示为111，表示r、w、x权限都开放。以此类推。</li>
</ol>
</li>
<li>Core dump：<ol>
<li>概念：程序运行过程中异常终止或崩溃，操作系统就会将程序当时的内存状态记录下来，保存在一个文件中。core保存寄存器信息、内存管理信息、其他处理器和操作系统状态和信息等。</li>
<li>产生原理：信号处理函数。</li>
</ol>
</li>
<li>Buddy系统：<ol>
<li>伙伴块定义：<ol>
<li>大小相同</li>
<li>地址连续</li>
<li>从同一个大块分离出来</li>
<li>用一位二进制数表示其伙伴关系，为1表示其中一块在使用，为0表示都空闲或都在使用。系统每次分配和回收伙伴块时都对其伙伴位与1进行异或。</li>
</ol>
</li>
<li>管理：由链表管理，类似于STL，每个链表节点为2次幂大小的freelist</li>
<li>分配：<ol>
<li>查对应的freelist，如果有空闲块就直接摘下分配。</li>
<li>如果没有就向上查找，直到找到空闲块。</li>
<li>不断等分这个空闲块，直到恰好为满足条件的大小，把其他分下来的空闲块挂在相应freelist上。</li>
<li>如果找不到则放弃分配。</li>
</ol>
</li>
<li>释放：<ol>
<li>查对应的freelist，如果没有伙伴块就直接挂上。</li>
<li>如果有则摘下伙伴合并，然后向上查找是否可合并。</li>
<li>直到不能合并或已经合并到最大块。</li>
</ol>
</li>
<li>缺点：<ol>
<li>小块阻碍大块合并</li>
<li>按2的幂次分块，有一定浪费</li>
<li>拆分和合并涉及较多链表和位图操作，开销大</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="3-计网"><a href="#3-计网" class="headerlink" title="3. 计网"></a>3. 计网</h1><ol>
<li>中间人攻击：客户端发起HTTPS请求时，被假基站转发到了中间人服务器。中间人分别冒充对方，与双方完成TLS握手。<ol>
<li>前提是用户点击接受了中间人服务器的证书，这种证书浏览器能识别出来是非法的，并提醒用户。</li>
</ol>
</li>
<li>正向代理与反向代理<ol>
<li>正向代理：在客户端部署代理服务器，代替客户端对外收发消息。主要用途：<ol>
<li>突破访问控制：VPN。</li>
<li>提高访问速度：代理服务器有缓冲区，保存请求的响应。</li>
<li>隐藏客户端真实的IP。</li>
</ol>
</li>
<li>反向代理：在服务端部署代理服务器，替代原服务器接收请求发送响应。<ol>
<li>隐藏服务器真实IP。</li>
<li>负载均衡。代理服务器根据负载将请求发送到某台服务器。</li>
<li>提高访问速度：缓存。</li>
<li>安全保障：代理服务器作为防火墙。</li>
</ol>
</li>
<li>相同：<ol>
<li>提升访问速度。</li>
<li>隐藏IP。</li>
<li>都是转发请求与响应。</li>
</ol>
</li>
<li>区别：<ol>
<li>部署位置不同。</li>
<li>作用不同：正向代理帮助突破访问控制；反向代理提供安全保障与负载均衡。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="4-MySQL"><a href="#4-MySQL" class="headerlink" title="4. MySQL"></a>4. MySQL</h1><h1 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5. Redis"></a>5. Redis</h1></section>
</article>

<section class="prev-next card slide-in-right">
	
		<a href="/2023/02/09/学习笔记-Linux/" class="link prev" title="学习笔记-Linux">
			<span class="hover-underline-animation">&larr; 学习笔记-Linux</span>
		</a>
	
	
		<a href="/2023/02/08/学习笔记-Git/" class="link next" title="学习笔记-Git">
			<span class="hover-underline-animation">学习笔记-Git &rarr;</span>
		</a>
	
</section>


<section class="article-toc">
  <div class="card uk-margin-remove-bottom">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E9%97%AE"><span class="toc-text">反问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-C-C"><span class="toc-text">1. C&#x2F;C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">2. 操作系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%AE%A1%E7%BD%91"><span class="toc-text">3. 计网</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-MySQL"><span class="toc-text">4. MySQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Redis"><span class="toc-text">5. Redis</span></a></li></ol>
  </div>
</section>

<section class="article slide-in-right">
  <div class="loader" id="loader">
    <svg viewBox="0 0 50 50">
      <circle class="ring" cx="25" cy="25" r="20"></circle>
      <circle class="ball" cx="25" cy="5" r="3.5"></circle>
    </svg>
  </div>

  <div class="comment" id="utteranc"></div>
  <noscript>Please activate JavaScript for normal use of comments</noscript>
</section>

<a class="card back-to-top" id="backTop">&UpArrow;</a>
</main>

    

    <script>
	window.COLD_STONE = {
		root: "/",
		author: "aoba moka" || '',
		gaid: "xxxxxxxxxxxxxx" || '',
		repo: "xrr2016/blog" || '',
	}
</script>




	<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad()</script>


<script src="/scripts/busuanzi.js" referrerpolicy="origin"></script>

<script src="/scripts/cold-stone.js"></script>



  <script src="//www.googletagmanager.com/gtag/js?id=xxxxxxxxxxxxxx"></script>

  <script>
	window.dataLayer = window.dataLayer || []
	function gtag() {
		dataLayer.push(arguments)
	}
	gtag('js', new Date())
	gtag('config', window.COLD_STONE.gaid)
  </script>


  </body>
</html>
