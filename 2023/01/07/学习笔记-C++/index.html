<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>学习笔记-C++ | 摩卡&#39;s blog</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/icons/icon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    <link href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css" rel="stylesheet">
  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script defer src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    
    
    <!-- 依赖于jquery和vue -->
    
        <script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>
    

    
        <script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>
    

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="摩卡's blog" type="application/atom+xml">
</head>

  
  <!-- 预加载动画 -->
  <!-- 页面预加载动画 -->

  
    <div class="preloader_2" id="loader">
  <div class="loader"></div>
</div>

  
<script>
  var endLoading = function () {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('DOMContentLoaded',endLoading);
</script>

  <body>
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (src) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header  " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
      <h3 class="drawer-box-head_title">摩卡&#39;s blog</h3>
      <h5 class="drawer-box-head_desc">随便写写，记录下都看了些啥</h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
        </div>
      
      <a href="/" class="logo">摩卡&#39;s blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
    <div id="he-plugin-simple"></div>
    <script>
      WIDGET = {
        CONFIG: {
          "modules": "012",
          "background": 5,
          "tmpColor": "4A4A4A",
          "tmpSize": 16,
          "cityColor": "4A4A4A",
          "citySize": 16,
          "aqiSize": 16,
          "weatherIconSize": 24,
          "alertIconSize": 18,
          "padding": "10px 10px 10px 10px",
          "shadow": "1",
          "language": "auto",
          "borderRadius": 5,
          "fixed": "false",
          "vertical": "middle",
          "horizontal": "center",
          "key": "2784dd3fcb1e4f0f9a9b579bf69641f2"
        }
      }
    </script>
    <script defer src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script> 
    
</header>
        <!-- 内容区域 -->
        
 <!-- prismjs 代码高亮 -->
 


<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        学习笔记-C++
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2023-01-07 |
        </span>
      

      

      
    
  </div>
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content post-row" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <h1 id="C和C-区别"><a href="#C和C-区别" class="headerlink" title="C和C++区别"></a>C和C++区别</h1><ul>
<li>面向过程&amp;面向对象：C++有类和对象，支持模板，有STL。</li>
<li>动态内存管理：malloc&amp;new。</li>
<li>类型安全</li>
<li>输入输出</li>
</ul>
<h1 id="1-关键字-方法"><a href="#1-关键字-方法" class="headerlink" title="1. 关键字/方法"></a>1. 关键字/方法</h1><h2 id="1-new与malloc"><a href="#1-new与malloc" class="headerlink" title="1. new与malloc"></a>1. new与malloc</h2><h3 id="1-new-delete"><a href="#1-new-delete" class="headerlink" title="1. new/delete"></a>1. new/delete</h3><p>new的实现：</p>
<ul>
<li>调用operator new标准库函数，分配内存。</li>
<li>在该段内存上赋值或执行构造函数（placement new）。</li>
</ul>
<p>delete的实现：</p>
<ul>
<li>对指针指向的对象调用析构函数。</li>
<li>调用operator delete标准库函数释放所用内存。</li>
</ul>
<p>operator new/delete又是封装了malloc/free实现内存分配。</p>
<h3 id="2-malloc-free"><a href="#2-malloc-free" class="headerlink" title="2. malloc/free"></a>2. malloc/free</h3><p>malloc的实现：判断申请空间大小。</p>
<p>类似于STL的allocator，8字节为一个单位，分为128个链表，称为bin，链表节点称为chunk。前64个bin为small bin，后面的为large bin。</p>
<ul>
<li>第一个bin为unsorted bin。</li>
<li>同一个small bin里的chunk大小相同，相邻small bin相差8字节。</li>
<li>large bin包含一个给定范围内的chunk，按大小序排列，每个bin相差64字节。</li>
<li>还有一个fast bin，申请释放一些小内存空间时，不大于max_fast（默认64B）的空间释放后进入。会定时合并其中相邻的chunk。</li>
<li></li>
<li>top chunk：在mmap区域分配一块较大的空闲内存，模拟sub-heap。bin无法满足需求时使用。</li>
<li>mmaped chunk：top chunk都无法满足时，直接用mmap。使用后立即解除映射归还操作系统。</li>
<li>last remainder chunk：找不到合适的small chunk，如果last remainder大小大于所需，就分裂该chunk，其中一个给用户，另一个变成新的last remainder chunk。</li>
</ul>
<p>流程：</p>
<ul>
<li>一开始，用户请求大小小于mmap阈值：加上128KB申请，作为初始heap。</li>
<li>后续小于mmap阈值：fast-&gt;small-&gt;合并fast加入unsorted-&gt;unsorted-&gt;unsorted加入large-&gt;large（前面精确匹配，large里最小匹配或最优匹配）</li>
<li>以上都查找失败且小于mmap阈值：top chunk。</li>
<li>以上都查找失败且小于mmap阈值：mmap申请空间，增加top chunk。</li>
<li>以上都失败或大于mmap阈值：mmap。</li>
</ul>
<p>具体：</p>
<ul>
<li>bin里的chunk分配调用brk()实现（把数据段.data的最高地址指针往高地址推）。brk会在堆中分配相应的空间，且使用该空间后不会立刻还给操作系统，而是缓存在malloc内存池中。（brk分配的内存需要等到更高地址的内存都被释放了才能释放）</li>
<li>较大空间调用mmap()实现（匿名映射）。mmap会在文件映射区中分配相应的虚拟空间，且使用该空间后立刻还给操作系统。mmap将文件映射区的虚拟地址与内核中的文件进行绑定。因为读写文件要经过page cache，所以相当于用户空间直接读写内核中的page cache。通过msync数据同步、munmap解除映射关系时主动刷盘；或者进程退出、系统关机时被动刷盘。<ul>
<li>mmap将文件映射区的虚拟地址与文件进行绑定。因为读写文件要经过page cache，所以相当于用户空间直接读写page cache。通过msync数据同步、munmap解除映射关系时主动刷盘；或者进程退出、系统关机时被动刷盘。</li>
</ul>
</li>
</ul>
<p>分大小调用的原因：</p>
<ul>
<li>不全用brk：堆空间不够大；空间使用结束后不会立刻还给操作系统，频繁申请大内存容易造成内存碎片。</li>
<li>不全用mmap：每次调用都重新分配空间，且使用完立刻还给操作系统，第一次访问该空间一定会发生缺页中断，影响系统性能。</li>
</ul>
<p>被free释放的内存会被保存在空闲双链表中，下次申请时直接找合适的返回，避免频繁的系统调用。</p>
<h3 id="3-new与malloc区别"><a href="#3-new与malloc区别" class="headerlink" title="3. new与malloc区别"></a>3. new与malloc区别</h3><p>new实际上封装了malloc。</p>
<ul>
<li>new是C++运算符，malloc是C/C++语言标准库函数</li>
<li>new自动计算分配空间大小，malloc需要手动计算</li>
<li>new类型安全，即返回的就是构造类型的指针，malloc不是，需要从void*强制转换</li>
<li>new不仅分配空间，还调用构造函数</li>
<li>new分配失败会抛出bad_alloc异常，malloc分配失败返回NULL</li>
</ul>
<h2 id="2-align-结构体对齐"><a href="#2-align-结构体对齐" class="headerlink" title="2. align 结构体对齐"></a>2. align 结构体对齐</h2><p>alignof：传入类型，计算出其对齐方式。</p>
<p>alignas：用于struct关键字后，指定结构体的对齐方式，如struct alignas(2)指定2字节对齐。但是如果指定的字节小于自然对齐的最小单位，则被忽略（结构体中有int这种大于2字节的）。</p>
<h2 id="3-const与"><a href="#3-const与" class="headerlink" title="3. const与*"></a>3. const与*</h2><p>把char与括号里的东西忽略，直接看const修饰的是p还是*p。</p>
<ul>
<li>const char* p，const修饰<em>p，说明 <em>p是const，p可变。</em></em>指针常量，即指针指向的对象是常量**。底层const。</li>
<li>char* const p，const修饰p，说明p是const， *p可变。<strong>常量指针，即指针本身是常量</strong>。顶层const。</li>
<li>const (char*) p，忽略括号const修饰p，说明p是const，*p可变。</li>
<li>const char* const p，常量指针常量。</li>
</ul>
<h2 id="4-static与const"><a href="#4-static与const" class="headerlink" title="4. static与const"></a>4. static与const</h2><h3 id="1-static"><a href="#1-static" class="headerlink" title="1. static"></a>1. static</h3><ul>
<li>不在类中<ul>
<li>隐藏：带static的全局变量和函数只能在该文件所在的编译模块中使用。static函数在整个内存中只有一份，而普通函数在每个调用该函数的编译单元中都有一份拷贝。</li>
<li>函数内定义的静态变量只能进行一次初始化，函数退出后依然存在，且不能初始化。</li>
</ul>
</li>
<li>在类中<ul>
<li>成员变量：只与类关联而不与对象关联，不能在类声明中初始化，只能在类定义体外部初始化。</li>
<li>成员函数：没有this指针，无法访问本类的非static成员变量与成员函数，不能被声明为const、virtual和volatile。</li>
</ul>
</li>
</ul>
<h3 id="2-const"><a href="#2-const" class="headerlink" title="2. const"></a>2. const</h3><ul>
<li>不在类中<ul>
<li>阻止一个变量被改变</li>
<li>修饰变量与static有一样的隐藏作用，只能在该文件中出现，其他文件不能引用声明。</li>
<li>定义时必须初始化</li>
<li>类对象只能调用const成员函数</li>
<li>const形参可接受const和非const实参</li>
</ul>
</li>
<li>在类中<ul>
<li>成员变量：不能在类定义外部初始化、不能在声明时初始化，只能通过构造函数初始化列表初始化，且必须要有构造函数。</li>
<li>成员函数：const对象不能调用非const成员函数，不可改变非mutable数据的值。</li>
</ul>
</li>
</ul>
<h2 id="5-final与override"><a href="#5-final与override" class="headerlink" title="5. final与override"></a>5. final与override</h2><h3 id="1-override"><a href="#1-override" class="headerlink" title="1. override"></a>1. override</h3><p>如果父类中使用了虚函数，在子类中重写该虚函数时可以加override，这样如果父类中没有相应的虚函数时，编译器会报错。</p>
<p>防止重写时打错名字。</p>
<h3 id="2-final"><a href="#2-final" class="headerlink" title="2. final"></a>2. final</h3><p>不希望某个类被继承或某个虚函数被重写。</p>
<h2 id="6-volatile"><a href="#6-volatile" class="headerlink" title="6. volatile"></a>6. volatile</h2><p>类型修饰符，表明该变量是随时发生变化的，可以被某些编译器未知的因素更改。</p>
<p>每次使用值时总是从它所在的内存读取，而不是寄存器、读缓存等。读取的数据立刻被保存。（可能通过汇编代码等偷偷修改变量的值而不被编译器察觉）</p>
<p>并且编译器不会对它的操作进行优化。</p>
<p>用途：</p>
<ul>
<li>被几个任务共享的变量。</li>
<li>中断服务程序修改的供其他程序检测的变量。</li>
<li>存储器映射的硬件寄存器。</li>
</ul>
<p>volatile指针和const指针辨认方法类似。</p>
<p><strong>const与volatile可以一起</strong>。const控制程序本身不改变该值，volatile告诉编译器该值可能被程序之外的方式修改。</p>
<p>可以把非volatile对象赋给volatile对象，反之不行。</p>
<p>应用：<code>for (volatile int i = 0; i &lt; 100000; ++i);</code></p>
<p>不加volatile编译器会优化，不会做这个循环。加了volatile就会循环完。</p>
<h2 id="7-mutable"><a href="#7-mutable" class="headerlink" title="7. mutable"></a>7. mutable</h2><p>修饰的变量即使在const函数中也可变。</p>
<h2 id="8-explicit"><a href="#8-explicit" class="headerlink" title="8. explicit"></a>8. explicit</h2><p>修饰只用一个参数的构造函数。（只有一个参数，或其他参数有默认值）</p>
<p>被修饰的类不能发生相应的隐式类型转换（用=号构造），只能显式类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>): a(a), b(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point a = <span class="number">1</span>; <span class="comment">// 匹配上了Point(1)，隐式调用了构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-new"><a href="#9-new" class="headerlink" title="9. new"></a>9. new</h2><ul>
<li>plain new/operator new：普通的new，空间分配失败抛出异常bad_alloc。<ul>
<li>operator new不能满足内存请求时：如果set_new_handler指定了错误处理函数，则调用后再次尝试请求内存；否则抛出异常。</li>
</ul>
</li>
<li>nothrow new：空间分配失败返回NULL</li>
<li>placement new：允许在一块已经分配成功的内存上重新构造对象，不分配内存。构造成功的对象要显式调用析构函数销毁，因为构造的对象大小并不一定等于原来分配的内存大小，delete会造成内存泄漏。</li>
</ul>
<p>STL中，new操作符内部先使用plain new分配空间，然后使用placement new在分配的空间上初始化。</p>
<h2 id="10-allocator-alloc"><a href="#10-allocator-alloc" class="headerlink" title="10. allocator/alloc"></a>10. allocator/alloc</h2><p>allocator与alloc负责封装堆内存管理的对象，在整个标准库中使用，特别是STL。</p>
<p>allocator只是malloc与free一层包装，而alloc由allocator与constructor组成，不仅负责申请/释放空间还负责调用构造/析构函数。</p>
<h2 id="11-delete"><a href="#11-delete" class="headerlink" title="11. delete"></a>11. delete</h2><p>new对象数组时C++会额外分配4字节保存数组大小，在delete[]时就能取出保存的大小，从而知道需要析构多少次。</p>
<h2 id="12-alloc系列函数"><a href="#12-alloc系列函数" class="headerlink" title="12. alloc系列函数"></a>12. alloc系列函数</h2><p>malloc：void *malloc(unsigned int num_bytes)。</p>
<p>num_bytes为要申请的空间大小，需要手动计算。</p>
<p>calloc：void *calloc(size_t n, size_t size)。</p>
<p>传入个数n与sizeof(type)即可申请空间，不需要人为计算，申请后将空间的值初始化为0。因为有初始化操作，效率较malloc低。</p>
<p>realloc：void realloc(void *ptr, size_t new_Size)。</p>
<p>对动态内存扩充。</p>
<h2 id="13-cast强制转换"><a href="#13-cast强制转换" class="headerlink" title="13. cast强制转换"></a>13. cast强制转换</h2><p>转换是一种编译器指令，大部分情况下并不改变指针的地址，而只是影响指针指向<strong>内存的大小和内容</strong>的<strong>解释方式</strong></p>
<ul>
<li>reinterpret_cast：普通的强制类型转换（只是对二进制位用新类型重新解释），高度危险但最灵活。可以进行static_cast不能进行的转换。</li>
<li>const_cast：去除类型的const或volatile属性。常量指针、引用转换成非常量指针、引用，仍然指向原来的对象。</li>
<li>static_cast：静态转换，即编译期转换。没有运行时类型检查，不能用于无关类型指针、int和指针的转换。<ul>
<li>类层次结构中父子类之间指针引用的转换。上行转换安全，但下行转换不安全，直接使用转换后的对象可能报错。</li>
<li>基本数据类型间转换</li>
<li>空指针转换成目标类型的空指针</li>
<li>任何类型的表达式转成void</li>
</ul>
</li>
<li>dynamic_cast：只能转换<strong>指针和引用类型</strong>，只能用于<strong>存在虚函数的父子关系类中的转换</strong>，有类型检查，运行时借助RTTI（Run Time Type Identification，运行时类型识别）进行类型转换，要求<strong>基类必须包含虚函数</strong>。<ul>
<li>上行转换与static_cast无条件，不会进行任何检测；下行转换有类型检查，比static_cast安全，但是只有一部分能成功（基类指针/引用确实指向一个派生类对象），不成功会返回空指针。</li>
<li>转换后必须是类的指针、引用或void*。</li>
<li>转换指针失败返回nullptr。</li>
<li>转换引用失败抛出异常。（因为引用不能为空）</li>
</ul>
</li>
</ul>
<h2 id="14-strcpy、sprintf、memcpy"><a href="#14-strcpy、sprintf、memcpy" class="headerlink" title="14. strcpy、sprintf、memcpy"></a>14. strcpy、sprintf、memcpy</h2><p>手撕时要考虑const、判断非空、重叠问题！</p>
<ul>
<li>操作对象：<ul>
<li>strcpy操作对象均为字符串</li>
<li>sprintf源操作对象可以是多种数据类型，目的操作对象是字符串</li>
<li>memcpy操作对象可以是任意可操作的内存地址</li>
</ul>
</li>
<li>执行效率：<ul>
<li>memcpy、strcpy、sprintf</li>
</ul>
</li>
<li>实现功能：<ul>
<li>strcpy实现字符串变量间的拷贝</li>
<li>sprintf实现其他数据类型格式到字符串的转化</li>
<li>memcpy实现内存块间的拷贝</li>
</ul>
</li>
</ul>
<h2 id="15-inline内联函数"><a href="#15-inline内联函数" class="headerlink" title="15. inline内联函数"></a>15. inline内联函数</h2><p>取舍：</p>
<ul>
<li>替换宏</li>
<li>作为类成员接口函数来读写类的私有成员或者保护成员（内联函数定义要与类的声明放在同一个文件，否则无法替换）</li>
<li>inline是编译时嵌入代码，通过增大代码空间消耗换取函数调用消耗，所以增大代码空间/函数执行的代价大于函数调用代价时（函数体过大、函数体内有循环）不应用inline。</li>
</ul>
<p>编译限制：</p>
<ul>
<li>不能有循环、过多条件判断。</li>
<li>函数体不能太大。</li>
<li>声明必须在调用语句前。</li>
</ul>
<p>内联只是建议，编译器并不一定内联，所以将构造函数、析构函数声明为内联函数可以，只是没有用，因为编译器会在这些函数中添加额外的操作。</p>
<p>指向派生类的指针调用声明为虚函数时，不会展开（多态）；对象本身调用虚函数时且函数不复杂时，会内联展开。</p>
<h2 id="16-iovec"><a href="#16-iovec" class="headerlink" title="16. iovec"></a>16. iovec</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">ptr_t</span> iov_base; <span class="comment">/* Starting address */</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">/* Length in bytes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *<span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *<span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义向量元素，iov_base指向存放的数据，iov_len表示接收的最大长度/实际写入的长度。</p>
<p>vector为iovec数组，count为vector大小。</p>
<h2 id="17-可变形参-vsprintf"><a href="#17-可变形参-vsprintf" class="headerlink" title="17. 可变形参/vsprintf"></a>17. 可变形参/vsprintf</h2><p>可变形参通过宏实现，定义在stdarg.h中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>&#123;<span class="comment">// num为参数个数，后面的为可变形参</span></span><br><span class="line">        va_list ap;</span><br><span class="line">        va_start(ap, num);</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, va_arg(ap, <span class="keyword">int</span>));</span><br><span class="line">               num--;</span><br><span class="line">        &#125;</span><br><span class="line">        va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>int vsprintf(char *str, const char *format, va_list arg)</code></p>
<p>format和arg与printf类似输入。</p>
<h2 id="18-fstream"><a href="#18-fstream" class="headerlink" title="18. fstream"></a>18. fstream</h2><p>函数：</p>
<ul>
<li>构造函数 <code>fstream()</code></li>
<li>构造函数 <code>fstream(filename: string, mode)</code>。这样构造时调用open。mode用按位或连接。<ul>
<li>ios::in：读</li>
<li>ios::out：写</li>
<li>ios::ate：初始位置在文件尾</li>
<li>ios::app：尾部写入</li>
<li>ios::trunc：如果文件已存在则先删除</li>
<li>ios::binary：二进制方式</li>
</ul>
</li>
<li><code>open(filename: string, mode)</code>。</li>
<li><code>is_open()</code></li>
<li><code>close()</code>：将缓存中的数据排出并关闭文件。析构时自动调用。</li>
<li>写：<ul>
<li><code>write(data: const char*, n: streamsize)</code></li>
<li>操作符&lt;&lt;重载</li>
</ul>
</li>
<li>读：<ul>
<li><code>getline(data: const char*, n: streamsize, delim: char)</code>：读取到delim停止，默认为’\n’即读取一行。</li>
<li><code>getline(is: istream&amp;, str: string&amp;, delim: char)</code></li>
<li>操作符&gt;&gt;重载。根据后面跟的变量类型决定什么时候停止（字符串读到空白字符停止）</li>
</ul>
</li>
</ul>
<h2 id="19-extern"><a href="#19-extern" class="headerlink" title="19. extern"></a>19. extern</h2><p>单定义规则：变量只能有一次定义。</p>
<p>C++提供了两种变量声明：</p>
<ul>
<li>定义声明：简称定义，给变量分配内存空间。</li>
<li>引用声明：简称声明，不给变量分配内存空间，因为引用已有变量。</li>
</ul>
<p>引用声明用extern关键字且不初始化，否则视为定义，分配空间。</p>
<p>在文件中使用其他文件定义的外部变量时，需要extern声明变量。（全局变量一般声明在.c文件中，而include一般作用于.h文件）</p>
<h2 id="20-union"><a href="#20-union" class="headerlink" title="20. union"></a>20. union</h2><p>作用：</p>
<ul>
<li>强制类型转换</li>
<li>查看类型分布（用char[]与想查看的类型union）</li>
<li>优化短字符串（char[]与unsigned long long union，可直接用ull作为哈希值，比较字符串是否相等）</li>
<li>取别名（数组与结构体union，通过数组遍历结构体成员）</li>
</ul>
<p>缺点：如果union了多个指针，没法释放被覆盖的指针指向的内存；union含有带析构函数的成员时，不会自动析构。</p>
<p>改进：C++ 17 variant</p>
<h1 id="2-比较"><a href="#2-比较" class="headerlink" title="2. 比较"></a>2. 比较</h1><h2 id="1-指针和引用"><a href="#1-指针和引用" class="headerlink" title="1. 指针和引用"></a>1. 指针和引用</h2><p>区别：</p>
<ul>
<li>存储内容：指针存储地址，引用实际上只是一个别名。</li>
<li>嵌套：指针可以有多级，引用只有一级。</li>
<li>初始化：指针可以为空，引用不行且必须在定义时初始化。</li>
<li>更改：指针定义后可以改变指向，而引用不可改变。</li>
<li>sizeof：指针得到4字节（指针大小），引用得到其引用变量的大小。</li>
<li>参数传递：指针参数传递本质上还是值传递，指针本身作为值被复制，在函数中改变指针地址并不会影响原指针；任何对于引用参数的处理都会通过间接寻址操作到主调函数的相关变量。</li>
<li>从汇编的层次看，引用是通过指针实现的。</li>
</ul>
<h2 id="2-堆和栈"><a href="#2-堆和栈" class="headerlink" title="2. 堆和栈"></a>2. 堆和栈</h2><ul>
<li>管理方式<ul>
<li>堆由程序员控制</li>
<li>栈由操作系统自动管理</li>
</ul>
</li>
<li>内存管理机制<ul>
<li>堆由空闲内存链表分配，是不连续的内存区域，大小可灵活调整</li>
<li>栈顶和栈底预设好，大小固定，超出会报栈溢出</li>
</ul>
</li>
<li>空间大小<ul>
<li>堆大小受限于有效虚拟内存</li>
<li>栈大小是操作系统预设的，windows下为2M</li>
</ul>
</li>
<li>碎片问题<ul>
<li>堆会产生碎片，栈不会</li>
</ul>
</li>
<li>生长方向<ul>
<li>堆向高地址方向生长，而栈向低地址</li>
</ul>
</li>
<li>分配方式<ul>
<li>堆都是动态分配</li>
<li>栈的静态分配由编译器完成，动态分配由alloca函数完成，由编译器释放</li>
</ul>
</li>
<li>分配效率<ul>
<li>堆由C/C++函数库提供，机制复杂（分配内存时需要寻找合适的内存，获取堆内容需要指针和实际内存两次访问），效率低</li>
<li>栈是操作系统提供的结构，计算机底层提供支持（专门寄存器存栈地址，专门指令执行操作），效率高</li>
</ul>
</li>
</ul>
<h2 id="3-宏与函数-typedef-内联函数-const"><a href="#3-宏与函数-typedef-内联函数-const" class="headerlink" title="3. 宏与函数/typedef/内联函数/const"></a>3. 宏与函数/typedef/内联函数/const</h2><p>与函数的区别：</p>
<ul>
<li>宏在预处理阶段，编译阶段前完成，直接进行文本插入替换；函数调用是在运行时跳转</li>
<li>宏定义没有类型，不检查类型</li>
<li>宏定义因为属于直接替换代码，没有返回值</li>
<li>宏不是语句，不要加分号</li>
</ul>
<p>与typedef的区别：</p>
<ul>
<li>typedef发生在编译阶段</li>
<li>typedef检查类型</li>
<li>typedef是语句</li>
</ul>
<p>与内联函数的区别：</p>
<ul>
<li>内联函数可以进行参数类型检查、语法判断</li>
<li>内联函数在编译时将函数代码嵌入目标代码，能省去函数调用开销，还能实现重载；宏在预处理阶段嵌入</li>
</ul>
<p>与const的区别：</p>
<ul>
<li>宏在预处理阶段直接替换，不占用内存；const在编译、运行时起作用，且占用内存。</li>
<li>宏不检查类型；const检查。</li>
</ul>
<h2 id="4-变量声明与变量定义"><a href="#4-变量声明与变量定义" class="headerlink" title="4. 变量声明与变量定义"></a>4. 变量声明与变量定义</h2><p>声明：只告知编译器变量声明的位置与类型，不分配内存。可多次出现。</p>
<p>定义：分配内存。只能有一个定义。</p>
<h2 id="5-数组名和指针"><a href="#5-数组名和指针" class="headerlink" title="5. 数组名和指针"></a>5. 数组名和指针</h2><p>数组名不是真正的指针，没有自增自减操作。</p>
<p>数组名当作形参传给函数后，退化成一般指针，可以自增自减、可被修改，但无法用sizeof得到数组大小（sizeof只会返回指针大小）。</p>
<h2 id="6-赋值初始化与成员初始化列表"><a href="#6-赋值初始化与成员初始化列表" class="headerlink" title="6. 赋值初始化与成员初始化列表"></a>6. 赋值初始化与成员初始化列表</h2><p>赋值初始化，在所有数据成员被分配内存空间后才进行；在构造函数中赋值操作，而复杂类型成员变量的赋值操作会产生临时对象，所以有可能降低效率。</p>
<p>列表初始化，在给数据成员分配内存空间时就进行；对于复杂类型成员变量初始化，少调用一次拷贝构造函数，所以会快一些。必须用到的场合：</p>
<ul>
<li>初始化引用成员、常量成员</li>
<li>调用基类构造函数且其有参数</li>
<li>调用成员类构造函数且其有参数</li>
</ul>
<p>派生类构造函数的执行顺序：</p>
<ol>
<li>虚拟基类的构造函数</li>
<li>基类的构造函数</li>
<li>（如果存在）虚表指针初始化</li>
<li>类类型的成员对象的构造函数（按照初始化顺序）</li>
<li>派生类自己的构造函数（用户在当前类构造函数中写的代码）</li>
</ol>
<p>析构顺序与构造顺序相反。</p>
<h2 id="7-vector的emplace-back与push-back"><a href="#7-vector的emplace-back与push-back" class="headerlink" title="7. vector的emplace_back与push_back"></a>7. vector的emplace_back与push_back</h2><p>对于vector&lt;A&gt;：</p>
<p>emplace_back接收A的构造函数的参数，进行原地构造。</p>
<p>push_back接收A类型的对象，然后触发转移构造函数。</p>
<p>如果要插入临时对象，emplace_back可以少触发一次转移构造函数。</p>
<h2 id="8-组合和继承"><a href="#8-组合和继承" class="headerlink" title="8. 组合和继承"></a>8. 组合和继承</h2><p>继承：</p>
<ul>
<li>优点：<ul>
<li>子类可以重写父类的方法来方便扩展。</li>
</ul>
</li>
<li>缺点：<ul>
<li>父类内部细节对子类可见</li>
<li>子类无法在运行期间改变从父类继承的方法的行为</li>
<li>如果对父类方法修改，子类必须做出相应的修改，父子类高耦合，违背了面向对象思想。</li>
</ul>
</li>
</ul>
<p>组合</p>
<ul>
<li>优点：<ul>
<li>包含对象的内部细节对当前对象不可见</li>
<li>低耦合关系，修改包含对象代码不需要修改当前对象</li>
<li>当前对象可以在运行时动态绑定包含对象</li>
</ul>
</li>
<li>缺点：<ul>
<li>容易产生过多对象</li>
</ul>
</li>
</ul>
<h2 id="9-Debug与Release版本"><a href="#9-Debug与Release版本" class="headerlink" title="9. Debug与Release版本"></a>9. Debug与Release版本</h2><p>只是定义的区别，实际上可以任意修改。</p>
<p>Debug调试版本：</p>
<ul>
<li>包含调试信息，所以容量很大。</li>
<li>不进行任何优化，因为优化会使调试复杂化。</li>
<li>有pdb文件，记录断点等调试信息。</li>
</ul>
<p>Release发布版本：</p>
<ul>
<li>不包含调试信息</li>
<li>编译时进行优化</li>
<li>无pdb文件</li>
</ul>
<h2 id="10-函数模板和类模板"><a href="#10-函数模板和类模板" class="headerlink" title="10. 函数模板和类模板"></a>10. 函数模板和类模板</h2><ul>
<li>函数模板的实例化由编译程序在处理函数调用时自动完成，而类模板的实例化必须由程序员在程序中显式指定。因此，函数模板允许隐式调用，而类模板不允许。隐式调用，即调用时不需要特别用尖括号指出匹配的类型。</li>
<li>函数只允许全特化，偏特化用函数重载完成。类允许全特化与偏特化。调用优先级全&gt;偏&gt;无。</li>
</ul>
<h2 id="11-自由存储区与堆"><a href="#11-自由存储区与堆" class="headerlink" title="11. 自由存储区与堆"></a>11. 自由存储区与堆</h2><p>new是在自由存储区上申请内存。</p>
<p>自由存储区是C++通过new和delete操作的内存的抽象概念，只要通过new申请来的内存就可称为自由存储区。</p>
<p>大部分C++编译器默认用堆实现自由存储区。</p>
<h1 id="3-类"><a href="#3-类" class="headerlink" title="3. 类"></a>3. 类</h1><h2 id="1-面向对象三大特性"><a href="#1-面向对象三大特性" class="headerlink" title="1. 面向对象三大特性"></a>1. 面向对象三大特性</h2><ul>
<li>继承：某种类型对象获得另一个类型对象的属性和方法。</li>
<li>封装：将数据以及对数据的操作封装成类。</li>
<li>多态：向不同对象发送同一消息，不同对象产生不同行为。重载实现编译时多态，虚函数实现运行时多态。允许子类类型的指针赋值给父类类型的指针。</li>
</ul>
<p>基于对象没有继承，因而更谈不上多态。</p>
<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h2><ul>
<li>默认构造函数：没有参数</li>
<li>初始化构造函数：有参数</li>
<li>拷贝构造函数：可自定义深拷贝</li>
<li>移动构造函数：将被移动对象的空间移动到本对象，本质上是浅拷贝，但是把被拷贝的指针指向NULL，就能避免释放带来的不安全。其参数是右值引用，也就是说只有用右值或将亡值初始化另一个对象时，才会调用</li>
<li>委托构造函数：使用初始化列表的形式，将部分工作委托给其他构造函数</li>
<li>继承构造函数：将部分工作委托给基类构造函数</li>
<li>转换构造函数：只有一个形参，且为其他类型变量，将其他类型变量隐式转换为本类变量</li>
</ul>
<h2 id="3-拷贝初始化"><a href="#3-拷贝初始化" class="headerlink" title="3. 拷贝初始化"></a>3. 拷贝初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str3 = <span class="string">&quot;I am a string&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这句代码先用字符串作为参数，用指定构造函数构造一个临时对象，然后再用拷贝构造函数拷贝到正在创建的对象。</p>
<p>编译器进行优化，跳过临时对象这一步，变为直接调用构造函数，因此等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="4-重载、重写、覆盖和隐藏"><a href="#4-重载、重写、覆盖和隐藏" class="headerlink" title="4. 重载、重写、覆盖和隐藏"></a>4. 重载、重写、覆盖和隐藏</h2><p>重载：同一范围，函数名相同，参数类型和数目不同，不能只有返回值不同。</p>
<p>重写/覆盖：在派生类中覆盖基类中的同名函数，要求基类函数必须是虚函数，且参数个数、参数类型、返回值类型相同。</p>
<p>与重载的区别：</p>
<ul>
<li>关系：重写存在于父类和子类，重载是同一范围</li>
<li>参数：重写要求参数列表相同，重载要求参数列表不同</li>
<li>调用方法：重写调用的方法根据对象类型决定，重载根据实参和形参的对应关系决定</li>
</ul>
<p>隐藏：派生类的函数屏蔽了基类中的<strong>同名</strong>函数。这种情况下通过类指针只能调用派生类函数，无法调用基类同名函数。</p>
<p>原理：命名空间查找。派生类作用域定义了该函数名，就认为已经找到，不会去基类查找。</p>
<ul>
<li>两个函数参数相同，基类不是虚函数</li>
<li>两个函数参数不同，不管基类是否是虚函数</li>
</ul>
<p>隐藏情况下的普通对象和对象指针：</p>
<ul>
<li>定义派生类普通对象，该对象只能调用派生类的同名函数，因为先在派生类作用域内查找。</li>
<li>定义基类指针指向该对象，该指针只能调用基类同名函数，因为先在基类作用域查找。</li>
<li>总之一句话：只要没有动态绑定（虚函数），永远根据定义时的类型走。</li>
</ul>
<h2 id="5-NRV优化"><a href="#5-NRV优化" class="headerlink" title="5. NRV优化"></a>5. NRV优化</h2><p>具名返回值（name return value）优化：</p>
<p>对于 <code>A a = f()</code>，f为 <code>A f() &#123;...&#125;</code></p>
<p>不发生优化时，f返回b时调用拷贝构造函数，将局部对象b拷贝到a。</p>
<p>具体做法为，把f变为 <code>void f(A&amp; __result) &#123;...&#125;</code>，并在返回前调用拷贝构造函数，将b拷贝给__result。</p>
<p>如果发生了优化，编译器直接把a的地址传进f，让a代替b完成f中的操作，返回b时就不需要拷贝了，因为a就是b。</p>
<p>具体做法为，把f变为 <code>void f(A&amp; __result) &#123;...&#125;</code>，并直接用__result代替b执行所有操作。</p>
<p>早期的编译器必须在定义了拷贝构造函数才会执行NRV优化：早期编译器需要一个判断标准决定是否优化。如果用户定义了自己的拷贝构造函数，说明客户由于某些原因摆脱了高效的逐位拷贝，拷贝开销将增大，所以应该实行优化，以引用替代拷贝降低开销。</p>
<h2 id="6-静态绑定与动态绑定"><a href="#6-静态绑定与动态绑定" class="headerlink" title="6. 静态绑定与动态绑定"></a>6. 静态绑定与动态绑定</h2><p>静态类型是对象在声明时的类型，编译期确定；动态类型是一个指针引用目前所指对象的类型，运行时决定。</p>
<p>静态绑定绑定的是静态类型，对应的函数或属性依赖于对象的静态类型，发生在编译期；动态绑定绑定的是动态类型，对应的函数或属性依赖于对象的动态类型，发生在运行时。</p>
<ul>
<li><strong>继承体系中只有虚函数用的是动态绑定，其他的全是静态绑定</strong>。只能通过<strong>指针与引用</strong>实现。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*virtual*/</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	C* pc = <span class="keyword">new</span> C(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">	B* pb = <span class="keyword">new</span> B(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">	A* pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">	pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">	C *pnull = <span class="literal">NULL</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">  </span><br><span class="line">    	pa-&gt;func();      <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">	pc-&gt;func();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">	pnull-&gt;func();   <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-具体过程"><a href="#1-具体过程" class="headerlink" title="1. 具体过程"></a>1. 具体过程</h3><p>静态绑定的具体过程：编译时发生</p>
<ul>
<li>查找pnull类型为C，发现其有非虚成员函数func。</li>
<li>找到func，生成函数调用C::func。</li>
</ul>
<p>动态绑定的具体过程：17 多态与虚函数</p>
<p>如果基类被初始化为派生类（即 <code>A a = new B</code>这种操作），因为派生类的内存一般都会大于基类，所以会触发slice切割操作，从而回避了多态机制，进而没有用B类的vtable初始化a。</p>
<h3 id="2-样例分析"><a href="#2-样例分析" class="headerlink" title="2. 样例分析"></a>2. 样例分析</h3><p>A的func不定义为虚函数时，pa的静态类型是A*，所以静态绑定A的func。</p>
<p>类的成员函数不与具体对象绑定，所有对象共用一份成员函数体。区分不同对象靠的是this指针，成员函数中对成员变量的访问都转化为this-&gt;成员对象。只要不对this指针指向的内容读取或修改，就能通过空对象访问成员函数。</p>
<p>对于pnull，该调用相当于func(C* this)，而函数体中没有用到this，所以能正常调用。（可以联动一下5 NRV优化）</p>
<p>A的func定义为虚函数时，所有的调用都要等到运行时指向对象的类型决定。pa绑定的是B的func，而pnull会报错空指针异常。</p>
<p>所以，<strong>绝对不要重新定义继承而来的非虚函数</strong>。</p>
<p>引用也能实现动态绑定。</p>
<h2 id="7-实现只能静态-动态创建对象"><a href="#7-实现只能静态-动态创建对象" class="headerlink" title="7. 实现只能静态/动态创建对象"></a>7. 实现只能静态/动态创建对象</h2><p>静态：new与delete重载成private/delete（更温和）</p>
<p>动态：构造、析构函数设置为protected，再用子类动态创建</p>
<h2 id="8-对象复用"><a href="#8-对象复用" class="headerlink" title="8. 对象复用"></a>8. 对象复用</h2><p>Flyweight享元模式：将对象存储到对象池中实现重复利用，避免多次创建重复对象的开销。</p>
<h2 id="9-空类"><a href="#9-空类" class="headerlink" title="9. 空类"></a>9. 空类</h2><p>空类也会实例化，在内存中分配一块地址，所以编译期会隐含添加一个字节。</p>
<p>空类在实例化时，默认添加：缺省构造函数、拷贝构造函数、析构函数、赋值运算符、*取址运算符与const *取址运算符。</p>
<h2 id="10-阻止类被实例化"><a href="#10-阻止类被实例化" class="headerlink" title="10. 阻止类被实例化"></a>10. 阻止类被实例化</h2><ol>
<li>将类定义为抽象基类</li>
<li>将构造函数声明为private</li>
</ol>
<h2 id="11-禁止程序自动生成拷贝构造函数"><a href="#11-禁止程序自动生成拷贝构造函数" class="headerlink" title="11. 禁止程序自动生成拷贝构造函数"></a>11. 禁止程序自动生成拷贝构造函数</h2><ol>
<li>重写拷贝构造函数与拷贝赋值函数为private。</li>
<li>为了防止类成员函数和friend函数调用，可以定义一个base类，在base类中设置private，派生类中将不会自动生成这两个函数。</li>
</ol>
<h2 id="12-memset-this-0-sizeof-this"><a href="#12-memset-this-0-sizeof-this" class="headerlink" title="12. memset(this,0,sizeof(*this))"></a>12. memset(this,0,sizeof(*this))</h2><ul>
<li>类含有虚函数表，会将虚函数表指针置为0</li>
<li>类含有C++类型对象，会破坏初始化结果</li>
</ul>
<h2 id="13-友元"><a href="#13-友元" class="headerlink" title="13. 友元"></a>13. 友元</h2><ol>
<li>友元关系不能被继承</li>
<li>友元关系单向、不可传递</li>
</ol>
<h2 id="14-类的内存空间"><a href="#14-类的内存空间" class="headerlink" title="14. 类的内存空间"></a>14. 类的内存空间</h2><p>一般的：由下列三项加和</p>
<ul>
<li>非静态成员的数据类型大小之和</li>
<li>编译器加入的额外成员变量，如指向虚函数表的指针</li>
<li>为了边缘对齐优化加入的padding</li>
</ul>
<p>特殊的：</p>
<ul>
<li>空类对象size为1，为了让对象的实例化能相互区别</li>
<li>作为基类时size为0</li>
</ul>
<h2 id="15-this指针"><a href="#15-this指针" class="headerlink" title="15. this指针"></a>15. this指针</h2><h3 id="1-创建时刻"><a href="#1-创建时刻" class="headerlink" title="1. 创建时刻"></a>1. 创建时刻</h3><p>在成员函数开始执行前构造，执行结束后清除。</p>
<h3 id="2-存放位置"><a href="#2-存放位置" class="headerlink" title="2. 存放位置"></a>2. 存放位置</h3><p>因编译器不同存放位置不同，栈、寄存器或全局变量。</p>
<h3 id="3-传递方式"><a href="#3-传递方式" class="headerlink" title="3. 传递方式"></a>3. 传递方式</h3><p>大部分指针通过ecx寄数寄存器传递this指针。</p>
<p>在call之前通过函数参数的首参传递。</p>
<h2 id="16-成员函数中delete-this"><a href="#16-成员函数中delete-this" class="headerlink" title="16. 成员函数中delete this"></a>16. 成员函数中delete this</h2><p>对象必须是通过new创建的，否则调用delete this会直接报告invalid pointer。</p>
<p>在成员函数中delete this，在之后进行的任何函数调用，不能访问该对象任何成员变量、虚函数与this指针，否则会出现不可预期的问题：内存空间并不是马上被回收到系统中，此时可以访问，但是其中的值不确定，所以不可预期。</p>
<p>如果在析构函数中调用，则会导致堆栈溢出，因为delete函数本身就要调用析构函数。</p>
<h2 id="17-多态与虚函数"><a href="#17-多态与虚函数" class="headerlink" title="17. 多态与虚函数"></a>17. 多态与虚函数</h2><h3 id="1-多态"><a href="#1-多态" class="headerlink" title="1. 多态"></a>1. 多态</h3><p>编译时多态：重载。名字相同，参数数目和类型不同的函数，编译时根据参数的类型、数目确定调用的方法。</p>
<p>运行时多态：重写。在派生类中重写基类的虚函数，运行时会根据指针指向对象的实际类型调用相应的函数。</p>
<h3 id="2-虚函数实现原理"><a href="#2-虚函数实现原理" class="headerlink" title="2. 虚函数实现原理"></a>2. 虚函数实现原理</h3><p>this-&gt;vptr-&gt;vtable-&gt;vfunction（所以静态函数不能为虚函数，因为没有this指针）</p>
<ul>
<li>类中含有virtual关键字修饰的方法时，编译器自动生成虚表，保存<strong>类的类型信息</strong>与各个虚函数的入口地址（<strong>一个类对应一个虚表</strong>）。对象地址的前四个字节存储指向虚表的指针。</li>
<li>编译期派生类构造虚表时：<ul>
<li>先将基类虚表拷贝到自己的虚表对应位置中</li>
<li>如果自己实现了从基类继承的虚函数，则用自己的函数地址覆盖虚表中基类的函数地址</li>
<li>如果自己定义了新的虚函数，就放在虚表新的位置</li>
<li>编译器再将虚函数调用转换为虚表对应函数的项的调用（编译器并不知道具体是哪个函数）</li>
</ul>
</li>
<li>基类指针赋值子类对象时，基类虚表指针被子类对象的虚表指针覆盖，所以查虚表查到的是子类的对应实现。</li>
</ul>
<p>C++中虚函数表位于只读数据段。</p>
<p>虚表指针初始化在基类成员构造函数调用之后，成员初始化列表之前。</p>
<h3 id="3-特殊函数能否为虚函数？"><a href="#3-特殊函数能否为虚函数？" class="headerlink" title="3. 特殊函数能否为虚函数？"></a>3. 特殊函数能否为虚函数？</h3><p>析构函数：一般写成虚函数，因为派生类中可能有基类不存在的成员变量，如果不写成虚函数，删除基类指针时只会调用基类的析构函数，只释放基类所用的内存，造成内存泄露。但是，CRTP模板除外。</p>
<p>inline、static、constructor都不能是虚函数。</p>
<p>inline必须在编译时展开，而虚函数在运行时才能确定调用的是哪个函数。虚函数不表现多态时，可以inline。</p>
<p>static函数没有this指针，虚函数必须要通过对象来调用。</p>
<p>构造函数：不能是虚函数，因为</p>
<ul>
<li>对象不初始化就没有指向虚函数表的指针。</li>
<li>虚函数在运行时动态确定类型，而在构造对象时对象还未创建成功，编译器无法知道其实际类型。</li>
</ul>
<p>也不应该在构造函数中调用虚函数，因为基类的构造函数期间将虚表指针指向基类的虚表，实际还是调用的基类的虚函数。</p>
<h3 id="4-虚函数开销"><a href="#4-虚函数开销" class="headerlink" title="4. 虚函数开销"></a>4. 虚函数开销</h3><p>空间：</p>
<ul>
<li>类开头多了4字节的虚函数表指针。</li>
<li>堆开辟虚函数表。</li>
</ul>
<p>时间：访问虚函数时多一次内存寻址。</p>
<p>本质：直接调用与间接调用的区别。直接调用的跳转地址由编译器确定，间接调用则是运行到该指令时，从寄存器取出地址跳转。</p>
<p>直接调用不存在分支跳转，CPU直接去跳转地址去指令即可，不存在分支预测，可保证CPU流水线不被打断。</p>
<p>间接调用跳转地址不确定，所以可能有多个分支可能，需要分支预测器进行预测，预测失败会导致流水线冲刷，重新取指、译码，影响程序性能。</p>
<h2 id="18-CRTP模板"><a href="#18-CRTP模板" class="headerlink" title="18. CRTP模板"></a>18. CRTP模板</h2><p>表现：</p>
<ul>
<li>基类是模板类</li>
<li>派生类继承基类时，将自身作为模板参数传递给基类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T&amp; derived = <span class="keyword">static_cast</span>&lt;T&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;Derived&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; Derived class &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>static_cast从基类到派生类的转换本来是不安全的，但是CRTP的设计原则就是假设Derived会继承于Base。</p>
<p>在实际使用时，只使用Derived的对象，而不会直接用Base&lt; Derive &gt; 定义对象，这保证了static_cast执行时，基类指针一定指向一个子类对象。</p>
<p>优点：省去动态绑定、查询虚函数表带来的开销。</p>
<p>缺点：模板影响代码可读性。</p>
<p>用途：</p>
<ul>
<li>“静态多态”/静态分发：每个派生类继承的基类随模板参数不同而不同，也就是不是同一个基类，并不是严格的多态。</li>
<li>每个子类的计数器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> t = <span class="keyword">static_cast</span>&lt;T *&gt;(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            t-&gt;op();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span> :</span> <span class="keyword">public</span> Base&lt;Derived1&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived1() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived1::op()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> :</span> <span class="keyword">public</span> Base&lt;Derived2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived2() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">op</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived2::op()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 辅助函数：完成静态分发</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DerivedClass&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helperFunc</span><span class="params">(Base&lt;DerivedClass&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">    d.func();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span>&#123;</span><br><span class="line">    Derived1 d1;</span><br><span class="line">    Derived2 d2;</span><br><span class="line">    helperFunc(d1);</span><br><span class="line">    helperFunc(d2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-模板特例化"><a href="#19-模板特例化" class="headerlink" title="19. 模板特例化"></a>19. 模板特例化</h2><p>template后加空尖括号，本质仍然是一个模板，按照最优匹配原则匹配。</p>
<p>类可以偏特化，函数必须全部。</p>
<p>偏特化：不一定只是对其中部分参数指定某个具体值，也可以是针对任何参数更进一步的条件限制的特化版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;</span>T*&gt; &#123;...&#125;; <span class="comment">// 仅适用于“T为原生指针”的情况</span></span><br></pre></td></tr></table></figure>
<h2 id="20-多继承与虚拟继承"><a href="#20-多继承与虚拟继承" class="headerlink" title="20. 多继承与虚拟继承"></a>20. 多继承与虚拟继承</h2><p>多继承即一个派生类指定多个基类，这样可以使一个派生类调用多个基类中的接口，但是如果出现菱形继承，派生类调用公共祖先类的接口时会出现二义性。</p>
<p>菱形继承关系中出现，无论基类被继承多少次，只会出现一个实体。子类会增加某种形式的指针，指向虚基类的子对象或一个相关的表格，其中存放虚基类的子对象地址或偏移量。</p>
<p><strong>虚继承的子类有一个虚类指针，占4字节。而且派生类会继承基类的指针，而不像虚函数一样共享一个。</strong></p>
<p>（虚继承还有另一种编译器的实现方式，就是放在vtable中）</p>
<h2 id="21-自动生成默认构造函数"><a href="#21-自动生成默认构造函数" class="headerlink" title="21. 自动生成默认构造函数"></a>21. 自动生成默认构造函数</h2><ol>
<li>带有默认构造函数的类成员对象</li>
<li>带有默认构造函数的基类</li>
<li>带有虚函数</li>
<li>带有虚基类</li>
</ol>
<p>并不是任何没有构造函数的类都会自动生成。</p>
<p>生成的默认构造函数中，只有基类子对象和成员类对象会被初始化。</p>
<h2 id="22-抽象基类"><a href="#22-抽象基类" class="headerlink" title="22. 抽象基类"></a>22. 抽象基类</h2><p>定义：带有纯虚函数的类（虚函数定义后加=0）。</p>
<p>作用：只能作为基类使用，不能定义对象。其纯虚函数的实现由派生类给出，如果派生类没有实现，那就仍然作为抽象类。用于定义派生类的通用接口，并强迫派生类实现这些接口（否则就不能实例化）。</p>
<p>很多情况下，基类本身是一个抽象概念，其生成对象是不合理的，比如图形与圆、三角。但是又需要抽象出这些图形的一些通用方法。</p>
<h2 id="23-自动生成拷贝构造函数"><a href="#23-自动生成拷贝构造函数" class="headerlink" title="23. 自动生成拷贝构造函数"></a>23. 自动生成拷贝构造函数</h2><ol>
<li>用到了<ol>
<li>对一个对象做显式初始化操作</li>
<li>对象作为参数、返回值传递</li>
</ol>
</li>
<li>带有有拷贝构造函数的类成员变量</li>
<li>带有有拷贝构造函数的基类</li>
<li>带有虚函数、虚基类</li>
</ol>
<h2 id="24-取类成员偏移"><a href="#24-取类成员偏移" class="headerlink" title="24. 取类成员偏移"></a>24. 取类成员偏移</h2><p>&amp;类名::成员，取到相对于类基址的偏移（而不是取其地址）</p>
<h1 id="4-C-11"><a href="#4-C-11" class="headerlink" title="4. C++ 11"></a>4. C++ 11</h1><h2 id="1-auto与decltype"><a href="#1-auto与decltype" class="headerlink" title="1. auto与decltype"></a>1. auto与decltype</h2><h3 id="1-auto"><a href="#1-auto" class="headerlink" title="1. auto"></a>1. auto</h3><p>让编译器通过初始值进行类型推演，获得定义类型的变量。</p>
<ul>
<li>必须初始化</li>
<li>二义性：一行定义多个变量时，各个变量不能推导出不同auto结果，否则编译失败</li>
<li>限制：不能用作函数参数、非静态成员变量、数组定义、模板参数</li>
<li>cv限制符：在不声明为引用或指针时，auto忽略等号右边的引用类型和const/volatile；否则保留。</li>
</ul>
<h3 id="2-decltype"><a href="#2-decltype" class="headerlink" title="2. decltype"></a>2. decltype</h3><p>选择并返回操作数的数据类型，编译器只分析表达式并得到其类型，而不实际计算。</p>
<p>decltype(exp)规则：根据exp决定</p>
<ul>
<li>不被括号包围的表达式/类成员访问表达式/变量：与exp类型一致。</li>
<li>函数调用：与返回值类型一致</li>
<li>左值/被括号包围：exp类型引用</li>
<li>cv限制符：会传递const、volatile、引用，指针解引用会返回引用类型。</li>
</ul>
<p>decltype(auto)：C++14新增。声明变量以及指示函数返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u) &#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-左值右值"><a href="#2-左值右值" class="headerlink" title="2. 左值右值"></a>2. 左值右值</h2><p>左值：可以放到等号左边，可以取地址并且有名字</p>
<ul>
<li>函数名、变量名</li>
<li>返回左值引用的函数调用</li>
<li>前置自增自减表达式</li>
<li>由赋值表达式或赋值运算符连接的表达式，a=b、a+=b等</li>
<li>解引用表达式*p</li>
<li>字符串字面量”abcd”（存在常量段，可以取地址）</li>
</ul>
<p>右值：不能放到等号左边，不能取地址且没有名字</p>
<ul>
<li>纯右值prvalue：<ul>
<li>除字符串外的字面值</li>
<li>返回非引用类型的函数引用</li>
<li>后置自增自减表达式（因为实现是先用临时值存储，然后自增，然后返回临时值）</li>
<li>算术表达式</li>
<li>取地址表达式</li>
</ul>
</li>
<li>将亡值xrvalue：<ul>
<li>将要被移动的对象</li>
<li>T&amp;&amp;函数返回值</li>
<li>move函数返回值</li>
<li>转换为T&amp;&amp;类型转换函数的返回值</li>
</ul>
</li>
</ul>
<p>区分方式：能否初始化一个左值引用。</p>
<p>右值引用出现的意义：</p>
<ul>
<li>高效传入函数参数，避免频繁使用拷贝构造函数降低效率。</li>
<li>转移将亡对象申请的资源，避免资源频繁申请与释放。</li>
</ul>
<p>左值可通过move转化为右值。</p>
<p>右值在一系列参数为右值的函数中被传递时，会因为其被右值引用绑定，变为左值。</p>
<p>在成员函数后加&amp;或&amp;&amp;，可以限定其只能被左值/右值对象调用。</p>
<p>类型和值类别：</p>
<ul>
<li>类型指数据类型</li>
<li>值类别指lvalue、rvalue，rvalue可分为prvalue、xrvalue。</li>
</ul>
<h3 id="1-移动语义"><a href="#1-移动语义" class="headerlink" title="1. 移动语义"></a>1. 移动语义</h3><p>转让资源，通过移动构造函数（move）实现，仅对于实现了移动构造函数的类有作用。</p>
<p>move源码：简单来说，通过remove_reference&lt;T&gt;移除所有引用，然后加上右值引用后强制转换。</p>
<p>remove_reference&lt;T&gt;：对普通类型、左值引用、右值引用分别特化</p>
<h3 id="2-完美转发"><a href="#2-完美转发" class="headerlink" title="2. 完美转发"></a>2. 完美转发</h3><p>写一个接收任意实参的函数模板，并转发到其他函数，目标函数会收到与转发函数完全相同的实参。在定义函数模板时使用右值引用做参数，能保证参数的const属性和值类型不发生变化。</p>
<p>完美转发=forward+万能引用+引用折叠。</p>
<p>万能引用：模板 + T&amp;&amp;，会将传进来的左值推导成左值引用，右值推导成右值引用。</p>
<p>forward 规则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"> <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line"> forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line"> &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，传参时通过remove_reference&lt;T&gt;加上&amp;变成左值，然后强制转换成传入的类型加两个&amp;&amp;。（引用不会变，而常量会变为右值引用）</p>
<ul>
<li>碰到右值int &amp;&amp;，T匹配成int</li>
<li>碰到左值int，T匹配成int&amp;</li>
<li>碰到左值const int，T匹配成const int &amp;</li>
<li>碰到左值const int *，T匹配成const int *&amp;</li>
<li>碰到左值cosnt int* const，T匹配成const int *const &amp;</li>
</ul>
<p>完美转发一般的模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line">	print(<span class="built_in">std</span>::forward&lt;T&gt;(v)); <span class="comment">// print有T&amp;与T&amp;&amp;两个重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-bind和function"><a href="#3-bind和function" class="headerlink" title="3. bind和function"></a>3. bind和function</h2><p>bind：将可调用对象和参数一起绑定，绑定结果使用function进行保存，延迟调用到任何需要的时候。还可以只绑定一部分参数，剩余参数使用placeholders(_1, _2, _3)表示正式调用时将第几个参数传入对应的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">std</span>::bind(f, _3, <span class="built_in">std</span>::bind(g, _3), _3, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">f2(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);  <span class="comment">// 相当于 f(12, g(12), 12, 4, 5);</span></span><br></pre></td></tr></table></figure>
<p>function：可调用对象的封装器。</p>
<p>可调用对象：</p>
<ul>
<li>函数指针</li>
<li>具有operator()成员函数的类对象（仿函数）、lambda表达式</li>
<li>可被转换成函数指针的类对象</li>
<li>类成员（函数）指针</li>
<li>bind表达式结果</li>
</ul>
<h2 id="4-智能指针"><a href="#4-智能指针" class="headerlink" title="4. 智能指针"></a>4. 智能指针</h2><p>智能指针：封装常规指针，能在销毁时自动释放指向的对象。</p>
<p><strong>代理模式+RAII思想</strong>。</p>
<p>迭代器就是一种智能指针。</p>
<h3 id="1-shared-ptr"><a href="#1-shared-ptr" class="headerlink" title="1. shared_ptr"></a>1. shared_ptr</h3><p>使用了引用计数，每一个共享指针的拷贝都指向相同内存，每次拷贝计数+1，每次析构计数-1，计数为0内存才释放。引用计数采用int*方式实现，使用了原子操作。</p>
<p>shared_ptr内部还会维护一个weak_count。只要weak_count不为0，即使shared_count为0控制块也不会释放，但此时调用weak_ptr的lock就会返回空指针。</p>
<ul>
<li>不要用一个裸指针初始化多个共享指针，会导致引用计数只有1，出现多次释放。</li>
<li>通过shared_from_this返回this指针，而不是直接作为shared_ptr返回，因为可能导致重复析构，不能把this交给智能指针管理。</li>
<li>尽量用make_shared初始化</li>
<li>不要delete get到的裸指针</li>
<li>同一个共享指针被多个线程写是不安全的。</li>
<li>避免循环引用（使用weak_ptr）</li>
</ul>
<h3 id="2-weak-ptr"><a href="#2-weak-ptr" class="headerlink" title="2. weak_ptr"></a>2. weak_ptr</h3><p>作为旁观者监视shared_ptr中管理的资源是否存在。</p>
<ul>
<li>只读</li>
<li>指向的资源不一定是可用的</li>
<li>使用前需要用lock()/expired()检查是否为空。</li>
</ul>
<p>shared_from_this就是通过weak_ptr返回的this指针。</p>
<p>解决循环引用问题。</p>
<p>应用：消息订阅机制；缓存对象。</p>
<h3 id="3-unique-ptr"><a href="#3-unique-ptr" class="headerlink" title="3. unique_ptr"></a>3. unique_ptr</h3><p>不允许其他智能指针共享内部指针，也不允许unique_ptr拷贝和复制，但可以拷贝与赋值一个将要被销毁的unique_ptr。可通过C++ 11的delete关键字，禁止自动生成拷贝构造函数实现。</p>
<h2 id="5-default、delete与explicit"><a href="#5-default、delete与explicit" class="headerlink" title="5. default、delete与explicit"></a>5. default、delete与explicit</h2><p>default：ClassType() = default生成默认构造函数</p>
<p>delete：如果没有定义特殊成员函数，编译器在需要这些函数时会隐式自动生成，如拷贝构造函数、拷贝赋值操作符。A(const A&amp;) = delete可禁止拷贝构造。unique_ptr即通过此实现。</p>
<p>explicit：修饰构造函数，只能显式构造而不能隐式转换。</p>
<h2 id="6-constexpr"><a href="#6-constexpr" class="headerlink" title="6. constexpr"></a>6. constexpr</h2><p>修饰的表达式在编译期间就会被计算出来，整个运行过程中都不可以改变。</p>
<p>修饰变量：</p>
<ul>
<li>变量为const常量，使用常量表达式初始化。</li>
<li>修饰的变量同时也是const。</li>
</ul>
<p>constexpr定义指针只对指针有效。</p>
<p>修饰函数：</p>
<ul>
<li>函数体除了using、typedef与static_assert外，只能有一条return。</li>
<li>必须有返回值，不为void。返回值必须为常量表达式。</li>
<li>使用前必须有定义，不能用声明代替。</li>
<li>可以是递归。</li>
</ul>
<p>修饰构造函数：</p>
<ul>
<li>所有成员用初始化列表初始化，并用常量表达式赋值，函数体为空。</li>
<li>成员函数必须用constexpr修饰，对象实例化也必须为constexpr。</li>
</ul>
<p>修饰模板函数：如果模板实例化后不满足上面对函数的要求，就当作普通函数处理。</p>
<p>修饰if表达式：if的条件需要在编译期计算出来，如通过模板判断是否为T类型等。</p>
<p>与const区别：大部分情况下等价。const表示“只读”的语义，而constexpr表示“常量”的语义。</p>
<p>const只读可以通过常引用的变量修改其值。</p>
<h2 id="7-lambda表达式"><a href="#7-lambda表达式" class="headerlink" title="7. lambda表达式"></a>7. lambda表达式</h2><p>lambda表达式的方括号提供闭包功能。</p>
<p>lambda表达式实际上是一个仿函数。每定义后，编译器会自动生成一个匿名类，且重载了()运算符，称为闭包类型。运行时即为生成一个该类型的匿名对象，调用()操作符。</p>
<p>可以通过传值或引用的方式捕捉其封装作用域内的变量。值捕获为lambda表达式<strong>创建时</strong>捕获，而非调用时。可以加mutable来修改值捕获的变量，但是修改的是拷贝的，不影响外面。哪种方式都能修改全局变量。</p>
<h3 id="1-C-14-新特性"><a href="#1-C-14-新特性" class="headerlink" title="1. C++ 14 新特性"></a>1. C++ 14 新特性</h3><h4 id="1-捕捉表达式"><a href="#1-捕捉表达式" class="headerlink" title="1. 捕捉表达式"></a>1. 捕捉表达式</h4><p>方括号内可以用表达式初始化捕捉的变量。</p>
<p>该特性可以通过move捕捉到unique_ptr，因为其不允许复制，无法以值方式捕捉。</p>
<h4 id="2-泛型lambda表达式"><a href="#2-泛型lambda表达式" class="headerlink" title="2. 泛型lambda表达式"></a>2. 泛型lambda表达式</h4><p>将类型指定为auto，类型推断规则与函数模板一样。</p>
<h2 id="8-nullptr"><a href="#8-nullptr" class="headerlink" title="8. nullptr"></a>8. nullptr</h2><p>是nullptr_t类型（指针空值类型）的右值常量。不是指针类型，但可以隐式转换成任何一种指针类型。</p>
<p>作用：代替NULL。</p>
<p>NULL在重载函数的参数分别为int、char*会产生歧义，因为不知道该把NULL解析成0还是空指针。</p>
<p>但是nullptr在重载函数参数为不同类型的指针时还是会产生歧义。</p>
<p>与NULL区别：</p>
<ul>
<li>NULL是宏定义(void*)0，C++中为0，编译器优先将其当成整型常量；nullptr为编译期常量，类型为nullptr_t，不是整型也不是指针类型。</li>
<li>模板推导时NULL会被推导为整型，而nullptr被推导为原类型。</li>
<li>重载时NULL会在整型与指针型间产生歧义。</li>
</ul>
<h2 id="9-列表初始化"><a href="#9-列表初始化" class="headerlink" title="9. 列表初始化"></a>9. 列表初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;d&#125;; <span class="comment">// 存在丢失信息风险，转换未执行，编译器报错</span></span><br><span class="line"><span class="keyword">int</span> a = d; <span class="comment">// 丢失信息，转换执行</span></span><br></pre></td></tr></table></figure>
<h2 id="10-array"><a href="#10-array" class="headerlink" title="10. array"></a>10. array</h2><p>定长数组。<code>array&lt;int, 5&gt; b</code>。</p>
<p>可用{}初始化、拷贝构造，不能用内置数组[]构造。</p>
<p>提供迭代、随机访问、头尾访问、[]。</p>
<h2 id="11-多线程"><a href="#11-多线程" class="headerlink" title="11. 多线程"></a>11. 多线程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sjc_0910/article/details/118861539">参考</a></p>
<h3 id="1-thread"><a href="#1-thread" class="headerlink" title="1. thread"></a>1. thread</h3><p>代替pthread</p>
<p>方法：</p>
<ul>
<li>构造函数：默认、初始化（传入一个函数以及需要的参数）、移动。（复制构造函数为delete）</li>
<li><code>join()</code>：等待线程结束并回收资源。（不是开始线程，线程在创建时就开始执行了）</li>
<li><code>joinable()</code></li>
<li><code>detach()</code>：将线程与调用其的线程分离，彼此独立执行。（分离的线程会在调用其的线程结束或自己结束时释放资源）（只能在线程创建时调用，且让线程不能再join）</li>
<li><code>get_id()</code></li>
<li>赋值</li>
</ul>
<p>初始化构造函数为 <code>template &lt;class Fn, class… Args&gt; explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;… args)</code>，右值引用显然不能传入左值，所以要借助ref与cref方法包装，分别包装按引用传递的值、按const引用传递到值。</p>
<p>注意点：</p>
<ul>
<li>线程会在函数运行完毕后自动释放，且不推荐其他释放方式。</li>
<li>必须执行join或detach，否则程序结束会引发异常。</li>
<li>join不是开始线程，线程在创建时就开始了。</li>
</ul>
<h3 id="2-mutex"><a href="#2-mutex" class="headerlink" title="2. mutex"></a>2. mutex</h3><p>代替mutex_t。</p>
<ul>
<li><code>lock()</code></li>
<li><code>unlock()</code></li>
<li><code>try_lock()</code>（如果未被上锁，则上锁并返回true）</li>
</ul>
<p>问题：一次只有一个线程能获得锁，还需要加锁解锁，太慢了。</p>
<h3 id="3-atomic"><a href="#3-atomic" class="headerlink" title="3. atomic"></a>3. atomic</h3><p>将变量改为atomic类型，让多线程必须同步操作该对象，避免锁机制的巨大开销。</p>
<p>a++与int a = b实际上都是线程不安全的，因为会被拆分成多条汇编指令。（int a = b不能直接拷贝，必须借助寄存器中转）</p>
<p>原子操作：</p>
<ul>
<li><code>load(val, order)</code>：读取值<ul>
<li>order：memory_order_relaxed/memory_order_consume/memory_order_acquire/memory_order_seq_cst</li>
</ul>
</li>
<li><code>store(val, order)</code>：存储值。<ul>
<li>order：memory_order_relaxed/memory_order_release/memory_order_seq_cst</li>
</ul>
</li>
</ul>
<p>不能通过atomic&lt;int&gt; v = 99初始化，因为拷贝构造函数通过delete禁止生成。（有初始化构造函数）</p>
<p>原理</p>
<ul>
<li>锁总线。其他cpu无法通过总线读写。</li>
<li>锁cache。（MESI）执行操作的CPU将自身cache里的原子变量设为独占，并lock；其他cpu将原子变量所在缓存无效。cpu修改完后，unlock。</li>
</ul>
<h3 id="4-async"><a href="#4-async" class="headerlink" title="4. async"></a>4. async</h3><p>定义在future头文件中，是个函数，返回值为future类型。相较于thread，可根据情况同步执行或创建新线程异步执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fn</span>, <span class="keyword">class</span>… <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="built_in">future</span>&lt;<span class="keyword">typename</span> result_of&lt;Fn(Args…)&gt;::type&gt;</span><br><span class="line">    async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;… args);</span><br></pre></td></tr></table></figure>
<p>policy：</p>
<ul>
<li>launch::async(0x1)：异步启动</li>
<li>launch::deferred(0x2)：调用future::get、future::wait时同步启动。实际上不创建线程，而是在本线程中运行。</li>
<li>launch::async | launch::deferred(0x3)：根据操作系统而定。系统资源紧张时会用同步启动。</li>
</ul>
<p>第一个参数也可省略，默认为0x3。</p>
<h3 id="5-future"><a href="#5-future" class="headerlink" title="5. future"></a>5. future</h3><p>定义 <code>future&lt;T&gt;</code>类型的对象val接收async的返回值（T为async传入函数的返回值类型），然后调用val.get()阻塞等待线程结束，并获取其返回值。</p>
<p>future对象没有复制构造函数。</p>
<p>成员函数：</p>
<ul>
<li><code>T get()</code>：阻塞等待线程结束并获取返回值。</li>
<li>类型为引用： <code>R&amp; future&lt;R&amp;&gt;::get()</code>：若类型为void，与wait相同。</li>
<li>类型为void：<code>void future::get()</code>：只能调用一次。特化void的原因：future作用不只有获取返回值，还可以检测线程是否已结束、阻塞等待。</li>
<li><code>void wait() const</code>：阻塞等待线程结束。</li>
<li><code>template &lt;class Rep, class Period&gt; future_status wait_for(const chrono::duration&lt;Rep,Period&gt;&amp; rel_time) const;</code>：阻塞等待rel_time，如果这段时间内线程结束，返回 <code>future_status::ready</code>，否则返回 <code>future_status::timeout</code>；如果async以 <code>launch::deferred</code>启动，不阻塞立即返回 <code>future_status::deferred</code>。</li>
</ul>
<h3 id="6-promise"><a href="#6-promise" class="headerlink" title="6. promise"></a>6. promise</h3><p>获得thread的返回值。实际上是作为引用参数，通过引用返回值。</p>
<p>promise是future的一个包装，不改变已有future的值，而是创建新的future对象。</p>
<p>同样没有复制构造函数。</p>
<p>成员函数：</p>
<ul>
<li><code>set_value</code>：与future的特化差不多。设置promise的值并设置 <code>future_status::ready</code>。void特化：只讲共享状态设置为ready。</li>
<li><code>get_future()</code>：重新构造一个future对象，值和状态都与promise相同。</li>
</ul>
<p>然后，将其作为函数的一个参数引用传递，线程运行完后通过 <code>val.get_future().get()</code>获得返回值。</p>
<h3 id="7-this-thread"><a href="#7-this-thread" class="headerlink" title="7. this_thread"></a>7. this_thread</h3><p>一个命名空间。通过 <code>this_thread::func()</code>调用。</p>
<p>函数：</p>
<ul>
<li><code>get_id()</code></li>
<li><code>template&lt;class Rep, class Period&gt; void sleep_for( const std::chrono::duration&lt;Rep, Period&gt;&amp; sleep_duration)</code>：等待sleep_duration这段时间，如 <code>chrono::seconds(1)</code></li>
<li><code>void yield() noexcept</code>：暂时放弃线程执行，将主动权交出。</li>
</ul>
<h3 id="8-lock-guard"><a href="#8-lock-guard" class="headerlink" title="8. lock_guard"></a>8. lock_guard</h3><p>mutex封装类。</p>
<p>当对象被创建后，就会尝试获得给到他的mutex的所有权。当控制权不在该对象被创建的范围后，对象被析构，mutex被释放。</p>
<p>可带第二个参数：</p>
<ul>
<li>adopt_lock：该互斥量已被lock。假设一方已经lock成功，就通知lock_guard不需要再在构造函数中lock mutex，用这个参数的前提是自己需要先lock mutex。</li>
<li>try_to_lock：尝试lock mutex，没成功则立即返回，用这个参数的前提是自己不能先lock。</li>
<li>defer_lock：初始化一个没加锁的mutex。用这个参数的前提是不能自己先lock，否则报异常。</li>
</ul>
<h3 id="9-unique-lock"><a href="#9-unique-lock" class="headerlink" title="9. unique_lock"></a>9. unique_lock</h3><p>与lock_guard的区别：可以中途用unlock解锁，如果析构时发现已经解锁则没有操作。lock_guard只能在析构时解锁。</p>
<p>需要额外存储锁的状态，效率稍差。</p>
<h3 id="10-condition-variable"><a href="#10-condition-variable" class="headerlink" title="10. condition_variable"></a>10. condition_variable</h3><p>condition_variable：有默认构造函数，拷贝构造函数被删除。</p>
<p>方法：</p>
<ul>
<li><code>wait(unique_lock)</code>：阻塞。</li>
<li><code>wait(unique_lock, lambda)</code>：lambda表达式返回false时阻塞。</li>
<li><code>wait_for(unique_lock, chrono::time_point)</code>：阻塞一段时间。</li>
<li><code>wait_for(unique_lock, chrono::time_point, lambda)</code>：lambda返回false时阻塞一段时间。</li>
<li><code>notify_one()</code>：唤醒第一个阻塞在条件变量上的线程。</li>
<li><code>notify_all()</code>：唤醒所有。</li>
</ul>
<p>虚假唤醒/惊群现象：多个线程被唤醒，但是条件只支持一个线程运行。</p>
<p>condition_variable_any：可以和任何满足条件的互斥量一起工作，会产生额外开销。</p>
<h2 id="12-可变参数模板"><a href="#12-可变参数模板" class="headerlink" title="12. 可变参数模板"></a>12. 可变参数模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vair_fun</span><span class="params">(T...args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解包方式：</p>
<p>递归：必须要设置一个出口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vir_fun</span><span class="params">()</span> </span>&#123; <span class="comment">// 模板函数递归的出口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vir_fun</span><span class="params">(T argc, args... argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; argc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    vir_fun(argv...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vir_fun(<span class="number">1</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>, <span class="number">2.34</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非递归：第7行对每个参数展开为 <code>(display(arg), 0)</code>，意思是先计算display(arg)，然后将0作为表达式的值返回给数组。arr只是为了将参数展开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vir_fun</span><span class="params">(args... argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; (display(argv), <span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vir_fun(<span class="number">1</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>, <span class="number">2.34</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="13-align"><a href="#13-align" class="headerlink" title="13. align"></a>13. align</h2><h3 id="1-alignof"><a href="#1-alignof" class="headerlink" title="1. alignof"></a>1. alignof</h3><p>返回指定类型的对齐方式</p>
<ul>
<li>对基础类型：与sizeof用法相同</li>
<li>对类：返回其对齐方式</li>
</ul>
<h3 id="2-alignas"><a href="#2-alignas" class="headerlink" title="2. alignas"></a>2. alignas</h3><p>用在struct关键字后面或基本类型数组前面，跟#pragma pack(n)作用相同，约束也一样</p>
<ul>
<li>偏移量为n和当前变量大小较小值的整数倍。</li>
<li>结构体大小为n和最大变量大小较小值的整数倍。</li>
<li>n必须为2的幂，为其他值则语句失效。</li>
</ul>
<h3 id="3-align-storage"><a href="#3-align-storage" class="headerlink" title="3. align_storage"></a>3. align_storage</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="built_in">std</span>::<span class="keyword">size_t</span> Len, <span class="built_in">std</span>::<span class="keyword">size_t</span> Align = <span class="comment">/*default-alignment*/</span> &gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">aligned_storage_t</span> = <span class="keyword">typename</span> aligned_storage&lt;Len, Align&gt;::type;</span><br></pre></td></tr></table></figure>
<p>提供对齐存储</p>
<h3 id="4-align"><a href="#4-align" class="headerlink" title="4. align"></a>4. align</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param  alignment 是想要分配的内存符合的内存对齐大小</span></span><br><span class="line"><span class="comment">/// @param  size 想要分配内存的大小</span></span><br><span class="line"><span class="comment">/// @param  ptr 是个输入输出参数，输入时指向待使用的内存，输出时调整为符合alignment对齐要求的内存地址</span></span><br><span class="line"><span class="comment">/// @param  space 是ptr指向的内存剩余的空间</span></span><br><span class="line"><span class="comment">/// @return 如果 ptr 经过调整后能满足大小为 alignment 的对齐要求，则返回ptr的值，否则返回 nullptr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">align</span><span class="params">( <span class="built_in">std</span>::<span class="keyword">size_t</span> alignment,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::<span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span>*&amp; ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::<span class="keyword">size_t</span>&amp; space)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一般用在分配buffer空间中。</p>
<h1 id="5-STL"><a href="#5-STL" class="headerlink" title="5. STL"></a>5. STL</h1><h2 id="1-STL标准模板库"><a href="#1-STL标准模板库" class="headerlink" title="1. STL标准模板库"></a>1. STL标准模板库</h2><p>C++ STL包括：</p>
<ul>
<li>算法：排序、复制等常用算法，以及不同容器特定的算法。</li>
<li>容器：数据的存放形式，包括序列式容器和关联式容器。<ul>
<li>序列式：以线性排列存储某一指定类型的数据。vector、deque、list。</li>
<li>关联式：在存储元素值时还会额外配备一个键，可直接通过键值找到目标元素。set、map。</li>
</ul>
</li>
<li>迭代器：在不暴露容器内部结构的情况下对容器的遍历。提供一个遍历容器元素的接口，因此内部必须保存与容器相关联的指针，然后重载*、-&gt;、++、–等运算来遍历。</li>
<li>仿函数：类中实现operator()，从而使该类的使用看上去像一个函数。</li>
<li>适配器：使一种事物的行为类似于另外一种事物行为的机制。迭代器适配器、函数适配器、容器适配器。queue、priority_queue、stack。其所有操作围绕类里的Sequence底层容器实现，stack、queue默认为deque，priority_queue默认为vector，通过封装<strong>heap系列算法</strong>实现。其元素进出必须符合一定规则，所以没有迭代器。</li>
<li>分配器：allocator空间管理。</li>
</ul>
<p>交互关系：</p>
<ul>
<li>容器通过分配器取得数据存储空间。</li>
<li>算法通过迭代器存储容器的内容。</li>
<li>仿函数协助算法完成不同的策略变化。</li>
<li>适配器可修饰容器、仿函数。</li>
</ul>
<p>特点：</p>
<ul>
<li>数据结构和算法分离，迭代器充当两者交互的中间件，如 <code>sort(arr.begin(), arr.end(), greater&lt;int&gt;)</code>。</li>
<li>高可复用性：不面向对象。为了具有足够通用性，STL主要依赖模板。</li>
<li>高性能。</li>
<li>高移植性：用STL编写的模块可跨项目移植。</li>
</ul>
<h2 id="2-内存配置器与内存池"><a href="#2-内存配置器与内存池" class="headerlink" title="2. 内存配置器与内存池"></a>2. 内存配置器与内存池</h2><p>new、malloc等申请内存的问题在于，由于每次申请的大小不定，频繁使用时会造成大量内存碎片降低性能。</p>
<p>内存池在真正使用内存之前，先申请分配一定数量、大小相等的内存块备用。有新的内存需求时就分出一部分内存块。</p>
<p>STL内存池使用双层级配置器。<strong>通过宏指定默认</strong>为第一级配置器还是第二级配置器。</p>
<p>第一级配置器只对malloc进行了一层封装，还是有碎片化问题。大内存块（大于128bytes）使用第一级配置器。</p>
<ul>
<li>allocate（封装的malloc，如果调用不成功则调用oom_malloc）与realloc（封装realloc，不成功则调用oom_realloc）分配内存，成功直接返回，失败调用处理函数</li>
<li>如果用户自定义了分配错误处理函数_malloc_alloc_oom_handler就调用，否则返回异常</li>
<li>如果处理函数处理完了，就再分配试试</li>
</ul>
<p>第二级配置器内置了轻量级内存池。对于小内存块申请，从空闲链表与内存池中分配。对于大内存块申请，移交第一级配置器。</p>
<p>用数组维护16条链表，最小8字节且以8字节逐渐递增，最大128字节。</p>
<ul>
<li>传入需要的内存字节数后，将所需内存大小上调至8倍数边界，找到对应的节点，查看是否为空，如果不为空则直接从对应的free_list中拔出，将拔出的指针后移一位。</li>
<li>如果free_list为空，调用refill，逻辑为：先看其内存池是否为空，如果不为空<ul>
<li>先调用chunk_alloc尝试拿20块内存（所需内存大小（上调后）*20），足够拿20个则其中一个分配给用户，另外19个挂在相应的free_list下。</li>
<li>如果不够20个节点大小，查看是否满足1个节点大小，如果足够则直接拿出一个给用户，剩下的空间分配尽可能多节点挂在相应的free_list下。</li>
<li>如果1个节点都不够，直接将剩余空间挂在free_list下（先查找到相应的），然后malloc给内存池申请内存，继续。</li>
</ul>
</li>
<li>内存池申请：chunk_alloc<ul>
<li>内存池为空且申请了内存，第二级配置器使用malloc从heap上申请内存，一次申请2 * 所需节点内存大小 * 20 + 一段额外空间，申请40块，一半拿来用（19+1），一半放内存池中。</li>
<li>malloc没成功，从<strong>比所需节点空间大的free_list</strong>中搜索，从中拔出一个节点用。</li>
<li>还是没成功，调用第一级配置器，期望获得内存分配给内存池。（第一级配置器有oom处理机制，将分配失败丢给第一级配置器处理）</li>
<li>如果没有因为异常终止，则在return时递归调用自己，再次尝试分配。</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>空间只能为8字节的倍数，引入内部碎片问题。</li>
<li>自由链表上的空间在进程结束前不会还给操作系统，如果不断开辟小块内存，最后整个堆的空间都会被挂在链表上，导致开辟大块内存失败；别的进程申请不到空间，也不能用当前进程的空闲内存，从而引发问题。</li>
</ul>
<h2 id="3-deque"><a href="#3-deque" class="headerlink" title="3. deque"></a>3. deque</h2><p>deque是容器而不是适配器。</p>
<p>deque的底层结构比vector复杂得多，是多段连续的内存空间，这些空间通过map管理，对外保持整体连续的假象。</p>
<p>map中每一个value都是指向一片连续空间的指针，称为缓存区，用来真正存储数据。</p>
<p>deque还维护了start与finish两个迭代器，分别表示begin与end。迭代器内部维护这块连续空间的开头与结尾，以及这块空间大小。初始指向申请空间的中心，为了留出两边插入元素的空间按。</p>
<p>与vector的差别：</p>
<ul>
<li>deque允许常数时间对头部增删元素</li>
<li>deque没有capacity的概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间连接起来。这些空间用一块map管理。</li>
</ul>
<p>使用场景：既需要头尾两端插入元素，又需要随机存取功能。（但是deque随机存取效率低，因为可能存在空间之间的跳跃）</p>
<h2 id="4-hashtable"><a href="#4-hashtable" class="headerlink" title="4. hashtable"></a>4. hashtable</h2><p>STL中的hashtable使用开链法解决冲突问题。其他解决方式还有线性探测、二次探测、再散列、公共溢出区。</p>
<p>即散列相同的数据存储在一个桶里，桶用其自己定义的hashtable_node组成的链表维护，桶本身用vector进行存储。</p>
<p>其内置了28个质数，如果hashtable内元素数目超过了当前选择的质数，就找出下一个比当前数目大的质数，重建table。</p>
<h2 id="5-type-traits类型萃取"><a href="#5-type-traits类型萃取" class="headerlink" title="5. type traits类型萃取"></a>5. type traits类型萃取</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/547313994">类型萃取</a></p>
<p>作用：提供编译器的计算、判断、转换、查询功能，与编译器的true/false。避免运行时再判断，提高程序效率。</p>
<p>利用类模板偏特化，如果匹配到偏特化类模板，就匹配到true_type的子类，否则匹配到一般类模板，false_type的子类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> <span class="title">v</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">integral_constant</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> T value = v; </span><br><span class="line">  <span class="comment">// static和constexpr缺一不可，表示在编译器确定 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> b&gt;</span><br><span class="line"><span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="keyword">bool</span>,b&gt;; </span><br><span class="line"><span class="comment">// using代替typedef，c++11特性</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> bool_constant&lt;<span class="literal">true</span>&gt; true_type; <span class="comment">// true_type中value被初始化为true，false_type中value则为false</span></span><br><span class="line"><span class="keyword">typedef</span> bool_constant&lt;<span class="literal">false</span>&gt; false_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_same</span> :</span> <span class="keyword">public</span> false_type &#123;&#125;;</span><br><span class="line"><span class="comment">// 主模板</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_same</span>&lt;</span>_Tp, _Tp&gt; : <span class="keyword">public</span> true_type &#123;&#125;; <span class="comment">// 如果T与U类型相同，即符合偏特化模板，会优先套用偏特化模板</span></span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>, <span class="title">bool</span> =</span> is_same&lt;T, U&gt;::value &gt; <span class="comment">// 默认模板参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;they are different type&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>&lt;</span>T, U, <span class="literal">true</span>&gt; &#123; <span class="comment">// 偏特化版本</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;they are same type&quot;</span>);</span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>定义内嵌型别与原生指针都有trivial的默认构造函数、拷贝构造函数、赋值操作符、析构函数且是POD类型。然后可在如分配空间后的初始化函数中，通过类似迭代器萃取advance函数那样传递调用。自定义类可自己实现特化的type traits，防止其使用默认的保守type traits。</p>
<p>一般如果class内含有指针成员且进行了动态配置，就要实现non_trivial_xxx。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_assignment;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;</span><span class="keyword">char</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_assignment;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一个应用：SFINAE（Substitution Failure Is Not An Error）替换失败并非错误特性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectX</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fallback</span> &#123;</span> <span class="keyword">int</span> X; &#125;; <span class="comment">// add member name &quot;X&quot;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> T, Fallback &#123; &#125;; <span class="comment">//多继承T和Fallback</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, U&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Check</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span> ArrayOfOne[<span class="number">1</span>];  <span class="comment">// typedef for an array of size one.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span> ArrayOfTwo[<span class="number">2</span>];  <span class="comment">// typedef for an array of size two.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayOfOne &amp; <span class="title">func</span><span class="params">(Check&lt;<span class="keyword">int</span> Fallback::*, &amp;U::X&gt; *)</span></span>; <span class="comment">// 如果T中也有X，那么由于&amp;U::X会出现二义性，func第一个重载匹配会失败，转而匹配第二个重载，导致得到ArrayOfTwo类型，即长度为2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> ArrayOfTwo &amp; <span class="title">func</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> DetectX type;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> IsMemberExist = <span class="keyword">sizeof</span>(func&lt;Derived&gt;(<span class="number">0</span>)) == <span class="number">2</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-扩容机制-reserve与resize"><a href="#6-扩容机制-reserve与resize" class="headerlink" title="6. 扩容机制 reserve与resize"></a>6. 扩容机制 reserve与resize</h2><p>以vector为例。</p>
<p>vector实际上维护三个迭代器：begin、finish（end()方法的返回值）与end_of_storage（空间的结束）。</p>
<p>size为finish - begin，capacity为end_of_storage - begin。</p>
<p>reserve改变capacity。可以预先分配一块内存，在空间未满时不糊引起重新分配，提高了效率。但是，这些内存空间可能仍不能访问，用[]访问可能越界。</p>
<p>resize改变size。</p>
<p>capacity返回容器总空间大小，size返回已用空间大小，如果两者相等说明vector目前的空间已经用完，再添加新元素会引起空间动态增长。</p>
<p>成倍扩容的原因：指数增长比线性增长快，扩充指定大小时，倍数扩容每次所需的均摊时间复杂度是常数，而等长扩容是线性。</p>
<p>选择1.5倍或2倍的原因：按照小于2倍的方式（1.5倍）扩容，多次扩容后可以重用之前开辟的空间。</p>
<p>linux按2倍方式扩容：引入伙伴系统分配内存，将整个内存区域构建成基本大小basicsize的2的幂次倍大小，向上取整取空闲分区分配。伙伴即为同一块内存分成的两块大小相等的内存，回收空间时会检查其伙伴是否空闲，如果空闲则合并这两块。</p>
<p>vs按1.5倍：堆管理系统会对释放的堆块进行合并。</p>
<h2 id="7-unordered-map与map"><a href="#7-unordered-map与map" class="headerlink" title="7. unordered_map与map"></a>7. unordered_map与map</h2><ul>
<li>底层实现：unordered_map是哈希表，map是红黑树。使用前者要求类型定义了计算哈希的函数以及重载了==，使用后者要求类型重载了&lt;。</li>
<li>有无序：前者无序存储，后者按key有序。</li>
<li>复杂度：前者能在常数复杂度内完成插入，但不稳定，极端情况下可能为线性复杂度；后者需要对数复杂度。</li>
</ul>
<h2 id="8-迭代器"><a href="#8-迭代器" class="headerlink" title="8. 迭代器"></a>8. 迭代器</h2><p>容器对应的迭代器</p>
<ul>
<li>随机访问迭代器：vector、deque</li>
<li>双向迭代器：list、(multi)set/map</li>
<li>前向迭代器：unordered_(multi)set/map、forward_list</li>
<li>无：容器适配器</li>
</ul>
<p>迭代器与萃取：详细的可以看看STL源码剖析121页</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type; <span class="comment">// 将迭代器I中的value_type萃取出来，用于函数的返回值定义等</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果I不是类成员呢，而是原生指针呢？要怎么获取value_type，也就是指针指向的值？</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>I*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> I value_type; <span class="comment">// 定义原生指针的偏特化模板，只有指针能匹配到这个模板</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果传入的是const该怎么匹配</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> I*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> I value_type; <span class="comment">// 定义原生指针的偏特化模板，只有指针能匹配到这个模板</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> iterator_traits&lt;I&gt; <span class="title">func</span><span class="params">(I iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *iter; <span class="comment">// I为迭代器，重载了*方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果迭代器要想使用STL算法，就应该这提供五个内嵌型别。自定义迭代器可继承iterator</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Category, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Distance = <span class="keyword">ptrdiff_t</span>, <span class="keyword">typename</span> Pointer = T*, <span class="keyword">typename</span> Reference = T&amp;&gt;</span><br><span class="line">struct iterator  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> Category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Distance difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> Pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;; <span class="comment">// 一般的迭代器应该提供的型别，后三种有默认值</span></span><br><span class="line"><span class="comment">// 编写自定义迭代器，可继承iterator类，传入迭代策略Category与存储的数据类型T，然后重载相应方法即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type; <span class="comment">// 计算两个迭代器的距离</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对原生指针的特化（const懒得写了）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>I*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> I value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> I* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> I&amp; reference; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>iterator_category：</p>
<ul>
<li>input iterator：只读。支持==、!=、++、*、-&gt;</li>
<li>output iterator：只写。支持++、*</li>
<li>forward iterator：允许写入型算法在这种迭代器形成的区间上进行读写操作。支持input/output。</li>
<li>bidirectional iterator：可双向移动。支持forward与-操作。</li>
<li>random access iterator：支持bidirectional，并允许随机移动，比如p+n/p-n/p[n]/p1-p2/p1&lt;p2</li>
</ul>
<p>强化关系：1、2 &lt; 3 &lt; 4 &lt; 5，较弱的迭代策略形参一定能接收较强的迭代策略实参，类似于父子类。</p>
<p>作用：advance(p, n)为将迭代器p前进n步。一般的实现方式是，通过if-else语句判断p的类型，然后根据类型调用不同的迭代策略advance函数。但是，需要运行时判断，效率低。</p>
<p>advance只需要提供两个参数，作为对外开放的接口，内部通过traits机制提取出迭代器类型，并将工作转交给__advance完成。原生指针通过traits机制获得random_access_iterator_tag作为迭代策略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> &#123;</span>&#125;: <span class="keyword">public</span> input_iterator_tag;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span>:</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span>:</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span>&#123; <span class="comment">// 命名为InputIterator：按照能支持的最底层的迭代器命名，因为能支持该种迭代器，说明一定能支持比其更高层的</span></span><br><span class="line">    __advance(i, n, iterator_traits&lt;I&gt;::iterator_category());<span class="comment">// 第三个参数产生一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(InputIterator&amp; i, Distance n, input_iterator_tag) &#123; <span class="comment">// 不需要第三个参数，只是拿来区分重载，所以不用命名</span></span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(RandomAccessIterator i, Distance n, random_access_iterator_tag) &#123;</span><br><span class="line">    i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SGI STL还提供了函数决定迭代器的内嵌型别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">telmpate &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category <span class="title">iteratory_category</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</span><br><span class="line">    <span class="keyword">return</span> category();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> itrator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-迭代器失效"><a href="#9-迭代器失效" class="headerlink" title="9. 迭代器失效"></a>9. 迭代器失效</h2><p>顺序容器/序列式容器（vector、deque）、连续空间的容器：</p>
<p>erase会使被删除元素与之后的迭代器都失效，所以不能用 <code>erase(i++)</code>；erase会返回删除元素的下一个元素的迭代器，应用 <code>i = erase(i)</code></p>
<p>关联容器（map、set）、基于节点的容器：</p>
<p>erase只使删除元素的迭代器失效，但是返回void，所以通过 <code>erase(i++)</code>删除</p>
<ul>
<li>vector/deque<ul>
<li>插入元素时，如果size &lt; capacity则插入元素后的所有迭代器失效，否则所有迭代器均失效（需要重新分配空间）。</li>
<li>删除元素时，删除位置后的所有迭代器失效。</li>
</ul>
</li>
<li>list：每一个节点内存不连续，删除仅当前迭代器失效，返回下一个有效迭代器。</li>
<li>map/set：底层是红黑树，同样不影响其他迭代器，mp.erase(it++)获取下一个迭代器。</li>
<li>unordered：rehash后全部失效。</li>
</ul>
<h2 id="10-list、slist"><a href="#10-list、slist" class="headerlink" title="10. list、slist"></a>10. list、slist</h2><p>list是双向链表，slist是单向链表，功能不如list但消耗空间更小、操作更快。在C++ 11中slist为forward_list。</p>
<p>list是环形链表，node节点指针始终指向尾端一个空白节点，是前闭后开的结构。</p>
<h2 id="11-uninitialized"><a href="#11-uninitialized" class="headerlink" title="11. uninitialized"></a>11. uninitialized</h2><p>将内存配置与对象构造分开。</p>
<p>uninitialized_copy：应用于容器的全区间构造函数。</p>
<p>uninitialized_fill(_n)</p>
<p>要么构造出所有必要元素，要么不构造任何东西（其中一个元素的copy construct失败）</p>
<p>会先萃取出容器元素的类型，区分是否为POD型别（Plain Old Data，标量型别或传统的struct型别，拥有trivial的构造/拷贝函数（我认为意思是可以直接为内存赋值的那种））。对于POD型别，直接copy或fill；对于非POD型别，会求保险调用construct。</p>
<h2 id="12-算法"><a href="#12-算法" class="headerlink" title="12. 算法"></a>12. 算法</h2><p>质变/非质变算法：算法在运算过程中是否会改变迭代区间内的内容。</p>
<p>很多质变算法还提供就地修改与copy修改两类。</p>
<p>根据迭代器的五种类型，算法也可以分为五类，代表它能接受的最低要求的迭代器。</p>
<h2 id="13-红黑树"><a href="#13-红黑树" class="headerlink" title="13. 红黑树"></a>13. 红黑树</h2><p>特性：</p>
<ul>
<li>节点为黑色或红色。</li>
<li>根节点为黑色，叶子节点（空节点，不是传统意义上的叶子节点）</li>
<li>如果一个节点是红色的，其子节点必定是黑色的。</li>
<li>从一个节点到其子孙节点的所有路径包含相同数目的黑节点。<strong>保证了相对平衡</strong>，不会出现二叉搜索树树的最坏情况（拉长成一条链表）</li>
</ul>
<p>删除操作：</p>
<ol>
<li>删除叶子节点（不是空节点，传统意义上的）<ol>
<li>为红色，可直接删除</li>
<li>为黑色<ol>
<li>父节点、兄弟节点、兄弟节点的子节点有红色，可通过旋转完成平衡。</li>
<li>上述三种都为黑色。将兄弟节点染红，但是子树黑高度降低了，将父节点视为当前节点，<strong>继续向上调整</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>删除只有一个子节点的节点，该节点一定为黑色，子节点一定为红色（因为该节点的另一个节点为黑色的空节点，而该节点到所有黑节点距离相同），用子节点代替该节点并染黑。</li>
<li>删除有两个子节点的节点，找到该节点的后继节点，用后继节点的值代替该节点，转为1删除后继节点。</li>
</ol>
<p>插入操作：</p>
<ol>
<li>键已经存在，直接改写值。</li>
<li>插入空树，作为根节点染黑。</li>
<li>插入位置的父节点为黑，直接插入。</li>
<li>插入位置的父节点为红，出现插入节点与父节点两个相邻红色节点（因为插入前满足红黑树性质，所以爷爷节点一定为黑）<ol>
<li>叔叔节点为红：将爷爷节点染红，父亲和叔叔节点染黑。将爷爷节点视为当前节点，继续向上调整。（爷爷节点又有可能跟上面二连红）</li>
<li>叔叔节点为黑或不存在（空节点一样视为黑）：以父节点为支点旋转，将父节点染黑，爷爷节点染红。</li>
</ol>
</li>
</ol>
<p>与AVL相比：红黑树只追求大致平衡，增删节点时的平均旋转次数小于AVL，在增删频繁时效率相对较高。</p>
<h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h1><h2 id="1-main函数执行前后"><a href="#1-main函数执行前后" class="headerlink" title="1. main函数执行前后"></a>1. main函数执行前后</h2><p>main函数执行前：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态static变量和global全局变量，即.data段</li>
<li>将未初始化部分的全局变量赋初值，即.bss段</li>
<li>全局对象初始化</li>
<li>传递argc、argv参数给main函数</li>
<li>__attribute__(constructor))：函数定义前修饰，main函数前执行</li>
</ul>
<p>main函数执行后：</p>
<ul>
<li>全局对象的析构函数</li>
<li>atexit：可以注册一个函数，程序正常终止时执行。</li>
<li>__attribute__((destructor))：函数定义后修饰，main函数后执行</li>
</ul>
<h2 id="2-指针的sizeof"><a href="#2-指针的sizeof" class="headerlink" title="2. 指针的sizeof"></a>2. 指针的sizeof</h2><p>指针的大小与编译环境有关，而与机器位数无关。</p>
<p>32位环境下指针4字节，64位环境下就是8字节。</p>
<h2 id="3-C-的类型安全"><a href="#3-C-的类型安全" class="headerlink" title="3. C++的类型安全"></a>3. C++的类型安全</h2><ul>
<li>空间分配：操作符new返回的指针类型严格与对象匹配，而不是void*</li>
<li>模板：改写C中以void*为参数的函数为模板参数，支持类型检查</li>
<li>宏定义：引入const、inline与模板代替#define</li>
<li>强制转换：提供dynamic_cast关键字，使得转换过程更加安全</li>
</ul>
<h2 id="4-零拷贝"><a href="#4-零拷贝" class="headerlink" title="4. 零拷贝"></a>4. 零拷贝</h2><p>vector中的emplace_back。</p>
<p>push_back需要调用拷贝构造函数与转移构造函数，而emplace_back原地构造。</p>
<h2 id="5-内存对齐"><a href="#5-内存对齐" class="headerlink" title="5. 内存对齐"></a>5. 内存对齐</h2><p>原因：大部分处理器一般以2幂次字节存取内存，称为内存存取粒度。如果任意存放，处理器还需要剔除不想要的字节，额外操作。</p>
<p>规则：</p>
<ol>
<li>分配内存的顺序按照声明顺序</li>
<li>每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍</li>
<li>整个结构体的大小必须是其中变量类型最大值的整数倍，如果不是需要在最后一个变量后面填充</li>
</ol>
<p>如果添加了#pragma pack(n)（不添加时默认为4）</p>
<ol>
<li>偏移量为n和当前变量大小较小值的整数倍。</li>
<li>结构体大小为n和最大变量大小较小值的整数倍。</li>
<li>n必须为2的幂，为其他值则语句失效。</li>
</ol>
<p>C++11 align</p>
<h2 id="6-编译、连接和模板类"><a href="#6-编译、连接和模板类" class="headerlink" title="6. 编译、连接和模板类"></a>6. 编译、连接和模板类</h2><p>编译单元：一个cpp文件以及其include的所有h文件，h文件中的代码将会被扩展到包含它的cpp文件里，然后该cpp文件被编译为一个obj文件。</p>
<p>分离式编译模式：一个程序由若干源文件共同实现，每个源文件单独编译生成目标文件，不知道彼此存在，最后连接所有目标文件形成单一的可执行文件。</p>
<p>例子：main.cpp中有f的调用，test.h中有f的声明，test.cpp中有f的实现。</p>
<ul>
<li>编译main.cpp时，编译器不知道f的实现，只给出一个指示，指示连接器应该为它寻找f的实现。</li>
<li>编译test.cpp时，编译器找到了f的实现，f的实现出现在test.obj中。</li>
<li>连接时，连接器在test.obj中找到f的实现代码地址，将main.obj中的地址改成f实际的地址。</li>
</ul>
<p>模板函数声明与实现无法分离：f&lt;T&gt;与f&lt;int&gt;等具体类型不是一个东西！</p>
<p>然而，如果f是模板函数，C++标准规定，当一个模板不被用到的时候，就不该被实例化。所以在原本的第2步，编译器不能实例化该模板，只能创建一个具有外部连接的符号，期待连接器找到符号的地址。所以原本应该出现的f的实现不会出现在test.obj中。这样导致整个工程的obj文件中都没有任何模板实例的二进制代码。</p>
<p>如：main.cpp中用到了f&lt;int&gt;，这时候会在展开的test.h中实例化对f&lt;int&gt;进行声明。由于分离式编译模式，编译时只需要类的声明即可编译成功，所以main.cpp会编译成功；</p>
<p><strong>链接</strong>时，需要找到f的实现，但是test.cpp编译单元中的实现**是f&lt;T&gt;而不是f&lt;int&gt;**，即找不到f&lt;int&gt;的实现，进而报错“对f&lt;int&gt;未定义的引用”。</p>
<p>编译器对函数模板进行两次编译：声明的地方对模板代码本身编译，调用的地方对参数替换后的代码编译。</p>
<h2 id="7-C-C-的输入输出缓冲与流"><a href="#7-C-C-的输入输出缓冲与流" class="headerlink" title="7. C/C++的输入输出缓冲与流"></a>7. C/C++的输入输出缓冲与流</h2><p>cin读取输入时，流程为键盘-输入缓冲区-cin。</p>
<p>缓冲分为三种：</p>
<ul>
<li>全缓冲：填满标准IO缓存才进行实际IO操作。读写磁盘文件。</li>
<li>行缓冲：输入输出中遇到换行符时执行真正的IO操作。键盘读写数据。</li>
<li>不带缓冲：不进行缓冲。标准出错情况stderr。</li>
</ul>
<p>缓冲区的刷新，即缓冲区内容被清空，清空前触发IO读写：</p>
<ul>
<li>缓冲区满</li>
<li>flush</li>
<li>endl</li>
<li>关闭文件</li>
</ul>
<p>缓冲区的限制：</p>
<ul>
<li>当且仅当标准输入/输出不涉及交互设备（键盘、屏幕等）时，它们是全缓存，如读写文件；如果涉及交互设备，一般默认为行缓存。</li>
<li>标准出错不是全缓存。</li>
</ul>
<p>流：数据传输的过程，例如键盘-输入缓冲区-cin的横线。</p>
<h2 id="8-引用传参-返回值"><a href="#8-引用传参-返回值" class="headerlink" title="8. 引用传参/返回值"></a>8. 引用传参/返回值</h2><p>好处：</p>
<ol>
<li>函数内部可以对参数进行修改</li>
<li>提高函数调用和运行的效率（没有传值和生成副本的时空消耗）</li>
</ol>
<p>限制：</p>
<ol>
<li>不能返回局部变量的引用，因为函数返回后就会被销毁</li>
<li>不能返回函数内部new分配内存的引用，因为会造成内存泄漏</li>
</ol>
<h2 id="9-C-标准库"><a href="#9-C-标准库" class="headerlink" title="9. C++标准库"></a>9. C++标准库</h2><p>标准函数库：通用、独立、不属于任何类的函数，继承自C++。输入/输出IO、字符串和字符处理、数学等。</p>
<p>面向对象类库：C++IO类、标准模板库等。</p>
<h2 id="10-回调函数"><a href="#10-回调函数" class="headerlink" title="10. 回调函数"></a>10. 回调函数</h2><ol>
<li>发生某种事件时，系统或其他函数会自动调用的一段函数，类似于中断处理函数。</li>
<li>将其指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，称其为回调函数。</li>
<li>可以将调用者被调用者分开，调用者可以不关心被调用者是谁。</li>
</ol>
<h2 id="11-C-从代码到可执行程序的流程"><a href="#11-C-从代码到可执行程序的流程" class="headerlink" title="11. C++从代码到可执行程序的流程"></a>11. C++从代码到可执行程序的流程</h2><h3 id="1-预编译"><a href="#1-预编译" class="headerlink" title="1. 预编译"></a>1. 预编译</h3><p>主要处理以#开头的预编译指令</p>
<ol>
<li>删除#define并展开宏定义</li>
<li>处理条件预编译指令，如#if</li>
<li>处理#include预编译指令，将文件内容替换到其位置</li>
<li>删除所有的注释</li>
<li>保留#pragma编译器指令</li>
<li>添加行号和文件标识</li>
</ol>
<p>生成.i、.ii文件</p>
<h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h3><p>词法分析、语法分析、语义分析以及优化，生成汇编代码.s</p>
<ol>
<li>词法分析：将源代码的字符序列分割成一系列记号</li>
<li>语法分析：产生以表达式为节点的语法树</li>
<li>语义分析：判断表达式是否有意义</li>
<li>优化</li>
<li>目标代码生成：将中间代码转换成目标机器代码，生成汇编语言</li>
<li>目标代码优化：寻找合适的寻址方式、使用位移代替乘法运算、删除多余指令等</li>
</ol>
<h3 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3. 汇编"></a>3. 汇编</h3><p>将汇编代码转变成机器可以执行的机器码文件，产生目标文件.o、.obj</p>
<h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4. 链接"></a>4. 链接</h3><p>将不同源文件产生的目标文件链接，形成一个可以执行的程序</p>
<p>静态链接：链接器从静态库中复制函数和数据，将其和应用程序的其他模块组合，创建最终的可执行文件。</p>
<p>特点：</p>
<ul>
<li>空间浪费：每个可执行程序对所有有需要的目标文件都有一份副本</li>
<li>更新困难：每当库函数代码修改，都要重新编译链接</li>
<li>运行速度快</li>
</ul>
<p>动态链接：把程序按照模块拆分成独立部分，运行时再链接。多个程序执行时共享一份共享库。</p>
<p>特点：</p>
<ul>
<li>更新方便：只需要替换原来的目标文件，不需要再链接一遍</li>
<li>性能损耗：每次执行都要链接；只要用到命令就需要附带整个链接库，造成空间浪费。</li>
</ul>
<p>装入时动态链接：可执行文件中只包含该cpp文件的代码部分，以及记录该可执行文件依赖哪些动态库。<strong>启动可执行文件时</strong>，装载器发现不完整，所以动态链接动态库文件。</p>
<p>运行时动态链接：可执行文件中只包含该cpp文件的代码部分，以及在某些第三方库的函数调用中记录需要使用这些库。<strong>程序运行到这些位置时</strong>，将第三方库的函数代码链接。</p>
<h2 id="12-垃圾回收机制"><a href="#12-垃圾回收机制" class="headerlink" title="12. 垃圾回收机制"></a>12. 垃圾回收机制</h2><p>实现垃圾回收器会带来额外的时空开销，使得C++不适合进行很多底层操作，所以C++不自带垃圾回收</p>
<h2 id="13-C-的内存管理"><a href="#13-C-的内存管理" class="headerlink" title="13. C++的内存管理"></a>13. C++的内存管理</h2><p>与Linux类似，从高地址到低地址依次是：</p>
<ul>
<li>栈：向低地址生长。函数内局部变量在栈上创建，函数返回时被自动释放。栈内存分配运算内置于处理器的指令集中，效率很高但容量有限。</li>
<li>堆：向高地址生长。分配与释放由应用程序控制，如果程序不释放，那么在程序结束后操作系统自动回收。灵活、容量大但效率不高。</li>
<li>全局/静态存储区：共同占用同一块内存区，在该区定义的变量如果没有初始化，会自动初始化为0。</li>
<li>常量存储区：不允许修改。</li>
<li>代码区：存储函数体的二进制代码。</li>
</ul>
<h2 id="14-RAII"><a href="#14-RAII" class="headerlink" title="14. RAII"></a>14. RAII</h2><p>Resource Acquisition is Initialization，资源获取即初始化，也就是说在构造函数中申请资源，在析构函数中释放资源。应该使用类管理资源，将资源和对象的生命周期绑定。</p>
<p>可用于防止内存泄漏。</p>
<p>智能指针即为RAII最具代表的实现。</p>
<h2 id="15-i和i"><a href="#15-i和i" class="headerlink" title="15. ++i和i++"></a>15. ++i和i++</h2><p>后者是右值，会产生临时对象导致效率降低，所以用前者更好。</p>
<p>后置重载要加上const：防止i++++这种操作出现，你期望+2，而实际上是对i++产生的临时对象再用++，只+1。</p>
<h2 id="16-常引用"><a href="#16-常引用" class="headerlink" title="16. 常引用"></a>16. 常引用</h2><p>引用：</p>
<p><code>int &amp;a = b</code>相当于 <code>int *const a = b</code></p>
<p>常引用：</p>
<p><code>const int &amp;a = b</code>就相当于 <code>const int *const a = b</code></p>
<p>常引用是万能引用，可以用左值或右值初始化。（另：<code>const int &amp;&amp;</code>只能用右值赋值）</p>
<p>对某个变量建立常引用时，允许发生类型转换，而一般的引用不允许。</p>
<p>对一个表达式建立常引用时</p>
<ul>
<li>如果该表达式的结果可以寻址，且表达式的数据类型与引用类型相同，就可以直接将该表达式结果的地址送入引用变量，导致的结果是表达式的地址与引用变量地址相同。</li>
<li>否则如果<strong>类型不相同</strong>，或表达式不可寻址，就只能另外建立一个匿名临时变量存放表达式的结果（或转换后的值），然后引用绑定匿名临时变量。</li>
</ul>
<p>常引用的作用：作为参数时可以传入左右值，同时禁止函数对其一切修改。</p>
<h2 id="17-乱序执行"><a href="#17-乱序执行" class="headerlink" title="17. 乱序执行"></a>17. 乱序执行</h2><p>如果后面的代码不需要等待前面的代码执行完毕，就会乱序执行。</p>
<p>一定不会出现乱序执行：</p>
<ul>
<li>对同一块内存访问，不会修改访问顺序。</li>
<li>新定义的变量值依赖于之前定义的变量，不会修改定义顺序。</li>
</ul>
<p>C++库提供了内存模型，用于在多线程情况下防止编译器乱序执行。</p>
<h1 id="问C-14、17、20新特性"><a href="#问C-14、17、20新特性" class="headerlink" title="问C++14、17、20新特性"></a>问C++14、17、20新特性</h1><p>问C++14、17、20的新特性，可以说的：</p>
<ul>
<li>string_view：””s操作符、分配在栈上、只存储指针和长度、只读。</li>
<li>optional、expected</li>
<li>variant</li>
<li>共享锁shared_lock、shared_mutex、shared_timed_mutex。配合shared_lock、unique_lock实现RAII的读写锁。</li>
<li>结构化绑定：pair、tuple、vector等。</li>
</ul>
<h1 id="7-C-14"><a href="#7-C-14" class="headerlink" title="7. C++ 14"></a>7. C++ 14</h1><p>比较熟悉的特性：shared_lock、shared_timed_mutex读写锁</p>
<h2 id="1-auto函数返回值类型推导"><a href="#1-auto函数返回值类型推导" class="headerlink" title="1. auto函数返回值类型推导"></a>1. auto函数返回值类型推导</h2><ul>
<li>函数内多个返回语句必须返回相同类型。</li>
<li>不能返回初始化列表。</li>
<li>不能推导虚函数。</li>
<li>可以用在前向声明，但是必须在定义在一个编译单元。</li>
<li>可以用在递归函数，但是必须用一个返回语句作为先导。（即递归出口必须写在开头）</li>
</ul>
<h2 id="2-模板"><a href="#2-模板" class="headerlink" title="2. 模板"></a>2. 模板</h2><p>支持变量模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">constexpr</span> T pi = T(<span class="number">3.1415926535897932385L</span>);</span><br></pre></td></tr></table></figure>
<p>支持别名模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    T t;</span><br><span class="line">    U u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> B = A&lt;T, <span class="keyword">int</span>&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="3-constexpr"><a href="#3-constexpr" class="headerlink" title="3. constexpr"></a>3. constexpr</h2><p>可以用局部变量、循环、多条返回。</p>
<h2 id="4-deprecated"><a href="#4-deprecated" class="headerlink" title="4. [[deprecated]]"></a>4. [[deprecated]]</h2><p>修饰名字/实体，指示其被弃用，允许使用但不推荐，会报警告。</p>
<h2 id="5-分隔符"><a href="#5-分隔符" class="headerlink" title="5. 分隔符"></a>5. 分隔符</h2><p>分隔二进制字面量与整形字面量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0b0001&#x27;0011&#x27;1010</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">3.14&#x27;1234&#x27;1234&#x27;1234</span>;</span><br></pre></td></tr></table></figure>
<h2 id="6-make-unique"><a href="#6-make-unique" class="headerlink" title="6. make_unique"></a>6. make_unique</h2><p>用于unique_ptr</p>
<h2 id="7-读写锁shared-timed-mutex"><a href="#7-读写锁shared-timed-mutex" class="headerlink" title="7. 读写锁shared_timed_mutex"></a>7. 读写锁shared_timed_mutex</h2><p><code>shared_timed_mutex</code>为读写锁类型。</p>
<p><code>shared_lock&lt;shared_timed_mutex&gt;(mtx: shared_timed_mutex)</code>创建读锁。</p>
<p><code>unique_lock&lt;shared_timed_mutex&gt;(mtx: shared_timed_mutex)</code>创建写锁。</p>
<h2 id="8-integer-sequence"><a href="#8-integer-sequence" class="headerlink" title="8. integer_sequence"></a>8. integer_sequence</h2><p>模板参数传入类型与该类型的多个值，通过 <code>((std::cout &lt;&lt; ints &lt;&lt; &#39; &#39;), ...);</code>解包。</p>
<h2 id="9-exchange"><a href="#9-exchange" class="headerlink" title="9. exchange"></a>9. exchange</h2><ul>
<li>右边替换左边值，返回左边旧值。</li>
<li>左边类型必须可用右边类型移动构造。</li>
</ul>
<h2 id="10-quoted"><a href="#10-quoted" class="headerlink" title="10. quoted"></a>10. quoted</h2><p>给字符串加双引号。</p>
<h1 id="8-C-17"><a href="#8-C-17" class="headerlink" title="8. C++ 17"></a>8. C++ 17</h1><p>比较熟悉的特性：结构化绑定、string_view</p>
<h2 id="1-构造函数模板自动推导"><a href="#1-构造函数模板自动推导" class="headerlink" title="1. 构造函数模板自动推导"></a>1. 构造函数模板自动推导</h2><p>pair、vector等。</p>
<h2 id="2-结构化绑定"><a href="#2-结构化绑定" class="headerlink" title="2. 结构化绑定"></a>2. 结构化绑定</h2><p>应用于public成员、C-Style数组、pair、tuple、array对象，通过 <code>auto [v1, v2] = p</code>获取值。</p>
<ul>
<li>不能加constexpr，可以通过引用直接改变被绑定的值。</li>
<li>不会发生类型退化，如char[]退化为char*。</li>
<li>用_跳过当前元素。</li>
<li>不适用于继承，所有非静态数据成员必须在一个类。</li>
</ul>
<p>要对自定义类型实现结构化绑定，需要实现类似tuple的get&lt;i&gt;API。</p>
<h2 id="3-折叠表达式"><a href="#3-折叠表达式" class="headerlink" title="3. 折叠表达式"></a>3. 折叠表达式</h2><p>用于可变参数模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ts ... ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ts + ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-has-include"><a href="#4-has-include" class="headerlink" title="4. __has_include"></a>4. __has_include</h2><p><code>#if __has_include(&lt;package&gt;)</code>判断是否有某个头文件。</p>
<h2 id="5-attribute"><a href="#5-attribute" class="headerlink" title="5. attribute"></a>5. attribute</h2><p>[[fallthrough]]，switch中代替break。</p>
<p>[[nodiscard]]，修饰内容不能被忽略，修饰函数表示返回值必须处理，否则warning。</p>
<p>[[maybe_used]]，提示编译器修饰的内容暂时没用，避免产生警告。</p>
<h2 id="6-字符串转换"><a href="#6-字符串转换" class="headerlink" title="6. 字符串转换"></a>6. 字符串转换</h2><p>from_chars</p>
<p>to_chars</p>
<h2 id="7-variant"><a href="#7-variant" class="headerlink" title="7. variant"></a>7. variant</h2><p>类似union，传入模板参数构造，可通过类型取值。</p>
<p>union的缺陷是，里面有析构函数的成员时，不会自动释放内存，所以引入variant，它会自动析构。</p>
<p>如何判断类型中所占最大的空间</p>
<ul>
<li>模板元，编译时期判断</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MaxSize&lt;Ts...&gt;  Ts... 最大的一个</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MaxSize</span> &#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(T) &gt; MaxSize&lt;Ts...&gt;::size ? <span class="keyword">sizeof</span>(T) : MaxSize&lt;Ts...&gt;::size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MaxSize</span>&lt;</span>T&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span>  size = <span class="keyword">sizeof</span>(T);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实现类似tuple的get&lt;i&gt;：同样是模板元，找到下标为i的类型，然后get里reinterpret_cast即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> idx, <span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type_element</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span>  Type_element&lt;idx - <span class="number">1</span>, Ts...&gt;::Type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type_element</span>&lt;</span><span class="number">0</span>, T, Ts...&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>找到某个类型的下标：模板元</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> id, <span class="keyword">typename</span> U, <span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Position</span> &#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = is_same&lt;U, T&gt;::value ? id : Position&lt;id + <span class="number">1</span>, U, Ts...&gt;::pos;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> id, <span class="keyword">typename</span> U, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Position</span>&lt;</span>id, U, T&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法：</p>
<ul>
<li>get&lt;type&gt;(variant)：以type类型访问，如果variant没有该type抛出异常。</li>
<li>holds_alternative&lt;type&gt;(variant)：检查是否有type。</li>
<li>get_if&lt;type&gt;(variant)：以type类型访问，如果有该类型，返回type*，否则返回空指针。</li>
</ul>
<h2 id="8-optional"><a href="#8-optional" class="headerlink" title="8. optional"></a>8. optional</h2><p>传入模板参数，修饰函数返回值，可以返回该类型，也可以返回nullopt。</p>
<p>可通过make_optional创建。</p>
<p>示例：<code>optional&lt;A&gt;</code>可返回A类型实例，或nullopt。</p>
<p>方法：</p>
<ul>
<li>*op/op-&gt;：访问值</li>
<li>operator bool/has_value()：检查是否有值</li>
<li>value()：返回值</li>
<li>value_or(val)：有值则返回值，否则返回val</li>
</ul>
<p>目的：更优雅地进行异常处理。</p>
<p>C++ 23：引入了expected，可通过error()方法返回不期待的值（相当于把optional的nullopt用了个值代替）</p>
<h2 id="9-any"><a href="#9-any" class="headerlink" title="9. any"></a>9. any</h2><p>存储任何类型的单个值</p>
<ul>
<li>type().name()获取类型</li>
<li>hash_value()判断有没有值</li>
<li>any_cast&lt;type&gt;(a)转换到存储的类型</li>
</ul>
<p>简单实现：基类Base，模板派生类Derive存储T类型数据，Any类中保存Base的unique_ptr，运行时dynamic_cast转换成Derive*类get到T类型数据。</p>
<h2 id="10-make-from-tuple"><a href="#10-make-from-tuple" class="headerlink" title="10. make_from_tuple"></a>10. make_from_tuple</h2><p>展开tuple作为构造函数参数。</p>
<h2 id="11-string-view"><a href="#11-string-view" class="headerlink" title="11. string_view"></a>11. string_view</h2><p>传入const char*以及大小（可选）</p>
<ul>
<li>高效：不拷贝字符串，只保存字符串指针与看到的大小</li>
<li>分配在栈上</li>
<li>只读</li>
</ul>
<p>方法：</p>
<ul>
<li><p>常规string方法</p>
</li>
<li><p>没有c_str()，因为string_view可能只截取其中一端，而c语言风格的字符串要求尾部为\0；代替的，有data()，返回指向视图首字符的指针。</p>
<ul>
<li>cout该方法与直接cout视图不一定一样，因为data()直接到尾部，而string_view截取的可能是不到尾部的一段。</li>
</ul>
</li>
<li><p>重载了””sv操作符： <code>&quot;narrow string literal&quot;sv</code>作为一个匿名string_view对象。</p>
<ul>
<li>（另：C++17也对string重载了””s操作符，而且调用的是basic_string_view的构造函数，免去了构造时再一次获取字符串长度）</li>
</ul>
</li>
</ul>
<h2 id="12-monostate"><a href="#12-monostate" class="headerlink" title="12. monostate"></a>12. monostate</h2><p>空类型</p>
<h2 id="13-scoped-lock"><a href="#13-scoped-lock" class="headerlink" title="13. scoped_lock"></a>13. scoped_lock</h2><p>可一次包装多个锁，相当于多个锁的unique_lock。</p>
<h1 id="9-C-20"><a href="#9-C-20" class="headerlink" title="9. C++ 20"></a>9. C++ 20</h1><p>比较熟悉的特性：module、ranges</p>
<h2 id="1-module"><a href="#1-module" class="headerlink" title="1. module"></a>1. module</h2><p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> m;</span><br><span class="line"><span class="keyword">namespace</span> m &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>引用：import</p>
<p>优点（相较于头文件）：</p>
<ul>
<li>不会有头文件重复include</li>
<li>模块间名称可以相同</li>
<li>模块只处理一次，编译更快（头文件每次include都要处理）</li>
</ul>
<p>更快：</p>
<ul>
<li>编译器缓存留下来，下次读取更快。</li>
<li>lazy loading：需要哪些定义/声明就加载哪些。</li>
<li>编译出object，只有链接的时候需要，不要再次处理、编译。</li>
</ul>
<p>module linkage：同一个module内部可见。</p>
<ul>
<li>对外export的名称按照平时方式name mangling</li>
<li>module内部需要module linkage的名称，使用_ZW开头的name mangling</li>
</ul>
<h2 id="2-ranges"><a href="#2-ranges" class="headerlink" title="2. ranges"></a>2. ranges</h2><p>range：有begin和end函数。</p>
<p>view：视图。对数据的遍历都是惰性求值，如views::iota(1)表示自然数序列，但是需要遍历时才往后加。</p>
<p>range adapter：将range或view转换为view。</p>
<p>管道运算符|：利用views namespace的范围适配器提供对range或view的变换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec3&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec3 | <span class="built_in">std</span>::views::elements&lt;<span class="number">1</span>&gt;)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>懒求值：v为一个view，不修改与复制vec的元素，只当其表示的一个元素被使用时才发生求值。（此处为cout）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">20</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> v = vec | filter(even) | transform([](<span class="keyword">const</span> <span class="keyword">int</span>&amp; a) &#123;<span class="keyword">return</span> a * a; &#125;)| take(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *v.begin() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-协程coroutine"><a href="#3-协程coroutine" class="headerlink" title="3. 协程coroutine"></a>3. 协程coroutine</h2><p>协程是一个函数，可以暂停与恢复执行。其状态与任何线程都无关。</p>
<p>与普通函数的区别：堆上保存状态，调用时在栈上分配空间后，保存一个引用指向堆上的状态。协程暂停时，将当前执行的代码位置记录到堆的状态中，回收栈上的空间。</p>
<p>作用：解决用到回调函数的异步函数多层嵌套。</p>
<p>操作符：co_await、co_return、co_yield。</p>
<p><img src="https://img2022.cnblogs.com/blog/2250167/202204/2250167-20220416162134241-1573199389.png" class="lazyload placeholder" data-srcset="https://img2022.cnblogs.com/blog/2250167/202204/2250167-20220416162134241-1573199389.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<h3 id="1-co-await"><a href="#1-co-await" class="headerlink" title="1. co_await"></a>1. co_await</h3><p>暂停协程，等某个操作完成后再恢复。</p>
<p>传给该操作符的对象必须实现：</p>
<ul>
<li><code>bool await_ready()</code>：协程执行co_await前调用，询问”操作是否完成“，如果返回true则协程不暂停。</li>
<li><code>void/bool await_suspend(coroutine_handle&lt;&gt;)</code>：await_ready()返回false时调用，用于接收协程句柄（参数），在异步操作完成时通过句柄让协程恢复执行。<ul>
<li>一般返回void，返回bool时返回值用于控制协程是否真的要暂停，如果返回false则表示不暂停。</li>
</ul>
</li>
<li><code>void/other await_resume()</code>：返回值是co_await操作符的返回值。协程恢复执行或不需要暂停的时候调用。</li>
</ul>
<p>co_await完成：</p>
<ul>
<li>挂起协程</li>
<li>返回到caller</li>
<li>等待某个任务完成后返回的结果</li>
</ul>
<p>co_await expr生成的伪代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; value = &lt;expr&gt;;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; awaitable = get_awaitable(promise, <span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(value)&gt;(value));</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; awaiter = get_awaiter(<span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(awaitable)&gt;(awaitable));</span><br><span class="line">    <span class="keyword">if</span> (!awaiter.await_ready()) <span class="comment">//是否需要挂起协程</span></span><br><span class="line">  	&#123;</span><br><span class="line">    	<span class="keyword">using</span> <span class="keyword">handle_t</span> = <span class="built_in">std</span>::experimental::coroutine_handle&lt;P&gt;;</span><br><span class="line"> </span><br><span class="line">    	<span class="keyword">using</span> <span class="keyword">await_suspend_result_t</span> = <span class="keyword">decltype</span>(awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)));</span><br><span class="line"> </span><br><span class="line">    	&lt;suspend-coroutine&gt; <span class="comment">//挂起协程</span></span><br><span class="line"> </span><br><span class="line">    	<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_void_v&lt;<span class="keyword">await_suspend_result_t</span>&gt;)</span></span></span><br><span class="line"><span class="function">    	</span>&#123;</span><br><span class="line">      		awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)); <span class="comment">//异步(也可能同步)执行task</span></span><br><span class="line">      		&lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt; <span class="comment">//返回给caller</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    	&#123;</span><br><span class="line">      		<span class="keyword">static_assert</span>(</span><br><span class="line">         		<span class="built_in">std</span>::is_same_v&lt;<span class="keyword">await_suspend_result_t</span>, <span class="keyword">bool</span>&gt;,</span><br><span class="line">         		<span class="string">&quot;await_suspend() must return &#x27;void&#x27; or &#x27;bool&#x27;.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      		<span class="keyword">if</span> (awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)))</span><br><span class="line">      		&#123;</span><br><span class="line">        		&lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">      		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"> </span><br><span class="line">    	&lt;resume-point&gt; <span class="comment">//task执行完成，恢复协程，这里是协程恢复执行的地方</span></span><br><span class="line">  	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> awaiter.await_resume(); <span class="comment">//返回task结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-co-return"><a href="#2-co-return" class="headerlink" title="2. co_return"></a>2. co_return</h3><p>协程的返回类型T要求：其中定义名为promise_type的内嵌类型。</p>
<p>promise_type要实现的函数：</p>
<ul>
<li><code>T get_return_object()</code>：创建协程的返回值。</li>
<li><code>void return_value(U u)</code>：传递返回数据给promise_type对象。</li>
<li><code>void return void()</code></li>
<li><code>suspend_never/suspend_always yield_value()</code></li>
</ul>
<p>co_return：从协程中返回数据。<code>co_return total</code>等价于 <code>promise_type.return_value(total)</code>。可以不带数据。需要根据其使用决定该在promise_type中定义哪个函数。</p>
<h3 id="3-co-yield"><a href="#3-co-yield" class="headerlink" title="3. co_yield"></a>3. co_yield</h3><p>在协程中多次返回数据而不结束协程。</p>
<p>返回一个数据，让协程暂停，等待下一次机会恢复执行。</p>
<p><code>co_yield val</code>等价于 <code>promise_type.yield_value(val)</code>。</p>
<h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><p>用户输入一次后，从协程中取一个值输出，生成下一个值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntReader</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::thread <span class="title">thread</span><span class="params">([<span class="keyword">this</span>, handle]() &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">static</span> <span class="keyword">int</span> seed = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">            value_ = ++seed;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            handle.resume();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        thread.detach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> value_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">promise_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> Task&#123; <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(*<span class="keyword">this</span>) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::suspend_always <span class="title">yield_value</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            value_ = value;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> value_&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Task(<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; handle) : coroutine_handle_(handle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coroutine_handle_.promise().GetValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        coroutine_handle_.resume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; coroutine_handle_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">GetInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        IntReader reader;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="keyword">co_await</span> reader;</span><br><span class="line">        <span class="keyword">co_yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = GetInt();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; line) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; task.GetValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        task.Next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-concept"><a href="#4-concept" class="headerlink" title="4. concept"></a>4. concept</h2><p>一个语法糖，用于对模板特例化做出约束。</p>
<p>相当于定义了一个别名，用来指代需要被特例化的某种类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个永远都能匹配成功的concept</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> always_satisfied = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个约束T只能是整数类型的concept，整数类型包括 char, unsigned char, short, ushort, int, unsinged int, long等。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> integral = <span class="built_in">std</span>::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个约束T只能是整数类型，并且是有符号的concept</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> signed_integral = integral&lt;T&gt; &amp;&amp; <span class="built_in">std</span>::is_signed_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意类型都能匹配成功的约束，因此mul只要支持乘法运算符的类型都可以匹配成功。</span></span><br><span class="line"><span class="keyword">template</span> &lt;always_satisfied T&gt;</span><br><span class="line"><span class="function">T <span class="title">mul</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整型才能匹配add函数的T</span></span><br><span class="line"><span class="keyword">template</span> &lt;integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有符号整型才能匹配subtract函数的T</span></span><br><span class="line"><span class="keyword">template</span> &lt;signed_integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">subtract</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mul(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 匹配成功, T =&gt; int</span></span><br><span class="line">    mul(<span class="number">1.0f</span>, <span class="number">2.0f</span>);  <span class="comment">// 匹配成功，T =&gt; float</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">-2</span>);  <span class="comment">// 匹配成功, T =&gt; int</span></span><br><span class="line">    add(<span class="number">1.0f</span>, <span class="number">2.0f</span>); <span class="comment">// 匹配失败, T =&gt; float，而T必须是整型</span></span><br><span class="line">    subtract(<span class="number">1U</span>, <span class="number">2U</span>); <span class="comment">// 匹配失败，T =&gt; unsigned int,而T必须是有符号整型</span></span><br><span class="line">    subtract(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 匹配成功, T =&gt; int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-requires"><a href="#5-requires" class="headerlink" title="5. requires"></a>5. requires</h2><p>可以与concept配合使用，也可以用在其他。</p>
<h3 id="1-简单约束"><a href="#1-简单约束" class="headerlink" title="1. 简单约束"></a>1. 简单约束</h3><p>要求requires后面的表达式是合法的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requires用在使用concept时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">requires</span> my_concept&lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// requires用在concept的定义，它表达了类型T的参数f，必须符合大括号内的模式，也就是能被调用。</span></span><br><span class="line"><span class="comment">// 也就是它是一个函数或者一个重载了operator()的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> callable = <span class="keyword">requires</span> (T f) &#123; f(); &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">requires</span> (T x) &#123; x + x; &#125; <span class="comment">// 要求x重载了operator+</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-类型约束"><a href="#2-类型约束" class="headerlink" title="2. 类型约束"></a>2. 类型约束</h3><p>typename后面接一个类型，要求该类型在concept进行evaluate时必须存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bar</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> value = <span class="keyword">int</span>;</span><br><span class="line">    value data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">baz</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> value = <span class="keyword">int</span>;</span><br><span class="line">    value data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用了SFINAE，要求T必须是baz类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;<span class="built_in">std</span>::is_same_v&lt;T, baz&gt;&gt;&gt;</span><br><span class="line">struct S &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> C = <span class="keyword">requires</span> &#123;</span><br><span class="line">    <span class="comment">// 对T的约束</span></span><br><span class="line">    <span class="keyword">typename</span> T::value;  <span class="comment">// A) 有成员value</span></span><br><span class="line">    <span class="keyword">typename</span> S&lt;T&gt;;     <span class="comment">// B) 有一个有效的S模板特例化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;C T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T a)</span></span>;</span><br><span class="line"></span><br><span class="line">g(foo&#123;&#125;); <span class="comment">// ERROR: Fails requirement A.</span></span><br><span class="line">g(bar&#123;&#125;); <span class="comment">// ERROR: Fails requirement B.</span></span><br><span class="line">g(baz&#123;&#125;); <span class="comment">// PASS.</span></span><br></pre></td></tr></table></figure>
<h3 id="3-嵌套约束"><a href="#3-嵌套约束" class="headerlink" title="3. 嵌套约束"></a>3. 嵌套约束</h3><p>requires嵌套requires</p>
<h2 id="6-同步库新增"><a href="#6-同步库新增" class="headerlink" title="6. 同步库新增"></a>6. 同步库新增</h2><h3 id="1-信号量semaphore"><a href="#1-信号量semaphore" class="headerlink" title="1. 信号量semaphore"></a>1. 信号量semaphore</h3><ul>
<li>多元信号量：非负值资源技术</li>
<li>二元信号量：只有两个状态</li>
</ul>
<p>方法</p>
<ul>
<li>release：增加内部计数器并对获取者解除阻塞</li>
<li>acquire：减少内部计数器或阻塞直至能获取</li>
<li>try_acquire：尝试减少内部计数器，不阻塞</li>
<li>try_acquire_for：尝试减少内部计数器，至多阻塞一段时长</li>
<li>try_acquire_until：尝试减少内部计数器，至多阻塞直到某个时间点</li>
</ul>
<h3 id="2-atomic新增"><a href="#2-atomic新增" class="headerlink" title="2. atomic新增"></a>2. atomic新增</h3><p>等待/阻塞在原子对象直到其值发生改变，然后通知函数发送通知，比自旋锁/轮询效率高。</p>
<p>方法</p>
<ul>
<li>wait：阻塞线程直到被提醒且原子值更改</li>
<li>notify_one：提醒至少一个在原子对象上的等待中阻塞的线程</li>
<li>notify_all：提醒所有在原子对象上的等待中阻塞的线程</li>
</ul>
<h3 id="3-锁存器latch"><a href="#3-锁存器latch" class="headerlink" title="3. 锁存器latch"></a>3. 锁存器latch</h3><p>只能减少的计数器，初值在创建时初始化，线程可以在上面阻塞，直到计数器归0。</p>
<p>一般用于同步线程。</p>
<p>因为只能减少，所以是一次性的。</p>
<p>方法</p>
<ul>
<li>用一个int初值初始化</li>
<li>赋值操作被delete</li>
<li>count_down：非阻塞减少计数器</li>
<li>try_wait：返回计数器是否为0</li>
<li>wait：阻塞到计数器归0</li>
<li>arrive_and_wait：减少计数器，并阻塞直到其归0</li>
</ul>
<p>官网的一段示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;latch&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> product&#123;<span class="string">&quot;not worked&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::thread action&#123;&#125;;</span><br><span class="line">  &#125; jobs[] = &#123;&#123;<span class="string">&quot;annika&quot;</span>&#125;, &#123;<span class="string">&quot;buru&quot;</span>&#125;, &#123;<span class="string">&quot;chuck&quot;</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::latch work_done&#123;<span class="built_in">std</span>::size(jobs)&#125;;</span><br><span class="line">  <span class="built_in">std</span>::latch start_clean_up&#123;<span class="number">1</span>&#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">auto</span> work = [&amp;](job&amp; my_job) &#123;</span><br><span class="line">    my_job.product = my_job.name + <span class="string">&quot; worked&quot;</span>;</span><br><span class="line">    work_done.count_down();</span><br><span class="line">    start_clean_up.wait();</span><br><span class="line">    my_job.product = my_job.name + <span class="string">&quot; cleaned&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Work starting... &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; job : jobs) &#123;</span><br><span class="line">    job.action = <span class="built_in">std</span>::thread&#123;work, <span class="built_in">std</span>::ref(job)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  work_done.wait();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;done:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; job : jobs) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; job.product &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Workers cleaning up... &quot;</span>;</span><br><span class="line">  start_clean_up.count_down();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; job : jobs) &#123;</span><br><span class="line">    job.action.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;done:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span>&amp; job : jobs) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; job.product &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-barrier"><a href="#4-barrier" class="headerlink" title="4. barrier"></a>4. barrier</h3><p>相较于latch，barrier功能相似，但是可复用。</p>
<p>相当于一个多阶段的任务，初值为参加任务的线程数</p>
<ul>
<li>每个阶段维护一个递减计数器，初始值为参加任务的线程数</li>
<li>线程通过arrive_and_wait减少计数器，并阻塞</li>
<li>当计数器为0时，表示该阶段完成，调用阶段完成时的回调函数</li>
<li>开启新一轮任务</li>
<li>线程不想参加当前以及后续任务了，可以通过arrive_and_drop跑路，把参加任务的线程数减去1，每阶段递减计数器的初值也永远减1</li>
</ul>
<p>方法：</p>
<ul>
<li>构造时两个参数：int型表示计数器初值，可调用对象表示所有阻塞线程运行完时，即一个阶段完成时的回调函数</li>
<li>赋值操作被delete</li>
<li>arrive：到达barrier，减少计数器</li>
<li>wait：阻塞，直到阶段完成时，回调函数被调用</li>
<li>arrive_and_wait：两个操作相加</li>
<li>arrive_and_drop：永久退出，意思是之后也不用算该线程了</li>
</ul>
<h3 id="5-jthread"><a href="#5-jthread" class="headerlink" title="5. jthread"></a>5. jthread</h3><p>jthread基于thread，其中包含一个thread成员，有thread的所有方法。可以用jthread替换所有thread。</p>
<p>jthread还封装了一个stop_token，可以通过stop_token控制线程结束</p>
<p>在thread的基础上，增加了功能：</p>
<ul>
<li>jthread对象析构时自动调用join，等待其所表示的执行流结束。RAII思想。</li>
<li>支持在线程外部主动停止线程执行（get_stop_source、get_stop_token 和 request_stop）。</li>
</ul>
<p>新方法：</p>
<ul>
<li>request_stop()：（线程外）将stop_token设置为结束标志。</li>
<li>get_stop_token()：获取stop_token</li>
<li>get_stop_token().stop_requested()：（线程内）通过stop_token的该方法确认是否结束。</li>
</ul>
<p>stop_callback：传入参数：stop_token、回调函数。request_stop()时当前线程执行注册的回调函数。</p>

      </div>
      <div class="post-tags-categories">
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>aoba moka</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2023/01/07/学习笔记-C++/" target="_blank" title="学习笔记-C++">https://aobamoka.github.io/2023/01/07/学习笔记-C++/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">



  
  <div class="post-nav-prev post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://picx.zhimg.com/80/v2-85c31120acff76826ab53ea8934ef4bb_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-85c31120acff76826ab53ea8934ef4bb_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
    </div>
    <a href="/2023/01/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86/" class="post-nav-link">
      <div class="title">
        <i class="fas fa-angle-left"></i> 上一篇:
        <div class="title-text">学习笔记-大数据场景处理</div>
      </div>
      
      <!-- <div class="content">
        1.找相同字符串场景：找相同URL
1. 分治法按照哈希值分组，所有相同字符串一定在同一组，然后在同一组中求相同字符串。
      </div> -->
    </a>
  </div>



  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://pica.zhimg.com/80/v2-61f99f8dcf899f54cad2a1aa28b21e44_1440w.webp" class="lazyload placeholder" data-srcset="https://pica.zhimg.com/80/v2-61f99f8dcf899f54cad2a1aa28b21e44_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" src="" alt="">
    </div>
    <a href="/2022/12/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">学习笔记-操作系统</div>
      </div>
      <!-- <div class="content">
        1. 硬件结构1. 冯诺依曼模型冯诺依曼模型：运算器、控制器、存储器、输入设备、输出设备。对应于现代计算机的结构：

存
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-container"></div>

    
  </div>

<!-- comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  <aside id='l_side'>
  
    
      <section class="widget side_blogger">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img src='/medias/test.png'/>
        </a>
      
    
    
      <div class='text'>
        
          <h2>摩卡</h2>
        
        
          <p>因幡めぐる单推</p>

        
        
          <p><span id="jinrishici-sentence">摩卡's blog</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
  </div>
</section>

    
  
  
  

  <div class="layout_sticky">    
    
      
<section class="widget side_toc">
  
  <header>
    
      <i style="color: " class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name' style="color: ">本文目录</span>
    
  </header>


  <div class='content'>
    <div class="toc-main">
      <div class="toc-content">
        <!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E5%92%8CC-%E5%8C%BA%E5%88%AB"><span class="toc-text">C和C++区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%85%B3%E9%94%AE%E5%AD%97-%E6%96%B9%E6%B3%95"><span class="toc-text">1. 关键字&#x2F;方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-new%E4%B8%8Emalloc"><span class="toc-text">1. new与malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-new-delete"><span class="toc-text">1. new&#x2F;delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-malloc-free"><span class="toc-text">2. malloc&#x2F;free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-new%E4%B8%8Emalloc%E5%8C%BA%E5%88%AB"><span class="toc-text">3. new与malloc区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-align-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90"><span class="toc-text">2. align 结构体对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-const%E4%B8%8E"><span class="toc-text">3. const与*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-static%E4%B8%8Econst"><span class="toc-text">4. static与const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-static"><span class="toc-text">1. static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-const"><span class="toc-text">2. const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-final%E4%B8%8Eoverride"><span class="toc-text">5. final与override</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-override"><span class="toc-text">1. override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-final"><span class="toc-text">2. final</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-volatile"><span class="toc-text">6. volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-mutable"><span class="toc-text">7. mutable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-explicit"><span class="toc-text">8. explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-new"><span class="toc-text">9. new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-allocator-alloc"><span class="toc-text">10. allocator&#x2F;alloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-delete"><span class="toc-text">11. delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-alloc%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-text">12. alloc系列函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-cast%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">13. cast强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-strcpy%E3%80%81sprintf%E3%80%81memcpy"><span class="toc-text">14. strcpy、sprintf、memcpy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">15. inline内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-iovec"><span class="toc-text">16. iovec</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82-vsprintf"><span class="toc-text">17. 可变形参&#x2F;vsprintf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-fstream"><span class="toc-text">18. fstream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-extern"><span class="toc-text">19. extern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-union"><span class="toc-text">20. union</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%AF%94%E8%BE%83"><span class="toc-text">2. 比较</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-text">1. 指针和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-text">2. 堆和栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%8F%E4%B8%8E%E5%87%BD%E6%95%B0-typedef-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-const"><span class="toc-text">3. 宏与函数&#x2F;typedef&#x2F;内联函数&#x2F;const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">4. 变量声明与变量定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">5. 数组名和指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%B5%8B%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-text">6. 赋值初始化与成员初始化列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-vector%E7%9A%84emplace-back%E4%B8%8Epush-back"><span class="toc-text">7. vector的emplace_back与push_back</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-text">8. 组合和继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Debug%E4%B8%8ERelease%E7%89%88%E6%9C%AC"><span class="toc-text">9. Debug与Release版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">10. 函数模板和类模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E5%8C%BA%E4%B8%8E%E5%A0%86"><span class="toc-text">11. 自由存储区与堆</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%B1%BB"><span class="toc-text">3. 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">1. 面向对象三大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">2. 构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">3. 拷贝初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E8%A6%86%E7%9B%96%E5%92%8C%E9%9A%90%E8%97%8F"><span class="toc-text">4. 重载、重写、覆盖和隐藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-NRV%E4%BC%98%E5%8C%96"><span class="toc-text">5. NRV优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">6. 静态绑定与动态绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-text">1. 具体过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B7%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">2. 样例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">7. 实现只能静态&#x2F;动态创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8"><span class="toc-text">8. 对象复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%A9%BA%E7%B1%BB"><span class="toc-text">9. 空类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%98%BB%E6%AD%A2%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">10. 阻止类被实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%A6%81%E6%AD%A2%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">11. 禁止程序自动生成拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-memset-this-0-sizeof-this"><span class="toc-text">12. memset(this,0,sizeof(*this))</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%8F%8B%E5%85%83"><span class="toc-text">13. 友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-text">14. 类的内存空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-this%E6%8C%87%E9%92%88"><span class="toc-text">15. this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%97%B6%E5%88%BB"><span class="toc-text">1. 创建时刻</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE"><span class="toc-text">2. 存放位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F"><span class="toc-text">3. 传递方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%ADdelete-this"><span class="toc-text">16. 成员函数中delete this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">17. 多态与虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%9A%E6%80%81"><span class="toc-text">1. 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2. 虚函数实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">3. 特殊函数能否为虚函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%99%9A%E5%87%BD%E6%95%B0%E5%BC%80%E9%94%80"><span class="toc-text">4. 虚函数开销</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-CRTP%E6%A8%A1%E6%9D%BF"><span class="toc-text">18. CRTP模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-text">19. 模板特例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-text">20. 多继承与虚拟继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">21. 自动生成默认构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-text">22. 抽象基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">23. 自动生成拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%8F%96%E7%B1%BB%E6%88%90%E5%91%98%E5%81%8F%E7%A7%BB"><span class="toc-text">24. 取类成员偏移</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-C-11"><span class="toc-text">4. C++ 11</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-auto%E4%B8%8Edecltype"><span class="toc-text">1. auto与decltype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-auto"><span class="toc-text">1. auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-decltype"><span class="toc-text">2. decltype</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC"><span class="toc-text">2. 左值右值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-text">1. 移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-text">2. 完美转发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-bind%E5%92%8Cfunction"><span class="toc-text">3. bind和function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">4. 智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-shared-ptr"><span class="toc-text">1. shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-weak-ptr"><span class="toc-text">2. weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-unique-ptr"><span class="toc-text">3. unique_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-default%E3%80%81delete%E4%B8%8Eexplicit"><span class="toc-text">5. default、delete与explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-constexpr"><span class="toc-text">6. constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">7. lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-C-14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">1. C++ 14 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8D%95%E6%8D%89%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1. 捕捉表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%9B%E5%9E%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">2. 泛型lambda表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-nullptr"><span class="toc-text">8. nullptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">9. 列表初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-array"><span class="toc-text">10. array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">11. 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-thread"><span class="toc-text">1. thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-mutex"><span class="toc-text">2. mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-atomic"><span class="toc-text">3. atomic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-async"><span class="toc-text">4. async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-future"><span class="toc-text">5. future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-promise"><span class="toc-text">6. promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-this-thread"><span class="toc-text">7. this_thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-lock-guard"><span class="toc-text">8. lock_guard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-unique-lock"><span class="toc-text">9. unique_lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-condition-variable"><span class="toc-text">10. condition_variable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">12. 可变参数模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-align"><span class="toc-text">13. align</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-alignof"><span class="toc-text">1. alignof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-alignas"><span class="toc-text">2. alignas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-align-storage"><span class="toc-text">3. align_storage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-align"><span class="toc-text">4. align</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-STL"><span class="toc-text">5. STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-text">1. STL标准模板库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E6%B1%A0"><span class="toc-text">2. 内存配置器与内存池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-deque"><span class="toc-text">3. deque</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-hashtable"><span class="toc-text">4. hashtable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-type-traits%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96"><span class="toc-text">5. type traits类型萃取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-reserve%E4%B8%8Eresize"><span class="toc-text">6. 扩容机制 reserve与resize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-unordered-map%E4%B8%8Emap"><span class="toc-text">7. unordered_map与map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">8. 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-text">9. 迭代器失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-list%E3%80%81slist"><span class="toc-text">10. list、slist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-uninitialized"><span class="toc-text">11. uninitialized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%AE%97%E6%B3%95"><span class="toc-text">12. 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">13. 红黑树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96"><span class="toc-text">6. 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E"><span class="toc-text">1. main函数执行前后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8C%87%E9%92%88%E7%9A%84sizeof"><span class="toc-text">2. 指针的sizeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-C-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-text">3. C++的类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-text">4. 零拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text">5. 内存对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">6. 编译、连接和模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-C-C-%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E4%B8%8E%E6%B5%81"><span class="toc-text">7. C&#x2F;C++的输入输出缓冲与流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">8. 引用传参&#x2F;返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-C-%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">9. C++标准库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">10. 回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">11. C++从代码到可执行程序的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-text">1. 预编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91"><span class="toc-text">2. 编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B1%87%E7%BC%96"><span class="toc-text">3. 汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%93%BE%E6%8E%A5"><span class="toc-text">4. 链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">12. 垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">13. C++的内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-RAII"><span class="toc-text">14. RAII</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-i%E5%92%8Ci"><span class="toc-text">15. ++i和i++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="toc-text">16. 常引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-text">17. 乱序执行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AEC-14%E3%80%8117%E3%80%8120%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">问C++14、17、20新特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-C-14"><span class="toc-text">7. C++ 14</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-auto%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-text">1. auto函数返回值类型推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E6%9D%BF"><span class="toc-text">2. 模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-constexpr"><span class="toc-text">3. constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-deprecated"><span class="toc-text">4. [[deprecated]]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-text">5. 分隔符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-make-unique"><span class="toc-text">6. make_unique</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%AF%BB%E5%86%99%E9%94%81shared-timed-mutex"><span class="toc-text">7. 读写锁shared_timed_mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-integer-sequence"><span class="toc-text">8. integer_sequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-exchange"><span class="toc-text">9. exchange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-quoted"><span class="toc-text">10. quoted</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-C-17"><span class="toc-text">8. C++ 17</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC"><span class="toc-text">1. 构造函数模板自动推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="toc-text">2. 结构化绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">3. 折叠表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-has-include"><span class="toc-text">4. __has_include</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-attribute"><span class="toc-text">5. attribute</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="toc-text">6. 字符串转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-variant"><span class="toc-text">7. variant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-optional"><span class="toc-text">8. optional</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-any"><span class="toc-text">9. any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-make-from-tuple"><span class="toc-text">10. make_from_tuple</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-string-view"><span class="toc-text">11. string_view</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-monostate"><span class="toc-text">12. monostate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-scoped-lock"><span class="toc-text">13. scoped_lock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-C-20"><span class="toc-text">9. C++ 20</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-module"><span class="toc-text">1. module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ranges"><span class="toc-text">2. ranges</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%8F%E7%A8%8Bcoroutine"><span class="toc-text">3. 协程coroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-co-await"><span class="toc-text">1. co_await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-co-return"><span class="toc-text">2. co_return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-co-yield"><span class="toc-text">3. co_yield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B"><span class="toc-text">4. 示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-concept"><span class="toc-text">4. concept</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-requires"><span class="toc-text">5. requires</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E7%BA%A6%E6%9D%9F"><span class="toc-text">1. 简单约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">2. 类型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B5%8C%E5%A5%97%E7%BA%A6%E6%9D%9F"><span class="toc-text">3. 嵌套约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%90%8C%E6%AD%A5%E5%BA%93%E6%96%B0%E5%A2%9E"><span class="toc-text">6. 同步库新增</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore"><span class="toc-text">1. 信号量semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-atomic%E6%96%B0%E5%A2%9E"><span class="toc-text">2. atomic新增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%81%E5%AD%98%E5%99%A8latch"><span class="toc-text">3. 锁存器latch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-barrier"><span class="toc-text">4. barrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-jthread"><span class="toc-text">5. jthread</span></a></li></ol></li></ol></li></ol> -->
        <div class="toc"></div>
      </div>
    </div>
  </div>
</section>
<!-- 手机端目录按钮 -->
<div id="toc-mobile-btn">
  <i class="fas fa-list-ul" aria-hidden="true"></i>
</div>

      
  <section class="widget side_recent_post">
    
  <header>
    
      <a style="color: " href='/tags/'><i class="fas fa-book fa-fw" aria-hidden="true"></i><span class='name'>最新文章</span></a>
    
  </header>


    <div class='content'>
      
      <!-- hash算法 -->
      
      <div class="aside-list">
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-2/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-20</span>
                
              </div>
              <a class="post-title" href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-2/">项目学习-CMU-15-445-Lab1-2</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-1/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-19</span>
                
              </div>
              <a class="post-title" href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-1/">项目学习-CMU-15-445-Lab1-1</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab0/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-19</span>
                
              </div>
              <a class="post-title" href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab0/">项目学习-CMU-15-445-Lab0</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Shell%E7%BC%96%E7%A8%8B/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-18</span>
                
              </div>
              <a class="post-title" href="/2023/03/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Shell%E7%BC%96%E7%A8%8B/">学习笔记-Shell编程</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SQL%E8%AF%AD%E6%B3%95/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://picx.zhimg.com/80/v2-b44931ea513e5f7b3b06f2703f79653c_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-b44931ea513e5f7b3b06f2703f79653c_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-16</span>
                
              </div>
              <a class="post-title" href="/2023/03/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SQL%E8%AF%AD%E6%B3%95/">学习笔记-SQL语法</a>
            </div>
          </div>
        
      </div>
    </div>
  </section>

    
  </div>
</aside>

  <!-- 图片放大 Wrap images with fancybox support -->
  <script src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || 'rgba(66, 185, 133, 0.8)';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          
            <!-- 不蒜子统计 -->
            <!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
      <i class="fas fa-eye" aria-hidden="true"></i>本站总访问量：<span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
      <i class="fas fa-users" aria-hidden="true"></i>本站访客数：<span id="busuanzi_value_site_uv"></span> 人
</span>

          
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark">
  <div class="dark-content">
    <i class="fas fa-moon" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-moon" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    

    <!-- 图片放大 -->
    
      <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    
      <script type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<!-- <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -70,
    // headingsOffset: -($(window).height() * 0.4 - 45),
    headingsOffset: -($(window).height() * 0.4 - 70),
    // positionFixedSelector: '.toc-main',
    // positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    orderedList: true,
    collapseDepth: 20,
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 150) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('side_toc')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  /* .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  } */
</style>
 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 渲染远程json加载的图片标签(getPhotoOnline)里的内容 -->
<script>
  function loadPhotoOnlineJS() {
    if ($(".post-detail").find(".getJsonPhoto-api").length == 0) {
      return;
    } 
    loadScript('/js/getPhotoOnline/index.js');
  };
  $(function () {
    loadPhotoOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getPhotoJson == "undefined") {
      loadPhotoOnlineJS();
    }
  })
</script>

<!-- 渲染远程json加载的site-card标签(getSiteOnline)里的内容 -->
<script>
  function loadSiteOnlineJS() {
    if ($(".post-detail").find(".getJsonSite-api").length == 0) {
      return;
    } 
    loadScript('/js/getSiteOnline/index.js');
  };
  $(function () {
    loadSiteOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getSiteJson == "undefined") {
      loadSiteOnlineJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
    <script type="text/javascript">
  var utteranceCommon = {};

  function check_utterance() {
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    if (isDark) {
      utteranceCommon.Theme = 'github-dark';
    } else {
      utteranceCommon.Theme = 'github-light';
    }

    return document.getElementById("gitment-container");
  }
  comment_el = '#gitment-container';
  load_utterance = function () {
    if ($(comment_el).length) {
      // 匿名函数，防止污染全局变量
      const HEAD = check_utterance();

      var utterances = document.createElement('script');
      utterances.type = 'text/javascript';
      utterances.async = true;
      utterances.setAttribute('issue-term', 'pathname')
      utterances.setAttribute('theme', utteranceCommon.Theme)
      utterances.setAttribute('repo', '')
      utterances.crossorigin = 'anonymous';
      utterances.src = 'https://utteranc.es/client.js';
      // content 是要插入评论的地方
      document.getElementById('gitment-container').appendChild(utterances);

    }
  }

  function dark_utterance() {
    const HEAD = check_utterance();
    if (!HEAD) return;
    const message = {
      type: 'set-theme',
      theme: utteranceCommon.Theme
    };
    const utteranceIframe = document.querySelector('iframe');
    utteranceIframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }

  $(document).ready(load_utterance);
  document.addEventListener('pjax:complete', function () {
    load_utterance();
  });

  $('.dark').click(function () {
    setTimeout(() => {
      dark_utterance();
    });
  })

</script>

<style>
  .utterances {
    max-width: inherit !important;
  }
</style>
  


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


<!-- 轮播图标签 -->
<script>
  var bambooSwiperTag = {};
  function load_swiper() {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    loadCSS("https://unpkg.com/swiper@6/swiper-bundle.min.css")
    loadScript("https://unpkg.com/swiper@6/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    bambooSwiperTag.swiper = new Swiper('.post-swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      autoplay: true ? {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false,
      } : false,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
      on:{
        init: function(){
          swiperAnimateCache(this); //隐藏动画元素 
          swiperAnimate(this); //初始化完成开始动画
        }, 
        slideChangeTransitionEnd: function(){ 
          swiperAnimate(this); //每个slide切换结束时也运行当前slide动画
          //this.slides.eq(this.activeIndex).find('.ani').removeClass('ani'); 动画只展现一次，去除ani类名
        } 
      }
    });
  }

  document.addEventListener('pjax:complete', function () {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    if (typeof bambooSwiperTag.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>
    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  </body>
</html>