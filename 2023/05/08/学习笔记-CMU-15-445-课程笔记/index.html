<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>学习笔记-CMU-15-445-课程笔记 | 摩卡&#39;s blog</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/icons/icon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    <link href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css" rel="stylesheet">
  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script defer src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    
    
    <!-- 依赖于jquery和vue -->
    
        <script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>
    

    
        <script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>
    

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="摩卡's blog" type="application/atom+xml">
</head>

  
  <!-- 预加载动画 -->
  <!-- 页面预加载动画 -->

  
    <div class="preloader_2" id="loader">
  <div class="loader"></div>
</div>

  
<script>
  var endLoading = function () {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('DOMContentLoaded',endLoading);
</script>

  <body>
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (src) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header  " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
      <h3 class="drawer-box-head_title">摩卡&#39;s blog</h3>
      <h5 class="drawer-box-head_desc">随便写写，记录下都看了些啥</h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
        </div>
      
      <a href="/" class="logo">摩卡&#39;s blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
    <div id="he-plugin-simple"></div>
    <script>
      WIDGET = {
        CONFIG: {
          "modules": "012",
          "background": 5,
          "tmpColor": "4A4A4A",
          "tmpSize": 16,
          "cityColor": "4A4A4A",
          "citySize": 16,
          "aqiSize": 16,
          "weatherIconSize": 24,
          "alertIconSize": 18,
          "padding": "10px 10px 10px 10px",
          "shadow": "1",
          "language": "auto",
          "borderRadius": 5,
          "fixed": "false",
          "vertical": "middle",
          "horizontal": "center",
          "key": "2784dd3fcb1e4f0f9a9b579bf69641f2"
        }
      }
    </script>
    <script defer src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script> 
    
</header>
        <!-- 内容区域 -->
        
 <!-- prismjs 代码高亮 -->
 


<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        学习笔记-CMU-15-445-课程笔记
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2023-05-08 |
        </span>
      

      
        <span class="post-detail-header_categories">
          <i class="iconfont iconbookmark1"></i> 分类：
          
            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-detail-header_category">
              学习笔记
            </a>
          
        </span>
      

      
    
  </div>
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content post-row" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <h1 id="1-SQL语言"><a href="#1-SQL语言" class="headerlink" title="1. SQL语言"></a>1. SQL语言</h1><p>SQL分为三类命令：</p>
<ul>
<li>数据操作语言DML：SELECT、INSERT、UPDATE、DELETE。</li>
<li>数据定义语言DDL：定义表、索引、视图等对象。</li>
<li>数据控制语言：安全控制等。</li>
</ul>
<h1 id="2-磁盘管理"><a href="#2-磁盘管理" class="headerlink" title="2. 磁盘管理"></a>2. 磁盘管理</h1><p>易失性设备：</p>
<ul>
<li>断电即失去存储的数据。</li>
<li>支持按字节寻址随机快速访问。</li>
<li>一般称为内存。</li>
</ul>
<p>非易失性设备：</p>
<ul>
<li>不需要一直通电。</li>
<li>按块/页寻址。为了读取特定偏移量的值，需要将整块/整页加载到内存中。</li>
<li>一般更易于顺序访问。</li>
<li>一般称为磁盘。</li>
</ul>
<h2 id="1-系统设计目标"><a href="#1-系统设计目标" class="headerlink" title="1. 系统设计目标"></a>1. 系统设计目标</h2><ul>
<li>允许DBMS管理超出可用内存量的数据库。</li>
<li>读写磁盘成本很高，因此必须谨慎管理，避免出现性能大幅下降与阻塞。</li>
<li>磁盘随机读写一般比顺序读写慢很多，所以应该尽量顺序读写。</li>
</ul>
<h2 id="2-基于磁盘的DBMS"><a href="#2-基于磁盘的DBMS" class="headerlink" title="2. 基于磁盘的DBMS"></a>2. 基于磁盘的DBMS</h2><ul>
<li>数据库全部存储在磁盘上，数据库的文件组织形式为页，第一页为目录页。</li>
<li>对数据进行操作时需要将数据放入内存，通过缓冲池来管理磁盘与内存之间的数据交换。</li>
<li>执行引擎负责执行查询。</li>
<li>执行引擎向缓冲池请求特定页面，缓冲池负责将页面置入内存，并为执行引擎提供指向内存中该页面的指针。</li>
</ul>
<h2 id="3-堆文件"><a href="#3-堆文件" class="headerlink" title="3. 堆文件"></a>3. 堆文件</h2><p>一组无序的页集合。</p>
<p>通过特殊的页——目录页记录堆文件中的页的使用状况，以及其他的一些元数据，如空闲页表、每页可用的slot数目等。利用目录页找到特定页在磁盘上的位置。</p>
<h2 id="4-页"><a href="#4-页" class="headerlink" title="4. 页"></a>4. 页</h2><p>一块固定大小的空间，是读写数据的基本单位。</p>
<p>三类页：</p>
<ul>
<li>硬件页（一般4KB）</li>
<li>操作系统页（4KB）</li>
<li>数据页（1-16KB）</li>
</ul>
<p>每页包含一个页头，存储页的元数据，包括：</p>
<ul>
<li>页尺寸</li>
<li>校验和</li>
<li>DBMS版本</li>
<li>事务可见性</li>
<li>压缩信息</li>
</ul>
<h2 id="5-slotted-pages-分槽页结构"><a href="#5-slotted-pages-分槽页结构" class="headerlink" title="5. slotted pages-分槽页结构"></a>5. slotted pages-分槽页结构</h2><p>页头中存储一个slot数组，数组中每一项存储每个tuple对应的offset值（tuple在页中相对于页的首地址的偏移量）和tuple的长度。</p>
<p>tuple从页尾部开始存放，slot数组则从前往后递增。二者相碰代表页面已满。</p>
<h2 id="6-tuple-元组"><a href="#6-tuple-元组" class="headerlink" title="6. tuple-元组"></a>6. tuple-元组</h2><p>元组本质上是字节序列，由DBMS将其解释为属性类型以及值。</p>
<h3 id="1-元组头"><a href="#1-元组头" class="headerlink" title="1. 元组头"></a>1. 元组头</h3><p>包含元组的元数据，如可见性信息（用于并发控制）、NULL值的位图等。</p>
<h3 id="2-数据"><a href="#2-数据" class="headerlink" title="2. 数据"></a>2. 数据</h3><p>一般按照创建表时的顺序存储。</p>
<h3 id="3-独特标识符"><a href="#3-独特标识符" class="headerlink" title="3. 独特标识符"></a>3. 独特标识符</h3><p>每个元组会被分配一个独特的标识符，一般为page_id + offset/slot。</p>
<h3 id="4-非规范化元组数据"><a href="#4-非规范化元组数据" class="headerlink" title="4. 非规范化元组数据"></a>4. 非规范化元组数据</h3><p>如果两个表相关联，DBMS可以进行预连接，把两个表放在一页中。</p>
<ul>
<li>读取速度更快，因为只需要加载一页。</li>
<li>需要为每个元组提供更多空间，更新代价变大。</li>
</ul>
<h2 id="7-日志结构化存储"><a href="#7-日志结构化存储" class="headerlink" title="7. 日志结构化存储"></a>7. 日志结构化存储</h2><p>不存储元组，只存储日志记录</p>
<ul>
<li>日志分为put和delete两种类型。</li>
<li>读取一条记录时，从新到旧扫描日志文件并重建元组。</li>
<li>读慢写快。只会顺序写入磁盘，而不修改已有数据。</li>
<li>可通过索引、定期压缩日志等方式降低读取时间。</li>
<li>可将日志压缩为按id排序的表SSTtables，加快元组搜索。<ul>
<li>最终会出现写放大问题。</li>
</ul>
</li>
</ul>
<h1 id="3-数据表示"><a href="#3-数据表示" class="headerlink" title="3. 数据表示"></a>3. 数据表示</h1><p>数据表示方案，即DBMS如何解释元组不同位置的字节，导出属性的值。</p>
<h2 id="1-Integers"><a href="#1-Integers" class="headerlink" title="1. Integers"></a>1. Integers</h2><p>整型，固定长度。</p>
<p>如：INTEGER、BIGINT、SMALLINT、TINYINT</p>
<h2 id="2-Variable-Precision-Numbers"><a href="#2-Variable-Precision-Numbers" class="headerlink" title="2. Variable Precision Numbers"></a>2. Variable Precision Numbers</h2><p>不精确、可变精度的数字类型，固定长度。</p>
<p>计算时带有舍入误差。</p>
<p>如：FLOAT、REAL</p>
<h2 id="3-Fixed-Point-Precision-Numbers"><a href="#3-Fixed-Point-Precision-Numbers" class="headerlink" title="3. Fixed-Point Precision Numbers"></a>3. Fixed-Point Precision Numbers</h2><p>具有任意精度和比例的数字类型，通常以精确、可变长度的二进制表示存储，并带有额外元数据，指示数据长度与小数点位置。</p>
<p>当舍入误差不可接受时，使用该种数据类型，代价是性能。</p>
<p>如：NUMERIC、DEMICAL</p>
<h2 id="4-Variable-Length-Data"><a href="#4-Variable-Length-Data" class="headerlink" title="4. Variable-Length Data"></a>4. Variable-Length Data</h2><p>任意长度的数据类型，通常与一个跟踪字符串长度的标头一起存储，以便跳到下一个值，以及可能的数据校验和。</p>
<p>可以将该数据存储在其他空间，甚至是外部文件中，数据库元组中只存储指向该数据的指针。</p>
<p>如：VARCHAR、VARBINARY、TEXT、BLOB</p>
<h2 id="5-Dates-and-Times"><a href="#5-Dates-and-Times" class="headerlink" title="5. Dates and Times"></a>5. Dates and Times</h2><p>如：TIME、DATE、TIMESTAMP</p>
<h2 id="6-System-Catalogs"><a href="#6-System-Catalogs" class="headerlink" title="6. System Catalogs"></a>6. System Catalogs</h2><p>DBMS维护一个内部目录存储元数据，用于解码元组的内容。</p>
<p>该内部目录包括数据库含有的表与列，以及其类型、排列顺序。</p>
<h1 id="4-数据库工作方式"><a href="#4-数据库工作方式" class="headerlink" title="4. 数据库工作方式"></a>4. 数据库工作方式</h1><h2 id="1-OLTP-Online-Transaction-Processing"><a href="#1-OLTP-Online-Transaction-Processing" class="headerlink" title="1. OLTP-Online Transaction Processing"></a>1. OLTP-Online Transaction Processing</h2><p>特点：快速短时间运行的操作、单次在单个实体上操作的简单查询、重复操作。通常更多处理写入。</p>
<p>例子：用户将物品添加到购物车中，或进行购买。</p>
<h2 id="2-OLAP-Online-Analytical-Processing"><a href="#2-OLAP-Online-Analytical-Processing" class="headerlink" title="2. OLAP-Online Analytical Processing"></a>2. OLAP-Online Analytical Processing</h2><p>特点：对数据库大量数据进行长时间、复杂的查询和读取。一般从OLTP端收集的现有数据中分析和导出新数据。</p>
<p>例子：计算特定的一天某个城市购买量最大的商品。</p>
<h2 id="3-HTAP-Hybrid-Transaction-Analytical-Processing"><a href="#3-HTAP-Hybrid-Transaction-Analytical-Processing" class="headerlink" title="3. HTAP-Hybrid Transaction + Analytical Processing"></a>3. HTAP-Hybrid Transaction + Analytical Processing</h2><p>在同一个数据库上结合OLTP与OLAP</p>
<h1 id="5-存储模型"><a href="#5-存储模型" class="headerlink" title="5. 存储模型"></a>5. 存储模型</h1><h2 id="1-NSM-n元存储模型"><a href="#1-NSM-n元存储模型" class="headerlink" title="1. NSM-n元存储模型"></a>1. NSM-n元存储模型</h2><p>按行存储，将单个元组所有属性连续存储在单个页面中。</p>
<p>适合OLTP这种请求量大、事务一般只在单个实体中操作的工作场景，因为只需要一次访问就能获得单个元组所有数据。</p>
<ul>
<li>优点：快速增删改、适合需要整个元组的查询。</li>
<li>缺点：不适合访问一部分元组、或是扫描表的大部分。</li>
</ul>
<h2 id="2-DSM-分解存储模型"><a href="#2-DSM-分解存储模型" class="headerlink" title="2. DSM-分解存储模型"></a>2. DSM-分解存储模型</h2><p>按列存储。</p>
<p>适合OLAP这种对表的属性子集进行大规模扫描的工作场景。</p>
<ul>
<li>优点：减少IO浪费，只读取需要的数据；适合查询处理和数据压缩。</li>
<li>缺点：由于元组拆分/缝合，增删改较慢，需要在每一列中分别找到对应位置。</li>
</ul>
<p>如果想重新组合元组：</p>
<ul>
<li>固定长度偏移：不同列中相同偏移量的值来自同一元组。要求列的每个值长度相同。</li>
<li>嵌入式元组ID：存储一个映射，表示如何跳转到某个id的元组的每个属性。存储开销很大。</li>
</ul>
<h1 id="6-数据压缩"><a href="#6-数据压缩" class="headerlink" title="6. 数据压缩"></a>6. 数据压缩</h1><p>数据如果是完全随机，没法压缩，但是现实生活中数据的特点使得压缩成为可行：</p>
<ul>
<li>属性值往往有高度倾斜的分布。</li>
<li>同一元组内的不同属性往往强关联。（邮政编码与城市）</li>
</ul>
<p>数据压缩要求：</p>
<ul>
<li>必须生成固定长度的值。因为DBMS需要能使用偏移量访问数据。</li>
<li>允许DBMS查询期间尽可能长时间地推迟解压缩。</li>
<li>必须是无损压缩。</li>
</ul>
<p>压缩粒度：</p>
<ul>
<li>块级别：压缩同一个表中的元组块。</li>
<li>元组级别：压缩一个元组中的内容（仅限行存储）。</li>
<li>属性级别：将多个属性值作为一个压缩到元组中。</li>
<li>列级别：压缩多个元组的相同列中的值（仅限列存储）。</li>
</ul>
<h2 id="1-列压缩方案"><a href="#1-列压缩方案" class="headerlink" title="1. 列压缩方案"></a>1. 列压缩方案</h2><h3 id="1-Run-Length-Encodin-RLE"><a href="#1-Run-Length-Encodin-RLE" class="headerlink" title="1. Run-Length Encodin RLE"></a>1. Run-Length Encodin RLE</h3><p>将一列中的相同元素压缩为三元组：</p>
<ul>
<li>属性值</li>
<li>属性在列区间的起始位置</li>
<li>元素数</li>
</ul>
<p>为了最大程度压缩，应该先对列排序。</p>
<h3 id="2-Bit-Packing-Encoding"><a href="#2-Bit-Packing-Encoding" class="headerlink" title="2. Bit-Packing Encoding"></a>2. Bit-Packing Encoding</h3><p>属性值小于值声明的最大值时，将其存储为更小的数据类型</p>
<h3 id="3-Mostly-Encoding"><a href="#3-Mostly-Encoding" class="headerlink" title="3. Mostly Encoding"></a>3. Mostly Encoding</h3><p>基于2，使用一个特殊标记指示值何时超过最大值，然后维护一个查找表存储它们。</p>
<h3 id="4-Bitmap-Encoding"><a href="#4-Bitmap-Encoding" class="headerlink" title="4. Bitmap Encoding"></a>4. Bitmap Encoding</h3><p>为特定属性的每个唯一值设置一个单独的位图。位图第i位表示表中第i个元组。</p>
<p>仅适用于不同值得数目较少的属性。</p>
<h3 id="5-Delta-Encoding"><a href="#5-Delta-Encoding" class="headerlink" title="5. Delta Encoding"></a>5. Delta Encoding</h3><p>不存储具体值，而是存储与某个值的差。（一般用于较大值的列，转化后再使用2压缩）</p>
<h3 id="6-Incremental-Encoding"><a href="#6-Incremental-Encoding" class="headerlink" title="6. Incremental Encoding"></a>6. Incremental Encoding</h3><p>记录常见的前后缀与长度，再进行压缩。</p>
<p>对已排序的数据最有效。</p>
<h3 id="7-Dictionary-Compression"><a href="#7-Dictionary-Compression" class="headerlink" title="7. Dictionary Compression"></a>7. Dictionary Compression</h3><p>字典编码，最常见的数据库压缩方案。用较小的值对常见的值进行编码（类似于霍夫曼编码）。需要支持快速编码/解码以及范围查询，即编码后的值排序顺序跟原始值相同。</p>
<h1 id="7-缓冲池"><a href="#7-缓冲池" class="headerlink" title="7. 缓冲池"></a>7. 缓冲池</h1><p>缓冲池负责数据在内存与磁盘之间的移动，对数据进行封装，让执行引擎看起来数据全部在内存中，不必担心数据如何取到内存中。</p>
<h2 id="1-lock-amp-latch"><a href="#1-lock-amp-latch" class="headerlink" title="1. lock &amp; latch"></a>1. lock &amp; latch</h2><p>锁：</p>
<ul>
<li>更高级的逻辑原语。</li>
<li>保护数据库内容（元组、表、数据库）不受其他事务影响。</li>
<li>事务在其整个持续时间内持有锁。</li>
<li>数据库系统可以在运行时向用户公开持有的锁。</li>
<li>需要能回滚更改。</li>
</ul>
<p>latch：</p>
<ul>
<li>低级保护原语。</li>
<li>用于内部结构的关键部分（哈希表、内存区域）。</li>
<li>仅在进行操作期间保持。</li>
<li>不需要能回滚更改。</li>
</ul>
<h2 id="2-缓冲池"><a href="#2-缓冲池" class="headerlink" title="2. 缓冲池"></a>2. 缓冲池</h2><p>从磁盘读取的页面在内存中的缓存。本质上是数据库内部分配的一块内存区域，用于存储从磁盘获取的页面。</p>
<p>内存区域组织为固定大小页面的数组，每个数组条目称为一个帧。</p>
<ul>
<li>当请求磁盘页时，会先在缓冲池中找对应的帧。</li>
<li>如果缓冲池找不到磁盘页对应的帧，系统从磁盘中获取页面的副本，缓存在帧中。</li>
<li>如果要读入新页时缓冲池已满，会淘汰一个帧，并发生写回。</li>
<li>如果发生写事件，会将缓冲池的帧标记为脏页。</li>
</ul>
<h2 id="3-缓冲池的元数据"><a href="#3-缓冲池的元数据" class="headerlink" title="3. 缓冲池的元数据"></a>3. 缓冲池的元数据</h2><ul>
<li>页id到缓冲池帧的映射</li>
<li>每页的元数据：<ul>
<li>脏标记</li>
<li>引用数</li>
</ul>
</li>
</ul>
<h2 id="4-IO策略"><a href="#4-IO策略" class="headerlink" title="4. IO策略"></a>4. IO策略</h2><p>大多数DBMS使用直接IO绕过操作系统缓存，避免页面冗余副本，以及管理不同的淘汰策略。</p>
<h2 id="5-缓冲池页面替换策略"><a href="#5-缓冲池页面替换策略" class="headerlink" title="5. 缓冲池页面替换策略"></a>5. 缓冲池页面替换策略</h2><h3 id="1-LRU"><a href="#1-LRU" class="headerlink" title="1. LRU"></a>1. LRU</h3><p>为每页维护一个时间戳，淘汰时选择最久未使用的页面淘汰。</p>
<p>实际使用时可通过list实现。</p>
<h3 id="2-CLOCK"><a href="#2-CLOCK" class="headerlink" title="2. CLOCK"></a>2. CLOCK</h3><p>FIFO与LRU的结合版。页面放在一个环上，每页赋予一个参考位，访问时设置为1。</p>
<p>指针从上次位置顺时针转动，碰到页：</p>
<ul>
<li>参考位为1，设置为0。</li>
<li>参考位为0，选择该页淘汰。</li>
</ul>
<h3 id="3-LRU与CLOCK存在的问题"><a href="#3-LRU与CLOCK存在的问题" class="headerlink" title="3. LRU与CLOCK存在的问题"></a>3. LRU与CLOCK存在的问题</h3><p>顺序洪泛：顺序扫描大量数据一次，会导致数据在缓冲池的大量进出，无法反映我们实际想要的页面。即最近使用的页面实际上是最不需要的。</p>
<p>一些改进：</p>
<h4 id="1-LRU-K"><a href="#1-LRU-K" class="headerlink" title="1. LRU-K"></a>1. LRU-K</h4><p>页访问超过K次，才能进入LRU活跃队列，否则按照距离第一次访问的间隔淘汰。</p>
<h4 id="2-对每个查询特化"><a href="#2-对每个查询特化" class="headerlink" title="2. 对每个查询特化"></a>2. 对每个查询特化</h4><p>根据每个事务/查询选择需要回收的页面，从而最大限度减少每次查询对缓冲池的污染。</p>
<h4 id="3-优先级提示"><a href="#3-优先级提示" class="headerlink" title="3. 优先级提示"></a>3. 优先级提示</h4><p>允许事务在查询期间根据每个页面上下文，告诉缓冲池页面是否重要。</p>
<h3 id="4-脏页淘汰策略"><a href="#4-脏页淘汰策略" class="headerlink" title="4. 脏页淘汰策略"></a>4. 脏页淘汰策略</h3><ul>
<li>淘汰时写回。</li>
<li>尽量不淘汰脏页，转而淘汰其他页。</li>
<li>可通过后台写入策略尽量避免写回。DBMS后台线程定期遍历页面，将脏页写入磁盘；当脏页被写回时，可以选择收回该页或取消脏标记。</li>
</ul>
<h1 id="8-哈希表"><a href="#8-哈希表" class="headerlink" title="8. 哈希表"></a>8. 哈希表</h1><h2 id="1-组成部分"><a href="#1-组成部分" class="headerlink" title="1. 组成部分"></a>1. 组成部分</h2><ul>
<li>哈希函数：将大的键空间映射到一个较小的域，用于计算桶或槽数组的索引。需要考虑执行速度和碰撞几率之间的权衡。</li>
<li>哈希策略：在碰撞之后如何处理键冲突。需要考虑两种减少冲突方式：增大哈希表空间与发生冲突时执行额外指令处理冲突之间的权衡。</li>
</ul>
<h2 id="2-哈希函数"><a href="#2-哈希函数" class="headerlink" title="2. 哈希函数"></a>2. 哈希函数</h2><p>接受任何值作为输入（key），输出对应的整数表示（哈希值），相同的键总应该得到相同的输入。</p>
<p>注重速率与碰撞率。</p>
<h2 id="3-静态哈希策略"><a href="#3-静态哈希策略" class="headerlink" title="3. 静态哈希策略"></a>3. 静态哈希策略</h2><p>哈希表的大小固定。如果哈希表已满，只能申请新空间后，将原有数据复制过去。一般事先得知要插入的数据量，并申请双倍的空间。</p>
<p>为了减少多余的比较次数，需要尽量避免散列冲突。</p>
<h3 id="1-线性探测法"><a href="#1-线性探测法" class="headerlink" title="1. 线性探测法"></a>1. 线性探测法</h3><p>发生碰撞时，搜索下一个槽，直到找到一个能用的槽，或遍历所有槽。</p>
<p>通常是最快的，但是存在两个问题：</p>
<ul>
<li>存数据时必须将key也存入，因为某个位置放的数据并不一定是它的key哈希直接得到的。</li>
<li>删除数据可能会导致线性探测中断，进而无法探测到已有数据：<ul>
<li>不实际删除，而是放一个删除标记。</li>
<li>删除数据后移动相邻的槽。操作复杂，较少实现。</li>
</ul>
</li>
</ul>
<p>存在相同键时：</p>
<ul>
<li>开链法。</li>
<li>冗余键：将相同的键同样存在哈希表中，线性探测法仍然有效。</li>
</ul>
<h3 id="2-Robin-Hood-Hashing"><a href="#2-Robin-Hood-Hashing" class="headerlink" title="2. Robin Hood Hashing"></a>2. Robin Hood Hashing</h3><p>基于线性探测法的拓展。</p>
<p>计算待插入数据当前探测位置距离其原本哈希位置的距离，并与当前探测位置存储数据的距离比较。如果待插入数据的距离较短，则将待插入数据替换为当前探测位置的数据，继续探测。</p>
<h3 id="3-Cuckoo-Hashing"><a href="#3-Cuckoo-Hashing" class="headerlink" title="3. Cuckoo Hashing"></a>3. Cuckoo Hashing</h3><p>使用多个哈希函数构建多个哈希表。</p>
<p>插入时检查每个表，根据负载因子等选择一个有剩余空间的表，或是随机选择一个表。如果没有表有空间，一般随机取出一个旧表项，并将其散列到另一个表中。可能会陷入循环，这时候一般重新构建更大的哈希表。</p>
<p>查询与删除较为高效，但是插入代价可能较高。</p>
<h2 id="4-动态哈希策略"><a href="#4-动态哈希策略" class="headerlink" title="4. 动态哈希策略"></a>4. 动态哈希策略</h2><p>根据需要重新调整哈希表大小，而无需重构整个表。</p>
<h3 id="1-开链法"><a href="#1-开链法" class="headerlink" title="1. 开链法"></a>1. 开链法</h3><h3 id="2-可拓展哈希"><a href="#2-可拓展哈希" class="headerlink" title="2. 可拓展哈希"></a>2. 可拓展哈希</h3><p>详见Lab1-1实验记录</p>
<h3 id="3-线性哈希"><a href="#3-线性哈希" class="headerlink" title="3. 线性哈希"></a>3. 线性哈希</h3><p>实现复杂且效率不高，一般用于高响应度系统中。</p>
<p>具体可看：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jackydai987/article/details/6673063">https://blog.csdn.net/jackydai987/article/details/6673063</a></p>
<h1 id="9-索引"><a href="#9-索引" class="headerlink" title="9. 索引"></a>9. 索引</h1><p>索引是表的某几列，通过对这些列进行排序建立表的索引表，来访问表中的元组。一般用在对这些列需要进行频繁范围查找的场合。</p>
<p>建立的索引数量存在权衡。索引表的数目增加，会导致查询速度变快，但是额外消耗的空间增加，且更新表需要同步更新每个索引表，更新代价变大。</p>
<p>一般使用B+树实现索引表。</p>
<h2 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1. B+树"></a>1. B+树</h2><p>多路搜索树。一种自平衡树结构，保持数据有序且在logn时间复杂度进行增删改查，以及顺序访问。</p>
<ul>
<li>M路搜索树，即一个节点最多有M个子节点。</li>
<li>完全平衡，即所有叶子节点都是相同深度。</li>
<li>每个内部节点的key数量在[M / 2 - 1, M - 1]之间。</li>
<li>每个有k个key的内部节点有k + 1个非空子节点。</li>
<li>叶子节点之间通过链表相连。</li>
</ul>
<p>键所对应的值：</p>
<ul>
<li>内部节点的值是指向对应子节点的指针。</li>
<li>叶子节点的值是元组数据，或是表的元组id。</li>
</ul>
<h3 id="1-插入"><a href="#1-插入" class="headerlink" title="1. 插入"></a>1. 插入</h3><ul>
<li>根据搜索树性质向下遍历，找到应该插入的叶子节点L。</li>
<li>在L的对应位置插入新的键值对<ul>
<li>如果插入后满足key数量的约束，操作结束。</li>
<li>否则，将L分裂为两个节点L1与L2。将L的键值对均匀分配到L1、L2中，并在L的父节点中插入一条新的键值对，用于指示L1、L2。</li>
</ul>
</li>
<li>L的父节点的插入也可能引起分裂，通过递归向上插入。</li>
</ul>
<h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h3><ul>
<li><p>根据搜索树性质向下遍历，找到删除项所在的叶子节点L。</p>
</li>
<li><p>找到删除项在L中的位置</p>
<ul>
<li>如果删除后满足key数量的约束，操作结束。</li>
<li>否则，尝试重新分配，即把左兄弟最后一个键值对或右兄弟第一个键值对借过来，以满足ke数量约束。同时调整父节点对应位置的key。</li>
<li>如果重新分配失败，即左右兄弟如果借键值对后也不满足key数量约束，尝试合并L与左兄弟或右兄弟，并删除L的父节点对应的key。</li>
</ul>
</li>
<li><p>L的父节点的删除也可能引起再分配或合并，通过递归向上删除。</p>
</li>
</ul>
<h3 id="3-查找"><a href="#3-查找" class="headerlink" title="3. 查找"></a>3. 查找</h3><p>单个查找：效率略高于传统二叉树，因为key更多，导致树更扁平，平均查找次数更少。</p>
<p>范围查找：查找到范围内第一个值后，可以通过叶子节点间的链表，遍历所有范围内的节点。</p>
<h2 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2. 并发控制"></a>2. 并发控制</h2><h2 id="1-Latch的实现方式"><a href="#1-Latch的实现方式" class="headerlink" title="1. Latch的实现方式"></a>1. Latch的实现方式</h2><h3 id="1-Blocking-OS-Mutex"><a href="#1-Blocking-OS-Mutex" class="headerlink" title="1. Blocking OS Mutex"></a>1. Blocking OS Mutex</h3><p>由操作系统内置的互斥结构实现。Linux提供了futex，由：</p>
<ul>
<li>用户空间中的latch</li>
<li>操作系统级的mutex</li>
</ul>
<p>组成。DBMS获得latch的步骤：</p>
<ul>
<li>获取用户空间latch</li>
<li>如果未能获取latch，进入内核空间获取代价更高的mutex</li>
<li>如果未能获取mutex，线程被阻塞</li>
</ul>
<p>cpp的mutex为该种实现方式。</p>
<p>优点：使用简单，DBMS不需要额外编码。</p>
<p>缺点：代价高且不可拓展。</p>
<h3 id="2-Test-and-Set-Spin-Latch-TAS"><a href="#2-Test-and-Set-Spin-Latch-TAS" class="headerlink" title="2. Test-and-Set Spin Latch (TAS)"></a>2. Test-and-Set Spin Latch (TAS)</h3><p>自旋latch，本质上是内存中线程试图更新的位置。</p>
<p>线程执行CAS以尝试更新指定的内存位置，DBMS可控制如果未能获得latch的行为，如重试、或取消该操作。</p>
<p>cpp的atomic为该种实现方式</p>
<p>优点：加锁解锁高效。</p>
<p>缺点：自选浪费cpu；不支持缓存，会出现缓存一致性问题。</p>
<h3 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3. 读写锁"></a>3. 读写锁</h3><p>cpp的shared_mutex为该种实现方式。</p>
<p>优点：允许读者并发。</p>
<p>缺点：DBMS必须管理读写队列避免饥饿；需要额外元数据记录读写线程数，存储开销大于自旋锁。</p>
<h2 id="2-B-树并发控制"><a href="#2-B-树并发控制" class="headerlink" title="2. B+树并发控制"></a>2. B+树并发控制</h2><p>B+树并发面临的两个问题：</p>
<ul>
<li>多个线程同时尝试修改某个节点的内容。</li>
<li>一个线程遍历树，同时另一个线程改变树结构。</li>
</ul>
<p>并发控制基本思想：</p>
<ul>
<li>获得父节点的latch。</li>
<li>获得子节点的latch。</li>
<li>如果子节点是“安全的”，释放父节点的latch。安全，即为在进行对应的操作后，不会触发树结构改变操作。<ul>
<li>如果是插入操作，子节点key数目必须小于最大数目。即在插入一个key后不会触发分裂。</li>
<li>如果是删除操作，子节点key数目必须大于最小数目。即在删除一个节点后不会触发再分配、合并。</li>
</ul>
</li>
</ul>
<p>基础的并发控制：</p>
<ul>
<li>读：从根节点开始往下查找，获得子节点的S latch后，即释放父节点的S latch。</li>
<li>写：从根节点开始往下查找，获得X latch。子节点被锁住后，检查其是否安全，如果安全，则释放所有祖先节点上的latch。</li>
</ul>
<p>问题：内部节点使用X latch过于保守，降低并发能力。</p>
<p>改进的并发控制：</p>
<ul>
<li>读：相同。</li>
<li>写：内部节点设置S latch，叶子节点设置X latch。如果叶子节点不安全，则释放所有的latch，并按照基础并发控制的操作重新设置latch。</li>
</ul>
<p>叶节点链表扫描出现的死锁：不同线程从不同方向遍历叶节点链表，试图从不同方向对同一节点获取锁时，索引锁不支持死锁检测。</p>
<ul>
<li>B与C是两个相邻的叶节点。</li>
<li>t1持有B的R锁，从B遍历到C，试图获取C的R锁。除非获取到C的R锁，否则t1不会释放B的R锁。</li>
<li>t2持有C的R锁，从C遍历到B，试图获取B的R锁。除非获取到B的R锁，否则t2不会释放C的R锁。</li>
<li>t1、t2都在等待对方释放，造成死锁。</li>
</ul>
<p>latch不支持死锁检测，所以只能从编码规则层面避免死锁。</p>
<p>必须支持无等待获取锁，即获取失败时进行异常处理，比如重启事务并再次操作。</p>
<p>解决方法：一般不允许相反方向的遍历。</p>
<h1 id="11-排序"><a href="#11-排序" class="headerlink" title="11. 排序"></a>11. 排序</h1><p>在order by、group by、join和distinct关键字的场合，需要排序。</p>
<p>需要排序的数据都能装进内存中：可使用标准排序算法，如快排。</p>
<p>需要排序的数据不能全部装进内存：外部排序算法，一般是外部归并排序。</p>
<ul>
<li>排序：一次取出能装进内存的数量的数据，排序后写回磁盘。</li>
<li>归并：将排序好的子文件合并为整个大文件。</li>
</ul>
<p>二路归并排序：从磁盘读取两个排序的页面，将它们合并到第三个缓冲页面中；每当第三页被填满，就写回磁盘，并被替换为一个空页。</p>
<p>实际上，内存不可能只容纳3块，所以有N路归并排序。</p>
<p>如果排序的列有聚簇索引，可以直接用索引树排序；如果是非聚簇索引，因为存在回表，所以使用索引树的代价反而大于排序。</p>
<h1 id="12-聚集"><a href="#12-聚集" class="headerlink" title="12. 聚集"></a>12. 聚集</h1><p>将一个或多个元组的值折叠为单个标量值。一般有排序、散列两种方法。</p>
<h2 id="1-排序聚集"><a href="#1-排序聚集" class="headerlink" title="1. 排序聚集"></a>1. 排序聚集</h2><p>排序天然将重复值聚合到一起，然后按照重复值折叠即可。</p>
<p>如果查询需要筛选，最好先执行筛选，减少需要排序的数据量。</p>
<h2 id="2-哈希聚集"><a href="#2-哈希聚集" class="headerlink" title="2. 哈希聚集"></a>2. 哈希聚集</h2><p>有些聚集函数本身不需要排序。</p>
<ul>
<li>分类：根据目标哈希键将元组分类，分别分配到不同内存空间，输入到不同磁盘分区。</li>
<li>rehash：对每个磁盘分区，读入内存，计算聚集。</li>
</ul>
<h1 id="13-连接"><a href="#13-连接" class="headerlink" title="13. 连接"></a>13. 连接</h1><p>根据谓词条件（某些列的条件关系），将两个表中的元组组合起来形成一个表。</p>
<h2 id="1-输入形式"><a href="#1-输入形式" class="headerlink" title="1. 输入形式"></a>1. 输入形式</h2><p>直接输出数据：将两个表两两组合符合条件的所有新元组的所有数据全部放入中间结果表中。</p>
<p>输出ID：只复制连接键和匹配元组的ID到中间结果表中，要查询其他的列信息需要根据ID再去对应的表查询一次。适合列存储，因为不会查询不需要的数据。</p>
<h2 id="2-Nested-Loop-Join"><a href="#2-Nested-Loop-Join" class="headerlink" title="2. Nested Loop Join"></a>2. Nested Loop Join</h2><p>由两个嵌套for循环连接，分别遍历两个表中的元组，两两比较，如果匹配连接谓词，则输入。</p>
<p>外部for循环的表称为外表，内部for循环的表称为内表。</p>
<p>DBMS总是希望使用较小的表（元组数、页面数）作为外部表。</p>
<p>假设内表有M页、m个元组，外表有N页、n个元组。</p>
<h3 id="1-Simple-Nested-Loop-Join"><a href="#1-Simple-Nested-Loop-Join" class="headerlink" title="1. Simple Nested Loop Join"></a>1. Simple Nested Loop Join</h3><p>每次取内表一个元组，跟外表所有项依次匹配。</p>
<p>IO开销：M + m * N</p>
<h3 id="2-Block-Nested-Loop-Join"><a href="#2-Block-Nested-Loop-Join" class="headerlink" title="2. Block Nested Loop Join"></a>2. Block Nested Loop Join</h3><p>改进为每次从内表获取一个块，与外表中每个块比较。</p>
<p>IO开销：M + M * N</p>
<p>如果有大小为B的缓存池：M + M / (B - 2) * N</p>
<h3 id="3-Index-Nested-Loop-Join"><a href="#3-Index-Nested-Loop-Join" class="headerlink" title="3. Index Nested Loop Join"></a>3. Index Nested Loop Join</h3><p>数据库在join键上为其中一个表建立了索引。假设为外表建立了索引，开销为C。</p>
<p>IO开销：M + m * C</p>
<h2 id="3-Sort-Merge-Join"><a href="#3-Sort-Merge-Join" class="headerlink" title="3. Sort-Merge Join"></a>3. Sort-Merge Join</h2><p>先按照连接键对两个表分别排序，然后双指针法匹配。</p>
<p>适用于至少一个表已经按连接键有序（如索引）、输出需要按连接键排序。</p>
<p>退化：两个表连接键的值都为一个值。</p>
<h2 id="4-Hash-Join"><a href="#4-Hash-Join" class="headerlink" title="4. Hash Join"></a>4. Hash Join</h2><p>外表构建哈希表，内表每个元组使用连接键查找哈希表。</p>
<p>只能用于相等连接。</p>
<p>内表匹配时常出现匹配不上的情况，可以提前用外表构建布隆过滤器，提前过滤匹配不上的索引。（一般用于连接键是字符串等比较代价较高的情况）</p>
<h3 id="1-Grace-Hash-Join"><a href="#1-Grace-Hash-Join" class="headerlink" title="1. Grace Hash Join"></a>1. Grace Hash Join</h3><p>数据量太大无法全部装入内存时，对两个表的连接键用同样的哈希函数，将两个表中哈希值相同的元组分配到同一块空间，然后再对这块空间进行hash join。</p>
<h2 id="5-开销总结"><a href="#5-开销总结" class="headerlink" title="5. 开销总结"></a>5. 开销总结</h2><p>sort-merge和hash的方法开销少很多。</p>
<p>hash一般情况下比sort-merge好，但是在排序情况下sort-merge是必要的/效果更好的，所以两者都应使用。</p>
<h1 id="14-SQL查询过程"><a href="#14-SQL查询过程" class="headerlink" title="14. SQL查询过程"></a>14. SQL查询过程</h1><p>DBMS将SQL语句转换为查询计划，其中算子以树的形式排列。</p>
<p>数据从树的叶子节点流向根节点，根节点输出查询的结果。</p>
<h2 id="1-处理模型"><a href="#1-处理模型" class="headerlink" title="1. 处理模型"></a>1. 处理模型</h2><p>定义了系统如何执行查询计划，如计算查询计划的方向、在算子之间传递哪种数据。</p>
<h3 id="1-Iterator-Model-火山模型-管道模型"><a href="#1-Iterator-Model-火山模型-管道模型" class="headerlink" title="1. Iterator Model-火山模型/管道模型"></a>1. Iterator Model-火山模型/管道模型</h3><p>为每个算子实现 <code>Init()</code>与 <code>Next()</code>函数，类似于迭代器。</p>
<ul>
<li>查询计划中，每个节点调用其子节点的 <code>Next()</code>，直到到达叶子节点。</li>
<li>叶子节点取出数据，将元组发送给父节点处理。每次调用 <code>Next()</code>返回一个元组。如果没有数据要发送，返回空元组。</li>
<li>父节点接收到元组后，处理完该元组，向上层节点发送数据后，再调用 <code>Next()</code>。</li>
</ul>
<p>适用于基于磁盘的系统，因为允许在访问下一个元组/页面前。</p>
<p>某些算子会阻塞，直到子算子发送所有的元组，如join、order by以及子查询，称为pipeline breaker。</p>
<p>特点：</p>
<ul>
<li>最大的开销在函数调用。</li>
<li>允许流式处理，开发方便。</li>
</ul>
<h3 id="2-Materialization-Model-物化模型"><a href="#2-Materialization-Model-物化模型" class="headerlink" title="2. Materialization Model-物化模型"></a>2. Materialization Model-物化模型</h3><p>每个算子每次处理都返回所有元组，一个算子只调用一次，一次将结果全部输出。</p>
<p>特点：函数调用开销小。适用于单次查询检索数据量小的OLTP，而不适合具有大量中间结果的OLAP。</p>
<h3 id="3-Vectorization-Model-矢量化模型"><a href="#3-Vectorization-Model-矢量化模型" class="headerlink" title="3.Vectorization Model-矢量化模型"></a>3.Vectorization Model-矢量化模型</h3><p>结合上两种模型。</p>
<p>每个算子实现了 <code>Next()</code>函数，但是返回一批数据，而不是单个元组。</p>
<p>特点：</p>
<ul>
<li>函数调用开销较小，适合扫描大量元组的OLAP查询。</li>
<li>允许操作人员更容易使用矢量化指令处理成批的元组。</li>
</ul>
<h2 id="2-数据读取方法"><a href="#2-数据读取方法" class="headerlink" title="2. 数据读取方法"></a>2. 数据读取方法</h2><h3 id="1-顺序扫描"><a href="#1-顺序扫描" class="headerlink" title="1. 顺序扫描"></a>1. 顺序扫描</h3><p>算子遍历表中的元组，对每个元组使用条件谓词求值，决定是否发给父算子。</p>
<p>优化方式：</p>
<ul>
<li>预读：提前获取接下来将要读到的几页，减少IO阻塞次数。</li>
<li>加载到内存：直接将页面加载到内存，而不是缓冲池。</li>
<li>多线程：多线程并行扫描。</li>
</ul>
<h3 id="2-索引扫描"><a href="#2-索引扫描" class="headerlink" title="2. 索引扫描"></a>2. 索引扫描</h3><p>通过索引遍历表中的元组。</p>
<p>索引选择原则：走完索引后剩下的元素最少。</p>
<h3 id="3-多索引扫描"><a href="#3-多索引扫描" class="headerlink" title="3. 多索引扫描"></a>3. 多索引扫描</h3><p>多个条件都有索引时，使用每个索引筛选元组ID集，并使用位图、哈希表、布隆过滤器等取交集。</p>
<h2 id="3-数据修改方法"><a href="#3-数据修改方法" class="headerlink" title="3. 数据修改方法"></a>3. 数据修改方法</h2><p>万圣节问题：更新操作更改了其他元组的物理位置，导致多次扫描同一个元组。</p>
<p>解决方法：耿总每个修改的元组ID。</p>
<h2 id="4-表达式求值"><a href="#4-表达式求值" class="headerlink" title="4. 表达式求值"></a>4. 表达式求值</h2><p>where的条件表示为表达式树。</p>
<p>如果每个元组都要执行一遍表达式树计算，会导致大量重复计算。</p>
<p>优化：检测到重复计算后，直接调用之前的计算结果。</p>
<h1 id="15-并行化数据库"><a href="#15-并行化数据库" class="headerlink" title="15. 并行化数据库"></a>15. 并行化数据库</h1><p>在并行和分布式系统中，数据库分配在多个“资源”中，以提高并行性。分为计算性资源（CPU内核、GPU等）与存储性资源（磁盘、存储器等）。</p>
<ul>
<li>并行系统：资源在物理上接近，之间的通信快速且便宜可靠。</li>
<li>分布式系统：资源可能相距很远，在公共网络上通信较慢，成本更高，且故障出现概率更大。</li>
</ul>
<p>但是，它们对应用程序的查询应该忽略物理差异，生成相同的结果。</p>
<h2 id="1-进程模型"><a href="#1-进程模型" class="headerlink" title="1. 进程模型"></a>1. 进程模型</h2><p>一个worker指在数据库中执行操作的单位，并发执行即多个worker同时在数据库中运行。</p>
<h3 id="1-Process-per-Worker"><a href="#1-Process-per-Worker" class="headerlink" title="1. Process per Worker"></a>1. Process per Worker</h3><p>每个worker分配一个进程，依赖操作系统的协调。应用程序请求数据库时，调度器指派一个worker负责连接，直到请求完成。</p>
<p>优：一个进程崩溃不会影响其他进程。</p>
<p>劣：性能不高。</p>
<h3 id="2-Process-Pool"><a href="#2-Process-Pool" class="headerlink" title="2. Process Pool"></a>2. Process Pool</h3><p>基于进程池的处理模型。</p>
<h3 id="3-Thread-per-Worker"><a href="#3-Thread-per-Worker" class="headerlink" title="3. Thread per Worker"></a>3. Thread per Worker</h3><p>每个worker分配一个线程，每个数据库只有一个进程和多个工作线程。</p>
<p>此时一般让DBMS接管调度。</p>
<p>优：上下文切换开销更小；不用维护共享数据，因为线程之间天然共享数据。</p>
<h2 id="2-查询间并发"><a href="#2-查询间并发" class="headerlink" title="2. 查询间并发"></a>2. 查询间并发</h2><p>多个worker执行不同的查询。需要并发控制来防止更新数据库操作出现冲突。</p>
<h2 id="3-查询内并发"><a href="#3-查询内并发" class="headerlink" title="3. 查询内并发"></a>3. 查询内并发</h2><p>并行执行单个查询的操作，减少查询时间。每个算子有着对应的并发版本，主要有两大实现思路：</p>
<ul>
<li>将执行任务分配给多个worker，同时执行。</li>
<li>将任务数据分成多块，分给多个worker，最后合并结果。</li>
</ul>
<h3 id="1-Intra-Operator"><a href="#1-Intra-Operator" class="headerlink" title="1. Intra-Operator"></a>1. Intra-Operator</h3><p>查询计划的运算符被分成多个独立片段，这些片段对不同的数据子集执行相同操作。</p>
<p>即将数据集分割，相同处理后再合并。</p>
<h3 id="2-Inter-Operator"><a href="#2-Inter-Operator" class="headerlink" title="2. Inter-Operator"></a>2. Inter-Operator</h3><p>类似于流水线，不同算子并发执行。</p>
<p>如果下层的算子太慢，上层的算子需要等待，可能浪费很多时间。</p>
<h3 id="3-Bushy"><a href="#3-Bushy" class="headerlink" title="3. Bushy"></a>3. Bushy</h3><p>结合了前两种。</p>
<h2 id="4-IO并发"><a href="#4-IO并发" class="headerlink" title="4. IO并发"></a>4. IO并发</h2><p>关键在将逻辑上一起的数据分开到不同磁盘。</p>
<h3 id="1-多磁盘并行"><a href="#1-多磁盘并行" class="headerlink" title="1. 多磁盘并行"></a>1. 多磁盘并行</h3><p>OS/硬件自动将DBMS文件存储在不同磁盘，本质上跟DBMS关系不大。</p>
<h3 id="2-数据库分块"><a href="#2-数据库分块" class="headerlink" title="2. 数据库分块"></a>2. 数据库分块</h3><h4 id="1-垂直分块"><a href="#1-垂直分块" class="headerlink" title="1. 垂直分块"></a>1. 垂直分块</h4><p>将表的一部分属性分到另一个盘。一般将一些大、冷门的数据分开。</p>
<h4 id="2-水平分块"><a href="#2-水平分块" class="headerlink" title="2. 水平分块"></a>2. 水平分块</h4><p>一般按照某个属性的值将数据拆分成子集，该属性作为partition key，查询时根据key的值找不同的磁盘的表。</p>
<p>将partition key设置成网关，就能实现不同主机分表。</p>
<h1 id="16-查询计划优化"><a href="#16-查询计划优化" class="headerlink" title="16. 查询计划优化"></a>16. 查询计划优化</h1><p>SQL查询语句只告诉DBMS需要计算什么，不告诉怎么计算。DBMS要做的就是优化计算，让计算变得更高效。</p>
<p>有两种策略：</p>
<ul>
<li>静态规则/启发式：将SQL执行计划树与制定好的规则相匹配，根据规则改变树结构，进而提升效率。不需要检查数据本身。</li>
<li>基于成本的搜索：读取数据并估计执行等效计划的成本，选择成本最低的计划。</li>
</ul>
<h2 id="1-启发式"><a href="#1-启发式" class="headerlink" title="1. 启发式"></a>1. 启发式</h2><ul>
<li>逻辑查询优化：两种计划树是等价的，但是一种比另一种高效，就可以设置规则匹配低效的树结构，并在匹配到时替换为高效的树结构。<ul>
<li>尽早过滤（谓词下推）</li>
<li>重新排序谓词，先应用过滤数据最多的谓词</li>
<li>分解复杂谓词并下推（拆分连接谓词）</li>
</ul>
</li>
<li>嵌套子查询优化：提前计算子查询结果，作为常数放在总查询计划中。</li>
<li>表达式重写：<ul>
<li>删除不必要的谓词，如永真/永假。</li>
<li>合并谓词，如and/or连接的可合并区间。</li>
</ul>
</li>
</ul>
<h2 id="2-基于成本"><a href="#2-基于成本" class="headerlink" title="2. 基于成本"></a>2. 基于成本</h2><ul>
<li><p>估算代价：</p>
<ul>
<li>物理代价：CPU周期、IO时间等。极其依赖硬件，经常出现在数据库一体机上。</li>
<li>逻辑代价：估算算子整体开销、处理的数据。</li>
<li>算法代价：分析算子详细步骤与时间复杂度。</li>
</ul>
</li>
<li><p>磁盘开销：基于磁盘的数据库使用，磁盘IO占大部分开销。</p>
<ul>
<li>PostgreSQL：估算代价完全基于经验，如顺序IO比随机IO快4倍，这个数字完全是基于大量调参的结果。</li>
<li>DB2：与数据库特征、硬件环境、通信带宽等都有关。</li>
</ul>
</li>
<li><p>统计信息</p>
</li>
<li><p>计划枚举：在足够多可供选择的方案中选择计划执行路径。</p>
<ul>
<li>单个关系的计划：直接用启发式优化。</li>
<li>多个关系的计划：连表顺序、连表算法、数据访问算法等。</li>
<li>动态规划</li>
</ul>
</li>
</ul>
<h1 id="17-并发控制理论"><a href="#17-并发控制理论" class="headerlink" title="17. 并发控制理论"></a>17. 并发控制理论</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><p>在共享数据库上执行的一系列操作。</p>
<p>是DBMS的基本单元，符合ACID原则。</p>
<p>事务之间的并发执行可能导致不一致性问题。</p>
<p>事务以BEGIN命令开始，执行结果为COMMIT或ABORT。</p>
<ul>
<li>COMMIT：事务的所有修改都保存到数据库中，或DBMS重写并中止。</li>
<li>ABORT：事务的所有更改都被撤销。</li>
</ul>
<h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>事务要么执行其所有操作，要么不执行任何操作。</p>
<p>通过两种方式保证</p>
<ul>
<li>日志：在内存和磁盘上维护当前执行的事务的所有操作，以便随时撤销或中止事务。</li>
<li>复制：只复制事务修改的page，事务提交时才被写回。数据恢复比日志快，但维护开销更大，所以几乎不用。</li>
</ul>
<h3 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2. 一致性"></a>2. 一致性</h3><p>在更高的层面上，数据库逻辑一致。事务执行前后数据库的逻辑不变，即事务执行前的状态逻辑+事务逻辑=事务执行后的状态逻辑。包含数据库一致与事务一致。</p>
<p>一致性应该是其他三个性保证导致的最终结果。</p>
<h3 id="3-隔离性"><a href="#3-隔离性" class="headerlink" title="3. 隔离性"></a>3. 隔离性</h3><p>提供事务在系统中单独运行的假象，不受并发的其他事务影响。</p>
<h3 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4. 持久化"></a>4. 持久化</h3><p>崩溃或重启后，提交的事务的所有更改都必须是持久的。可通过日志或影子分页确保。</p>
<h2 id="2-两阶段锁"><a href="#2-两阶段锁" class="headerlink" title="2. 两阶段锁"></a>2. 两阶段锁</h2><p>详情见Lab4-1。</p>
<h2 id="3-时间戳排序并发控制"><a href="#3-时间戳排序并发控制" class="headerlink" title="3. 时间戳排序并发控制"></a>3. 时间戳排序并发控制</h2><p>乐观并发控制协议。该协议认为事务冲突很少，不要求在读写对象前获取锁，而是使用时间戳确定事务的可序列化顺序。</p>
<p>即，DBMS保证两个事务的串行执行相对顺序与它们的时间戳相对大小相同。</p>
<p>可以使用系统时间或逻辑时钟作为时间戳。</p>
<h3 id="1-基础时间戳排序"><a href="#1-基础时间戳排序" class="headerlink" title="1. 基础时间戳排序"></a>1. 基础时间戳排序</h3><p>每个数据库对象标记最后一个访问它的事务的时间戳，包括读时间戳R-TS与写时间戳W-TS。DBMS为每个操作检查时间戳，如果事务试图违反时间戳顺序访问对象，事务将中止并重启。</p>
<p>读操作：事务的时间戳小于W-TS时，说明该事务将读到未来写入的内容，事务中止并用新的时间戳重新启动；否则，读取有效，并更新R-TS。</p>
<p>写操作：如果事务时间戳小于W-TS或R-TS，说明覆盖了未来的更改，中止并重新启动；否则写有效，并更新W-TS。</p>
<p>托马斯写优化：如果写事务时间戳小于W-TS，说明没有其他事务会读取该事务的写入，可忽略该事务并继续执行。</p>
<p>特点：</p>
<ul>
<li>没有死锁，因为事务从不等待。</li>
<li>如果短事务一直冲突，可能引起长事务饥饿。</li>
<li>时间戳分配与更新成为高并发系统瓶颈。</li>
</ul>
<h3 id="2-乐观并发控制OCC"><a href="#2-乐观并发控制OCC" class="headerlink" title="2. 乐观并发控制OCC"></a>2. 乐观并发控制OCC</h3><p>使用时间戳。适用冲突少的场合，如只读，或访问不相交的数据子集。</p>
<p>数据库很大且工作负载不倾斜时，冲突概率很低，适用OCC。</p>
<p>DBMS为每个事务创建一个专有工作区，事务所有修改应用到工作区中，其他任何事务都无法修改。事务提交时，比较事物的工作区是否与其他事务冲突，没有则写入。</p>
<p>包含三个阶段：</p>
<ul>
<li>读阶段：跟踪事务的读写操作，写入专有工作区中。</li>
<li>验证阶段：事务提交时，检查是否与其他事务冲突。</li>
<li>写阶段：如果验证成功，将专有工作区的更改应用于数据库；否则中止并重启事务。</li>
</ul>
<h1 id="18-多版本并发控制-MVCC"><a href="#18-多版本并发控制-MVCC" class="headerlink" title="18. 多版本并发控制-MVCC"></a>18. 多版本并发控制-MVCC</h1><p>DBMS在数据库中维护单个逻辑对象的多个物理版本。</p>
<p>优点：</p>
<ul>
<li>读写事务不会互相屏蔽，即一个事务在修改对象的同时，其他事务可以读取该对象的旧版本。</li>
<li>只读事务可以读取数据库快照而无需加锁。</li>
<li>更容易支持时间戳查询。</li>
</ul>
<h2 id="1-版本存储"><a href="#1-版本存储" class="headerlink" title="1. 版本存储"></a>1. 版本存储</h2><p>DBMS使用元组的一个指针字段，为每个元组创建一个版本链表，按时间戳从新到旧排序。事务读写时遍历版本链，直到找到正确的版本。</p>
<h3 id="1-只附加存储"><a href="#1-只附加存储" class="headerlink" title="1. 只附加存储"></a>1. 只附加存储</h3><p>单个元组所有版本存储在同一个表空间中，每次更新将元组的新版本附加到表中，并更新版本链。</p>
<h3 id="2-时间戳存储"><a href="#2-时间戳存储" class="headerlink" title="2. 时间戳存储"></a>2. 时间戳存储</h3><p>DBMS维护单独的旧版本表，存储旧版本的元组。</p>
<p>每次更新时，DBMS将更新前的元组复制到旧版本表，然后用新数据覆盖主表中的元组，主表中指针指向旧版本表。</p>
<h3 id="3-增量存储"><a href="#3-增量存储" class="headerlink" title="3. 增量存储"></a>3. 增量存储</h3><p>与时间戳存储类似，但是只将变化的部分存储在旧版本表中。</p>
<p>导致写入速度比时间戳存储快，因为只需要写入变化；读取速度比时间戳存储慢，因为需要根据变化的部分构建旧版本元组。</p>
<h2 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2. 垃圾回收"></a>2. 垃圾回收</h2><p>DBMS需要随时间推移从数据库中删除可回收的物理版本。</p>
<p>可回收：如果没有任何活动事务可以看到某个版本，或者该版本由中止的事务创建，则该版本是可回收的。</p>
<h3 id="1-元组级"><a href="#1-元组级" class="headerlink" title="1. 元组级"></a>1. 元组级</h3><h4 id="1-后台扫描"><a href="#1-后台扫描" class="headerlink" title="1. 后台扫描"></a>1. 后台扫描</h4><p>独立线程定期扫描表，寻找可回收的版本。</p>
<p>优化：维护一个脏页位图，跟踪自上次扫描以来哪些页面已被修改。</p>
<h4 id="2-协同清理"><a href="#2-协同清理" class="headerlink" title="2. 协同清理"></a>2. 协同清理</h4><p>工作线程在遍历版本链时识别可回收的版本。</p>
<h3 id="2-事务级"><a href="#2-事务级" class="headerlink" title="2. 事务级"></a>2. 事务级</h3><p>每个事务负责跟踪自己的旧版本，维护自己的读写操作集合。</p>
<p>事务完成时，垃圾回收器使用该集合标识要回收的元组。</p>
<h1 id="19-日志"><a href="#19-日志" class="headerlink" title="19. 日志"></a>19. 日志</h1><h2 id="1-故障恢复"><a href="#1-故障恢复" class="headerlink" title="1. 故障恢复"></a>1. 故障恢复</h2><p>数据库崩溃时，内存中所有未提交到磁盘的数据都有丢失风险。恢复算法的作用是防止崩溃后信息丢失。恢复算法分为两部分：</p>
<ul>
<li>正常事务处理期间的操作：确保DBMS能从故障恢复。</li>
<li>将数据库恢复到ACD状态失败后的操作。</li>
</ul>
<p>主要有REDO和UNDO两种原语。</p>
<h2 id="2-故障分类"><a href="#2-故障分类" class="headerlink" title="2. 故障分类"></a>2. 故障分类</h2><p>不是所有故障都能恢复。</p>
<h3 id="1-事务故障"><a href="#1-事务故障" class="headerlink" title="1. 事务故障"></a>1. 事务故障</h3><p>事务出现错误并且必须中止。</p>
<ul>
<li>逻辑错误：由于完整性、违反约束等内部条件，事务无法完成。</li>
<li>内部状态错误：由于死锁等错误情况，DBMS必须中止活动事务。</li>
</ul>
<h3 id="2-系统故障"><a href="#2-系统故障" class="headerlink" title="2. 系统故障"></a>2. 系统故障</h3><p>承载DBMS的底层软硬件故障。</p>
<ul>
<li>软件故障：DBMS实现出现问题，如未捕获的除以0异常等，系统不得不中止。</li>
<li>硬件故障：托管DBMS的计算机崩溃。故障停止假设：假设非易失性存储内容不会因为系统崩溃而损坏。</li>
</ul>
<h3 id="3-存储介质故障"><a href="#3-存储介质故障" class="headerlink" title="3. 存储介质故障"></a>3. 存储介质故障</h3><p>物理存储设备损坏时发生的不可修复的故障。</p>
<p>此时必须从存档版本恢复DBMS，需要人工干预恢复。</p>
<ul>
<li>不可修复的硬件故障：磁头崩溃之类的磁盘故障会破坏非易失性存储器的部分。破坏是可以检测到的。</li>
</ul>
<h2 id="3-缓冲池管理策略"><a href="#3-缓冲池管理策略" class="headerlink" title="3. 缓冲池管理策略"></a>3. 缓冲池管理策略</h2><p>DBMS有以下保证：</p>
<ul>
<li>一旦DBMS告诉某人某事务已提交，它做的任何更改都是持久的。</li>
<li>如果事务中止，它做的所有更改都是非持久的。</li>
</ul>
<p>窃取策略：是否可以将属于不同事务的未提交更改写入磁盘。</p>
<p>强制策略：DBMS是否要求事务在被允许提交前，其更新反映在非易失性存储上。</p>
<p>最容易实现的策略：NO-STEAL+FORCE。</p>
<ul>
<li>DBMS不需要撤销中止事务的更改，因为没有写入磁盘。</li>
<li>BMDS不需要重做已提交事务的更改，因为所有更改都在提交时写入磁盘。</li>
<li>限制：事务修改的所有数据都必须能装进内存。否则，事务无法执行，因为不允许DBMS在事务提交前将脏页写入磁盘。</li>
</ul>
<h2 id="4-影子分页"><a href="#4-影子分页" class="headerlink" title="4. 影子分页"></a>4. 影子分页</h2><p>之前的方案中，DBMS写入时复制页面，维护两个版本：</p>
<ul>
<li>master：仅包含提交的事务的更改。</li>
<li>shadow：包含未提交事务的更改。</li>
</ul>
<p>更新只在shadow中进行，在事务提交时shadow切换为新的master，旧master被垃圾回收。</p>
<p>缺陷：复制页面成本很高；shadow提交开销高，需要刷新所有更新的页面、页表，导致数据碎片化、垃圾回收；一次只支持一个写事务。</p>
<h2 id="5-预写日志-WAL"><a href="#5-预写日志-WAL" class="headerlink" title="5. 预写日志-WAL"></a>5. 预写日志-WAL</h2><p>在更新磁盘前，将操作先记录在日志文件中，用于执行撤销、重做操作，以便在崩溃后恢复数据库。</p>
<p>允许DBMS将随机写入转换为顺序写入，提高了性能；但是恢复比影子分页慢，因为需要重放日志。</p>
<p>实现：</p>
<ul>
<li>首先将事务日志记录在内存中。</li>
<li>允许在外存中重写页面之前，将该页面更新相关的日志记录先写入外存。</li>
<li>在事务日志写入外存前，事务不被视为已提交。</li>
<li>事务开始时写入BEGIN记录，标志事务开始点。</li>
<li>事务完成后写入COMMIT记录，确保在向应用程序返回确认前清空所有日志记录。</li>
</ul>
<p>每条日志包含：</p>
<ul>
<li>事务id</li>
<li>操作对象id</li>
<li>旧值</li>
<li>新值</li>
</ul>
<p>事务只有在其日志刷新到外存，才会告诉外部世界已提交。</p>
<p>可使用组提交优化，批量处理多个日志刷新，以分摊开销。</p>
<p>刷新时机：日志缓冲区满；每隔一定时间。</p>
<h2 id="6-日志分类"><a href="#6-日志分类" class="headerlink" title="6. 日志分类"></a>6. 日志分类</h2><ul>
<li>物理日志：记录对数据库中特定位置的字节级更改。<ul>
<li>git diff</li>
</ul>
</li>
<li>逻辑日志：记录事务执行的高级操作，如sql语句。<ul>
<li>写入日志的数据相比于物理日志更少，因为一条语句可能引起多个更改。</li>
<li>update、delete、insert语句。</li>
</ul>
</li>
<li>物理逻辑日志：<ul>
<li>混合物理日志与逻辑日志。指定具体的页，而不指定页中具体位置。</li>
<li>类似于，指定sql语句用在了哪些页？</li>
<li>DBMS最常用的日志。</li>
</ul>
</li>
</ul>
<h2 id="7-检查点"><a href="#7-检查点" class="headerlink" title="7. 检查点"></a>7. 检查点</h2><p>WAL技术的一个缺点是，日志文件会不断变大，每次崩溃后重放日志的时间也会变长。</p>
<p>因此，DBMS需要定期检查，将所有缓冲区刷新到磁盘。</p>
<p>检查点的设置需要权衡：太少会导致系统重启后恢复时间太长；太多会导致运行性能下降。</p>
<p>实现：</p>
<ul>
<li>停止接受新事务，并等待所有活动事务完成。</li>
<li>将当前内存中所有日志记录和脏页刷新到磁盘。</li>
<li>写入CHECKPOINT条目到日志，并刷新到磁盘。</li>
</ul>
<h1 id="20-故障恢复"><a href="#20-故障恢复" class="headerlink" title="20. 故障恢复"></a>20. 故障恢复</h1><p>ARIES恢复算法：</p>
<ul>
<li>WAL：在将数据库更改写入磁盘之前，先将更改日志写入磁盘。</li>
<li>redo：在重启时，回溯操作，并恢复数据库到崩溃前的状态。</li>
<li>undo：在日志中记录undo，确保在重复失败的请款下不会重复操作。</li>
</ul>
<h2 id="1-WAL"><a href="#1-WAL" class="headerlink" title="1. WAL"></a>1. WAL</h2><p>每条日志分配一个全局唯一的日志序列号LSN。</p>
<ul>
<li>每次事务修改页面，更新pageLSN，表示该页最近更新的LSN。</li>
<li>每次DBMS将WAL缓冲区写入磁盘，更新内存的flushedLSN，表示目前为止刷新的最大LSN。</li>
<li>DBMS将第i页写入磁盘前，必须至少刷新日志到pageLSNi &lt;= flushedLSN的点。</li>
</ul>
<h2 id="2-正常运行"><a href="#2-正常运行" class="headerlink" title="2. 正常运行"></a>2. 正常运行</h2><h3 id="1-事务提交"><a href="#1-事务提交" class="headerlink" title="1. 事务提交"></a>1. 事务提交</h3><ul>
<li>DBMS将commit记录写入内存日志缓冲区。</li>
<li>DBMS将所有日志记录刷新到磁盘。</li>
<li>DBMS向应用程序返回事务已提交的确认信息。</li>
<li>DBMS写一条特殊的TXN-END日志记录，表示该事务已全部完成，今后不会再出现该事务的日志记录。</li>
</ul>
<h3 id="2-事务中止"><a href="#2-事务中止" class="headerlink" title="2. 事务中止"></a>2. 事务中止</h3><p>日志中有prevLSN附加字段，表示事务的前一个LSN。</p>
<p>CLR补偿日志记录：记录为了撤销之前的更新记录需要采取的操作。包含更新日志记录的所有字段，以及undoNext指针（下一个要撤销的LSN）。DBMS将CLR添加到日志当中，这些日志永远不需要撤销。</p>
<p>中止事务：</p>
<ul>
<li>DBMS向内存日志缓冲区追加一条abort记录。</li>
<li>以相反的顺序撤销事物的更新，从数据库中删除更改。<ul>
<li>对于每个未提交的更新，DBMS在日志中创建CLR，并将对应的记录恢复到旧值。</li>
</ul>
</li>
<li>所有被中止的事务都被undo后，DBMS写一条TXN-END记录。</li>
</ul>
<h2 id="3-检查点"><a href="#3-检查点" class="headerlink" title="3. 检查点"></a>3. 检查点</h2><p>DBMS定期设置检查点，将缓冲池的脏页写到磁盘上。这样如果需要故障恢复，只需要从上一次写磁盘的日志位置开始，减少重放日志量。</p>
<h3 id="1-阻塞检查点"><a href="#1-阻塞检查点" class="headerlink" title="1. 阻塞检查点"></a>1. 阻塞检查点</h3><p>当DBMS需要设置检查点时，停止事务和查询的运行。</p>
<ul>
<li>阻止新事务启动。</li>
<li>等待活动事务执行完毕。</li>
<li>刷新脏页到磁盘。</li>
</ul>
<h3 id="2-阻塞检查点优化"><a href="#2-阻塞检查点优化" class="headerlink" title="2. 阻塞检查点优化"></a>2. 阻塞检查点优化</h3><p>DBMS不必等待活动事务完成，而是保存检查点开始时各个事务的状态，在刷盘完毕后恢复执行。类似于线程切换。</p>
<ul>
<li>阻止新事务启动。</li>
<li>在DBMS执行检查点时暂停所有活动事务。</li>
</ul>
<h3 id="3-活动事务表ATT"><a href="#3-活动事务表ATT" class="headerlink" title="3. 活动事务表ATT"></a>3. 活动事务表ATT</h3><p>ATT表示DBMS的活动事务的状态，包含：</p>
<ul>
<li>事务id</li>
<li>事务状态：运行、提交、undo</li>
<li>lastLSN：事务最近写的LSN</li>
</ul>
<h3 id="4-脏页表DPT"><a href="#4-脏页表DPT" class="headerlink" title="4. 脏页表DPT"></a>4. 脏页表DPT</h3><p>DPT包含缓冲池中未被提交的事务修改的页面信息。每个脏页包含一个recLSN（第一条修改了该页的日志LSN）</p>
<p>ATT和DPT用于帮助DBMS恢复数据库在崩溃前的状态。</p>
<h3 id="5-模糊检查点"><a href="#5-模糊检查点" class="headerlink" title="5. 模糊检查点"></a>5. 模糊检查点</h3><p>额外为检查点设置两个状态：</p>
<ul>
<li>begin：此时DBMS获取当前ATT、DPT。</li>
<li>end：包含begin时获取的ATT、DPT。</li>
</ul>
<h2 id="4-ARIES恢复算法"><a href="#4-ARIES恢复算法" class="headerlink" title="4. ARIES恢复算法"></a>4. ARIES恢复算法</h2><p>用于DBMS在崩溃后恢复，由三个阶段组成：</p>
<ul>
<li>Analysis：读取WAL，识别崩溃时缓冲池中的脏页和活动事务。ATT提供崩溃时的活动事务信息，DPT提供可能没有保存的脏页信息。</li>
<li>Redo：从日志的适当位置开始，重复所有操作。</li>
<li>Undo：撤销崩溃前未提交的事务操作。</li>
</ul>
<h3 id="1-Analysis"><a href="#1-Analysis" class="headerlink" title="1. Analysis"></a>1. Analysis</h3><p>从数据库的最后一条LSN开始：</p>
<ul>
<li>从检查点向前扫描日志。</li>
<li>如果发现某事务的TXN-END记录，从ATT中删除该事务。</li>
<li>所有其他事务标记为UNDO状态，添加到ATT。</li>
<li>对于update日志，如果修改的页不再DPT中，将其添加到DPT，并将P的recLSN设置为日志的LSN。</li>
</ul>
<h3 id="2-Redo"><a href="#2-Redo" class="headerlink" title="2. Redo"></a>2. Redo</h3><p>DBMS从DPT中包含最小recLSN的日志向前扫描，如果下列条件都不满足，则重放该日志：</p>
<ul>
<li>受影响的页不在DPT。</li>
<li>受影响的页在DPT，但日志的LSN小于DPT中该页的recLSN。</li>
<li>磁盘上受影响的pageLSN &gt;= LSN</li>
</ul>
<p>重放时，DBMS重新应用日志中的更改，然后将被更改页面的pageLSN设置为该日志的LSN。</p>
<p>redo结束时，为状态为COMMIT的所有事务写入TXN-END日志记录，将其从ATT中删除。</p>
<h3 id="3-Undo"><a href="#3-Undo" class="headerlink" title="3. Undo"></a>3. Undo</h3><p>处理崩溃时的活动事务，即在Analysis阶段标记于UNDO状态的事务。</p>
<p>反向遍历日志记录，并依次反转更新，每次反转写入一条CLR日志。</p>
<p>最后一个事务成功中止时，DBMS将日志刷盘，准备开始处理新事务。</p>
<h1 id="21-分布式数据库"><a href="#21-分布式数据库" class="headerlink" title="21. 分布式数据库"></a>21. 分布式数据库</h1><p>相较于多线程数据库的特点：</p>
<ul>
<li>节点之间可以相距很远。</li>
<li>节点可能通过公共网络连接，缓慢、不可靠。</li>
<li>存在不可忽视的通信成本和连接问题，如节点崩溃、数据包丢失。</li>
</ul>
<h2 id="1-系统结构"><a href="#1-系统结构" class="headerlink" title="1. 系统结构"></a>1. 系统结构</h2><p>关于CPU可以直接访问哪些共享资源。</p>
<ul>
<li>共享内存：一般不使用，因为由内核级别提供，导致多进程同步问题。</li>
<li>共享磁盘：每个CPU有自己的内存充当缓存。更新数据后，如果该数据在其他CPU中也有副本，必须将更新告知其他CPU。</li>
<li>不共享：节点之间只通过网络进行通信。<ul>
<li>很难扩容、确保数据一致性。</li>
<li>性能、效率更高。</li>
</ul>
</li>
</ul>
<h2 id="2-设计思路"><a href="#2-设计思路" class="headerlink" title="2. 设计思路"></a>2. 设计思路</h2><p>目的：保持数据透明性。即用户不需要知道数据的物理位置、表的分区与复制方式，像使用单节点数据库一样使用分布式数据库。</p>
<p>节点如何在集群中交互的设计：</p>
<ul>
<li>同构节点：每个节点可执行的任务相同。</li>
<li>异构节点：每个节点被分配特定的任务。</li>
</ul>
<h2 id="3-分片策略"><a href="#3-分片策略" class="headerlink" title="3. 分片策略"></a>3. 分片策略</h2><p>DBMS接收到查询后，首先分析查询需要访问的数据，将不同的查询片段发送到不同的节点，最后组合不同节点的查询结果，产生答案。</p>
<p>分片目的：最大化单节点事务，即只访问一个分片上包含的数据的事务。</p>
<p>实现：</p>
<ul>
<li>数据分区：不同区存不同表。如果有经常查询的表，可能会造成负载不均衡。</li>
<li>垂直分区：表不同属性差分为不同区。</li>
<li>水平分区：表的元组按某列的值拆分为不相交的子集。</li>
</ul>
<h2 id="4-分布式并发控制"><a href="#4-分布式并发控制" class="headerlink" title="4. 分布式并发控制"></a>4. 分布式并发控制</h2><ul>
<li>集中式协调：集中式协调器负责协调。</li>
<li>中间件：集中式协调器充当中间件，负责接受查询请求，并将查询路由到正确的分区。</li>
<li>去中心化协调：客户端直接向其中一个分区发送查询，该分区与其他分区通信，并将查询结果返回客户端。</li>
</ul>
<h1 id="22-分布式OLTP"><a href="#22-分布式OLTP" class="headerlink" title="22. 分布式OLTP"></a>22. 分布式OLTP</h1><h2 id="1-提交协议"><a href="#1-提交协议" class="headerlink" title="1. 提交协议"></a>1. 提交协议</h2><p>多节点事务完成时，DBMS需要询问所有涉及的节点，该提交是否安全。有不同协议，规定需要提交的节点：</p>
<ul>
<li>两阶段提交</li>
<li>三阶段提交</li>
<li>Paxos</li>
<li>Raft</li>
<li>ZAB：Zookeeper原子广播协议</li>
<li>Viewstamped复制</li>
</ul>
<h3 id="1-两阶段提交"><a href="#1-两阶段提交" class="headerlink" title="1. 两阶段提交"></a>1. 两阶段提交</h3><ul>
<li>客户端向协调者发送提交请求</li>
<li>第一阶段：提交请求/投票<ul>
<li>协调者发送prepare消息与事务内容，询问参与者是否提交当前事务。</li>
<li>参与者向协调者发送是否可以提交。</li>
</ul>
</li>
<li>第二阶段：提交/执行<ul>
<li>如果所有参与者返回yes，说明事务可以提交：<ul>
<li>协调者发送commit请求。</li>
<li>参与者将事务真正提交，释放占用的事务资源，返回ack。</li>
<li>协调者收到所有参与者的ack时，事务完成。</li>
</ul>
</li>
<li>有参与者返回no或超时：<ul>
<li>协调者发送rollback请求。</li>
<li>参与者根据undo日志回滚到事务执行前的状态，释放占用的事务资源，返回ack。</li>
<li>协调者收到所有参与者的ack时，事务回滚完成。</li>
</ul>
</li>
</ul>
</li>
<li>要么所有人提交，要么无人提交。</li>
<li>崩溃：<ul>
<li>在确定下一个操作前，节点阻塞。</li>
<li>协调者崩溃：参与者选择中止；或相互通信，协调是否可以提交。</li>
<li>参与者崩溃：协调者假设该参与者返回no。</li>
</ul>
</li>
<li>缺点：<ul>
<li>协调者存在单点故障问题。</li>
<li>执行过程同步，各参与者等待其他参与者响应时阻塞，存在性能问题。</li>
<li>存在不一致风险，如果只有部分参与者收到commit请求，会导致部分提交。</li>
</ul>
</li>
</ul>
<h3 id="2-Paxos-Raft"><a href="#2-Paxos-Raft" class="headerlink" title="2. Paxos/Raft"></a>2. Paxos/Raft</h3><p>共识协议：提议者提出一个结果（提交/中止），接受者投票决定该结果是否应该成功。</p>
<ul>
<li>客户端向提议者发送提交请求。</li>
<li>提议者向其他节点发送提议。</li>
<li>如果某个接受者没有向其他更新时间戳的提议者发送过同意，则同意该提议；否则，拒绝该提议。</li>
<li>只要大多数接受者同意，提议者响应客户端已提交。</li>
</ul>
<p>2PC是paxos的退化情况。</p>
<p>改进：Multi-Paxos：系统选举出一个领导，在一段时间内监视提议变更，从而跳过提议阶段。</p>
<h2 id="2-数据复制"><a href="#2-数据复制" class="headerlink" title="2. 数据复制"></a>2. 数据复制</h2><p>通过冗余数据提高可用性。</p>
<ul>
<li><p>主节点：</p>
<ul>
<li>必须选出一个主节点，同步所有其他节点的更新，并将更新同步到其他节点。</li>
<li>没有主节点，每个节点更新后都需要同步到所有节点中。</li>
</ul>
</li>
<li><p>K-Safety：如果某个数据可用副本数小于K，则DBMS停止提供服务。</p>
</li>
<li><p>传播方案：</p>
<ul>
<li>同步方案：主节点确保所有副本应用更改后，才通知客户端更新成功。</li>
<li>异步方案：主节点不等待副本应用，直接通知客户端更新成功。</li>
</ul>
</li>
<li><p>传播时机：</p>
<ul>
<li>连续：生成日志消息时立即发送。</li>
<li>提交：仅在事务提交后向副本发送该事务的日志消息。</li>
</ul>
</li>
</ul>
<h2 id="3-CAP"><a href="#3-CAP" class="headerlink" title="3. CAP"></a>3. CAP</h2><p>分布式系统不能同时满足三个属性：</p>
<ul>
<li>一致性：一旦写入完成，所有将来的读取都应该返回最近一次写入的值。</li>
<li>可用性：所有已启动的节点都能满足所有请求。</li>
<li>分区容忍：尽管节点之间存在了一些消息丢失，系统仍然可以正常运行。</li>
</ul>
<p>PACELC理论：考虑了一致性与延迟的权衡。在分布式系统网络分区（P）的情况下，必须在A与C之间选择；否则（E），即使系统在没有网络分区的情况下正常运行，也必须在延迟（L）与C之间选择。</p>

      </div>
      <div class="post-tags-categories">
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>aoba moka</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2023/05/08/学习笔记-CMU-15-445-课程笔记/" target="_blank" title="学习笔记-CMU-15-445-课程笔记">https://aobamoka.github.io/2023/05/08/学习笔记-CMU-15-445-课程笔记/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">



  
  <div class="post-nav-prev post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
    </div>
    <a href="/2023/05/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Muduo%E5%BA%93%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0/" class="post-nav-link">
      <div class="title">
        <i class="fas fa-angle-left"></i> 上一篇:
        <div class="title-text">学习笔记-Muduo库核心代码学习</div>
      </div>
      
      <!-- <div class="content">
        1. Multi-Reactormuduo库基于多reactor-多线程/Multi-Reactor实现。

八股部分：
      </div> -->
    </a>
  </div>



  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://picx.zhimg.com/80/v2-85c31120acff76826ab53ea8934ef4bb_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-85c31120acff76826ab53ea8934ef4bb_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" src="" alt="">
    </div>
    <a href="/2023/05/07/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab4-3/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">项目学习-CMU-15-445-Lab4-3</div>
      </div>
      <!-- <div class="content">
        1. 基础知识1. 并发SQL查询将事务锁应用于Lab3实现的算子中。
实际实现中，事务只在最底层的算子中与数据库的数据
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-container"></div>

    
  </div>

<!-- comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  <aside id='l_side'>
  
    
      <section class="widget side_blogger">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img src='/medias/test.png'/>
        </a>
      
    
    
      <div class='text'>
        
          <h2>摩卡</h2>
        
        
          <p>不太会说话</p>

        
        
          <p><span id="jinrishici-sentence">摩卡's blog</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
  </div>
</section>

    
  
  
  

  <div class="layout_sticky">    
    
      
<section class="widget side_toc">
  
  <header>
    
      <i style="color: " class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name' style="color: ">本文目录</span>
    
  </header>


  <div class='content'>
    <div class="toc-main">
      <div class="toc-content">
        <!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-SQL%E8%AF%AD%E8%A8%80"><span class="toc-text">1. SQL语言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-text">2. 磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-text">1. 系统设计目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E7%A3%81%E7%9B%98%E7%9A%84DBMS"><span class="toc-text">2. 基于磁盘的DBMS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A0%86%E6%96%87%E4%BB%B6"><span class="toc-text">3. 堆文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%A1%B5"><span class="toc-text">4. 页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-slotted-pages-%E5%88%86%E6%A7%BD%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="toc-text">5. slotted pages-分槽页结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-tuple-%E5%85%83%E7%BB%84"><span class="toc-text">6. tuple-元组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%83%E7%BB%84%E5%A4%B4"><span class="toc-text">1. 元组头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE"><span class="toc-text">2. 数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%8B%AC%E7%89%B9%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">3. 独特标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%9E%E8%A7%84%E8%8C%83%E5%8C%96%E5%85%83%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="toc-text">4. 非规范化元组数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E5%8C%96%E5%AD%98%E5%82%A8"><span class="toc-text">7. 日志结构化存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-text">3. 数据表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Integers"><span class="toc-text">1. Integers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Variable-Precision-Numbers"><span class="toc-text">2. Variable Precision Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Fixed-Point-Precision-Numbers"><span class="toc-text">3. Fixed-Point Precision Numbers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Variable-Length-Data"><span class="toc-text">4. Variable-Length Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Dates-and-Times"><span class="toc-text">5. Dates and Times</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-System-Catalogs"><span class="toc-text">6. System Catalogs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">4. 数据库工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-OLTP-Online-Transaction-Processing"><span class="toc-text">1. OLTP-Online Transaction Processing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-OLAP-Online-Analytical-Processing"><span class="toc-text">2. OLAP-Online Analytical Processing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-HTAP-Hybrid-Transaction-Analytical-Processing"><span class="toc-text">3. HTAP-Hybrid Transaction + Analytical Processing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">5. 存储模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-NSM-n%E5%85%83%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. NSM-n元存储模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-DSM-%E5%88%86%E8%A7%A3%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. DSM-分解存储模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-text">6. 数据压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%97%E5%8E%8B%E7%BC%A9%E6%96%B9%E6%A1%88"><span class="toc-text">1. 列压缩方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Run-Length-Encodin-RLE"><span class="toc-text">1. Run-Length Encodin RLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Bit-Packing-Encoding"><span class="toc-text">2. Bit-Packing Encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Mostly-Encoding"><span class="toc-text">3. Mostly Encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Bitmap-Encoding"><span class="toc-text">4. Bitmap Encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Delta-Encoding"><span class="toc-text">5. Delta Encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Incremental-Encoding"><span class="toc-text">6. Incremental Encoding</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Dictionary-Compression"><span class="toc-text">7. Dictionary Compression</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-text">7. 缓冲池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-lock-amp-latch"><span class="toc-text">1. lock &amp; latch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-text">2. 缓冲池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-text">3. 缓冲池的元数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-IO%E7%AD%96%E7%95%A5"><span class="toc-text">4. IO策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BC%93%E5%86%B2%E6%B1%A0%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-text">5. 缓冲池页面替换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LRU"><span class="toc-text">1. LRU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CLOCK"><span class="toc-text">2. CLOCK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LRU%E4%B8%8ECLOCK%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3. LRU与CLOCK存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-LRU-K"><span class="toc-text">1. LRU-K</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E6%AF%8F%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%89%B9%E5%8C%96"><span class="toc-text">2. 对每个查询特化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E5%85%88%E7%BA%A7%E6%8F%90%E7%A4%BA"><span class="toc-text">3. 优先级提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%84%8F%E9%A1%B5%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">4. 脏页淘汰策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">8. 哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">1. 组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-text">2. 哈希函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E5%93%88%E5%B8%8C%E7%AD%96%E7%95%A5"><span class="toc-text">3. 静态哈希策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-text">1. 线性探测法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Robin-Hood-Hashing"><span class="toc-text">2. Robin Hood Hashing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Cuckoo-Hashing"><span class="toc-text">3. Cuckoo Hashing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E5%93%88%E5%B8%8C%E7%AD%96%E7%95%A5"><span class="toc-text">4. 动态哈希策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E9%93%BE%E6%B3%95"><span class="toc-text">1. 开链法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AF%E6%8B%93%E5%B1%95%E5%93%88%E5%B8%8C"><span class="toc-text">2. 可拓展哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-text">3. 线性哈希</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E7%B4%A2%E5%BC%95"><span class="toc-text">9. 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-B-%E6%A0%91"><span class="toc-text">1. B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5"><span class="toc-text">1. 插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4"><span class="toc-text">2. 删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9F%A5%E6%89%BE"><span class="toc-text">3. 查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-text">2. 并发控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Latch%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">1. Latch的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Blocking-OS-Mutex"><span class="toc-text">1. Blocking OS Mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Test-and-Set-Spin-Latch-TAS"><span class="toc-text">2. Test-and-Set Spin Latch (TAS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">3. 读写锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-B-%E6%A0%91%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-text">2. B+树并发控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%8E%92%E5%BA%8F"><span class="toc-text">11. 排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E8%81%9A%E9%9B%86"><span class="toc-text">12. 聚集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E8%81%9A%E9%9B%86"><span class="toc-text">1. 排序聚集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E8%81%9A%E9%9B%86"><span class="toc-text">2. 哈希聚集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E8%BF%9E%E6%8E%A5"><span class="toc-text">13. 连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BE%93%E5%85%A5%E5%BD%A2%E5%BC%8F"><span class="toc-text">1. 输入形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Nested-Loop-Join"><span class="toc-text">2. Nested Loop Join</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Simple-Nested-Loop-Join"><span class="toc-text">1. Simple Nested Loop Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Block-Nested-Loop-Join"><span class="toc-text">2. Block Nested Loop Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Index-Nested-Loop-Join"><span class="toc-text">3. Index Nested Loop Join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Sort-Merge-Join"><span class="toc-text">3. Sort-Merge Join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Hash-Join"><span class="toc-text">4. Hash Join</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Grace-Hash-Join"><span class="toc-text">1. Grace Hash Join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BC%80%E9%94%80%E6%80%BB%E7%BB%93"><span class="toc-text">5. 开销总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-SQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">14. SQL查询过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. 处理模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Iterator-Model-%E7%81%AB%E5%B1%B1%E6%A8%A1%E5%9E%8B-%E7%AE%A1%E9%81%93%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. Iterator Model-火山模型&#x2F;管道模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Materialization-Model-%E7%89%A9%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. Materialization Model-物化模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Vectorization-Model-%E7%9F%A2%E9%87%8F%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.Vectorization Model-矢量化模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-text">2. 数据读取方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%89%AB%E6%8F%8F"><span class="toc-text">1. 顺序扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F"><span class="toc-text">2. 索引扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F"><span class="toc-text">3. 多索引扫描</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95"><span class="toc-text">3. 数据修改方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">4. 表达式求值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E5%B9%B6%E8%A1%8C%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">15. 并行化数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. 进程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Process-per-Worker"><span class="toc-text">1. Process per Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Process-Pool"><span class="toc-text">2. Process Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Thread-per-Worker"><span class="toc-text">3. Thread per Worker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E9%97%B4%E5%B9%B6%E5%8F%91"><span class="toc-text">2. 查询间并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9F%A5%E8%AF%A2%E5%86%85%E5%B9%B6%E5%8F%91"><span class="toc-text">3. 查询内并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Intra-Operator"><span class="toc-text">1. Intra-Operator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Inter-Operator"><span class="toc-text">2. Inter-Operator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Bushy"><span class="toc-text">3. Bushy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-IO%E5%B9%B6%E5%8F%91"><span class="toc-text">4. IO并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%9A%E7%A3%81%E7%9B%98%E5%B9%B6%E8%A1%8C"><span class="toc-text">1. 多磁盘并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%9D%97"><span class="toc-text">2. 数据库分块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9E%82%E7%9B%B4%E5%88%86%E5%9D%97"><span class="toc-text">1. 垂直分块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B0%B4%E5%B9%B3%E5%88%86%E5%9D%97"><span class="toc-text">2. 水平分块</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E4%BC%98%E5%8C%96"><span class="toc-text">16. 查询计划优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%90%AF%E5%8F%91%E5%BC%8F"><span class="toc-text">1. 启发式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC"><span class="toc-text">2. 基于成本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA"><span class="toc-text">17. 并发控制理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1"><span class="toc-text">1. 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">1. 原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">2. 一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-text">3. 隔离性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">4. 持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="toc-text">2. 两阶段锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-text">3. 时间戳排序并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%97%B6%E9%97%B4%E6%88%B3%E6%8E%92%E5%BA%8F"><span class="toc-text">1. 基础时间戳排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6OCC"><span class="toc-text">2. 乐观并发控制OCC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-MVCC"><span class="toc-text">18. 多版本并发控制-MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%89%88%E6%9C%AC%E5%AD%98%E5%82%A8"><span class="toc-text">1. 版本存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%AA%E9%99%84%E5%8A%A0%E5%AD%98%E5%82%A8"><span class="toc-text">1. 只附加存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%B6%E9%97%B4%E6%88%B3%E5%AD%98%E5%82%A8"><span class="toc-text">2. 时间戳存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E9%87%8F%E5%AD%98%E5%82%A8"><span class="toc-text">3. 增量存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">2. 垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%83%E7%BB%84%E7%BA%A7"><span class="toc-text">1. 元组级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%8E%E5%8F%B0%E6%89%AB%E6%8F%8F"><span class="toc-text">1. 后台扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%8F%E5%90%8C%E6%B8%85%E7%90%86"><span class="toc-text">2. 协同清理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8B%E5%8A%A1%E7%BA%A7"><span class="toc-text">2. 事务级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E6%97%A5%E5%BF%97"><span class="toc-text">19. 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-text">1. 故障恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%85%E9%9A%9C%E5%88%86%E7%B1%BB"><span class="toc-text">2. 故障分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1%E6%95%85%E9%9A%9C"><span class="toc-text">1. 事务故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C"><span class="toc-text">2. 系统故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C"><span class="toc-text">3. 存储介质故障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2%E6%B1%A0%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">3. 缓冲池管理策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BD%B1%E5%AD%90%E5%88%86%E9%A1%B5"><span class="toc-text">4. 影子分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97-WAL"><span class="toc-text">5. 预写日志-WAL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%97%A5%E5%BF%97%E5%88%86%E7%B1%BB"><span class="toc-text">6. 日志分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="toc-text">7. 检查点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-text">20. 故障恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-WAL"><span class="toc-text">1. WAL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C"><span class="toc-text">2. 正常运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="toc-text">1. 事务提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E6%AD%A2"><span class="toc-text">2. 事务中止</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="toc-text">3. 检查点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%BB%E5%A1%9E%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="toc-text">1. 阻塞检查点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%BB%E5%A1%9E%E6%A3%80%E6%9F%A5%E7%82%B9%E4%BC%98%E5%8C%96"><span class="toc-text">2. 阻塞检查点优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B4%BB%E5%8A%A8%E4%BA%8B%E5%8A%A1%E8%A1%A8ATT"><span class="toc-text">3. 活动事务表ATT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%84%8F%E9%A1%B5%E8%A1%A8DPT"><span class="toc-text">4. 脏页表DPT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A8%A1%E7%B3%8A%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="toc-text">5. 模糊检查点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ARIES%E6%81%A2%E5%A4%8D%E7%AE%97%E6%B3%95"><span class="toc-text">4. ARIES恢复算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Analysis"><span class="toc-text">1. Analysis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redo"><span class="toc-text">2. Redo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Undo"><span class="toc-text">3. Undo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">21. 分布式数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-text">1. 系统结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-text">2. 设计思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%86%E7%89%87%E7%AD%96%E7%95%A5"><span class="toc-text">3. 分片策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-text">4. 分布式并发控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-%E5%88%86%E5%B8%83%E5%BC%8FOLTP"><span class="toc-text">22. 分布式OLTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE"><span class="toc-text">1. 提交协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">1. 两阶段提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Paxos-Raft"><span class="toc-text">2. Paxos&#x2F;Raft</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">2. 数据复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-CAP"><span class="toc-text">3. CAP</span></a></li></ol></li></ol> -->
        <div class="toc"></div>
      </div>
    </div>
  </div>
</section>
<!-- 手机端目录按钮 -->
<div id="toc-mobile-btn">
  <i class="fas fa-list-ul" aria-hidden="true"></i>
</div>

      
  <section class="widget side_recent_post">
    
  <header>
    
      <a style="color: " href='/tags/'><i class="fas fa-book fa-fw" aria-hidden="true"></i><span class='name'>最新文章</span></a>
    
  </header>


    <div class='content'>
      
      <!-- hash算法 -->
      
      <div class="aside-list">
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%AF%E8%A7%82%E6%B5%8B/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">09-11</span>
                
              </div>
              <a class="post-title" href="/2023/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%AF%E8%A7%82%E6%B5%8B/">学习笔记 可观测</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-InfluxDB/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">09-11</span>
                
              </div>
              <a class="post-title" href="/2023/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-InfluxDB/">学习笔记 InfluxDB</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SpringMVC/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">09-11</span>
                
              </div>
              <a class="post-title" href="/2023/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SpringMVC/">学习笔记 SpringMVC</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ZooKeeper/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-5f7cb7e900b9dcf5354c3d4d2c5cc3c2_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-5f7cb7e900b9dcf5354c3d4d2c5cc3c2_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">09-11</span>
                
              </div>
              <a class="post-title" href="/2023/09/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ZooKeeper/">学习笔记 ZooKeeper</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/09/02/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic2.zhimg.com/80/v2-29e78b52051ce542adf6d786d61fbd19_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-29e78b52051ce542adf6d786d61fbd19_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">09-02</span>
                
              </div>
              <a class="post-title" href="/2023/09/02/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">经验分享-如何在阿里云ECS上部署自己的应用程序</a>
            </div>
          </div>
        
      </div>
    </div>
  </section>

    
  </div>
</aside>

  <!-- 图片放大 Wrap images with fancybox support -->
  <script src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || 'rgba(66, 185, 133, 0.8)';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          
            <!-- 不蒜子统计 -->
            <!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
      <i class="fas fa-eye" aria-hidden="true"></i>本站总访问量：<span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
      <i class="fas fa-users" aria-hidden="true"></i>本站访客数：<span id="busuanzi_value_site_uv"></span> 人
</span>

          
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark">
  <div class="dark-content">
    <i class="fas fa-moon" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-moon" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    

    <!-- 图片放大 -->
    
      <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    
      <script type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<!-- <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -70,
    // headingsOffset: -($(window).height() * 0.4 - 45),
    headingsOffset: -($(window).height() * 0.4 - 70),
    // positionFixedSelector: '.toc-main',
    // positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    orderedList: true,
    collapseDepth: 20,
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 150) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('side_toc')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  /* .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  } */
</style>
 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 渲染远程json加载的图片标签(getPhotoOnline)里的内容 -->
<script>
  function loadPhotoOnlineJS() {
    if ($(".post-detail").find(".getJsonPhoto-api").length == 0) {
      return;
    } 
    loadScript('/js/getPhotoOnline/index.js');
  };
  $(function () {
    loadPhotoOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getPhotoJson == "undefined") {
      loadPhotoOnlineJS();
    }
  })
</script>

<!-- 渲染远程json加载的site-card标签(getSiteOnline)里的内容 -->
<script>
  function loadSiteOnlineJS() {
    if ($(".post-detail").find(".getJsonSite-api").length == 0) {
      return;
    } 
    loadScript('/js/getSiteOnline/index.js');
  };
  $(function () {
    loadSiteOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getSiteJson == "undefined") {
      loadSiteOnlineJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
    <script type="text/javascript">
  var utteranceCommon = {};

  function check_utterance() {
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    if (isDark) {
      utteranceCommon.Theme = 'github-dark';
    } else {
      utteranceCommon.Theme = 'github-light';
    }

    return document.getElementById("gitment-container");
  }
  comment_el = '#gitment-container';
  load_utterance = function () {
    if ($(comment_el).length) {
      // 匿名函数，防止污染全局变量
      const HEAD = check_utterance();

      var utterances = document.createElement('script');
      utterances.type = 'text/javascript';
      utterances.async = true;
      utterances.setAttribute('issue-term', 'pathname')
      utterances.setAttribute('theme', utteranceCommon.Theme)
      utterances.setAttribute('repo', '')
      utterances.crossorigin = 'anonymous';
      utterances.src = 'https://utteranc.es/client.js';
      // content 是要插入评论的地方
      document.getElementById('gitment-container').appendChild(utterances);

    }
  }

  function dark_utterance() {
    const HEAD = check_utterance();
    if (!HEAD) return;
    const message = {
      type: 'set-theme',
      theme: utteranceCommon.Theme
    };
    const utteranceIframe = document.querySelector('iframe');
    utteranceIframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }

  $(document).ready(load_utterance);
  document.addEventListener('pjax:complete', function () {
    load_utterance();
  });

  $('.dark').click(function () {
    setTimeout(() => {
      dark_utterance();
    });
  })

</script>

<style>
  .utterances {
    max-width: inherit !important;
  }
</style>
  


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


<!-- 轮播图标签 -->
<script>
  var bambooSwiperTag = {};
  function load_swiper() {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    loadCSS("https://unpkg.com/swiper@6/swiper-bundle.min.css")
    loadScript("https://unpkg.com/swiper@6/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    bambooSwiperTag.swiper = new Swiper('.post-swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      autoplay: true ? {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false,
      } : false,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
      on:{
        init: function(){
          swiperAnimateCache(this); //隐藏动画元素 
          swiperAnimate(this); //初始化完成开始动画
        }, 
        slideChangeTransitionEnd: function(){ 
          swiperAnimate(this); //每个slide切换结束时也运行当前slide动画
          //this.slides.eq(this.activeIndex).find('.ani').removeClass('ani'); 动画只展现一次，去除ani类名
        } 
      }
    });
  }

  document.addEventListener('pjax:complete', function () {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    if (typeof bambooSwiperTag.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>
    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  </body>
</html>