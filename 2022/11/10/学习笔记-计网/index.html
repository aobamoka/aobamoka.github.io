<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>学习笔记-计网 | 摩卡&#39;s blog</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/icons/icon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    <link href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css" rel="stylesheet">
  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script defer src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    
    
    <!-- 依赖于jquery和vue -->
    
        <script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>
    

    
        <script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>
    

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="摩卡's blog" type="application/atom+xml">
</head>

  
  <!-- 预加载动画 -->
  <!-- 页面预加载动画 -->

  
    <div class="preloader_2" id="loader">
  <div class="loader"></div>
</div>

  
<script>
  var endLoading = function () {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('DOMContentLoaded',endLoading);
</script>

  <body>
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (src) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header  " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
      <h3 class="drawer-box-head_title">摩卡&#39;s blog</h3>
      <h5 class="drawer-box-head_desc">随便写写，记录下都看了些啥</h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
        </div>
      
      <a href="/" class="logo">摩卡&#39;s blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
    <div id="he-plugin-simple"></div>
    <script>
      WIDGET = {
        CONFIG: {
          "modules": "012",
          "background": 5,
          "tmpColor": "4A4A4A",
          "tmpSize": 16,
          "cityColor": "4A4A4A",
          "citySize": 16,
          "aqiSize": 16,
          "weatherIconSize": 24,
          "alertIconSize": 18,
          "padding": "10px 10px 10px 10px",
          "shadow": "1",
          "language": "auto",
          "borderRadius": 5,
          "fixed": "false",
          "vertical": "middle",
          "horizontal": "center",
          "key": "2784dd3fcb1e4f0f9a9b579bf69641f2"
        }
      }
    </script>
    <script defer src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script> 
    
</header>
        <!-- 内容区域 -->
        
 <!-- prismjs 代码高亮 -->
 


<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        学习笔记-计网
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2022-11-10 |
        </span>
      

      

      
    
  </div>
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content post-row" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <h1 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h1><h2 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h2><ul>
<li>物理层：在物理网络中传输数据帧。集线器。</li>
<li>数据链路层：数据的封帧和差错检测。交换机。</li>
<li>网络层：数据的路由、转发、分片。路由器。</li>
<li>传输层：端到端传输。TCP、UDP。</li>
<li>会话层：建立、管理和终止表示层实体之间的通信会话，为应用程序提供建立、维持会话的功能。RPC。</li>
<li>表示层：把数据转换成兼容另一个系统能识别的格式，即翻译成用户/计算机能看懂的格式。还有安全加密、压缩等功能。</li>
<li>应用层：给应用程序提供统一接口。</li>
</ul>
<p>与网络四层（应用层、传输层、网际层、网络传输层）的关系：</p>
<ul>
<li>七层是标准而非实现；四层是实现的应用模型</li>
<li>四层模型由七层模型简化合并而来</li>
</ul>
<p>分层的好处：</p>
<ul>
<li>耦合度低，方便更新维护的同时不影响其他层</li>
<li>灵活性高</li>
<li>能促进标准化工作</li>
</ul>
<h2 id="2-各层协议"><a href="#2-各层协议" class="headerlink" title="2. 各层协议"></a>2. 各层协议</h2><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><ul>
<li>HTTP超文本传输协议</li>
<li>HTTPS超文本传输安全协议</li>
<li>Telnet远程登录服务的标准协议<ul>
<li>建立在TCP上，通过一个终端登录到其他服务器。</li>
<li>缺点：所有数据均以明文形式发送。</li>
</ul>
</li>
<li>FTP文件传输协议。用并行的两条TCP连接，控制连接（端口21）与数据连接（端口20）。</li>
<li>TFTP简单文件传输协议</li>
<li>SMTP简单邮件传输协议（发送用）<ul>
<li>发送邮件</li>
<li>判断邮箱存在<ul>
<li>查询邮箱域名对应的SMTP服务器地址。</li>
<li>尝试与服务器建立连接。</li>
<li>连接成功后尝试向需要验证的邮箱发送邮件。</li>
<li>根据返回结果判断真实性。</li>
</ul>
</li>
</ul>
</li>
<li>POP3/IMAP邮件接收地协议（接收用）</li>
<li>DHCP动态主机配置协议<ul>
<li>客户端发起DHCP发现报文，使用UDP广播通信（因为客户端没有IP地址，也不知道DHCP服务器地址，没法建立连接），DHCP客户端传递给链路层，广播到所有网络设备。</li>
<li>DHCP服务器用DHCP提供报文响应，仍然使用广播。报文携带服务器提供可租约的IP地址、子网掩码、默认网关、DNS服务器以及租用期。</li>
<li>客户端收到多个服务器的提供报文，选择一个服务器，发送DHCP响应，回显配置的参数。</li>
<li>服务端用DHCP ACK报文回应，应答要求的参数。</li>
<li>客户端IP地址快到期时，客户端发送DHCP请求报文，服务器回复ACK/NACK报文表示是否同意租用。</li>
<li>广播需要服务器和客户端在一个局域网内，所以用DHCP中继代理中转。</li>
</ul>
</li>
<li>SSH：安全的网络传输协议。相较于Telnet，会对传输的数据加密。</li>
</ul>
<h3 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h3><p>TCP、UDP</p>
<h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><ul>
<li>IP网际协议：定义数据传输的基本单元和格式，定义数据包的递交方法和路由选择</li>
<li>ICMP Internet控制报文协议：检测网路的连接状况，确保连线的准确性</li>
<li>RIP路由信息协议：使用条数衡量到达目标的路由距离</li>
<li>IGMP Internet组管理协议：实现组播、广播等通信</li>
</ul>
<h3 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h3><ul>
<li>ARP地址解析协议：根据IP地址获取MAC地址<ul>
<li>主机广播ARP请求，同个链路的设备收到ARP请求时拆开包查看，如果目标IP地址与自身一致，则将自己的MAC地址塞入ARP响应包返回给主机。</li>
</ul>
</li>
<li>RARP反向地址转换协议：根据MAC地址获取IP地址<ul>
<li>需要RARP服务器，在该服务器上注册设备的MAC地址与IP地址，然后RARP协议直接到服务器查询。</li>
</ul>
</li>
<li>PPP点对点协议：通过拨号或专线方式建立点对点连接发送数据</li>
</ul>
<h2 id="3-WWW万维网构建技术"><a href="#3-WWW万维网构建技术" class="headerlink" title="3. WWW万维网构建技术"></a>3. WWW万维网构建技术</h2><ol>
<li>HTML超文本标记语言</li>
<li>HTTP超文本传输协议</li>
<li>URL统一资源标识符：指定超文本文档所在地址</li>
</ol>
<h1 id="2-HTTP"><a href="#2-HTTP" class="headerlink" title="2. HTTP"></a>2. HTTP</h1><h2 id="1-HTTP报文格式"><a href="#1-HTTP报文格式" class="headerlink" title="1. HTTP报文格式"></a>1. HTTP报文格式</h2><p>首部为名称-值的键值对。</p>
<p>每行以\r\n结束。（回车符+换行符）</p>
<h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1. 请求报文"></a>1. 请求报文</h3><p>第一行为请求行，包含请求方法、URL、协议版本</p>
<p>接下来多行都是请求头部，格式为“字段：值”。</p>
<p>一个空行分隔首部和内容主体。</p>
<p>最后是请求主体内容。</p>
<h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2. 响应报文"></a>2. 响应报文</h3><p>第一行为状态行，包含协议版本、状态码与描述</p>
<p>接下来多行都是响应头部，格式为“字段：值”。</p>
<p>一个空行分隔首部和内容主体。</p>
<p>最后是响应主体内容。</p>
<h2 id="2-HTTP缓存"><a href="#2-HTTP缓存" class="headerlink" title="2. HTTP缓存"></a>2. HTTP缓存</h2><p>可通过Cache-Control的no-store指令禁止缓存，no-cache指令强制确认缓存，即使用缓存必须向服务器确认效性而不允许直接用强制缓存。</p>
<p>HTTP缓存分为强制缓存与协商缓存。</p>
<p>强制缓存可以通过状态码200后是否有from disk cache判断，通过判断HTTP响应头部中的Cache-Control（相对时间，优先级高）和Expires（绝对时间）两个字段决定是否使用本地缓存。</p>
<p><strong>只有未能命中强制缓存时，才能发起带有协商缓存字段的请求</strong>。协商缓存响应状态码为304，表示与服务端协商后，通过协商结果判断是否用本地缓存。流程如图：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="协商缓存"></p>
<p>文字过程：</p>
<ol>
<li>浏览器第一次请求访问服务器资源时，服务器返回时在头部加上ETag唯一标识（根据请求的资源生成）</li>
<li>浏览器再次请求访问服务器该资源时，首先检查强制缓存是否过期<ol>
<li>如果没有过期，直接使用本地缓存</li>
<li>如果过期，在请求头部加上If-None-Match字段，该字段的值就是ETag唯一标识</li>
</ol>
</li>
<li>服务器再次收到请求后，根据If-None-Match值与请求资源的唯一标识比较：<ol>
<li>值相等，返回304且不返回资源</li>
<li>不相等，返回200且返回资源，并加上新的ETag</li>
</ol>
</li>
<li>浏览器如果收到304，则从本地缓存中加载资源，否则更新资源</li>
</ol>
<p>Etag基于文件唯一标识实现，而Last-Modified基于时间，所以Etag更能准确判断文件是否修改过。</p>
<p>Etag优先级高于Last-Modified的原因：</p>
<ol>
<li>即使没有修改文件内容，最后修改时间也可能改变。</li>
<li>有些文件的修改是1s内多次，而If-modified-since只能检测秒级粒度。</li>
<li>有些服务器不能精确获取最后修改时间。</li>
</ol>
<h2 id="3-HTTP1-1"><a href="#3-HTTP1-1" class="headerlink" title="3. HTTP1.1"></a>3. HTTP1.1</h2><p>相较于HTTP1.0</p>
<ul>
<li>连接方式：长连接改善了短连接造成的性能开销（HTTP1.0每次发送请求都要建立一次TCP连接）。Connection：Keep-Alive。</li>
<li>多了Host域，存放url。因为HTTP1.1时代一个物理主机上已经可以存在多个虚拟主机，且共享一个IP地址，要通过域名区分。</li>
<li>带宽优化：多了range域，支持只请求资源的某个部分。Content-Range中声明返回对象的偏移值和长度。服务器返回了该范围则返回206，防止Cache将响应误认为是完整对象。</li>
<li>多了100状态码。客户端可事先发送只带头域的请求，如果服务器因为权限拒绝，就返回401；如果接受就返回100，客户端可继续发送带实体的完整请求，在请求头包含Expect：100-continue。</li>
<li>缓存：引入Etag、If-None-Match等更多判断缓存是否过期的标准。</li>
</ul>
<p>1.1的特点</p>
<ol>
<li>优点：<ol>
<li><strong>简单</strong>：报文格式使用header+body，头部信息使用key-value，易于理解。</li>
<li><strong>可拓展性强</strong>：HTTP协议的每个组成部分都允许开发人员自定义，且允许第七层之下的层随意变化。</li>
<li><strong>应用广泛与跨平台</strong>。</li>
</ol>
</li>
<li>双刃剑：<ol>
<li><strong>无状态</strong>：服务器不需要额外信息记录状态，减轻压力；如果完成有关联的操作时很麻烦，需要借助Cookie技术，在第一次相应时附加Cookie信息，之后根据接收报文的Cookie信息判断是否关联。</li>
<li><strong>明文传输</strong>：方便阅读，从而方便调试工作；但是相当于信息裸奔，引发诸多<strong>不安全</strong>，如<strong>通信内容不完整、通信对象伪装、通信内容被窃听</strong>。</li>
<li><strong>队头阻塞</strong>：当顺序发送的请求序列中的一个请求被阻塞时，后面排队的所有请求也一同被阻塞。</li>
</ol>
</li>
<li>特点：<ol>
<li>长连接/持久连接：只要任意一端没有明确提出断开连接，则保持TCP连接。</li>
<li>管道网络传输：允许连续发出报文而不必等待ACK；但是会造成响应端的队头阻塞，而且该功能默认关闭，实际上并没有使用。</li>
</ol>
</li>
<li>缺陷：高延迟<ol>
<li>并发连接有限</li>
<li>队头阻塞</li>
<li>HTTP头部巨大且重复（HTTP协议的无状态导致）</li>
<li>不支持服务器主动推送</li>
</ol>
</li>
</ol>
<h2 id="4-HTTPS"><a href="#4-HTTPS" class="headerlink" title="4. HTTPS"></a>4. HTTPS</h2><ol>
<li><p>特点：在TCP与HTTP层之间加入了SSL（Secure Socket Layer，安全套接字）/TLS（Transport Layer Security，安全传输层协议）安全协议，在三次握手后还需要进行SSL/TLS握手。HTTPS实现了信息加密（防窃听）、校验机制（防篡改）与身份证书（防冒充）。</p>
</li>
<li><p>SSL与TLS：TLS1.0是SSL3.0的升级版，没太大区别。</p>
</li>
<li><p>优点：</p>
<ol>
<li>信息加密：交互信息无法被窃听。</li>
<li>校验机制：无法篡改通信内容。</li>
<li>身份证书：无法伪造身份，并能证明报文完整。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>效率低：通信前必须进行TLS四次握手，存在握手时延。</li>
<li>部署成本高：购买CA证书；加解密计算占用CPU，需要高服务器数目或配置。</li>
</ol>
</li>
<li><p>SSL/TLS安全协议：使用了对称加密与非对称加密的混合加密。</p>
<ol>
<li>对称加密：双方用同一把密钥加密与解密。但是密钥会在交换过程中被窃取。</li>
<li>非对称加密：接收方生成公钥与私钥，将公钥发给发送方。公钥加密的消息只有私钥能解密。但是速度慢。因为对称加密主要用的位运算，非对称加密主要用大数乘法、大数模。</li>
</ol>
</li>
<li><p>混合加密——保证信息加密：</p>
<ol>
<li>接收方生成公钥a和私钥，并发送给发送方公钥a。</li>
<li>发送方生成临时密钥公钥b作为对称加密的公钥，使用公钥b加密发送的信息，使用公钥a加密公钥b，并打包发送。</li>
<li>接收方使用私钥解密得到公钥b，然后用公钥b解密得到信息。</li>
</ol>
</li>
<li><p>摘要算法+数字签名——防篡改：</p>
<ol>
<li>摘要算法：发送方计算内容的哈希值，加密并发送给接收方，接收方接收后计算内容的哈希值并与解密的内容对比是否一致。</li>
<li>数字签名：使用非对称加密，私钥加密公钥解密，来确保发送者是私钥持有者。</li>
</ol>
</li>
<li><p>数字证书——防伪造：</p>
<ol>
<li><p>CA（数字证书认证机构）。CA的公钥已经事先设置在操作系统中</p>
</li>
<li><p>流程：</p>
<ol>
<li>服务器将自己的公钥上传到CA。</li>
<li>CA打包持有者的公钥、用途、颁发者、有效时间等信息，计算Hash值进行摘要，并用私钥给Hash值加密，生成Certificate Signature，最后将其添加在文件证书上，形成数字证书。</li>
<li>客户端接收到服务端的数字证书后，先用CA的公钥（操作系统内置）解密签名，并与自己用相同Hash算法算出的Hash值对照确认身份，并获得服务器的公钥。</li>
<li>客户端使用服务器的公钥加密发送。</li>
<li>服务器解密。</li>
</ol>
</li>
<li><p>信任链：证书存在层级关系。如果收到的不是根证书，客户端会逐级向上请求证书，直到根证书，再从根证书逐级向下查询下级证书是否可信。</p>
</li>
<li><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
</li>
</ol>
</li>
</ol>
<h2 id="5-TLS四次握手——RSA算法"><a href="#5-TLS四次握手——RSA算法" class="headerlink" title="5. TLS四次握手——RSA算法"></a>5. TLS四次握手——RSA算法</h2><p>注意：每一次一端发送信息，另一端都会回复ACK表示确认收到，步骤里就没有详细说明了。</p>
<ol>
<li>第一次：<ol>
<li>Client Hello消息：客户端给出自己的TLS版本号、支持的密码套件列表与生成的随机数。</li>
</ol>
</li>
<li>第二次：<ol>
<li>Server Hello：服务器确认是否支持TLS版本号，并选择一个密码套件，生成一个随机数，返回Server Hello消息。密码套件的基本形式是“<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>”。</li>
<li>Server Certificate：服务器发送含有数字证书的Server Certificate给客户端。</li>
<li>Server Hello Done：表示本次打招呼完毕。</li>
</ol>
</li>
<li>第三次：客户端验证证书确认是否可信。客户端生成新的随机数，用服务器的RSA公钥加密并通过Client Key Exchange消息传递给服务器。服务器用RSA私钥解密得到随机数。双方使<strong>用三个随机数生成会话密钥</strong>，客户端共发送：<ol>
<li>Client Key Exchange：第三个随机数</li>
<li>Change Cipher Spec：加密通信算法改变通知，表示之后的信息都用会话密钥加密通信</li>
<li>Finished：握手结束通知，把之前所有内容的发生数据做个摘要，供对方校验（加密通信是否可用、握手途中是否被篡改）</li>
</ol>
</li>
<li>第四次：服务器算出会话密钥后，返回3的后两种消息，双方验证无误后握手正式完成。<ol>
<li>Change Cipher Spec：加密通信算法改变通知，表示之后的信息都用会话密钥加密通信</li>
<li>Finished：握手结束通知，把之前所有内容的发生数据做个摘要，供对方校验（加密通信是否可用、握手途中是否被篡改）</li>
</ol>
</li>
<li>后续都使用会话密钥加密通信。</li>
<li>缺陷：不支持前向保密：客户端使用服务端的公钥加密随机数，服务端用私钥解密。一旦服务器的私钥泄露，过去被第三方结果的所有TLS通讯密文都会被破解，进而获得过去的会话密钥，进而破解过去的会话信息。</li>
</ol>
<h2 id="6-TLS四次握手——ECDHE算法"><a href="#6-TLS四次握手——ECDHE算法" class="headerlink" title="6. TLS四次握手——ECDHE算法"></a>6. TLS四次握手——ECDHE算法</h2><p>注意：每一次一端发送信息，另一端都会回复ACK表示确认收到，步骤里就没有详细说明了。</p>
<ol>
<li>离散对数：当模数p是一个很大的质数时，即使知道底数a和真数b，在现有计算机的水平下几乎无法计算出离散对数。<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="离散对数"></li>
<li>发展历程：基于离散对数的DH算法，分为两种实现：static DH算法中一方私钥是静态的，这样会导致随着时间延长，黑客截获海量的密钥协商过程并暴力破解私钥；DHE算法中双方的私钥都随机临时生成，但是因为需要做大量乘法导致计算性能不佳。</li>
<li>原理：双方事先确定使用的椭圆曲线以及基点G；随机生成私钥d并与G相乘得到公钥Q；双方交换公钥，与自己的私钥相乘得到坐标x，y，x相同，即为共享密钥。</li>
<li>第一次：与RSA相同。</li>
<li>第二次：与RSA相似，但是选择ECDHE作为密钥协商算法。<ol>
<li>Server Hello：服务器确认是否支持TLS版本号，并选择一个密码套件，生成一个随机数，返回Server Hello消息。</li>
<li>Server Certificate：服务器发送含有数字证书的Server Certificate给客户端。</li>
<li>Server Key Exchange：服务器选择椭圆曲线、基点，生成随机数服务器私钥保留在本地，并计算出来服务器公钥。</li>
<li>Server Hello Done。</li>
</ol>
</li>
<li>第三次：客户端验证证书确认是否可信。客户端生成随机数客户端私钥，然后根据服务器选择的椭圆曲线参数，计算出客户端公钥，用Client Key Exchange发送给服务端。双方计算出x，并使用客户端随机数+服务器随机数+x生成会话密钥。后续与RSA相同。</li>
<li>第四次：与RSA相同。</li>
<li>不同：使用ECDHE算法，客户端可以不等服务端最后一次TLS握手就能提前发送加密的HTTP数据，节省了一个消息往返的时间。</li>
<li>前向安全性：每一次的私钥都是独立生成的。</li>
</ol>
<h2 id="7-TLS其他"><a href="#7-TLS其他" class="headerlink" title="7. TLS其他"></a>7. TLS其他</h2><p>TLS在实现上分为握手协议和记录协议两层：</p>
<ul>
<li>握手协议即为四次握手的过程</li>
<li>记录协议负责保护应用程序数据并验证其完整性和来源，对HTTP数据加密时使用。<ul>
<li>消息被分割成多个较短的片段，分别进行压缩</li>
<li>每个被压缩的片段加上消息认证码（通过哈希算法生成的MAC值）。MAC值用于识别篡改，同时为了防止重放攻击，还加上了片段的编码。</li>
<li>通过对称算法（会话密钥）加密。</li>
<li>加上由数据类型、版本号、压缩后长度等信息组成的报头，组成最终的报文数据。</li>
</ul>
</li>
</ul>
<p>中间人服务器攻击：截取握手信息并分别对客户端/服务端伪造服务端/客户端。但是需要用户接受中间人服务器的证书，而<strong>浏览器能识别出非法证书</strong>并提醒。</p>
<p>抓包工具：抓包工具类似中间人服务器攻击，但是先在客户端安装了其根证书，相当于抓包工具给自己创建了认证中心CA。</p>
<p>此外，可以通过双向认证来避免中间人截取。</p>
<h2 id="8-HTTP1-1优化"><a href="#8-HTTP1-1优化" class="headerlink" title="8. HTTP1.1优化"></a>8. HTTP1.1优化</h2><ol>
<li><p>尽量避免发送HTTP请求：缓存技术。</p>
</li>
<li><p>减少HTTP请求次数：</p>
<ol>
<li>减少重定向请求次数：将重定向工作交由代理服务器完成。</li>
<li>合并请求：将小图片拼成大图片、打包资源等。</li>
<li>延迟发送请求：进入页面时只获取用户能看到的页面资源。</li>
</ol>
</li>
<li><p>压缩：</p>
<ol>
<li>无损压缩：用在文本文件、代码文件、可执行文件中，去除换行符、空格之后用霍夫曼编码压缩（gzip等）。</li>
<li>有损压缩：用在多媒体数据。</li>
</ol>
</li>
</ol>
<h2 id="9-HTTPS优化"><a href="#9-HTTPS优化" class="headerlink" title="9. HTTPS优化"></a>9. HTTPS优化</h2><ol>
<li>硬件优化、软件优化：升级。</li>
<li>软件优化：Linux内核、OpenSSL。</li>
<li>协议优化：<ol>
<li>密钥交换算法优化：ECDHE</li>
<li>TLS优化：升级到1.3。<ol>
<li>把Hello和公钥交换合并成一个消息，将握手时间减少到1RTT。客户端在Hello消息中带上支持的椭圆曲线与对应的公钥，服务端选定一个曲线，回复时带上自己计算出的公钥。</li>
<li>减少密码套件，废除不支持前向安全的RSA与DH算法，防止降级攻击。</li>
</ol>
</li>
</ol>
</li>
<li>证书优化：<ol>
<li>传输：选择椭圆曲线（ECDSA）证书而不是RSA证书，因为在相同安全强度下ECC密钥长度远小于RSA。</li>
<li>验证：<ol>
<li>证书吊销列表CRL：CA定期更新维护被撤销信任的证书序号。实时性较差；随证书增多列表变大，下载速度变慢。</li>
<li>在线证书状态协议OCSP：向CA发送查询请求证书的有效状态。受制于网络状态与CA服务器繁忙。</li>
<li>OCSP Stapling：服务器向CA周期性查询证书状态，获得带有时间戳和签名的响应结果并缓存。</li>
</ol>
</li>
</ol>
</li>
<li>会话复用：<ol>
<li>Session ID：首次握手后用Session ID标识会话密钥。服务器内存压力大；客户端不一定连接到同一台服务器。</li>
<li>Session Ticket：服务器加密会话密钥作为Ticket发送给客户端缓存。不具备前向安全性；应对重放攻击困难。</li>
<li>Pre-shared Key：TLS1.3，只需要0RTT就能恢复会话。将Ticket与HTTP请求一同发送给服务端。同样有重放攻击危险。</li>
<li>应对重放攻击：设定合理的过期时间；只对安全的HTTP请求使用会话复用。</li>
</ol>
</li>
</ol>
<h2 id="10-HTTP2-0"><a href="#10-HTTP2-0" class="headerlink" title="10. HTTP2.0"></a>10. HTTP2.0</h2><ol>
<li>新特性：<ol>
<li>传输格式：从基于文本变为基于二进制。1.x以换行符作为纯文本分隔符，2将传输的信息分割为更小的消息和帧，并对其采用二进制格式编码。</li>
<li>多路复用：连接共享。每条Stream为一个请求，多个Stream共享一条连接，且不同Stream可以乱序到达，效率大大提高。</li>
<li>头部压缩：避免重复header传输，减少包大小，提高效率。</li>
<li>服务端推送：把客户端需要的资源伴随index.html一起发送过去，省去客户端重复请求。</li>
</ol>
</li>
<li>HPACK算法头部压缩：压缩的是Frame帧数据，包括原HTTP1.1的头部和包体<ol>
<li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E5%A4%B4%E9%83%A8.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E9%9D%99%E6%80%81%E5%A4%B4%E9%83%A8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="头部"></li>
<li>静态字典：为高频出现在头部的字符串和字段建立了一张静态表，使用huffman编码压缩（频率越高，huffman编码越短）。</li>
<li>动态字典：为不在静态表范围内的头部字符串构建，在发送完某字段数据后，双方同步更新动态表，从index=62开始添加，这样在下次发送只需要发送1个字节的index号。</li>
</ol>
</li>
<li>二进制帧：将响应报文划分为10种类型的帧，分为数据帧和控制帧，并采用二进制编码。<ol>
<li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="帧"></li>
<li>标志位携带简单的控制信息，如END_HEADERS表示头数据结束标志，END_Stream表示单方向数据发送结束，PRIORITY表示流的优先级。</li>
<li>流标识符标识该Frame属于哪个stream。</li>
<li>帧数据存放通过HPACK算法压缩过的HTTP头部和包体。</li>
</ol>
</li>
<li>并发传输：多个Stream复用一条TCP连接达到并发。<ol>
<li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/stream.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Stream"></li>
<li>从大到小：<ol>
<li>一个TCP连接中有多个Stream</li>
<li>一个Stream里有多个Message，Message相当于HTTP1中的请求或相应，由HTTP头部和包体构成。</li>
<li>一条Message里包含多个Frame，它是HTTP2的最小单位，以二进制压缩格式存放HTTP1中的内容。HTTP1.1的首部信息封装到headers帧，request body封装到data帧。</li>
</ol>
</li>
<li>同一个HTTP请求与响应跑在一个Stream中，一个Frame由多个TCP报文构成。</li>
<li>不同Stream帧可以乱序发送，由帧头部的流标识符区分并有序组装，因此可以通过并发Stream实现并发请求；同一Stream内部的帧必须严格有序。</li>
<li>可以根据控制位对每个Stream设置不同优先级。</li>
<li>双方都可以建立Stream，客户端建立的Stream必须是奇数号，而服务端必须是偶数号。</li>
<li>通过Stream实现并发，在HTTP1.1中实现多少个并发Stream就要建立多少次TCP连接，而在HTTP2.0中只需要建立一次。</li>
</ol>
</li>
<li>主动推送资源：<ol>
<li>旧版本：浏览器收到html文件后，发现包含CSS样式表文件、PNG图片文件等文件时，还需要对每个文件发出一条请求，请求该资源。</li>
<li>问题：请求时延；收到资源前网页显示空白，影响用户体验。</li>
<li>主动推送：客户端访问HTML时，服务器可以主动推送CSS、PNG等文件。服务器通过PUSH_PROMISE帧传输HTTP头部，并通过Promised Stream ID字段告知客户端将会在哪个偶数号Stream中发送包体。</li>
</ol>
</li>
<li>特点：压缩算法、Stream并发、服务器主动推送</li>
<li>缺点：<ol>
<li>HTTP2基于TCP协议传递数据，TCP是字节流协议，必须保证收到的字节数据完整且连续，当前一个字节数据没有到达时，后收到的字节数据都会放在内核缓冲区，存在队头阻塞问题。即<strong>TCP丢包时，TCP中的所有Stream都要等待</strong>。</li>
<li>TCP与TLS的握手延迟。</li>
<li>网络迁移需要重新连接。</li>
</ol>
</li>
</ol>
<h2 id="11-HTTP3-0"><a href="#11-HTTP3-0" class="headerlink" title="11. HTTP3.0"></a>11. HTTP3.0</h2><ol>
<li><p>QUIC：基于UDP在应用层实现的协议。QUIC是传输层协议。</p>
<ol>
<li>无队头阻塞：底层UDP不关心数据包的顺序与丢失。为了保证可靠性，Stream中的一个数据包丢失了，该流的其他数据包无法被HTTP3读取直到QUIC重传丢失的报文；<strong>其他流的数据报文可以正常被读取</strong>。</li>
<li>更快的连接建立：QUIC内部包含TLS，在自己的帧里会携带TLS里的记录；QUIC使用的是TLS1.3，因此仅需1个RTT就可以同时完成连接建立与密钥协商；第二次连接时应用数据包可以和QUIC握手信息一起发送，达到0RTT。</li>
<li>连接迁移：通过头部的CID标识连接，双方在随机生成的CID列表上达成一致，列表上的CID映射到同一连接，切换环境时切换CID。（防止CID被窃取获得用户地址）迁移后双方都向对方发起路径验证，探测可达性。</li>
</ol>
</li>
<li><p>HTTP层</p>
<ol>
<li>帧头部：直接使用QUIC里的Stream，帧头部只有类型和长度两个字段。</li>
<li>头部压缩算法：QPACK<ol>
<li>静态表：扩大到91项</li>
<li>动态表：如果首次出现的请求丢包，后续收到请求时无法解码出HPACK头部；QUIC使用QPACK Encoder Stream传递键值对与QPACK Decoder Stream响应，进行动态表同步。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="12-RPC远程过程调用"><a href="#12-RPC远程过程调用" class="headerlink" title="12. RPC远程过程调用"></a>12. RPC远程过程调用</h2><p>通过网络从远程计算机上请求服务，而不需要了解底层网络技术。简单来说，程序像调用本地方法一样调用远程方法。</p>
<ol>
<li>HTTP主要用于b(rowser)/s(erver)架构，而RPC主要用于c(lient)/s(erver)架构。因为之前的软件大部分作为客户端只需要跟自家的服务端建立连接，因此可以使用自家造的RPC协议，而浏览器需要访问不同公司的服务器，所以需要统一的标准，即HTTP。</li>
<li>两者区别：<ol>
<li>服务发现：找到服务对应的IP端口：HTTP通过DNS服务找IP地址，端口默认80（DNS也是一种服务发现）；RPC有专门的中间服务保存服务名和IP信息。</li>
<li>底层连接形式：都是建立长连接。HTTP通过keep alive保持连接并复用；RPC一般有连接池，复用连接。</li>
<li>传输消息：RPC采用体积更小的序列化协议保存结构体数据，因此性能比HTTP1.1更好一些。</li>
</ol>
</li>
</ol>
<h2 id="13-长轮询"><a href="#13-长轮询" class="headerlink" title="13. 长轮询"></a>13. 长轮询</h2><p>用于手机扫网页端二维码等场景。打开二维码时发送的HTTP请求增大超时延迟，在超时延迟内服务器只要收到扫码请求就立即返回给客户端网页，因此可以实现及时响应。</p>
<p>消息较少时使用，如果服务器想频繁主动推送大量消息，要用WebSocket。</p>
<h2 id="14-WebSocket"><a href="#14-WebSocket" class="headerlink" title="14. WebSocket"></a>14. WebSocket</h2><p>实现全双工连接。</p>
<ol>
<li>建立：在完成TCP握手与一次HTTP通信后，如果想建立WebSocket连接，就在HTTP header头中表示想升级成WebSocket协议，并附带一段随机生成的base64码。如果服务器支持升级，就用base64码用某个公开算法变成另一段字符串，同时带上101状态码（协议切换）返回给浏览器。浏览器使用同样的公开算法转换base64码来验证是否一致。</li>
<li>格式：<img src="https://img-blog.csdnimg.cn/img_convert/3a63a86e5d7e72a37b9828fc6e65c21f.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/3a63a86e5d7e72a37b9828fc6e65c21f.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="WebSocket"></li>
<li>opcode：数据类型</li>
<li>payload长度：先读最开始的7位，如果是0-125表示payload全部长度；如果是126表示长度在126-65535之间，还会读取16bit；如果长度是127还会再读64bit。</li>
<li>使用场景：需要<strong>服务器和客户端频繁交互</strong>的场景，如游戏、网页聊天室、网页协同办公软件。</li>
<li>除了建立连接时通过http报文携带websocket升级信息外，工作时与http并没有关系。</li>
</ol>
<h2 id="15-GET与POST的区别"><a href="#15-GET与POST的区别" class="headerlink" title="15. GET与POST的区别"></a>15. GET与POST的区别</h2><p>本质实际上都是一样的，只是浏览器和客户端会对不同类型的HTTP包做出不同的限制，导致它们在应用过程中不同。</p>
<ol>
<li>操作：获取数据、修改数据</li>
<li>安全性：GET数据参数暴露在url中，安全性相对较低，POST把数据放在HTTP包体，相对安全</li>
<li>数据限制：GET最大为2K，POST理论上没有限制</li>
<li>GET请求会被浏览器主动缓存。</li>
<li>某些浏览器中POST会分请求头与数据两个数据包。</li>
<li>本质区别：GET幂等，而POST不是</li>
</ol>
<h2 id="16-DNS"><a href="#16-DNS" class="headerlink" title="16. DNS"></a>16. DNS</h2><p>域名解析服务器。</p>
<p>基于UDP实现，端口号为53。</p>
<p>查询方式：</p>
<ul>
<li>递归查询：如果询问的服务器上找不到对应IP地址，就由被询问的服务器发起下一步查询。</li>
<li>迭代查询：如果询问的服务器上找不到对应IP地址，会返回下一步查询应该访问的服务器。</li>
<li>非递归查询：发生在客户端与DNS服务器之间，指请求的DNS服务器已经知道答案，直接返回。可能为DNS服务器本机缓存了对应的IP地址，或缓存了对应域名的权威服务器（绕过了根域名服务器，再发一次请求即可拿到结果返回）。</li>
</ul>
<p>流程：</p>
<ul>
<li>检查浏览器缓存、系统hosts文件是否有域名对应的IP地址，没有则委托给本地配置的首选DNS服务器。</li>
<li>DNS服务器首先查看自己的缓存，若没有或已过期则向根域名DNS服务器请求。</li>
<li>根域名DNS服务器查看自己的缓存，若没有则返回对应的顶级域名服务器IP地址。</li>
<li>如此往复查询顶级域名服务器、权威域名服务器等，直到获取到IP地址。</li>
<li>如果查询不到，则浏览器显示页面无法打开。</li>
</ul>
<p>格式：<code>scheme://host.domain:port/path/filename</code></p>
<ul>
<li>scheme：协议类型</li>
<li>host：域主机（HTTP默认为www）</li>
<li>domain：域名</li>
<li>port：主机端口号</li>
<li>path：服务器上的路径</li>
<li>filename：文档/资源名称（省略则为服务器设置的默认文件）</li>
</ul>
<h2 id="17-DNS负载均衡"><a href="#17-DNS负载均衡" class="headerlink" title="17. DNS负载均衡"></a>17. DNS负载均衡</h2><p>DNS服务器为同一个主机名配置多个IP地址，在应答DNS查询时，根据每台机器的负载量、距离用户的位置等因素，将不同的用户引导到不同的机器。</p>
<p>详见25 Nginx</p>
<h2 id="18-Cookie与Session"><a href="#18-Cookie与Session" class="headerlink" title="18. Cookie与Session"></a>18. Cookie与Session</h2><p>共同点：跟踪浏览器用户身份的会话方式。</p>
<p>Cookie：浏览器第一次发送请求给服务端时，服务端创建包含用户信息的cookie，并发送给浏览器。浏览器再次访问时需要携带cookie，服务端就能识别不同的用户。</p>
<p>服务器使用Set-Cookie头，浏览器使用Cookie头。</p>
<p>Cookie保存在客户端，可存储的数据量有限，一般不超过4KB。</p>
<p>Session：浏览器第一次发送请求给服务端时，服务端创建一个Session，并创建一个特殊的Cookie（key为固定值JSESSIONID，value为session对象ID）发送给浏览器。浏览器再次访问时，服务端根据name为JSESSIONID的Cookie的value，即sessionID去查询Session对象，从而区分用户。Session对象记录用户的操作。</p>
<p>Session保存在服务端，较用户端更安全，但会占用服务器资源。</p>
<p>用户登录操作：</p>
<ul>
<li>用户提交包含用户名和密码的表单</li>
<li>服务器验证，如果正确就将信息存储到Redis中，其在Redis中的Key称为SessionID</li>
<li>服务器返回响应报文的Set-Cookie首部字段包含SessionID，客户端收到后将Cookie存入浏览器</li>
<li>客户端再次请求时包含该Cookie值，服务器收到后提取出SessionID，从Redis取出用户信息。</li>
</ul>
<p>存在安全性问题，需要生成不易被想到的ID、经常性重新生成ID、用其他方法额外验证。</p>
<p>比较：</p>
<ol>
<li>cookie数据保存在用户端浏览器，session数据保存在服务端</li>
<li>cookie数据不安全，可以被本地拷贝并进行cookie欺骗</li>
<li>cookie的value只能是字符串类型，而session是object类型</li>
</ol>
<h2 id="19-各种漏洞与攻击"><a href="#19-各种漏洞与攻击" class="headerlink" title="19. 各种漏洞与攻击"></a>19. 各种漏洞与攻击</h2><h4 id="1-XSS攻击"><a href="#1-XSS攻击" class="headerlink" title="1. XSS攻击"></a>1. XSS攻击</h4><p>跨站点脚本攻击：目标网站目标用户浏览器渲染HTML文档的过程中，出现了不被预期的脚本指令并执行。</p>
<p>反射型XSS（非持久型）：发出请求时XSS代码出现在URL中，作为输入提交到服务端，服务端响应后，XSS代码随相应内容传回给服务器，最后浏览器解析执行XSS代码。</p>
<p>存储型XSS（持久型）：提交的代码存储在服务器端，下次请求目标页面时不用再提交XSS代码。</p>
<p>DOM XSS：DOM XSS的代码不需要服务器参与，触发XSS靠浏览器端的DOM解析。</p>
<h4 id="2-CSRF攻击"><a href="#2-CSRF攻击" class="headerlink" title="2. CSRF攻击"></a>2. CSRF攻击</h4><p>跨站点请求伪造：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。</p>
<p>防范方式：</p>
<ul>
<li>安全框架：Spring Security</li>
<li>token机制：请求中如果没有token或内容不正确，则拒绝请求</li>
<li>验证码</li>
<li>referer识别：Referer字段记录HTTP请求的来源地址，如果是其他网站则拒绝请求</li>
</ul>
<h4 id="3-文件上传漏洞"><a href="#3-文件上传漏洞" class="headerlink" title="3. 文件上传漏洞"></a>3. 文件上传漏洞</h4><p>用户上传可执行的脚本文件，并通过脚本文件获得执行服务端命令的能力。</p>
<p>防范方式：</p>
<ul>
<li>文件上传的目录设置为不可执行</li>
<li>判断文件类型、对类型白名单校验</li>
<li>要求重新命名上传的文件</li>
<li>限制文件大小</li>
<li>单独设置文件服务器域名</li>
</ul>
<h2 id="20-HTTP状态码"><a href="#20-HTTP状态码" class="headerlink" title="20. HTTP状态码"></a>20. HTTP状态码</h2><ul>
<li>1XX：信息性状态码，表示接收的请求正在处理，还没有处理完，有后续报文。<ul>
<li>100 Continue：一切正常。</li>
</ul>
</li>
<li>2XX：成功状态码，表示请求正常处理完毕。<ul>
<li>200 OK</li>
<li>204 No Content：响应报文不包含实体的主体部分，一般在只需要从客户端向服务器发信息而不需要返回数据时使用。</li>
<li>206 Partial Content：客户端进行了范围请求，且服务器已经正确处理部分GET请求，实现断点续传或同时分片下载。响应报文包含由Content-Range指定范围的实体内容。</li>
</ul>
</li>
<li>3XX：重定向状态码，表示需要进行附加操作以完成请求。<ul>
<li>301 Moved Permanently：永久性重定向。搜索引擎抓取新内容的同时也将旧地址替换为重定向后的地址。</li>
<li>302 Found：临时性重定向。搜索引擎抓取新内容也会保留旧地址。</li>
<li>303 See Other：功能与302相同，但明确要求客户端用GET获取资源。</li>
<li>304 Not Modified：如果请求报文首部包含一些条件，且不满足条件，服务器返回304。</li>
<li>307 Temporary Redirect：临时重定向，与302含义类似，但要求浏览器不会把重定向请求的POST改成GET。</li>
</ul>
</li>
<li>4XX：客户端错误状态码，表示服务器无法处理请求。<ul>
<li>400 Bad Request：请求报文中存在语法错误。</li>
<li>401 Unauthorized：发送的请求中需要认证信息，如果之前已请求过则表示认证失败。</li>
<li>403 Forbidden：请求被拒绝。（无文件/目录读写权限等问题）</li>
<li>404 Not Found：请求的资源在服务器上不存在。</li>
</ul>
</li>
<li>5XX：服务器错误状态码，表示服务器处理请求出错。<ul>
<li>500 Internal Server Error：服务器执行请求时发生错误。</li>
<li>503 Service Unavailable：服务器超负荷/停机维护，暂时无法处理请求。</li>
</ul>
</li>
</ul>
<h2 id="21-中间人攻击"><a href="#21-中间人攻击" class="headerlink" title="21. 中间人攻击"></a>21. 中间人攻击</h2><p>中间人截取握手信息并分别对客户端/服务端伪造服务端/客户端。但是需要用户接受中间人服务器的证书，而浏览器能识别出非法证书并提醒。</p>
<h2 id="22-降级攻击"><a href="#22-降级攻击" class="headerlink" title="22. 降级攻击"></a>22. 降级攻击</h2><p>因为兼容性问题，浏览器进行高版本的HTTPS连接失败时，会尝试用旧的协议版本。攻击者通过旧的协议中存在的漏洞进行攻击。</p>
<p>通过禁止服务端对漏洞较多的旧版本协议支持可避免。</p>
<h2 id="23-前向安全性-重放攻击"><a href="#23-前向安全性-重放攻击" class="headerlink" title="23. 前向安全性/重放攻击"></a>23. 前向安全性/重放攻击</h2><p>前向安全性：当前时段的私钥泄露后不影响泄露以前时段的私钥与签名的安全。</p>
<p>重放攻击：窃听者窃取了作为身份证明的密码/哈希，并在被要求提供身份证明时提供该密码/哈希，并获得访问权限。如果窃听者截获了某个POST报文与Session ID或Session Ticket，就能不断发送该报文，在客户不知情的情况下改变数据库。</p>
<h2 id="24-安全和幂等"><a href="#24-安全和幂等" class="headerlink" title="24. 安全和幂等"></a>24. 安全和幂等</h2><p>安全：请求方法不会破坏服务器上的资源。<br>幂等：多次执行相同的操作获得的结果相同。<br>GET操作按RFC语义实现查操作，是安全且幂等的，因此可以对其请求的数据做缓存。<br>POST操作按RFC语义实现增删操作，既不安全也不幂等，因此浏览器一般不会缓存POST请求，也不能将其保存为书签。<br>如果不按照RFC规范定义语义实现GET与POST，那GET也可能实现增删，POST也可能实现查。</p>
<h2 id="25-Nginx与负载均衡"><a href="#25-Nginx与负载均衡" class="headerlink" title="25. Nginx与负载均衡"></a>25. Nginx与负载均衡</h2><p>高性能的HTTP和反向代理服务器，同时提供IMAP/POP3/SMTP服务。</p>
<p>特点：占有内存少，并发能力强。</p>
<p>功能：正向代理、反向代理、负载均衡、动静分离。</p>
<h3 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1. 负载均衡"></a>1. 负载均衡</h3><p>分为两种：</p>
<ul>
<li>四层负载均衡：工作在传输层，通过修改IP+端口号转发到应用服务器。</li>
<li>七层负载均衡：工作在应用层，还可根据URL、浏览器类别、语言等信息决定是否负载均衡。</li>
</ul>
<p>服务器通常是多台形成分布式系统，并通过负载均衡器决定将请求报文分配到哪台服务器。</p>
<p>不同服务器配置不同，为了让性能高的服务器分配到更高的请求。</p>
<p>Nginx负载均衡有加权轮询（默认）、IP哈希、url哈希等方式。</p>
<h3 id="2-动静分离"><a href="#2-动静分离" class="headerlink" title="2. 动静分离"></a>2. 动静分离</h3><p>动静分离将网站静态资源（HTML、JavaScript、CSS、img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用的访问。</p>
<p>Nginx服务器将接收到的请求分为动态请求和静态请求。一种做法是静态资源部署在nginx上，后台项目部署到应用服务器上。静态请求直接去nginx设定的根目录取资源，动态请求转发给真实后台。</p>
<p>好处：</p>
<ul>
<li>api接口服务化：后端应用更为服务化，只需要提供api接口，可以被多个功能模块、多个平台的功能使用，有效节省后端人力，便于功能维护。</li>
<li>前后端开发并行：前后端只需要关心接口协议，各自开发可并行，有效提高开发效率、减少联调时间。</li>
<li>减轻后端服务器压力、提高静态资源访问速度：后端不必再将模板渲染为html返回，静态服务器可采取更专业的技术。</li>
</ul>
<h3 id="3-反向代理"><a href="#3-反向代理" class="headerlink" title="3. 反向代理"></a>3. 反向代理</h3><p>一般用在负载均衡中。</p>
<p>好处：</p>
<ul>
<li>隐藏：对客户端隐藏真实的服务器IP。</li>
<li>缓存：如果nginx服务器上有请求的数据缓存，可不必请求真实服务器，提高访问速度。</li>
<li>负载均衡</li>
<li>安全：代理服务器可提供防火墙功能，防止对服务器的直接访问。</li>
</ul>
<h3 id="4-正向代理"><a href="#4-正向代理" class="headerlink" title="4. 正向代理"></a>4. 正向代理</h3><p>好处：</p>
<ul>
<li>隐藏</li>
<li>缓存</li>
<li>突破访问控制：通过代理服务器访问客户端原本被禁止访问的网页。</li>
</ul>
<p>额外的问题：正向代理接到HTTPS报文时无法解密，从而无法得知服务器地址。</p>
<p>HTTP CONNECT隧道解决方案：7层</p>
<ol>
<li>客户端给代理发送HTTP CONNECT请求。</li>
<li>代理利用HTTP CONNECT请求的主机与端口与目的服务器建立TCP连接。</li>
<li>代理服务器返回客户端200。</li>
<li>客户端和代理服务器建立起HTTP CONNECT隧道，HTTPS流量到达代理服务器后，直接通过TCP透传给目的服务器。</li>
</ol>
<p>NGINX stream解决方案：4层</p>
<p>通过TLS/SSL四次握手中第一次的Client Hello报文中的扩展地址SNI（Server Name indication）来获取服务器地址。</p>
<h1 id="3-传输层"><a href="#3-传输层" class="headerlink" title="3. 传输层"></a>3. 传输层</h1><h2 id="1-基本特征"><a href="#1-基本特征" class="headerlink" title="1. 基本特征"></a>1. 基本特征</h2><h3 id="1-TCP三大特点"><a href="#1-TCP三大特点" class="headerlink" title="1. TCP三大特点"></a>1. TCP三大特点</h3><p>面向连接的（一对一）、可靠的（保证到达）、字节流（消息分组且有序）</p>
<h3 id="2-TCP与UDP的区别"><a href="#2-TCP与UDP的区别" class="headerlink" title="2. TCP与UDP的区别"></a>2. TCP与UDP的区别</h3><ul>
<li>面向连接：TCP使用前必须要建立连接，UDP不需要。UDP是面向报文的。</li>
<li>可靠性：TCP保证交付，能确认应答和重传，保证数据无重复、不丢失、按序到达，UDP尽最大努力交付，不保证可靠性，可能乱序、丢包。</li>
<li>传输方式：TCP基于字节流，没有边界，UDP继承IP层特性，基于数据包，有边界。</li>
<li>分片方式：TCP会对数据进行分片传输，有数据丢失只重传丢失的片，UDP交给IP层分片，有数据丢失需要重传所有的数据片。</li>
<li>服务对象：TCP一对一，UDP可一对多、多对一、多对多。</li>
<li>连接控制：TCP有拥塞控制、流量控制等机制，UDP没有。</li>
<li>首部开销：TCP一般是20个字节，UDP首部只有8个字节。</li>
</ul>
<h3 id="3-分片机制"><a href="#3-分片机制" class="headerlink" title="3. 分片机制"></a>3. 分片机制</h3><p>在已有IP分包机制的存在下，TCP仍然加入了自己的分片机制，是因为：IP层没有超时重传机制，如果一大份数据中的一个IP分片丢失，TCP需要重传这一大份数据的所有分片。所以由TCP事先分片，防止IP再进行分包，确保一个IP报文中最多只有一个TCP报文，这样即使丢失也可以只重传一个报文。</p>
<p>然而，各个网络层设备的MTU不同，如果进入到MTU较小的设备，可能还会进行分片。可以尝试获取整条路线的最小MTU值，来避免IP分包。</p>
<h3 id="4-TIME-WAIT状态"><a href="#4-TIME-WAIT状态" class="headerlink" title="4. TIME_WAIT状态"></a>4. TIME_WAIT状态</h3><p>主动断开连接的一方才有TIME_WAIT状态。</p>
<ol>
<li>TIME_WAIT时间为2MSL（报文最大生存时间），从客户端接收到FIN后发送ACK开始计时，在接到重发的FIN后会重新开始计时。</li>
<li>为什么是2MSL：一般认为网络中可能还存在来自发送方的数据包，发送方接收到这些数据包的ACK时最长需要一来一回的时间。</li>
<li>为什么需要TIME_WAIT状态：<ol>
<li>等待报文一来一回的时间，防止历史连接的数据被后续连接接收。</li>
<li>等待足够时间，以确保被动关闭连接的另一方能被正确关闭。</li>
</ol>
</li>
<li>优化：TIME_WAIT状态过多会占用系统资源、端口资源<ol>
<li>net.ipv4.tcp_tw_reuse与tcp_timestamps：复用处于TIME_WAIT的socket为新的连接，还需要时间戳的支持以判断过期的历史连接数据。</li>
<li>net.ipv4.tcp_max_tw_bucket：处于最大TIME_WAIT连接数时重置后面的TIME_WAIT连接状态。</li>
<li>SO_LINGER：设置socket选项来设置调用close关闭连接行为，比如直接发送RST异常关闭。</li>
</ol>
</li>
</ol>
<h3 id="5-TCP重传与SACK"><a href="#5-TCP重传与SACK" class="headerlink" title="5. TCP重传与SACK"></a>5. TCP重传与SACK</h3><ol>
<li>超时重传：动态计算超时重传时间RTO</li>
<li>快速重传：收到三个相同的ACK报文时重传丢失的报文段。</li>
<li>SACK选择性确认：在TCP头部<strong>选项</strong>字段中加入SACK，将已收到停留在缓冲区的数据信息告知发送方。发送方可以据此只重传丢失的数据。</li>
<li>Duplicate SACK（D-SACK）（net.ipv4.tcp_dsack）：告知发送方哪些信息被重复接收。<strong>SACK范围比ACK大表示已收到的信息，比ACK小表示重复收到的信息。</strong><ol>
<li>让发送方知道是发出去的包丢了还是ACK丢了</li>
<li>知道是不是发送方的数据包被网络延迟</li>
<li>知到网络中是不是把发送方的数据包复制了</li>
</ol>
</li>
</ol>
<h3 id="6-滑动窗口"><a href="#6-滑动窗口" class="headerlink" title="6. 滑动窗口"></a>6. 滑动窗口</h3><p><strong>累计确认</strong>：发送方收到ACK应答，就认为该ACK号之前的所有数据接收方都已收到。</p>
<p>无需等待ACK而可以继续发送数据的最大值。接收方通过头部的Window字段告知接收窗口大小，发送方维护滑动窗口。</p>
<ol>
<li><p>发送方的滑动窗口swnd：实际大小为拥塞控制窗口cwnd与接收窗口rwnd的最小值。</p>
<ol>
<li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="发送方滑动窗口"></li>
<li>SND.WND：发送窗口的大小，由接收方指定</li>
<li>SND.UNA：指向已发送但未确认（#2）的第一个字节的序列号</li>
<li>SND.NXT：指向未发送但可发送（#3）的第一个字节序列号</li>
<li>可用窗口大小=SND.WND - (SND.NXT - SND.UNA)</li>
</ol>
</li>
<li><p>接收方的滑动窗口rwnd</p>
<ol>
<li>结构：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="接收方的滑动窗口"></li>
<li>RCV.WND：接收窗口大小，会告知发送方</li>
<li>RCV.NXT：指向期望收到的下一个数据字节的序列号</li>
</ol>
</li>
<li><p>接收窗口大小约等于发送窗口大小，但不完全相等。</p>
</li>
</ol>
<h3 id="7-流量控制"><a href="#7-流量控制" class="headerlink" title="7. 流量控制"></a>7. 流量控制</h3><p>出现原因：发送速率长时间大于接收方处理速率时，会塞满接收方缓冲区，导致报文被丢弃，重传浪费资源。</p>
<p>发送方根据接收方的实际接收能力控制发送的数据量。</p>
<ol>
<li>应用程序读取能力不够时，会出现接收窗口收缩到0的死锁情况；如果操作系统直接减少接收缓冲区大小，甚至可能出现数据包丢失。TCP规定不允许同时减少缓存与收缩窗口，只能先收缩窗口。</li>
<li>窗口关闭：TCP一方收到另一方的零窗口通知时启动持续计时器，在超时时发送<strong>窗口探测报文</strong>。如果多次探测还是0则发送RST报文中断连接。</li>
<li>糊涂窗口综合症：TCP为了很少的数据就发送报文，导致资源浪费。<ol>
<li>接收方<strong>不通告小窗口</strong>：接收方窗口大小小于min(MSS, 缓存空间/2)时发送零窗口通知</li>
<li>发送方<strong>避免发送小数据</strong>：（需要1满足）发送方使用<strong>Nagle算法</strong>，只有满足窗口大小&gt;=MSS且数据大小&gt;=MSS、收到之前发送数据的ACK、是FIN报文时才发送数据，否则囤积数据。</li>
</ol>
</li>
</ol>
<h3 id="8-拥塞控制"><a href="#8-拥塞控制" class="headerlink" title="8. 拥塞控制"></a>8. 拥塞控制</h3><p>网络层同样参与了拥塞控制：</p>
<ul>
<li>根据网络负载动态调整不同线路权值，将流量引导到不同线路上。</li>
<li>准入控制。</li>
<li>调整发送速率。</li>
<li>有选择主动丢弃一些数据报。</li>
</ul>
<p>流量控制是避免发送方的数据填满<strong>接收方</strong>的缓冲区，而拥塞控制是避免发送方的数据填满整个<strong>网络</strong>。</p>
<p>实际发送窗口的大小取流量控制窗口和拥塞控制窗口的最小值。</p>
<ol>
<li>拥塞窗口cwnd=min(swnd, rwnd)</li>
<li>慢启动：发送方每收到一个ACK，++cwnd。变化趋势：1-&gt;2-&gt;4-&gt;8-&gt;……，呈指数型增长。慢启动门限ssthresh（一般为65535）。当cwnd&gt;=ssthresh时改为拥塞避免算法</li>
<li>拥塞避免：每收到一个ACK，cwnd+=1/cwnd。收到上一个cwnd发送的所有报文时，即增长1，变成线性增长。网络慢慢进入拥塞，最终在出现丢包需要进行重传时进入拥塞发生。</li>
<li>拥塞发生：<ol>
<li>超时重传：ssthresh=cwnd/2，cwnd重置为初始值（一般为1），重新开始慢启动。</li>
<li>快速重传：cwnd/=2，ssthresh=cwnd，进入快速恢复算法。</li>
</ol>
</li>
<li>快速恢复：认为能连续收到3个重复ACK时网络状况并不那么糟糕，所以不需要像超时重传那样反应剧烈。<ol>
<li>cwnd+=3（在快速重传的基础上），表示确认3个数据包被收到。</li>
<li>重传丢失的数据包</li>
<li>如果再收到重复的ACK，cwnd加1。加1代表每个收到的重复ACK包都已经离开了网络，是为了尽快重传丢失的数据包。</li>
<li>如果收到新数据的ACK，将cwnd设置为快速重传设置的ssthresh值（ACK确认新数据，说明重复ACK的数据都已经收到，恢复过程已经结束），进入拥塞避免状态。</li>
</ol>
</li>
<li>为什么是3个ACK：根据实践经验确定，两次duplicated ACK很可能是乱序造成的，而三次及以上的duplicated ACK很可能是丢包造成的。</li>
<li>慢与快指的是拥塞窗口的设定值，而不是增长速率。</li>
</ol>
<h3 id="9-TCP-Fast-Open"><a href="#9-TCP-Fast-Open" class="headerlink" title="9. TCP Fast Open"></a>9. TCP Fast Open</h3><ol>
<li>第一次建立连接时，服务端在第二次握手时产生一个加密Cookie与SYN+ACK包一起发送，客户端在第三次握手时将ACK与HTTP请求一起发送。</li>
<li>下次请求时客户端在SYN包中带上Cookie与应用数据，服务端能直接从Cookie获取TCP相关信息，跳过握手并返回SYN+ACK+数据，只需要一个RTT。</li>
<li>需要双方同时支持。</li>
</ol>
<h3 id="10-TCP小报文优化"><a href="#10-TCP小报文优化" class="headerlink" title="10. TCP小报文优化"></a>10. TCP小报文优化</h3><p>当TCP承载的数据很少，只有几个字节时，用一个20字节的报头发送这些数据效率很低。</p>
<h4 id="1-Nagle算法"><a href="#1-Nagle算法" class="headerlink" title="1. Nagle算法"></a>1. Nagle算法</h4><p><strong>发送方</strong>使用Nagle<strong>算法</strong>，发送前等待一段时间，只有满足其中之一</p>
<ul>
<li>窗口大小&gt;=MSS且数据大小&gt;=MSS</li>
<li>收到之前发送数据的ACK</li>
<li>含有FIN</li>
</ul>
<p>才发送数据，否则囤积数据直到算法超时。</p>
<h4 id="2-TCP延迟确认"><a href="#2-TCP延迟确认" class="headerlink" title="2. TCP延迟确认"></a>2. TCP延迟确认</h4><p><strong>接收方</strong>使用TCP延迟确认机制</p>
<ol>
<li>有响应数据发送时，ACK随响应数据一起发送</li>
<li>没有响应数据发送时，ACK等待一段时间</li>
<li>在等待期间对方第二个数据报文到达，则ACK立刻发送</li>
</ol>
<p>与Nagle算法一起使用可能会适得其反，反而使效率降低。</p>
<p>发送小数据时，接收方没有数据要发送，等待下一个报文到达或超时时再发送ACK，发送方等待当前报文的ACK再发送下一个数据，会造成额外时延。</p>
<h3 id="11-close与shutdown"><a href="#11-close与shutdown" class="headerlink" title="11. close与shutdown"></a>11. close与shutdown</h3><ol>
<li>close：完全断开连接，无法发送数据与传输数据，调用close一方的连接叫孤儿连接，进程名为空。只关闭该进程的套接字ID，如果有共享，相当于共享计数-1，不会触发四次挥手，其他进程仍能使用。</li>
<li>shutdown：比close多一个参数。切断进程共享的套接字的所有链接。<ol>
<li>SHUT_RD(0)：关闭连接的读方向。立即丢弃接收缓冲区的数据，并在之后有数据到来时返回ACK并丢弃。</li>
<li>SHUT_WR(1)：关闭连接的写方向。立即发送发送缓冲区未发送的数据，并发送FIN报文。</li>
<li>SHUT_RDWR(2)：1和2各执行一次。</li>
</ol>
</li>
</ol>
<h3 id="12-面向字节流-amp-面向报文"><a href="#12-面向字节流-amp-面向报文" class="headerlink" title="12. 面向字节流&amp;面向报文"></a>12. 面向字节流&amp;面向报文</h3><p>TCP是面向字节流的协议，而UDP是面向报文的协议.</p>
<ol>
<li>用户协议通过UDP协议传输时，操作系统不会对消息进行拆分，这意味着每个UDP报文代表一条完整的用户消息。</li>
<li>用户协议通过TCP协议传输时，消息可能会被分成多个TCP报文，而拆分方式不固定，不能认为一个用户消息对应一个TCP报文。（TCP协议传输的数据粒度比报文更细）</li>
<li>解决粘包：固定长度；特殊字符作为边界（如HTTP以回车+换行作为边界）；自定义消息结构（包头固定大小，在包头中记录数据大小）。</li>
</ol>
<h3 id="13-TCP时间戳"><a href="#13-TCP时间戳" class="headerlink" title="13. TCP时间戳"></a>13. TCP时间戳</h3><ol>
<li>精确计算RTT</li>
<li>防止序列号回绕（随机出相同的SYN）：判断新收到的数据包的时间戳是否在递增序列中，如果不在表示该数据包过期。</li>
</ol>
<h3 id="14-PAWS机制"><a href="#14-PAWS机制" class="headerlink" title="14. PAWS机制"></a>14. PAWS机制</h3><p>因为TCP包的seq号可能发生绕回，服务端无法分辨经过一个循环的seq号与本循环的seq号。</p>
<p>PAWS机制必须要开启tcp_timestamps选项，让所有TCP包带上时间戳，从而丢弃来自同一个客户端的、时间戳不是递增的数据包。</p>
<p>PAWS机制会放过过期的RST报文。</p>
<p>per-host：只通过IP区分不同客户端。</p>
<h3 id="15-时间戳"><a href="#15-时间戳" class="headerlink" title="15. 时间戳"></a>15. 时间戳</h3><p>tcp_timestamps：TCP时间戳（默认为1），开启后可开启如下两个功能</p>
<ol>
<li>tcp_tw_reuse：客户端在调用connect函数时，如果内核选择到的端口已被相同四元组的连接占用，且该连接处于TIME_WAIT状态超过1秒，那么就会重用该连接。<ol>
<li>如果开启，有可能导致历史RST报文到达重用的连接，从而强制断开该连接。（正常情况下认为TIME_WAIT持续的时间足够让连接中的报文在网络中自然消失）</li>
<li>如果第四次挥手的ACK丢失，可能被动关闭连接的一方无法正常关闭。（收到上一个连接重传的FIN的话，会直接回复RST让对方异常关闭）</li>
</ol>
</li>
<li>tcp_tw_recycle：允许处于TIME_WAIT状态的连接被快速回收。<ol>
<li>如果开启，会开启per-host的PAWS机制，对对端IP进行检查。</li>
<li>如果此时客户端环境使用了NAT网关，客户端环境的每一台机器通过NAT网关后都会是相同的IP地址</li>
<li>如果服务器主动关闭与客户端A的连接后，同一环境的客户端B通过相同的NAT网关与服务器建立连接，且其timestamp比A的小，由于服务端的per-host的PAWS机制作用，服务端会丢弃B发来的SYN包。</li>
</ol>
</li>
</ol>
<h3 id="16-TCP-Fast-Open-TLSv1-3"><a href="#16-TCP-Fast-Open-TLSv1-3" class="headerlink" title="16. TCP Fast Open + TLSv1.3"></a>16. TCP Fast Open + TLSv1.3</h3><p>TCP Fast Open：客户端和服务端同时支持的情况下，在第二次以后的通信过程中，客户端可携带第一次通信服务器发送的cookie直接发送数据，服务端收到cookie后直接建立连接并返回数据。</p>
<p>TLSv1.3：会话恢复机制：利用Session ID等，在第二次以后的通信过程中，实现0-RTT握手。</p>
<p>这两者同时使用的话，在第二次以后的通信过程中，可以同时进行，并且还能同时携带HTTP请求。</p>
<h3 id="17-TCP-keepalive与HTTP-keep-alive"><a href="#17-TCP-keepalive与HTTP-keep-alive" class="headerlink" title="17. TCP keepalive与HTTP keep-alive"></a>17. TCP keepalive与HTTP keep-alive</h3><ol>
<li>HTTP keep-alive：HTTP长连接：HTTP使用同一个TCP连接来发送和接收多个HTTP请求应答。由应用程序实现。</li>
<li>TCP keepalive：TCP保活机制：在没有数据交互时，内核的TCP协议栈会发送探测报文给对方，如果对方程序正常工作就会响应，TCP保活时间被重置；否则在达到保活探测次数后，TCP报告该连接已死亡。由内核实现。</li>
</ol>
<p>TCP缺陷：</p>
<ol>
<li>升级困难：TCP在内核中实现，升级内核很麻烦。并且很多新特性需要通信双方都支持。</li>
<li>建立连接延迟：握手延迟。</li>
<li>队头阻塞：字节流协议。</li>
<li>网络迁移需要重新建立TCP连接。</li>
</ol>
<h3 id="18-QUIC"><a href="#18-QUIC" class="headerlink" title="18. QUIC"></a>18. QUIC</h3><p>基于UDP在应用层实现的可靠传输。QUIC是传输层协议。</p>
<ol>
<li><p>三层Header：UDP头部与HTTP消息之间，由外到内依次为：</p>
<ol>
<li><p>Packet Header</p>
<ol>
<li>Long Packet Header用于首次建立连接，包含源连接ID和目标连接ID。</li>
<li>Short Packet Header用于日常传输连接，包含目标连接ID、编号和负载数据。</li>
<li>双方通过三次握手协商连接ID。编号严格递增（即使重传，编号也比丢失的要大）（为了去除TCP的ACK歧义，该ACK响应的是原始报文还是重传报文，从而避免RTT误判）</li>
<li>支持乱序确认，后续报文不必阻塞在缓冲区。</li>
</ol>
</li>
<li><p>QUIC Frame Header：一个Packet中可存放多个QUIC Frame。有包括Stream在内的多种类型</p>
<ol>
<li>通过该层的Stream ID+Offset字段信息确认重传报文与丢失报文的一致性。</li>
</ol>
</li>
<li><p>HTTP3 Frame Header</p>
</li>
</ol>
</li>
<li><p>TCP队头阻塞问题的解决</p>
<ol>
<li>HTTP2的队头阻塞：多个Stream在一条TCP连接上传输，也意味着共用一个TCP滑动窗口，发生数据丢失会阻塞所有的HTTP请求。</li>
<li>QUIC为每个Stream分配独立的滑动窗口。</li>
</ol>
</li>
<li><p>实现UDP没有的流量控制：分为每个Stream与总的Connection两个级别。</p>
<ol>
<li>通过window_update帧告诉对端自己可以接收的字节数，通过BlockFrame告诉对端被阻塞。</li>
<li>Stream级别：每个Stream有独立的滑动窗口，所以每个Stream都能做流量控制。</li>
<li>Connection流量控制：限制连接中所有Stream相加起来的总字节数。</li>
</ol>
</li>
<li><p>改进TCP拥塞控制算法，还支持其他多种算法：QUIC处于应用层，因此可以随浏览器更新，迭代速度很快，并且可以针对不同应用设置不同的算法。</p>
</li>
<li><p>QUIC不用四元组绑定连接，而是通过头部的CID标识连接，双方在随机生成的CID列表上达成一致，列表上的CID映射到同一连接，切换环境时切换CID。（防止CID被窃取获得用户地址）迁移后双方都向对方发起路径验证，探测可达性。</p>
</li>
<li><p>总之就是在应用层实现了绝大多数TCP提高效率的机制，如滑动窗口等，但是规避了TCP作为字节流协议的队头阻塞问题。</p>
</li>
</ol>
<h3 id="16-客户端connect选择端口的流程"><a href="#16-客户端connect选择端口的流程" class="headerlink" title="16. 客户端connect选择端口的流程"></a>16. 客户端connect选择端口的流程</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.jpg" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<h3 id="17-半连接、全连接队列"><a href="#17-半连接、全连接队列" class="headerlink" title="17. 半连接、全连接队列"></a>17. 半连接、全连接队列</h3><p>全连接队列是链表，而半连接队列是哈希表</p>
<ol>
<li>accept前连接已经建立，accept只是从全连接队列中取出一条可用的连接。</li>
<li>链表与哈希表的设置：全连接队列中都是建立完成的连接，服务器只负责取出连接读写并处理业务，不关心取到哪条；而半连接队列中的连接需要等待第三次握手时，将相应的连接取出来，设置成哈希表方便查找对应的连接。</li>
</ol>
<h3 id="18-tcp-abort-on-overflow"><a href="#18-tcp-abort-on-overflow" class="headerlink" title="18. tcp_abort_on_overflow"></a>18. tcp_abort_on_overflow</h3><ol>
<li>0：全连接队列满了后会丢弃第三次握手的ACK包，并开启定时器重传SYN+ACK包。如果次数超过限制还会把对应半连接队列里的连接删除。</li>
<li>1：直接返回RST</li>
</ol>
<h3 id="19-cookies方案取代半连接队列"><a href="#19-cookies方案取代半连接队列" class="headerlink" title="19. cookies方案取代半连接队列"></a>19. cookies方案取代半连接队列</h3><ol>
<li>cookies信息实时计算，保存在TCP包头的seq里，所以如果信息丢失，服务器不会重发第二次握手信息。</li>
<li>编码解码cookies耗费CPU，同样可能被利用攻击，如编写大量无意义的cookie与SYN组成报文，让服务端解析从而耗费资源。</li>
</ol>
<h3 id="20-TCP丢包"><a href="#20-TCP丢包" class="headerlink" title="20. TCP丢包"></a>20. TCP丢包</h3><p>常见丢包情况：</p>
<ul>
<li>建立连接丢包：对方全连接队列已满。</li>
<li>流量控制丢包：滑动窗口与缓存空间同时缩小。</li>
<li>缓冲区丢包。</li>
<li>网络丢包。</li>
</ul>
<p>TCP在没收到对方的ACK确认时，会重传丢失的包。</p>
<p>TCP只保证到传输层的可靠性，不保证应用层的可靠性，因此还是可能丢失信息，比如应用在读取接收缓冲区的信息时崩溃。这些需要应用程序自己实现逻辑保证。</p>
<p>为了应对这种丢包情况，在两端通信引入第三端服务器：</p>
<ol>
<li>只需要跟服务器建立一个连接，耗费资源少</li>
<li>方便进行鉴权校验，防止信息泄露</li>
<li>软件版本兼容</li>
</ol>
<h3 id="21-★-拆包-粘包问题"><a href="#21-★-拆包-粘包问题" class="headerlink" title="21. ★ 拆包/粘包问题"></a>21. ★ 拆包/粘包问题</h3><p>本质原因：TCP协议数据传输基于字节流，需要应用层自行设计消息的边界。</p>
<p>UDP不会出现的原因：面向消息传输，有消息保护边界，接收方一次只接收一条独立的信息。</p>
<p>一个完整的业务可能被拆分成多个包发送，多个小的包可能封装成一个大的包发送</p>
<p>拆包：数据包大于缓冲区，在运输层将数据拆分。</p>
<p>原因：</p>
<ol>
<li>降低IP分片的压力</li>
<li>重传时只需传输丢失的分片，减少重传所需传输的数据。</li>
</ol>
<p>粘包：TCP连接复用、流量/拥塞控制、接收方不及时处理、Nagle算法、延迟确认</p>
<p>解决：</p>
<ol>
<li>消息定长，或标记数据长度</li>
<li>包尾增加特殊字符分割</li>
<li>将消息分为消息头和消息尾</li>
</ol>
<h3 id="22-数据包发送流程总结"><a href="#22-数据包发送流程总结" class="headerlink" title="22. 数据包发送流程总结"></a>22. 数据包发送流程总结</h3><p>假设是端到端服务且用TCP通信。</p>
<ol>
<li>三次握手建立TCP连接。</li>
<li>数据包从聊天框发出，从聊天软件所在的用户空间拷贝到内核空间的发送缓冲区。</li>
<li>数据包依次经过传输层、网络层进入数据链路层，经过流控，通过RingBuffer发送到物理层的网卡。</li>
<li>网卡将数据包发送到互联网中，经过路由器和交换机的跳转，到达目的机器的网卡。</li>
<li>网卡通知DMA将数据包信息放到RingBuffer中，再触发硬中断给CPU，CPU触发软中断让ksoftirqd线程去收包。</li>
<li>数据包经过多个层到达传输层，从内核空间拷贝到用户空间的聊天软件中。</li>
</ol>
<p>linux中用内核态中的sk_buff维护待发送的包。因为TCP协议支持丢失重传，所以sk_buff只是拷贝发送，直到收到ACK才删除。<br>各个层数据包叫法不同但用同一个结构体维护的原因：多次拷贝降低CPU效率，所以通过调整sk_buff-&gt;data指针来添加与剥离头部。</p>
<h3 id="23-MTU与MSS"><a href="#23-MTU与MSS" class="headerlink" title="23. MTU与MSS"></a>23. MTU与MSS</h3><p>MTU：一个网络包的最大长度，以太网中一般为1500字节（IP头部）<br>MSS：网络包所能容纳TCP数据的最大长度（TCP的数据部分，不包括TCP头部），一般为MTU-20（TCP头部大小）-20（IP头部大小）=1460</p>
<h3 id="24-RTO和RTT"><a href="#24-RTO和RTT" class="headerlink" title="24. RTO和RTT"></a>24. RTO和RTT</h3><p>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的间隔。即为<strong>重传间隔</strong>。RTO一般是根据网络状况动态计算的。</p>
<p>RTT：数据从发送到接受到对方相应之间的时间间隔，即数据包在网络中一个<strong>往返用时</strong>。</p>
<h3 id="25-TCP头部常用选项"><a href="#25-TCP头部常用选项" class="headerlink" title="25. TCP头部常用选项"></a>25. TCP头部常用选项</h3><p>TCP头部最后一个选项字段是可变长的可选信息，最多包含40字节，即TCP头部总共最多60字节。</p>
<p>第一个字段kind说明选项类型，第二个选项length（如果有）指定选项总长度，第三个字段info（如果有）为选项的具体信息。</p>
<p>kind=0：选项表结束EOP，一个报文段仅用一次，说明首部没有更多消息，应用数据放在下一个32位字开始处。</p>
<p>kind=1：空操作NOP，没有特殊含义，用于填充TCP选项总长度为4字节的整数倍。</p>
<p>kind=2：最大报文段长度MSS，TCP连接初始化时双方使用该字段协商MSS，一般为最大传输单元MTU-40字节，含义是20字节TCP头部与20字节IP头部，从而尽量避免发生IP分片。对以太网而言，MSS=1500-40=1460。</p>
<p>kind=4：选择性确认SACK，用在连接初始化时，告知是否支持SACK技术。</p>
<p>kind=5：SACK实际工作，告知对方提前收到或重复收到的报文序列号，帮助对方精准重传或得知哪些报文重复收到。</p>
<p>kind=8：时间戳RTT，提供较为准确的计算双方回路时间RTT的算法，为流量控制等提供信息。</p>
<h3 id="26-TCP如何保证可靠性？"><a href="#26-TCP如何保证可靠性？" class="headerlink" title="26. TCP如何保证可靠性？"></a>26. TCP如何保证可靠性？</h3><ol>
<li>检验和：头部的检验和字段，有差错直接丢弃重传。</li>
<li>序列号/确认应答：根据序列号排序、去重，根据ACK决定发送内容。</li>
<li>滑动窗口：提高传输报文的效率，也避免发送过多产生异常。</li>
<li>超时重传：防止包丢失，保证包交付。</li>
<li>拥塞控制：保证TCP可靠交付的同时提高性能。</li>
<li>流量控制：避免大量丢包，提高传输效率。</li>
</ol>
<h3 id="27-ARQ协议"><a href="#27-ARQ协议" class="headerlink" title="27. ARQ协议"></a>27. ARQ协议</h3><p>自动重传请求，通过使用确认和超时两个机制，在不可靠服务的基础上实现可靠的信息传输。</p>
<h4 id="1-停止等待ARQ协议"><a href="#1-停止等待ARQ协议" class="headerlink" title="1. 停止等待ARQ协议"></a>1. 停止等待ARQ协议</h4><p>每发完一个分组就停止发送，等待对方确认。如果过了一段时间没收到确认，说明没有发送成功，需要重新发送。直到收到确认再发下一个分组。</p>
<p>接收方如果收到重复分组，丢弃该分组，但是还要发确认。</p>
<h4 id="2-连续ARQ协议"><a href="#2-连续ARQ协议" class="headerlink" title="2. 连续ARQ协议"></a>2. 连续ARQ协议</h4><p>发送方维持一个发送窗口，窗口内的分组可连续发送而不必等待确认。接收方一般累计确认，只对按序到达的最后一个分组确认，表明这个分组为止的所有分组都已正确收到。</p>
<p>优点：信道利用率高，容易实现。</p>
<p>缺点：不能向发送方反映出接收方已正确收到的所有分组的信息，容易导致发送方上传冗余报文。</p>
<h2 id="2-特殊情况"><a href="#2-特殊情况" class="headerlink" title="2. 特殊情况"></a>2. 特殊情况</h2><h3 id="1-握手与挥手为什么不x次？"><a href="#1-握手与挥手为什么不x次？" class="headerlink" title="1. 握手与挥手为什么不x次？"></a>1. 握手与挥手为什么不x次？</h3><p>第三次握手是可以携带数据的，而前两次不行。</p>
<p>不两次握手：无法阻止历史连接的建立，造成资源浪费；如果服务端的SYN+ACK报文丢失，会造成客户端与服务端的初始序列号无法同步；服务端需要确认客户端能正常收到报文，所以需要客户端的回复。</p>
<p>不四次握手：服务端的ACK与同步信号SYN明显可以合并</p>
<p>不三次挥手：要三次挥手只能将被动方的ACK与FIN合并，但是在被动方收到ACK时可能还有数据要收发，这种情况下不能立刻断开连接。</p>
<p>TCP挥手有时候是3次的原因：被动断开方没有数据要发送，且开启了TCP延迟确认机制，第二次与第三次挥手会合并。</p>
<h3 id="2-必须三次握手的原因-为什么不能两次握手"><a href="#2-必须三次握手的原因-为什么不能两次握手" class="headerlink" title="2. 必须三次握手的原因/为什么不能两次握手"></a>2. 必须三次握手的原因/为什么不能两次握手</h3><ol>
<li>防止历史连接初始化连接：如果有之前申请建立连接的报文由于网络拥堵未能到达，客户端再次发送建立连接的请求，但是之前的报文先到达，这就叫历史连接。客户端在第三次握手时根据序列号或超时时间确认连接是否为历史连接，如果是则发送RST终结历史连接。</li>
<li>同步双方初始序列号：双方发送的携带初始序列号的报文都需要得到应答，才能确保同步，从而根据序列号进行去重、顺序接收、重发等后续操作。四次握手的中间两次可以合并，而两次握手不能保证服务端的序列号得到应答。</li>
<li>避免资源浪费：历史连接建立会成为冗余的连接，造成资源浪费。</li>
</ol>
<h3 id="3-SYN攻击"><a href="#3-SYN攻击" class="headerlink" title="3. SYN攻击"></a>3. SYN攻击</h3><p>攻击者伪造不同IP发送SYN报文给服务端，占满服务端的半连接队列。</p>
<p>应对措施：</p>
<ol>
<li>增大半连接队列（还需要一同增大全连接队列）。</li>
<li>改用cookie绕过半连接队列。但服务端计算cookie会占用大量CPU时间。</li>
<li>减少SYN+ACK重传次数从而加快半连接断开。</li>
</ol>
<h3 id="4-FIN-WAIT2中收不到第三次挥手"><a href="#4-FIN-WAIT2中收不到第三次挥手" class="headerlink" title="4. FIN_WAIT2中收不到第三次挥手"></a>4. FIN_WAIT2中收不到第三次挥手</h3><p>主动关闭方收到对方的ACK报文后，就会进入FIN_WAIT2状态，这时如果不收到第三次挥手：</p>
<ul>
<li>如果使用close函数关闭连接，就无法再收发数据，FIN_WAIT2状态持续一段时间（tcp_fin_timeout，默认为60）后直接关闭。</li>
<li>如果使用shutdown函数关闭连接，指定只关闭发送方向而不关闭接收方向，那么就会一直处于FIN_WAIT2状态。</li>
</ul>
<h3 id="5-建立连接后某一方出现故障"><a href="#5-建立连接后某一方出现故障" class="headerlink" title="5. 建立连接后某一方出现故障"></a>5. 建立连接后某一方出现故障</h3><ol>
<li>客户端：服务端会通过保活机制探测客户端是否活动。<ol>
<li>客户端重启成功：因为连接数据已清除，所以收到保活报文时返回RST，服务端收到RST则主动关闭连接。</li>
<li>客户端没有重启：服务端发送保活报文次数达到上限仍没有收到回应，则主动关闭连接。</li>
</ol>
</li>
<li>服务端：如果是进程崩溃，进程的连接资源会交给内核回收，内核主动与客户端完成四次挥手。</li>
</ol>
<h3 id="6-Socket的accept与listen"><a href="#6-Socket的accept与listen" class="headerlink" title="6. Socket的accept与listen"></a>6. Socket的accept与listen</h3><p>服务端接收到FIN报文后会在缓冲区后插入文件描述符EOF，应用程序在read到EOF时调用close关闭套接字，使服务器发出FIN包。</p>
<p>没有accept可以建立连接：accept只是从已建立的连接中取出一个可用的。</p>
<p>没有listen可以建立连接：客户端可以形成TCP自连接。客户端在connect方法时，将自己的连接信息放入内核的一个全局hash表中，消息经过回环地址重新回到TCP传输层时，根据IP+端口信息从hash表中取出信息，成功建立连接。</p>
<h3 id="7-TCP全连接队列满"><a href="#7-TCP全连接队列满" class="headerlink" title="7. TCP全连接队列满"></a>7. TCP全连接队列满</h3><p>TCP全连接队列已满时，是否需要放弃连接：通过修改tcp_abort_on_overflow参数。</p>
<ol>
<li>0：如果队列已满，server扔掉client发过来的ack。</li>
<li>1：如果队列已满，server发送RST包给client，表示废除握手过程和连接。</li>
<li>一般应当设置为0，因为有时服务器只是短暂繁忙，当队列有空位时再次接收到ACK请求仍然能成功建立连接。</li>
</ol>
<h3 id="8-TCP连接双方同时关闭"><a href="#8-TCP连接双方同时关闭" class="headerlink" title="8. TCP连接双方同时关闭"></a>8. TCP连接双方同时关闭</h3><p>两方发送FIN报文后等待ACK，都等来了FIN报文，因此都进入CLOSING状态，之后双方回复ACK确认对方发送通道关闭，进入TIME_WAIT状态。</p>
<h3 id="9-第一次握手的SYN包被丢弃"><a href="#9-第一次握手的SYN包被丢弃" class="headerlink" title="9. 第一次握手的SYN包被丢弃"></a>9. 第一次握手的SYN包被丢弃</h3><ol>
<li>半连接队列已满，且没开syncookie或全连接队列也已满。</li>
<li>开启了tcp_rw_recycle（快速回收），且客户端在NAT环境。</li>
</ol>
<h3 id="10-处于ESTABLISH状态的服务端收到了客户端的SYN报文"><a href="#10-处于ESTABLISH状态的服务端收到了客户端的SYN报文" class="headerlink" title="10. 处于ESTABLISH状态的服务端收到了客户端的SYN报文"></a>10. 处于ESTABLISH状态的服务端收到了客户端的SYN报文</h3><p>客户端掉线，重新连接后发送SYN给服务端。此时客户端IP与服务端IP、端口都没有变。</p>
<ol>
<li>端口号与历史连接不同：服务端认为需要建立新的连接。如果服务端向旧连接发送了数据，因为客户端该连接已经被关闭，会返回RST报文强制关闭，否则旧连接在TCP保活机制下释放。</li>
<li>端口号与历史连接相同：服务端会回复一个携带了正确序列号和确认号的ACK（Challenge ACK）。客户端收到后发现序列号不是自己所期望的，就会返回RST报文。</li>
<li>可以利用这个性质强行关闭连接。</li>
</ol>
<h3 id="11-挥手时被动关闭端的FIN报文比发送的数据更早到达另一方"><a href="#11-挥手时被动关闭端的FIN报文比发送的数据更早到达另一方" class="headerlink" title="11. 挥手时被动关闭端的FIN报文比发送的数据更早到达另一方"></a>11. 挥手时被动关闭端的FIN报文比发送的数据更早到达另一方</h3><p>服务端接收到FIN报文后会将文件描述符EOF放在接收缓冲区的末尾，应用程序在read到EOF时调用close关闭套接字，使服务器发出FIN包。</p>
<h3 id="12-TIME-WAIT状态下的TCP连接收到SYN"><a href="#12-TIME-WAIT状态下的TCP连接收到SYN" class="headerlink" title="12. TIME_WAIT状态下的TCP连接收到SYN"></a>12. TIME_WAIT状态下的TCP连接收到SYN</h3><ol>
<li>合法SYN：SYN比期望收到的下一个SYN大，且时间戳比最后收到的报文时间戳大：重用该四元组连接，直接进入SYN_RECV状态并返回SYN+ACK。</li>
<li>非法SYN：上述两个条件一项不成立：回复一个与第四次挥手一样的ACK报文（Challenge ACK），客户端收到后发现与期望的ACK不同（此时客户端为SYN_SENT状态），于是回复RST。</li>
<li>TIME_WAIT下收到RST：如果net.ipv4.tcp_rfc1337=0，TIME_WAIT会直接结束，否则丢弃。</li>
</ol>
<h3 id="13-连接的一方进程崩溃与主机崩溃"><a href="#13-连接的一方进程崩溃与主机崩溃" class="headerlink" title="13. 连接的一方进程崩溃与主机崩溃"></a>13. 连接的一方进程崩溃与主机崩溃</h3><p>进程崩溃时，内核会与该进程连接的对方进行挥手并回收资源，所以连接会正常关闭。</p>
<p>如果是主机崩溃：</p>
<ol>
<li>对方没有开启keepalive机制：<ol>
<li>双方没有数据交互：对方的连接将一直是ESTABLISHED状态，直至对方内核重启。</li>
<li>迅速重启且对方发送了数据：回复RST。</li>
<li>一直没有重启且对方发送了数据：对方达到重传上限后主动断开。</li>
</ol>
</li>
<li>对方开启了：keepalive探测到主机崩溃，返回消息后对方主动断开。</li>
</ol>
<h3 id="14-考虑TCP连接是否断开一定要考虑有无数据传输与keepalive机制两个方面"><a href="#14-考虑TCP连接是否断开一定要考虑有无数据传输与keepalive机制两个方面" class="headerlink" title="14. 考虑TCP连接是否断开一定要考虑有无数据传输与keepalive机制两个方面"></a>14. 考虑TCP连接是否断开一定要考虑有无数据传输与keepalive机制两个方面</h3><h3 id="15-TCP与UDP可以绑定相同的端口"><a href="#15-TCP与UDP可以绑定相同的端口" class="headerlink" title="15. TCP与UDP可以绑定相同的端口"></a>15. TCP与UDP可以绑定相同的端口</h3><p>由主机根据<strong>IP包头的协议号字段</strong>判断将信息送给哪个模块处理。</p>
<h3 id="16-收到Seq号不符合期望的报文"><a href="#16-收到Seq号不符合期望的报文" class="headerlink" title="16. 收到Seq号不符合期望的报文"></a>16. 收到Seq号不符合期望的报文</h3><p>客户端：</p>
<ul>
<li>SYN-SENT状态：回复RST。</li>
<li>非SYN-SENT状态：丢弃。</li>
</ul>
<p>服务端：</p>
<ul>
<li>非LISTEN状态：回复Challege-ACK报文，指示期望收到的Seq号。</li>
<li>LISTEN状态：都还没收到过报文，当然直接接收并回复SYN+ACK了。</li>
</ul>
<p>客户端SYN-SENT回RST而不是丢弃的原因：</p>
<ul>
<li>服务端已经存在一个相同四元组的旧连接，如果不删除该连接，服务端无法确认新连接，只会一直回复旧连接的Challenge-ACK。</li>
<li>如果选择丢弃，双方都会触发超时重传，然后依然无法连接，直到最大重传次数后CLOSE，严重浪费时间。</li>
</ul>
<h3 id="17-客户端连接不存在的IP-端口"><a href="#17-客户端连接不存在的IP-端口" class="headerlink" title="17. 客户端连接不存在的IP/端口"></a>17. 客户端连接不存在的IP/端口</h3><p>TCP连接不存在的IP：</p>
<ul>
<li>目的IP与源IP在同一局域网：卡在本机数据链路层无法发送。因为ARP找不到IP对应的MAC，所以无法形成帧头部。</li>
<li>目的IP与源IP不在同一局域网：得不到ACK，超时重传到最大次数后释放连接。路由器会进行转发，但因为目标IP地址不存在，所以SYN报文最终在网络中消亡或被找不到转发端口的路由表丢弃。</li>
</ul>
<p>TCP连接不存在的端口：目标设备收到后，发现没有服务监听该端口，就回复RST，客户端收到RST后释放连接。</p>
<p>发送UDP到不存在的端口：目标设备<strong>网络层</strong>看到没有进程在监听指定的协议端口，由IP回复ICMP报文，告知“目标端口不可达”。</p>
<h3 id="18-常见网络攻击"><a href="#18-常见网络攻击" class="headerlink" title="18. 常见网络攻击"></a>18. 常见网络攻击</h3><h4 id="1-IP欺骗"><a href="#1-IP欺骗" class="headerlink" title="1. IP欺骗"></a>1. IP欺骗</h4><p>伪造某台主机的IP地址，清空已经建立好的连接。</p>
<p>缓解：入口过滤，检查传入的IP数据包并确认其源标头。</p>
<h4 id="2-SYN洪泛攻击"><a href="#2-SYN洪泛攻击" class="headerlink" title="2. SYN洪泛攻击"></a>2. SYN洪泛攻击</h4><p>发送海量SYN报文，塞满服务器半连接队列，耗尽系统资源。</p>
<p>攻击者还可伪造SYN报文IP地址，阻止服务器屏蔽单一源地址。</p>
<p>缓解：</p>
<ul>
<li>增大半连接、全连接队列。</li>
<li>减少重传次数。</li>
<li>cookie。</li>
</ul>
<h4 id="3-UDP洪泛攻击"><a href="#3-UDP洪泛攻击" class="headerlink" title="3. UDP洪泛攻击"></a>3. UDP洪泛攻击</h4><p>发送海量UDP报文，让服务器利用资源检查是否有程序在端口接收数据包、用ICMP响应，耗尽系统资源。</p>
<p>缓解：操作系统限制ICMP报文响应速率。</p>
<h4 id="4-HTTP洪泛攻击"><a href="#4-HTTP洪泛攻击" class="headerlink" title="4. HTTP洪泛攻击"></a>4. HTTP洪泛攻击</h4><p>利用大量HTTP请求使目标达到饱和，无法响应正常流量，出现拒绝服务。</p>
<p>防护：</p>
<ul>
<li>对发出请求的设备询问。</li>
<li>防火墙</li>
<li>管理IP信誉数据库。</li>
</ul>
<h4 id="5-DNS洪泛攻击"><a href="#5-DNS洪泛攻击" class="headerlink" title="5. DNS洪泛攻击"></a>5. DNS洪泛攻击</h4><p>利用大量DNS请求中断该域的DNS解析。</p>
<h4 id="6-TCP重置攻击"><a href="#6-TCP重置攻击" class="headerlink" title="6. TCP重置攻击"></a>6. TCP重置攻击</h4><p>攻击者伪造消息断开连接。利用Challenge ACK。</p>
<h4 id="7-中间人攻击"><a href="#7-中间人攻击" class="headerlink" title="7. 中间人攻击"></a>7. 中间人攻击</h4><p>对通信双方冒充对方，充当第三方分别与双方通信。</p>
<p>防范：CA证书</p>
<h4 id="8-DDOS"><a href="#8-DDOS" class="headerlink" title="8. DDOS"></a>8. DDOS</h4><p>分布式拒绝服务。</p>
<p>即处于不同位置的多个攻击者通过大量的流量淹没服务器，消耗带宽与系统资源，最终导致网络瘫痪，停止提供正常服务。</p>
<p>洪泛攻击都是DDoS攻击。</p>
<p>应对：</p>
<ul>
<li>高防服务器</li>
<li>黑名单</li>
<li>DDoS清洗：对用户请求数据实时监控，及时发现异常流量并清理。</li>
<li>CDN加速：将流量分散到各个节点，隐藏真实IP，同时降低负载。</li>
</ul>
<h1 id="4-IP"><a href="#4-IP" class="headerlink" title="4. IP"></a>4. IP</h1><p>作用：实现主机与主机之间的点对点通信。</p>
<h2 id="1-与链路层"><a href="#1-与链路层" class="headerlink" title="1. 与链路层"></a>1. 与链路层</h2><p>MAC实现直连的两个设备之间的通信，而IP负责在没有直连的两个网络之间通信传输。</p>
<h2 id="2-地址分类"><a href="#2-地址分类" class="headerlink" title="2. 地址分类"></a>2. 地址分类</h2><ol>
<li>A类地址：0.0.0.0 ~ 127.255.255.255。私有IP：10.0.0.0 ~ 10.255.255.255</li>
<li>B类地址：128.0.0.0 ~ 191.255.255.255。私有IP：172.16.0.0 ~ 172.31.255.255</li>
<li>C类地址：192.0.0.0 ~ 223.255.255.255。私有IP：192.168.0.0 ~ 192.168.255.255</li>
<li>D类地址：224.0.0.0 ~ 239.255.255.255：没有主机号，常被用于多播</li>
<li>E类地址：240.0.0.0 ~ 255.255.255.255：没有主机号，暂未使用</li>
</ol>
<h2 id="3-多播"><a href="#3-多播" class="headerlink" title="3. 多播"></a>3. 多播</h2><p>将包发送给特定组内的所有主机，与广播不同，多播可以穿透路由器。</p>
<h2 id="4-环回地址"><a href="#4-环回地址" class="headerlink" title="4. 环回地址"></a>4. 环回地址</h2><p>127.0.0.1/localhost主机名。使用该IP地址或主机名时，数据包不会流向网络。</p>
<h2 id="5-IPv6"><a href="#5-IPv6" class="headerlink" title="5. IPv6"></a>5. IPv6</h2><ol>
<li>特点：<ol>
<li>可分配地址大大增加</li>
<li>可自动配置，即使没有DHCP服务器也可以自动分配IP地址</li>
<li>包头长度固定40字节，去掉包头校验和，简化首部结构，大大提高传输性能</li>
<li>能应对伪造IP地址的网络安全功能以及防止线路窃听功能</li>
</ol>
</li>
<li>首部改进：<ol>
<li>取消了首部校验和字段（因为数据链路层和传输层都会校验）</li>
<li>取消了分片重组相关字段，只允许在源与目的主机分片重组，提高了转发速度</li>
<li>取消选项字段从而固定头部长度，选项字段可能出现在IPv6首部的“下一个首部”指出的位置上</li>
</ol>
</li>
</ol>
<h2 id="6-其他协议"><a href="#6-其他协议" class="headerlink" title="6. 其他协议"></a>6. 其他协议</h2><h3 id="1-RARP"><a href="#1-RARP" class="headerlink" title="1. RARP"></a>1. RARP</h3><p>已知MAC地址求IP地址，通常需要架设RARP服务器，并在服务器上注册设备的MAC地址及其IP地址。</p>
<h3 id="2-DHCP"><a href="#2-DHCP" class="headerlink" title="2. DHCP"></a>2. DHCP</h3><p>动态获取IP地址。客户端进程监听68号端口，服务端进程监听67号端口。</p>
<ol>
<li>客户端发起DHCP DISCOVER的IP数据包，使用UDP广播通信，0.0.0.0作为源IP地址，广播地址作为目标地址。</li>
<li>DHCP服务器用DHCP OFFER响应，广播地址作为目标地址，报文信息携带服务器提供的可租约IP地址、子网掩码、默认网关、DNS服务器以及IP地址租用期。</li>
<li>客户端收到多个服务器的DHCP OFFER后选择一个，发送DHCP REQUEST回显配置的参数。</li>
<li>服务端用DHCP ACK响应，应答要求的参数。</li>
<li>租约的DHCP IP地址快到期时，客户端会发送DHCP请求报文<ol>
<li>如果服务器同意继续租用，就回应DHCP ACK并延长租期</li>
<li>如果服务器不同意，回应DHCP NACK，客户端停止使用IP地址</li>
</ol>
</li>
<li>DHCP交互中全程使用UDP广播通信。为了解决<strong>DHCP服务器和客户端不在一个局域网内</strong>的问题，需要由<strong>DHCP中继代理交互</strong>。中继代理之间以及与服务器之间采用单播的方式。</li>
</ol>
<h3 id="3-NAT"><a href="#3-NAT" class="headerlink" title="3. NAT"></a>3. NAT</h3><p>网络地址转换</p>
<p>改进：网络地址与端口转换NAPT：将IP地址+端口号一起转换，这样可以只用一个全球IP地址。</p>
<ol>
<li>缺点：<ol>
<li>外部无法主动与NAT内部服务器建立连接</li>
<li>转换表的生成与转换操作都会产生性能开销</li>
<li>通信过程中如果NAT重启，所有TCP连接都会重置</li>
</ol>
</li>
<li>解决：<ol>
<li>改用IPv6，每台设备配置一个公有地址</li>
<li>NAT穿透技术：客户端主动获得NAT设备公有IP并建立端口映射条目，然后用该条目对外通信。</li>
</ol>
</li>
</ol>
<h3 id="4-ICMP"><a href="#4-ICMP" class="headerlink" title="4. ICMP"></a>4. ICMP</h3><p>互联网控制报文协议</p>
<p>确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因和改善网络设置等。如果某个IP包未能达到目标地址，由ICMP负责通知。</p>
<ol>
<li><p>查询报文类型：回送消息：类型0和8：可以向对端主机发送回送请求消息（8），也可以接收对端主机发回的回送应答消息（0）</p>
</li>
<li><p>差错报文类型</p>
<ol>
<li><p>目标不可达消息（3）：IP路由器无法将IP数据包发送给目标地址，同时在消息中显示不可达的具体原因</p>
<ol>
<li>0：网络不可达；1；主机不可达；2：协议不可达；3：端口不可达；4：需要分片但设置了未分片</li>
</ol>
</li>
<li><p>原点抑制消息（4）：当路由器向低速线路发送数据时，其发送队列的缓存变为0而无法发送出去，可以向IP包源地址发送一个ICMP原点抑制消息。收到包的主机了解在整个项目的某一处发生了拥堵，从而增大IP包传输间隔。可能引起不公平的网络通信。</p>
</li>
<li><p>重定向消息（5）：路由器发现发送端主机使用了不是最优的路径发送数据，它会返回ICMP重定向消息，包含最合适的路由信息和源数据。</p>
</li>
<li><p>超时消息（11）：TTL=0时路由器发送ICMP超时消息给发送端主机</p>
</li>
</ol>
</li>
</ol>
<h3 id="5-IGMP"><a href="#5-IGMP" class="headerlink" title="5. IGMP"></a>5. IGMP</h3><p>因特网组管理协议</p>
<p>工作在主机（被组播对象）和最后一跳路由之间</p>
<ol>
<li>功能：向路由器申请加如何退出组播组，然后路由器就会记录IGMP路由器表。</li>
<li>版本：IGMPv1、IGMPv2、IGMPv3.</li>
<li>常规查询与响应工作机制：<ol>
<li>路由器周期性发送目标地址为224.0.0.1（同一网段内所有主机和路由器）的IGMP常规查询报文</li>
<li>主机收到查询，启动报告延迟计时器，超时后就发送IGMP成员关系报告报文（目标IP地址为组播地址）；如果超时前收到了同一组内其他成员的报告报文，就不再发送。</li>
<li>路由器收到报告报文后在IGMP路由表中加入该组播组</li>
</ol>
</li>
<li>离开组播组工作机制：<ol>
<li>主机发送IGMPv2离组报文，目标地址224.0.0.2（网段内所有路由器）</li>
<li>路由器收到后，以1s为间隔连续发送IGMP特定组查询报文，以确认该网络是否还有组的其他成员。</li>
<li>如果还有主机是成员，则立即响应，路由器知道还有组后会继续转发组播数据包；否则不再转发。</li>
</ol>
</li>
</ol>
<h2 id="7-ping"><a href="#7-ping" class="headerlink" title="7. ping"></a>7. ping</h2><p>ping基于ICMP，使用查询报文类型：回送消息：类型0和8：可以向对端主机发送回送请求消息（8），也可以接收对端主机发回的回送应答消息（0）。</p>
<h2 id="8-traceroute"><a href="#8-traceroute" class="headerlink" title="8. traceroute"></a>8. traceroute</h2><ol>
<li>故意设置特殊TTL追踪去往目的地时沿途经过的路由器：利用TTL，从1开始按照递增顺序发送UDP包，强制接收ICMP超时消息；路径上的路由器依次接收到TTL=0的报文，就会返回ICMP差错报文，类型是时间超时；发送UDP包时会填入不可能的端口号33434，这样到达目的地时返回的就是“端口不可达”的ICMP。</li>
<li>故意设置不分片从而确认路径MTU：每次收到ICMP就减少包的大小，来定位一个合适的MTU。</li>
</ol>
<h1 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h1><h2 id="1-RDMA"><a href="#1-RDMA" class="headerlink" title="1. RDMA"></a>1. RDMA</h2><p>远程直接内存访问技术。</p>
<p>相对于DMA技术。DMA技术可以让外部设备绕过CPU直接访问主存，而RDMA技术还能让外部设备访问另一台远端主机上用户态的主存。</p>
<p>与传统的基于socket的通信：基于socket的通信通过特定API管理程序行为，RDMA技术仅使用操作系统建立一个通道，就能在不需要操作系统干预的情况下进行应用程序间消息传递。</p>
<p>通过网络把资料直接传入计算机的存储区，将数据从一个系统快速移动到远程系统存储器，而不影响操作系统。消除了外部存储器复制和上下文切换的开销，能解放内存带宽和CPU周期。</p>
<p>特点：</p>
<ul>
<li>无需CPU干预</li>
<li>内核旁路：应用程序可绕过内核，在用户态传输数据</li>
<li>零拷贝：每个应用程序能直接访问集群中设备的虚拟内存。数据能直接在缓冲区接收与发送，不必复制到网络层。</li>
<li>异步接口：实现计算与通信分离。</li>
</ul>
<p>InfiniBand（IB）、以太网RoCE、以太网iWARP支持RDMA。</p>
<h3 id="1-传统TCP-IP通信的问题"><a href="#1-传统TCP-IP通信的问题" class="headerlink" title="1. 传统TCP/IP通信的问题"></a>1. 传统TCP/IP通信的问题</h3><p>I/O瓶颈问题：高速网络环境下与网络I/O相关的主机处理的高开销（数据移动和复制操作）限制了机器间的传输带宽。</p>
<ul>
<li>低性能：通过内核发送消息，内核态与用户态的切换，以及内核中的封装与解包造成大量开销。</li>
<li>低灵活性：内核很难更新，导致难以支持新的网络协议和消息通信协议。</li>
</ul>
<h3 id="2-一些前置技术"><a href="#2-一些前置技术" class="headerlink" title="2. 一些前置技术"></a>2. 一些前置技术</h3><p>TCP Offloading：将主机封装多层网络协议的工作转移到网卡。</p>
<p>U-Net Networking：移动协议栈到用户空间，并从数据通信路径中彻底删除内核。</p>
<ul>
<li>带来了高性能与高灵活性。</li>
<li>为每个进程提供了一种拥有网络接口的错觉。</li>
</ul>
<h3 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h3><p>Memory verbs：多用于数据类报文</p>
<ul>
<li>read：从远程主机读取部分内存。<ul>
<li>调用前，远程主机提供适当权限。</li>
<li>调用者指定远程虚拟地址，像本地内存地址一样拷贝。可以在不通知远程主机的情况下执行。</li>
</ul>
</li>
<li>write：与read相对应。带即时数的写操作会将即时数通知给远程主机</li>
<li>atomic：原子取、加、比较和交换</li>
</ul>
<p>Messaging verbs：多用于连接控制类报文</p>
<ul>
<li>send：把数据发送到远程QP的接收队列。<ul>
<li>接收端事先注册接收缓冲区，负责其维护和发布。</li>
<li>发送方可选择使用即时数，用于发送到接收端作为接收的通知。</li>
</ul>
</li>
<li>receive：与发送操作相对应。</li>
</ul>
<h3 id="4-传输模式"><a href="#4-传输模式" class="headerlink" title="4. 传输模式"></a>4. 传输模式</h3><ul>
<li>可靠连接RC：QP一对一相连，消息从一个QP发送队列发送到另一个的接收队列。数据包按序交付，类似TCP。</li>
<li>不可靠连接UC：QP一对一相连，数据包可能丢失。传输层出错的消息不重传，需要高层协议处理。</li>
<li>不可靠数据包UD：一个QP可与其他任意UD、QP传输，不保证按序交付，交付的数据可能被丢弃。支持多播，类似UDP。</li>
</ul>
<h3 id="5-工作过程"><a href="#5-工作过程" class="headerlink" title="5. 工作过程"></a>5. 工作过程</h3><ul>
<li>一个应用执行RDMA读/写请求时，不执行任何复制，不需要任何内核内存参与，RDMA请求从用户空间应用发到本地网卡。</li>
<li>网卡读取缓冲内容，通过网络传送到远端网卡。</li>
<li>网络上传输的RDMA信息包括目标虚拟地址、内存钥匙和数据本身。请求可完全在用户空间中处理，也可以在应用一直睡眠到请求完成的情况下通过系统中断处理。</li>
<li>远程网卡确认内存钥匙，直接将数据写入本地应用缓存。</li>
</ul>
<h3 id="6-消息队列"><a href="#6-消息队列" class="headerlink" title="6. 消息队列"></a>6. 消息队列</h3><p>提供基于消息队列的点对点通信。</p>
<p>应用需要通信时，创建一条Channel连接，其首尾断点是队列对QP，每个QP由发送队列SQ和接收队列RQ。QP映射到应用的虚拟地址空间，因此应用可通过其直接访问远程网卡。</p>
<p>工作队列WQ：SQ/RQ，根据当前应用是发送/接收数据。</p>
<p>完成队列CQ：知会用户WQ上的消息已经被处理完。</p>
<p>一个工作队列的元素WQE对应一个完成队列的元素CQE</p>
<p>提供了一套软件传输接口，方便用户创建传输请求WR。</p>
<ul>
<li>WR中描述应用希望传输到Channel对端的消息。</li>
<li>WR通知QP中的某个WQ。</li>
<li>WQ中用户的WR被转换为工作队列元素WQE，等待远程网卡的异步调度解析，并从WQE指向的buffer中拿到真正的消息发送到Channel对端。</li>
</ul>
<h3 id="7-RDMA-READ"><a href="#7-RDMA-READ" class="headerlink" title="7. RDMA READ"></a>7. RDMA READ</h3><ol>
<li>A、B建立链接，初始化QP</li>
<li>数据存储在B的buffer地址VB，VB提前注册到B的网卡，拿到内存钥匙。</li>
<li>B把VB、key封装成报文传送到A，同时在WQ中注册一个WR，用于接收数据传输的A返回的状态。</li>
<li>A收到B的报文后，网卡将VB、key连同VA封装到RDMA READ请求，发送给B。AB两端不需要任何软件参与，就能将B的数据存储到A的虚拟地址。</li>
<li>A存储完后向B返回整个数据传输的状态信息。</li>
</ol>
<p>只需要提供远程访问的虚拟地址，不需要应用参与，适用于批量数据传输。</p>
<h3 id="8-RDMA-WRITE"><a href="#8-RDMA-WRITE" class="headerlink" title="8. RDMA WRITE"></a>8. RDMA WRITE</h3><ol>
<li>A、B建立链接，初始化QP</li>
<li>数据要存储在B的buffer地址VB，VB提前注册到B的网卡，拿到返回的内存钥匙。</li>
<li>B把VB、key封装成报文传送到A，同时在WQ中注册一个WR，用于接收数据传输的A返回的状态。</li>
<li>A收到B的报文后，网卡将VB、key连同VA封装到RDMA WRITE请求，发送给B。AB两端不需要任何软件参与，就能将B的数据存储到A的虚拟地址。</li>
<li>A发送数据完后向B返回整个数据传输的状态信息</li>
</ol>
<h3 id="9-RDMA-SEND-RECIEVE"><a href="#9-RDMA-SEND-RECIEVE" class="headerlink" title="9. RDMA SEND/RECIEVE"></a>9. RDMA SEND/RECIEVE</h3><p>双边操作必须要远端应用感知才能完成收发。</p>
<p>A向B发送数据</p>
<ul>
<li>AB各自创建并初始化QP、CQ</li>
<li>AB分别向WQ中注册WQE。A的WQ=SQ，WQE描述指向一个等待被发送的数据；B的WQ=RQ，WQE描述指向一块用于存储数据的buffer。</li>
<li>A的网卡异步调度到A的WQE，解析到SEND消息，从buffer直接向B发送数据。</li>
<li>数据流到B的网卡后，B的WQE被消耗，将数据直接存储到WQE指向的存储位置。</li>
<li>AB通信完成后，A的CQ产生一个完成消息CQE表示发送完成，B的CQ产生一个完成消息CQE表示接收完成。每个WQE处理完成都会产生一个CQE。</li>
</ul>
<p>与传统通信的区别在于零拷贝、绕过内核。</p>

      </div>
      <div class="post-tags-categories">
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>aoba moka</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2022/11/10/学习笔记-计网/" target="_blank" title="学习笔记-计网">https://aobamoka.github.io/2022/11/10/学习笔记-计网/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">



  
  <div class="post-nav-prev post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://pic4.zhimg.com/80/v2-83ea273b88e119d9615aed0d89aad4ab_1440w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-83ea273b88e119d9615aed0d89aad4ab_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
    </div>
    <a href="/2022/11/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MySQL/" class="post-nav-link">
      <div class="title">
        <i class="fas fa-angle-left"></i> 上一篇:
        <div class="title-text">学习笔记-MySQL</div>
      </div>
      
      <!-- <div class="content">
        大三上的数据库课，而且讲的很浅，感觉没记下些啥，可能很基础的也会记上来。。。
1. 基础篇1. 关系型数据库与非关系型数
      </div> -->
    </a>
  </div>



  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" src="" alt="">
    </div>
    <a href="/2022/11/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%846/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">读书笔记-网络是怎样连接的6</div>
      </div>
      <!-- <div class="content">
        网络是怎样连接的 读书笔记6前言突然发现45章有一大半都是讲运营商的，感觉看了跟没看似的……
不过终于快把这本书啃完了，
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-container"></div>

    
  </div>

<!-- comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  <aside id='l_side'>
  
    
      <section class="widget side_blogger">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img src='/medias/test.png'/>
        </a>
      
    
    
      <div class='text'>
        
          <h2>摩卡</h2>
        
        
          <p>因幡めぐる单推</p>

        
        
          <p><span id="jinrishici-sentence">摩卡's blog</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
  </div>
</section>

    
  
  
  

  <div class="layout_sticky">    
    
      
<section class="widget side_toc">
  
  <header>
    
      <i style="color: " class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name' style="color: ">本文目录</span>
    
  </header>


  <div class='content'>
    <div class="toc-main">
      <div class="toc-content">
        <!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">1. 基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. OSI七层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-text">2. 各层协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-text">1. 应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-text">2. 传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">3. 网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-text">4. 数据链路层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-WWW%E4%B8%87%E7%BB%B4%E7%BD%91%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF"><span class="toc-text">3. WWW万维网构建技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-HTTP"><span class="toc-text">2. HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">1. HTTP报文格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-text">1. 请求报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-text">2. 响应报文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HTTP%E7%BC%93%E5%AD%98"><span class="toc-text">2. HTTP缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-HTTP1-1"><span class="toc-text">3. HTTP1.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-HTTPS"><span class="toc-text">4. HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-TLS%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E2%80%94%E2%80%94RSA%E7%AE%97%E6%B3%95"><span class="toc-text">5. TLS四次握手——RSA算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-TLS%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E2%80%94%E2%80%94ECDHE%E7%AE%97%E6%B3%95"><span class="toc-text">6. TLS四次握手——ECDHE算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-TLS%E5%85%B6%E4%BB%96"><span class="toc-text">7. TLS其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-HTTP1-1%E4%BC%98%E5%8C%96"><span class="toc-text">8. HTTP1.1优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-HTTPS%E4%BC%98%E5%8C%96"><span class="toc-text">9. HTTPS优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-HTTP2-0"><span class="toc-text">10. HTTP2.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-HTTP3-0"><span class="toc-text">11. HTTP3.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-RPC%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-text">12. RPC远程过程调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-text">13. 长轮询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-WebSocket"><span class="toc-text">14. WebSocket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">15. GET与POST的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-DNS"><span class="toc-text">16. DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-DNS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">17. DNS负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Cookie%E4%B8%8ESession"><span class="toc-text">18. Cookie与Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%90%84%E7%A7%8D%E6%BC%8F%E6%B4%9E%E4%B8%8E%E6%94%BB%E5%87%BB"><span class="toc-text">19. 各种漏洞与攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-XSS%E6%94%BB%E5%87%BB"><span class="toc-text">1. XSS攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CSRF%E6%94%BB%E5%87%BB"><span class="toc-text">2. CSRF攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E"><span class="toc-text">3. 文件上传漏洞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">20. HTTP状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-text">21. 中间人攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E9%99%8D%E7%BA%A7%E6%94%BB%E5%87%BB"><span class="toc-text">22. 降级攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%89%8D%E5%90%91%E5%AE%89%E5%85%A8%E6%80%A7-%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB"><span class="toc-text">23. 前向安全性&#x2F;重放攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89"><span class="toc-text">24. 安全和幂等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Nginx%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">25. Nginx与负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">1. 负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-text">2. 动静分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">3. 反向代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-text">4. 正向代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-text">3. 传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-text">1. 基本特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TCP%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9"><span class="toc-text">1. TCP三大特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. TCP与UDP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E7%89%87%E6%9C%BA%E5%88%B6"><span class="toc-text">3. 分片机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-TIME-WAIT%E7%8A%B6%E6%80%81"><span class="toc-text">4. TIME_WAIT状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-TCP%E9%87%8D%E4%BC%A0%E4%B8%8ESACK"><span class="toc-text">5. TCP重传与SACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">6. 滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">7. 流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">8. 拥塞控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-TCP-Fast-Open"><span class="toc-text">9. TCP Fast Open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-TCP%E5%B0%8F%E6%8A%A5%E6%96%87%E4%BC%98%E5%8C%96"><span class="toc-text">10. TCP小报文优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Nagle%E7%AE%97%E6%B3%95"><span class="toc-text">1. Nagle算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TCP%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4"><span class="toc-text">2. TCP延迟确认</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-close%E4%B8%8Eshutdown"><span class="toc-text">11. close与shutdown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81-amp-%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87"><span class="toc-text">12. 面向字节流&amp;面向报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-TCP%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">13. TCP时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-PAWS%E6%9C%BA%E5%88%B6"><span class="toc-text">14. PAWS机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">15. 时间戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-TCP-Fast-Open-TLSv1-3"><span class="toc-text">16. TCP Fast Open + TLSv1.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-TCP-keepalive%E4%B8%8EHTTP-keep-alive"><span class="toc-text">17. TCP keepalive与HTTP keep-alive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-QUIC"><span class="toc-text">18. QUIC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%AE%A2%E6%88%B7%E7%AB%AFconnect%E9%80%89%E6%8B%A9%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-text">16. 客户端connect选择端口的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E3%80%81%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-text">17. 半连接、全连接队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-tcp-abort-on-overflow"><span class="toc-text">18. tcp_abort_on_overflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-cookies%E6%96%B9%E6%A1%88%E5%8F%96%E4%BB%A3%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-text">19. cookies方案取代半连接队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-TCP%E4%B8%A2%E5%8C%85"><span class="toc-text">20. TCP丢包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E2%98%85-%E6%8B%86%E5%8C%85-%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">21. ★ 拆包&#x2F;粘包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-text">22. 数据包发送流程总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-MTU%E4%B8%8EMSS"><span class="toc-text">23. MTU与MSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-RTO%E5%92%8CRTT"><span class="toc-text">24. RTO和RTT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-TCP%E5%A4%B4%E9%83%A8%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9"><span class="toc-text">25. TCP头部常用选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="toc-text">26. TCP如何保证可靠性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-ARQ%E5%8D%8F%E8%AE%AE"><span class="toc-text">27. ARQ协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85ARQ%E5%8D%8F%E8%AE%AE"><span class="toc-text">1. 停止等待ARQ协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE"><span class="toc-text">2. 连续ARQ协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-text">2. 特殊情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8F%A1%E6%89%8B%E4%B8%8E%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8Dx%E6%AC%A1%EF%BC%9F"><span class="toc-text">1. 握手与挥手为什么不x次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BF%85%E9%A1%BB%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">2. 必须三次握手的原因&#x2F;为什么不能两次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-SYN%E6%94%BB%E5%87%BB"><span class="toc-text">3. SYN攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-FIN-WAIT2%E4%B8%AD%E6%94%B6%E4%B8%8D%E5%88%B0%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">4. FIN_WAIT2中收不到第三次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%90%8E%E6%9F%90%E4%B8%80%E6%96%B9%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C"><span class="toc-text">5. 建立连接后某一方出现故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Socket%E7%9A%84accept%E4%B8%8Elisten"><span class="toc-text">6. Socket的accept与listen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-TCP%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BB%A1"><span class="toc-text">7. TCP全连接队列满</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-TCP%E8%BF%9E%E6%8E%A5%E5%8F%8C%E6%96%B9%E5%90%8C%E6%97%B6%E5%85%B3%E9%97%AD"><span class="toc-text">8. TCP连接双方同时关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84SYN%E5%8C%85%E8%A2%AB%E4%B8%A2%E5%BC%83"><span class="toc-text">9. 第一次握手的SYN包被丢弃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A4%84%E4%BA%8EESTABLISH%E7%8A%B6%E6%80%81%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%B6%E5%88%B0%E4%BA%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84SYN%E6%8A%A5%E6%96%87"><span class="toc-text">10. 处于ESTABLISH状态的服务端收到了客户端的SYN报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%8C%A5%E6%89%8B%E6%97%B6%E8%A2%AB%E5%8A%A8%E5%85%B3%E9%97%AD%E7%AB%AF%E7%9A%84FIN%E6%8A%A5%E6%96%87%E6%AF%94%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%97%A9%E5%88%B0%E8%BE%BE%E5%8F%A6%E4%B8%80%E6%96%B9"><span class="toc-text">11. 挥手时被动关闭端的FIN报文比发送的数据更早到达另一方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-TIME-WAIT%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%E6%94%B6%E5%88%B0SYN"><span class="toc-text">12. TIME_WAIT状态下的TCP连接收到SYN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%80%E6%96%B9%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%B4%A9%E6%BA%83"><span class="toc-text">13. 连接的一方进程崩溃与主机崩溃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E8%80%83%E8%99%91TCP%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%90%A6%E6%96%AD%E5%BC%80%E4%B8%80%E5%AE%9A%E8%A6%81%E8%80%83%E8%99%91%E6%9C%89%E6%97%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%8Ekeepalive%E6%9C%BA%E5%88%B6%E4%B8%A4%E4%B8%AA%E6%96%B9%E9%9D%A2"><span class="toc-text">14. 考虑TCP连接是否断开一定要考虑有无数据传输与keepalive机制两个方面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-TCP%E4%B8%8EUDP%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-text">15. TCP与UDP可以绑定相同的端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%94%B6%E5%88%B0Seq%E5%8F%B7%E4%B8%8D%E7%AC%A6%E5%90%88%E6%9C%9F%E6%9C%9B%E7%9A%84%E6%8A%A5%E6%96%87"><span class="toc-text">16. 收到Seq号不符合期望的报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84IP-%E7%AB%AF%E5%8F%A3"><span class="toc-text">17. 客户端连接不存在的IP&#x2F;端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB"><span class="toc-text">18. 常见网络攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-IP%E6%AC%BA%E9%AA%97"><span class="toc-text">1. IP欺骗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SYN%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><span class="toc-text">2. SYN洪泛攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-UDP%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><span class="toc-text">3. UDP洪泛攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-HTTP%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><span class="toc-text">4. HTTP洪泛攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-DNS%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><span class="toc-text">5. DNS洪泛攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-TCP%E9%87%8D%E7%BD%AE%E6%94%BB%E5%87%BB"><span class="toc-text">6. TCP重置攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-text">7. 中间人攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-DDOS"><span class="toc-text">8. DDOS</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-IP"><span class="toc-text">4. IP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8E%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-text">1. 与链路层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="toc-text">2. 地址分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E6%92%AD"><span class="toc-text">3. 多播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%8E%AF%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-text">4. 环回地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-IPv6"><span class="toc-text">5. IPv6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE"><span class="toc-text">6. 其他协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-RARP"><span class="toc-text">1. RARP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DHCP"><span class="toc-text">2. DHCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-NAT"><span class="toc-text">3. NAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ICMP"><span class="toc-text">4. ICMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-IGMP"><span class="toc-text">5. IGMP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-ping"><span class="toc-text">7. ping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-traceroute"><span class="toc-text">8. traceroute</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%A1%A5%E5%85%85"><span class="toc-text">5. 补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RDMA"><span class="toc-text">1. RDMA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9FTCP-IP%E9%80%9A%E4%BF%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">1. 传统TCP&#x2F;IP通信的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E4%BA%9B%E5%89%8D%E7%BD%AE%E6%8A%80%E6%9C%AF"><span class="toc-text">2. 一些前置技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">3. 基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F"><span class="toc-text">4. 传输模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">5. 工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">6. 消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-RDMA-READ"><span class="toc-text">7. RDMA READ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-RDMA-WRITE"><span class="toc-text">8. RDMA WRITE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-RDMA-SEND-RECIEVE"><span class="toc-text">9. RDMA SEND&#x2F;RECIEVE</span></a></li></ol></li></ol></li></ol> -->
        <div class="toc"></div>
      </div>
    </div>
  </div>
</section>
<!-- 手机端目录按钮 -->
<div id="toc-mobile-btn">
  <i class="fas fa-list-ul" aria-hidden="true"></i>
</div>

      
  <section class="widget side_recent_post">
    
  <header>
    
      <a style="color: " href='/tags/'><i class="fas fa-book fa-fw" aria-hidden="true"></i><span class='name'>最新文章</span></a>
    
  </header>


    <div class='content'>
      
      <!-- hash算法 -->
      
      <div class="aside-list">
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-2/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-20</span>
                
              </div>
              <a class="post-title" href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-2/">项目学习-CMU-15-445-Lab1-2</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-1/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-19</span>
                
              </div>
              <a class="post-title" href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-1/">项目学习-CMU-15-445-Lab1-1</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab0/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-19</span>
                
              </div>
              <a class="post-title" href="/2023/03/19/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab0/">项目学习-CMU-15-445-Lab0</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Shell%E7%BC%96%E7%A8%8B/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-18</span>
                
              </div>
              <a class="post-title" href="/2023/03/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Shell%E7%BC%96%E7%A8%8B/">学习笔记-Shell编程</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SQL%E8%AF%AD%E6%B3%95/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://picx.zhimg.com/80/v2-b44931ea513e5f7b3b06f2703f79653c_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-b44931ea513e5f7b3b06f2703f79653c_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-16</span>
                
              </div>
              <a class="post-title" href="/2023/03/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SQL%E8%AF%AD%E6%B3%95/">学习笔记-SQL语法</a>
            </div>
          </div>
        
      </div>
    </div>
  </section>

    
  </div>
</aside>

  <!-- 图片放大 Wrap images with fancybox support -->
  <script src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || 'rgba(66, 185, 133, 0.8)';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          
            <!-- 不蒜子统计 -->
            <!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
      <i class="fas fa-eye" aria-hidden="true"></i>本站总访问量：<span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
      <i class="fas fa-users" aria-hidden="true"></i>本站访客数：<span id="busuanzi_value_site_uv"></span> 人
</span>

          
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark">
  <div class="dark-content">
    <i class="fas fa-moon" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-moon" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    

    <!-- 图片放大 -->
    
      <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    
      <script type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<!-- <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -70,
    // headingsOffset: -($(window).height() * 0.4 - 45),
    headingsOffset: -($(window).height() * 0.4 - 70),
    // positionFixedSelector: '.toc-main',
    // positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    orderedList: true,
    collapseDepth: 20,
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 150) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('side_toc')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  /* .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  } */
</style>
 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 渲染远程json加载的图片标签(getPhotoOnline)里的内容 -->
<script>
  function loadPhotoOnlineJS() {
    if ($(".post-detail").find(".getJsonPhoto-api").length == 0) {
      return;
    } 
    loadScript('/js/getPhotoOnline/index.js');
  };
  $(function () {
    loadPhotoOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getPhotoJson == "undefined") {
      loadPhotoOnlineJS();
    }
  })
</script>

<!-- 渲染远程json加载的site-card标签(getSiteOnline)里的内容 -->
<script>
  function loadSiteOnlineJS() {
    if ($(".post-detail").find(".getJsonSite-api").length == 0) {
      return;
    } 
    loadScript('/js/getSiteOnline/index.js');
  };
  $(function () {
    loadSiteOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getSiteJson == "undefined") {
      loadSiteOnlineJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
    <script type="text/javascript">
  var utteranceCommon = {};

  function check_utterance() {
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    if (isDark) {
      utteranceCommon.Theme = 'github-dark';
    } else {
      utteranceCommon.Theme = 'github-light';
    }

    return document.getElementById("gitment-container");
  }
  comment_el = '#gitment-container';
  load_utterance = function () {
    if ($(comment_el).length) {
      // 匿名函数，防止污染全局变量
      const HEAD = check_utterance();

      var utterances = document.createElement('script');
      utterances.type = 'text/javascript';
      utterances.async = true;
      utterances.setAttribute('issue-term', 'pathname')
      utterances.setAttribute('theme', utteranceCommon.Theme)
      utterances.setAttribute('repo', '')
      utterances.crossorigin = 'anonymous';
      utterances.src = 'https://utteranc.es/client.js';
      // content 是要插入评论的地方
      document.getElementById('gitment-container').appendChild(utterances);

    }
  }

  function dark_utterance() {
    const HEAD = check_utterance();
    if (!HEAD) return;
    const message = {
      type: 'set-theme',
      theme: utteranceCommon.Theme
    };
    const utteranceIframe = document.querySelector('iframe');
    utteranceIframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }

  $(document).ready(load_utterance);
  document.addEventListener('pjax:complete', function () {
    load_utterance();
  });

  $('.dark').click(function () {
    setTimeout(() => {
      dark_utterance();
    });
  })

</script>

<style>
  .utterances {
    max-width: inherit !important;
  }
</style>
  


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


<!-- 轮播图标签 -->
<script>
  var bambooSwiperTag = {};
  function load_swiper() {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    loadCSS("https://unpkg.com/swiper@6/swiper-bundle.min.css")
    loadScript("https://unpkg.com/swiper@6/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    bambooSwiperTag.swiper = new Swiper('.post-swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      autoplay: true ? {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false,
      } : false,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
      on:{
        init: function(){
          swiperAnimateCache(this); //隐藏动画元素 
          swiperAnimate(this); //初始化完成开始动画
        }, 
        slideChangeTransitionEnd: function(){ 
          swiperAnimate(this); //每个slide切换结束时也运行当前slide动画
          //this.slides.eq(this.activeIndex).find('.ani').removeClass('ani'); 动画只展现一次，去除ani类名
        } 
      }
    });
  }

  document.addEventListener('pjax:complete', function () {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    if (typeof bambooSwiperTag.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>
    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  </body>
</html>