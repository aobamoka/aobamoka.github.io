<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>学习笔记-MySQL | 摩卡&#39;s blog</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/icons/icon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    <link href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css" rel="stylesheet">
  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script defer src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    
    
    <!-- 依赖于jquery和vue -->
    
        <script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>
    

    
        <script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>
    

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="摩卡's blog" type="application/atom+xml">
</head>

  
  <!-- 预加载动画 -->
  <!-- 页面预加载动画 -->

  
    <div class="preloader_2" id="loader">
  <div class="loader"></div>
</div>

  
<script>
  var endLoading = function () {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('DOMContentLoaded',endLoading);
</script>

  <body>
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (src) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header  " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
      <h3 class="drawer-box-head_title">摩卡&#39;s blog</h3>
      <h5 class="drawer-box-head_desc">随便写写，记录下都看了些啥</h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
        </div>
      
      <a href="/" class="logo">摩卡&#39;s blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
    <div id="he-plugin-simple"></div>
    <script>
      WIDGET = {
        CONFIG: {
          "modules": "012",
          "background": 5,
          "tmpColor": "4A4A4A",
          "tmpSize": 16,
          "cityColor": "4A4A4A",
          "citySize": 16,
          "aqiSize": 16,
          "weatherIconSize": 24,
          "alertIconSize": 18,
          "padding": "10px 10px 10px 10px",
          "shadow": "1",
          "language": "auto",
          "borderRadius": 5,
          "fixed": "false",
          "vertical": "middle",
          "horizontal": "center",
          "key": "2784dd3fcb1e4f0f9a9b579bf69641f2"
        }
      }
    </script>
    <script defer src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script> 
    
</header>
        <!-- 内容区域 -->
        
 <!-- prismjs 代码高亮 -->
 


<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('https://pic4.zhimg.com/80/v2-83ea273b88e119d9615aed0d89aad4ab_1440w.webp')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        学习笔记-MySQL
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2022-11-23 |
        </span>
      

      
        <span class="post-detail-header_categories">
          <i class="iconfont iconbookmark1"></i> 分类：
          
            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-detail-header_category">
              学习笔记
            </a>
          
        </span>
      

      
    
  </div>
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content post-row" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <p>大三上的数据库课，而且讲的很浅，感觉没记下些啥，可能很基础的也会记上来。。。</p>
<h1 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h1><h2 id="1-关系型数据库与非关系型数据库"><a href="#1-关系型数据库与非关系型数据库" class="headerlink" title="1. 关系型数据库与非关系型数据库"></a>1. 关系型数据库与非关系型数据库</h2><h3 id="1-关系型数据库"><a href="#1-关系型数据库" class="headerlink" title="1. 关系型数据库"></a>1. 关系型数据库</h3><p>关系模型：对关系的表述，二维表格模型。关系名即为表名。一般格式为关系名(属性1，属性2，……，属性N)。</p>
<p>关系型数据库：采用了关系模型组织数据的数据库。</p>
<p>优点：</p>
<ol>
<li>容易理解：使用了关系模型组织。</li>
<li>使用方便：通用SQL语言操作。</li>
<li>易于维护：丰富的完整性（实体完整性、参照完整性和用户定义的完整性）大大减低了数据冗余和不一致的概率。</li>
</ol>
<p>缺点：</p>
<ol>
<li>高并发时硬盘I/O成为瓶颈。</li>
<li>难以对数据库系统升级扩展，需要停机维护和数据迁移。</li>
<li>多表关联查询与复杂查询性能欠佳。</li>
</ol>
<h3 id="2-非关系型数据库NoSQL"><a href="#2-非关系型数据库NoSQL" class="headerlink" title="2. 非关系型数据库NoSQL"></a>2. 非关系型数据库NoSQL</h3><p>Not only SQL：不仅仅是SQL，不是“不是SQL”！</p>
<p>非关系型的、分布式的、一般不保证遵循ACID原则的数据存储系统。</p>
<p>结构不固定，键值对、宽列、文档、图表等结构。每个元组可以有不一样的字段。</p>
<p>优点：</p>
<ol>
<li>高可拓展性：使用分布式硬件集群横向扩展。</li>
<li>高性能：针对特定数据模型和访问模式进行了优化。</li>
<li>灵活架构</li>
<li>没有复杂的关系</li>
</ol>
<p>缺点：</p>
<ol>
<li>没有标准化</li>
<li>查询功能有限</li>
<li>最终一致性不直观</li>
</ol>
<p>BASE：NoSQL数据库对可用性及一致性的弱要求原则：（因为CAP的三点不能同时很好的满足）</p>
<ul>
<li>基本可用Basically Available</li>
<li>软状态/柔性事务Soft-state：无连接</li>
<li>最终一致性Eventually Consistency：ACID的最终目的</li>
</ul>
<h3 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h3><p>最大区别：是否支持外键</p>
<ol>
<li>数据存储模型：SQL结构化存储，具有固定行和列的表格；NoSQL非结构化存储，有文档、键值对等多种结构。</li>
<li>ACID属性：SQL提供；NoSQL通常不支持ACID事务，为了可扩展、高性能进行了权衡。</li>
<li>性能：SQL性能通常取决于磁盘子系统，为了最佳性能通常需要优化查询、索引和表结构；NoSQL性能通常取决于底层硬件、网络延迟以及应用程序。</li>
<li>扩展：SQL通常是垂直扩展，即使用性能更强大的服务器，此外读写分离、分库分表等；NoSQL通常是横向扩展，即增加服务器。</li>
<li>用途：SQL是普通企业级的项目数据存储；NoSQL用途随结构不同而变化，如图数据库分析数据见的关系。</li>
</ol>
<h2 id="2-SQL数据完整性"><a href="#2-SQL数据完整性" class="headerlink" title="2. SQL数据完整性"></a>2. SQL数据完整性</h2><p>数据库中数据在逻辑上的一致性、准确性、有效性和相容性。</p>
<p>包括实体完整性、参照完整性、用户自定义完整性。</p>
<p>SQL Server中分为实体完整性、域完整性和引用完整性。</p>
<h3 id="1-实体完整性"><a href="#1-实体完整性" class="headerlink" title="1. 实体完整性"></a>1. 实体完整性</h3><p>又叫行完整性，指表中每一个记录都能唯一标识，且不存在重复的记录。可通过主键约束和唯一性约束实现。</p>
<p>主键约束：主键列取值不能为空且不能重复。</p>
<p>唯一性约束：允许值为空，但不允许重复，包括空。</p>
<h3 id="2-域完整性"><a href="#2-域完整性" class="headerlink" title="2. 域完整性"></a>2. 域完整性</h3><p>又叫列完整性，指数据集对某一列是否有效和确定是否允许为空值。可通过空值约束、默认约束和检查约束实现。</p>
<p>空值约束：值是否可以为空。</p>
<p>默认约束：为列设置默认值。</p>
<p>检查约束：为列设置取值范围。</p>
<h3 id="3-引用完整性"><a href="#3-引用完整性" class="headerlink" title="3. 引用完整性"></a>3. 引用完整性</h3><p>又称参照完整性、外键约束。保证主键和外部键的关系得到维护。通过定义外键约束实现。</p>
<p>外键约束：定义任意个列，这些列可参照当前表或其他表的主键或UNIQUE约束列。</p>
<p>有更新规则与删除规则，共用四种模式：不执行任何操作、级联、置空、设置默认值。</p>
<p>不执行任何操作：默认值。外键列不能增改主键列没有的值（删除不受影响），主键表不能修改涉及外部键值记录的主键值，不能删除涉及外部键值的记录（插入不受影响）。</p>
<p>级联：外键列不能增改主键列没有的值（删除不受影响），外键值随主键值同步修改、删除（插入不受影响）。</p>
<p>置空：外键列不能增改主键列没有的值（删除不受影响），外键值随主键值改删置空（插入不受影响）。</p>
<p>设置默认值：外键列不能增改主键列没有的值（删除不受影响），外键值随主键值改删置为默认值（插入不受影响）。</p>
<h3 id="4-用户定义的完整性"><a href="#4-用户定义的完整性" class="headerlink" title="4. 用户定义的完整性"></a>4. 用户定义的完整性</h3><p>针对某一具体应用的数据必须满足的语义要求。</p>
<h2 id="3-MYSQL架构"><a href="#3-MYSQL架构" class="headerlink" title="3. MYSQL架构"></a>3. MYSQL架构</h2><p>MYSQL架构分为Server层和存储引擎层。存储引擎层只负责数据的存储和提取，其他所有功能都在Server层。InnoDB是MYSQL默认的存储引擎。</p>
<p>MYSQL基于TCP传输。</p>
<p>执行流程：</p>
<ol>
<li>连接器：通过TCP握手连接MYSQL服务。</li>
<li>查询缓存：查询Server层的k-v缓存（SQL查询语句-查询结果）。由于命中率很低且每更新数据库就需要清空，从MYSQL 8.0开始不用这个阶段。</li>
<li>解析SQL：解析器进行词法分析和语法分析<ol>
<li>词法分析：识别关键词，构建SQL语法树。</li>
<li>语法分析：根据语法规则判断输入的SQL语句是否符合语法。</li>
</ol>
</li>
<li>执行SQL：<ol>
<li>预处理阶段：预处理器检查SQL查询语句中的表或字段是否存在；将select *中的*展开为表上所有列。</li>
<li>优化阶段：优化器将SQL查询语句的执行方案确定下来。比如再表里有多个索引时，优化器基于查询成本决定选择哪个索引。</li>
<li>执行阶段：执行器和存储引擎交互（以记录为单位）<ol>
<li>主键索引查询：id = 1：查询条件用到了主键索引，而且是等值查询，同时主键id唯一。执行器将条件交给存储引擎，让存储引擎查询记录，存储引擎将结果发回给执行器，执行器判断记录是否符合查询条件，如果符合发送给客户端，否则跳过，直到找不到或者返回-1表示已查询完。</li>
<li>全表扫描：name = ‘xxx’：优化器选择访问类型为all。存储引擎从表中第一条记录读起，执行器判断是否符合条件，如果是则发给客户，否则跳过，直到存储引擎把表中所有记录读完并返回读取完毕。</li>
<li>索引下推：age &gt; 20 and reward = 100000，且对age和reward建立了联合索引：执行器调用接口定位到满足查询条件的第一条二级索引记录(age &gt; 20)；存储器在定位到二级索引后先不执行回表操作，而是先判断reward列条件是否成立，如果不成立直接跳过该索引，成立则回表；执行器再判断其他条件是否成立并决定发给客户端，然后继续向存储引擎索要下一条记录。即将部分条件交给存储引擎直接判断。</li>
</ol>
</li>
</ol>
</li>
<li>总体流程：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="MYSQL执行流程"></li>
</ol>
<h2 id="4-表空间文件结构"><a href="#4-表空间文件结构" class="headerlink" title="4. 表空间文件结构"></a>4. 表空间文件结构</h2><p>一张数据库表的数据保存在ibd文件中，也称为独占表空间文件。表空间由段、区、页、行组成，逻辑结构依次缩小。</p>
<h3 id="1-行"><a href="#1-行" class="headerlink" title="1. 行"></a>1. 行</h3><p>每一条记录都是按行存放。</p>
<h3 id="2-页"><a href="#2-页" class="headerlink" title="2. 页"></a>2. 页</h3><p>数据按页为单位读写，默认大小为16KB。</p>
<p>分页的原因：数据量过大，避免一次性将所有数据加载出来。</p>
<p>数据页中有一个页目录，起记录的索引作用。</p>
<ol>
<li>将所有记录划分成几个组。</li>
<li>每个记录组的最后一条记录是组内最大的记录，其头信息会存储该组记录数，作为n_owned字段。</li>
<li>页目录存储每组最后一条记录的地址偏移量，也被称为槽。</li>
</ol>
<h3 id="3-区"><a href="#3-区" class="headerlink" title="3. 区"></a>3. 区</h3><p>B+树中，每一层通过双向链表相连。链表中相邻的页的物理位置也相邻，方便使用顺序IO。</p>
<p>为某个索引分配空间按区为单位分配，一般1MB，从而使得物理位置相邻。</p>
<h3 id="4-段"><a href="#4-段" class="headerlink" title="4. 段"></a>4. 段</h3><ul>
<li>索引段：存储B+树的非叶子节点的区的集合。</li>
<li>数据段：存储B+树的叶子节点的区的集合。</li>
<li>回滚段：存储回滚数据的集合。</li>
</ul>
<h2 id="5-行格式"><a href="#5-行格式" class="headerlink" title="5. 行格式"></a>5. 行格式</h2><ul>
<li>Redundant：5.0前的老格式，现在没人用了。</li>
<li>Compact：5.0~5.7默认行格式。</li>
<li>Dynamic：5.7之后默认行格式</li>
<li>Compressed</li>
</ul>
<h3 id="1-Compact"><a href="#1-Compact" class="headerlink" title="1. Compact"></a>1. Compact</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<p>变长字段长度列表：逆序存储变长字段的长度。数据表中没有变长字段，则没有这段。</p>
<p>NULL值列表：每列对应一个二进制位，逆序表示是否为NULL值。数据表字段都定义成NOT NULL时，没有这段。</p>
<p>row_id：在没有指定主键与唯一约束时自动添加。如果指定了其中之一，则没有这段。</p>
<p>发生行溢出时，记录的真实数据处只会保留部分数据，用20字节存储指向溢出页的地址，剩余的数据放在溢出页。</p>
<h2 id="6-三大范式"><a href="#6-三大范式" class="headerlink" title="6. 三大范式"></a>6. 三大范式</h2><h3 id="1-第一范式"><a href="#1-第一范式" class="headerlink" title="1. 第一范式"></a>1. 第一范式</h3><p>对关系模式的基本要求，不满足则不是关系数据库。</p>
<p>1NF：无重复的列/字段不可分。</p>
<p><strong>原子性</strong>，字段不可再分。</p>
<h3 id="2-第二范式"><a href="#2-第二范式" class="headerlink" title="2. 第二范式"></a>2. 第二范式</h3><p>先要满足1NF。</p>
<p>2NF：有主键，非主键字段依赖于主键。</p>
<p><strong>唯一性</strong>，一个表只说明一个事务。</p>
<h3 id="3-第三范式"><a href="#3-第三范式" class="headerlink" title="3. 第三范式"></a>3. 第三范式</h3><p>先要满足2NF。</p>
<p>3NF：非主键字段不能相互依赖。不存在传递依赖。</p>
<h3 id="4-BCNF"><a href="#4-BCNF" class="headerlink" title="4. BCNF"></a>4. BCNF</h3><p>先要满足3NF</p>
<p>任何非主键字段不能对主键子集依赖。</p>
<h2 id="7-InnoDB与MyISAM"><a href="#7-InnoDB与MyISAM" class="headerlink" title="7. InnoDB与MyISAM"></a>7. InnoDB与MyISAM</h2><ol>
<li>应用层：外键、事务、行锁、是否可以没有主键。</li>
<li>并发：InnoDB支持行级锁，MyISAM不支持。</li>
<li>备份：InnoDB支持在线热备份。</li>
<li>崩溃恢复：MyISAM崩溃后损坏概率较InnoDB高，且恢复速度较慢。</li>
<li>索引：MyISAM树节点的data域只存放数据记录的地址，称为非聚簇索引。InnoDB树节点的data域保存了完整的数据记录，称为聚簇索引。其他索引的data域存储的是主键值而不是地址。</li>
<li>适用场景：MyISAM适合插入不频繁而查询非常频繁的场合，因为没有事务；InnoDB适合可靠性要求非常高、要求事务或插入相当频繁的场合。</li>
</ol>
<h2 id="8-数据库结构优化"><a href="#8-数据库结构优化" class="headerlink" title="8. 数据库结构优化"></a>8. 数据库结构优化</h2><ul>
<li>范式优化/反范式优化：消除冗余（节省空间）/增加冗余（减少join）</li>
<li>限定数据范围：查询时必须带上某些限制，尽量使用索引，避免全表扫描</li>
<li>读写分离：主库负责写，从库负责读</li>
<li>拆分表<ul>
<li>横向拆分：根据某个记录（如主键）哈希值的不同拆分表。</li>
<li>纵向拆分：将属性分为活跃字段（常用）与不活跃字段，拆成两张表。</li>
</ul>
</li>
</ul>
<h2 id="9-高并发优化"><a href="#9-高并发优化" class="headerlink" title="9. 高并发优化"></a>9. 高并发优化</h2><ul>
<li>加入缓存：web服务框架中、服务器与数据库层间。</li>
<li>增加数据库索引（但不能太多，否则每个索引维护的树都需要同步更新，同样会变慢）</li>
<li>主从读写分离</li>
<li>拆分表</li>
<li>分布式架构</li>
</ul>
<h2 id="10-游标与视图"><a href="#10-游标与视图" class="headerlink" title="10. 游标与视图"></a>10. 游标与视图</h2><p>游标：对<strong>查询出来的结果集</strong>作为一个单元处理。一般用于需要逐条记录（逐行）处理的场合。</p>
<p>视图：虚拟的表，和物理表相同的功能，对其修改不影响原表。相比于多表查询更容易获取数据。</p>
<p>作用：</p>
<ol>
<li>简化操作。把经常使用的数据定义为视图。</li>
<li>安全性。用户只能查询与修改能看到的数据。</li>
<li>逻辑上的独立性。屏蔽真实表结构的影响。</li>
</ol>
<p>比较：</p>
<ol>
<li>本质：游标作为指针操作，视图作为数据库对象展示给用户。</li>
<li>占用资源：游标占用资源大，视图占用资源小。</li>
<li>工作方式：游标针对行操作，视图针对基表的一个整体的查询。</li>
</ol>
<h2 id="11-LSM树"><a href="#11-LSM树" class="headerlink" title="11. LSM树"></a>11. LSM树</h2><p>日志结构合并树。</p>
<p>作为各种NoSQL的底层存储索引。</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul>
<li>横跨内外存，分为多个层，L0位于内存，L1-LN位于磁盘。</li>
<li>内存中一般采用<strong>有序、高性能查找的结构</strong>，如AVL树、红黑树、跳表等。</li>
<li>外存中每一层本质是多个<strong>文件</strong>，文件内是排序好的数据。</li>
<li>每一层树数据达到阈值后向下层compact。</li>
<li>增删改LSM树均在内存操作，归并时将修改刷盘。</li>
<li>特点：<strong>写性能强、读性能弱</strong>。</li>
</ul>
<p>与B+树都使用了WAL，但B+树增删改均是随机写，LSM树只是追加顺序写，而LSM树读操作最坏需要遍历所有层，所以读效率一般不如B+树。</p>
<h3 id="2-具体结构"><a href="#2-具体结构" class="headerlink" title="2. 具体结构"></a>2. 具体结构</h3><p>由memtable、immutable-memtable（内存）与SSTable（磁盘）组成。</p>
<h3 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h3><p>分为两步：</p>
<ol>
<li>WAL写日志</li>
<li>将待插入的数据定位到内存中待写入的位置，写入。（不在乎该数据是否在磁盘中）</li>
</ol>
<p>增删改操作在memtable中进行，memtable大小达到阈值后转变成immutable-memtable（即将刷盘的中间态），并新建一个memtable。后台线程将immutable-memtable写入磁盘L1层形成SSTable文件，随后销毁immutable-memtable。</p>
<p>SSTable不可修改，改删都是以顺序写入新记录的形式呈现。读取数据从新到旧读，所以先读到最新的数据。</p>
<p>单个SSTable不存在相同key的数据，而不同SStable可能存在。</p>
<h3 id="4-更新"><a href="#4-更新" class="headerlink" title="4. 更新"></a>4. 更新</h3><ol>
<li>在内存中找待更新的数据。</li>
<li>如果内存中找到，就更新。</li>
<li>否则将待更新的数据插入到本应存在的位置。</li>
</ol>
<h3 id="5-删除"><a href="#5-删除" class="headerlink" title="5. 删除"></a>5. 删除</h3><p>只是将更新改为打上delete标签。</p>
<h3 id="6-查找"><a href="#6-查找" class="headerlink" title="6. 查找"></a>6. 查找</h3><p>性能偏弱，按照层次增加依次查找，知道找到为止。</p>
<p>外存中每一层的多个SSTable配有布隆过滤器和索引。布隆过滤器快速判断block内部是否存在待查找的值，可能存在则通过索引加速查找。</p>
<p>最坏需要遍历所有层。</p>
<h3 id="7-合并"><a href="#7-合并" class="headerlink" title="7. 合并"></a>7. 合并</h3><p>将低级别多个SSTable文件中的数据放入高一级的SSTable文件，并清除这些低级别的文件。</p>
<p>三个问题：</p>
<ul>
<li>读放大：读取数据时实际读取量大于真正的数据量。如LSM读取数据时可能需要扫描多个SSTable。</li>
<li>写放大：写入数据时实际写入量大于真正的数据量。如LSM树写入触发Compact操作。</li>
<li>空间放大：数据实际占用的磁盘空间比数据真正大小更多。如LSM树存放的旧版冗余数据都是无效的。</li>
</ul>
<p>必要性：对一个数据增删改时，磁盘中可能存有其历史版本，而这些历史版本不会被读取到、没有任何作用，但是占着磁盘，需要清理。</p>
<p>两种广泛应用的策略</p>
<h4 id="1-STCS-Size-Tiered-Compaction-Strategy"><a href="#1-STCS-Size-Tiered-Compaction-Strategy" class="headerlink" title="1. STCS Size-Tiered-Compaction-Strategy"></a>1. STCS Size-Tiered-Compaction-Strategy</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772b1dc05459429ca9fd7c837d3dddfa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" class="lazyload placeholder" data-srcset="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772b1dc05459429ca9fd7c837d3dddfa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<p>保证<strong>同一层</strong>中所有SSTable大小相近。</p>
<p>某层SSTable数量达到阈值时，将其合成一个更大的SSTable，放入下一个level，且在合并过程中清理重复的、被删除的数据。</p>
<p>多路归并排序。</p>
<p>对三个问题的解决：</p>
<ul>
<li>读放大：<strong>存在</strong>。不知道要查找的key在哪个SSTable，还是需要从新到旧遍历所有SSTable。</li>
<li>写放大：<strong>存在</strong>。写时触发Compact。</li>
<li>空间放大：<strong>存在</strong>。这种策略只能保证每个SSTable不存在重复数据，但同一层多个SSTable依然可能有相同数据。</li>
</ul>
<h4 id="2-LCS-Leveled-Compaction-Strategy"><a href="#2-LCS-Leveled-Compaction-Strategy" class="headerlink" title="2. LCS Leveled-Compaction-Strategy"></a>2. LCS Leveled-Compaction-Strategy</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38fbb237a5654586a225f6237424fd94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" class="lazyload placeholder" data-srcset="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38fbb237a5654586a225f6237424fd94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<p>保证<strong>磁盘</strong>所有层SSTable大小一致。</p>
<p>每一层限制总文件大小，层内按序排列且无重复数据（SSTable之间也有序）。</p>
<p>某层总文件大小达到阈值时，在该层选择一个SSTable与下一层key范围有交集的SSTable合并。保证合并后单个SSTable大小不超过阈值，且层内有序。多个不相关Compact可并行。</p>
<p>对三个问题的解决：</p>
<ul>
<li>读放大：较小。层内SSTable也有序，所以可直接定位到可能存放key的SSTable。</li>
<li>写放大：存在。写时触发Compact。</li>
<li>空间放大：较小。层内无重复数据，compact时不创建临时文件。</li>
</ul>
<h3 id="8-MVCC在LSM树的应用"><a href="#8-MVCC在LSM树的应用" class="headerlink" title="8. MVCC在LSM树的应用"></a>8. MVCC在LSM树的应用</h3><p>问题：高频率读写时，一个连接读取的SSTable被其他连接写入时合并。</p>
<p>解决：</p>
<ul>
<li>悲观锁：效率过低</li>
<li>MVCC。</li>
</ul>
<p>MVCC：快照+对所有SSTable加上引用计数。某个版本的引用计数降为0时，清理版本内引用计数为0的SSTable。</p>
<h2 id="12-跳表skiplist"><a href="#12-跳表skiplist" class="headerlink" title="12. 跳表skiplist"></a>12. 跳表skiplist</h2><p>实现与红黑树、AVL树相似。用于Redis的Zset实现。</p>
<p>每个节点由key、value与level大小的指针数组组成。</p>
<h3 id="1-层数"><a href="#1-层数" class="headerlink" title="1. 层数"></a>1. 层数</h3><p>每个节点都会随机到一个不同的层数x，该节点0~X所有层都是同一数据。</p>
<p>计算方式：（Redis中p=1/4，MaxLevel=64）</p>
<ul>
<li>节点初始为第0层。</li>
<li>在有第i层的情况下，第i+1层出现概率为p。</li>
<li>最大为MaxLevel层。</li>
</ul>
<p>每层的指针连接到相同层下一个节点（相当于每一层构成一个链表）。</p>
<h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2. 查找"></a>2. 查找</h3><ul>
<li>从dummyhead的最高层level出发。</li>
<li>当前层key小于待查key<ul>
<li>当前层next节点为空，跳到下一层。</li>
<li>否则跳到当前层next节点。</li>
</ul>
</li>
<li>当前层key大于待查key<ul>
<li>当前层不为第0层，跳到下一层的上一个节点。（具体实现时可不用双向链表，而是直接与next的key比较）</li>
<li>当前层为第0层，查找失败。</li>
</ul>
</li>
<li>当前层key等于待查key，查找成功。</li>
</ul>
<h3 id="3-插入-1"><a href="#3-插入-1" class="headerlink" title="3. 插入"></a>3. 插入</h3><p><img src="https://pic4.zhimg.com/80/v2-6a28162637f7ec3496470aa8c2d73f6b_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-6a28162637f7ec3496470aa8c2d73f6b_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<ul>
<li>先查询合适的插入位置。在查询的过程中记录每层最后一个遍历到的节点作为update数组。</li>
<li>创建新节点，随机生成待插入节点的level。如果level大于跳表当前最大层数，则将level设为跳表最大层数+1，update[level]更新为dummyhead。</li>
<li>用update连接上新节点，更新新节点各层的指针。</li>
</ul>
<h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h3><p><img src="https://pic4.zhimg.com/80/v2-41ed3ff71b11abc2e6aa79de40f6f95f_720w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-41ed3ff71b11abc2e6aa79de40f6f95f_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<p>与插入类似，记录update，移除时调整update中各节点指针指向。</p>
<p>删除后，跳表当前最大层数可能发生变化，需要调整。具体为dummyhead节点最高level向下查，看next指针是否为空，为空则将level-1。</p>
<h3 id="5-比较"><a href="#5-比较" class="headerlink" title="5. 比较"></a>5. 比较</h3><p>与哈希表：范围查找。</p>
<p>与平衡树：</p>
<ul>
<li>范围查找。</li>
<li>平衡树增删触发染色、旋转操作<ul>
<li>实现复杂</li>
<li>可能需要回溯，涉及节点多，并发时锁范围大，导致效率低。</li>
</ul>
</li>
<li>内存占用，平衡树每个节点至少需要两个指针，跳表p=1/4时平均每个节点只要1.33个指针。</li>
</ul>
<h1 id="2-索引篇"><a href="#2-索引篇" class="headerlink" title="2. 索引篇"></a>2. 索引篇</h1><h2 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1. InnoDB"></a>1. InnoDB</h2><ol>
<li><p>创建表的索引选择(聚簇索引)：只能有一</p>
<ol>
<li>如果有主键，默认用主键作为聚簇索引的索引键</li>
<li>如果没有主键，选择第一个不包含NULL值的唯一列作为聚簇索引的索引键</li>
<li>如果都没有，InnoDB自动生成一个隐式自增id列作为聚簇索引的索引键</li>
</ol>
</li>
<li><p>创建的主键索引和二级索引默认使用B+Tree索引</p>
<ol>
<li>B+Tree是一种多叉树，叶子节点存放数据，非叶子节点存放索引，每个节点里的数据按主键顺序存放，每个叶子节点都指向下一个叶子节点，形成一个链表。</li>
<li>二级索引：<ol>
<li>回表：二级索引的叶子节点中存放的是主键，所以在二级索引查询到后主键值后，还需要根据主键去主键索引的B+Tree再查询一次。</li>
<li>覆盖索引：需要查询的字段正好是索引字段。如果查询的数据就在二级索引的叶子节点中（比如主键），就不用再查。</li>
</ol>
</li>
<li>B+Tree的优势<ol>
<li>B Tree：<ol>
<li><strong>首要原因：B+ Tree的叶子节点使用了双链表连接，适合数据库中频繁的范围查询。</strong></li>
<li>B树叶子节点也会存储数据，所以数据量相同的情况下，B+Tree能存放更多索引，导致比B树更“矮胖”，磁盘I/O次数更少</li>
<li>B+ Tree增删节点时更为方便， B树还需要额外变形。</li>
</ol>
</li>
<li>二叉树：二叉树每个节点的子节点只能是两个，因此平均检索次数比B+ Tree更多。</li>
<li>Hash：<ol>
<li>哈希表不适合做范围查询</li>
<li>哈希表查询时需要将数据全部加载到内存中，而B+ Tree可以根据节点分段加载</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据存储形式</p>
<ol>
<li>数据按照数据页为单位进行读写，默认大小16KB。由文件头、页头、最大最小记录、用户记录、空闲空间、页目录、文件尾七个部分组成。<ol>
<li>File Header文件头中有两个指针分别指向上一页与下一页</li>
<li>页中记录按照主键顺序组成单向链表，为提高检索效率，将所有数据分组（每组记录数有限制），每个组中最后一条记录为组内最大记录，在该记录的头信息中存储该组记录数，页目录存储每组组内最大记录的地址偏移量，称为槽。通过槽查找记录时可以使用二分法。</li>
</ol>
</li>
<li>InnoDB里的B+ Tree每个节点都是一个数据页</li>
</ol>
</li>
</ol>
<h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><ol>
<li><p>索引分类</p>
<ol>
<li><p>按数据结构分类：</p>
<ol>
<li>B+Tree索引</li>
<li>HASH索引</li>
<li>全文索引：通过关键字匹配的方式进行全文过滤<ol>
<li>想对词语进行全文索引，它的长度必须满足在一个区间内（配置文件指定，一般为3~84）。</li>
<li>自然语言的全文索引：计算每一个文档对象和查询的相关度，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索。为了避免搜索语气词、助词这些没有意义的词。</li>
<li>在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性。</li>
<li><strong>比like%快，但是精度比它低</strong>。</li>
</ol>
</li>
</ol>
</li>
<li><p>按物理存储分类：</p>
<ol>
<li>主键索引/聚簇索引：InnoDB中，聚簇索引一般情况下等于主键索引。但是创建表时没有指定主键索引，会尝试第一个not null的唯一索引，如果还不行，那么就会自动生成隐藏的递增列作为聚簇索引。</li>
<li>二级索引 = 非聚簇索引</li>
<li>聚簇与非聚簇的重要区别：<strong>键的叶子节点是否存储了完整数据</strong>。<ol>
<li>MyISAM的主键叶子节点存储的是数据的地址，并非完整数据，所以仍是非聚簇索引。</li>
<li>InnoDB的主键叶子节点存储的是完整的数据，所以是聚簇索引。</li>
<li>InnoDB的非主键叶子节点存储的是对应的主键值，所以是非聚簇索引。</li>
</ol>
</li>
<li>聚簇索引优点：<ol>
<li>查询速度快：相较于非聚簇索引少一次回表查询。</li>
<li>适合排序查找和范围查找：叶子节点由二叉树连接。</li>
</ol>
</li>
<li>聚簇索引缺点：<ol>
<li>依赖于有序的数据：插入时需要数据是有序的。如果键是字符串这种难比较的键，插入与查找速度慢。</li>
<li>更新代价大：主键修改会涉及到树结构的变动，因此一般设置为主键不可修改。</li>
</ol>
</li>
</ol>
</li>
<li><p>按字段特性分类：</p>
<ol>
<li>主键索引：一张表最多只有一个，索引列的值不允许有空值</li>
<li>唯一索引：一张表可以有多个，索引列的值必须唯一，<strong>允许有空值</strong></li>
<li>普通索引</li>
<li>前缀索引：对字符类型字段的前几个字符建立索引，可以建立在字段类型为char、varchar、binary、varbinary的列上</li>
</ol>
</li>
<li><p>按字段个数分类；</p>
<ol>
<li>单列索引</li>
<li>联合索引：建立在多列上的索引。B+Tree先按照其中一列进行排序，相同时再按另一列排序。存在最左匹配原则，即按照最左优先的方式进行索引的匹配（以(a, b)建立联合索引，不能只查找where b = x）。<ol>
<li>如 select * from table where a &gt; 1 and b = 2。联合索引先按照a字段的值排序，所以搜索时可以定位到符合a &gt; 1的第一条记录，然后会沿链表向后扫描直到结束，但是在符合a &gt; 1的记录中b是无序的，所以只能逐条判断b = 2是否成立。因此，这条语句只有a字段使用了联合索引进行索引查询，而b字段没用到。</li>
<li>如果改成a &gt;= 1，则当a = 1时可以通过b = 2条件减少二级索引范围，当a &gt; 1时再逐条扫描所以这条语句a和b字段都用到了联合索引。</li>
<li>如果改成name like ‘j%’，则当name = j时可以通过b = 2条件检索二级索引范围，当name更长时则需要逐条扫描，所以name和b都用到了联合索引。</li>
<li>索引下推优化：可以在联合索引遍历过程中，先对联合索引包含的字段做判断，直接过滤掉不满足条件的记录，减少回表次数。</li>
<li>索引区分度：某个字段不同值的个数除以表的总行数。<ol>
<li>建立联合索引时，越靠前的字段被用于索引过滤的概率越高。如果索引区分度小且字段分布均匀，那么无论搜索哪个值都不能去掉很多数据。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>索引的适用场合：</p>
<ol>
<li>索引需要有的特点：<ol>
<li>一般不能随便更新，因为更新代价很高。</li>
<li>能唯一标识一个记录。</li>
</ol>
</li>
<li>需要：<ol>
<li>字段唯一性限制、非空：身份证</li>
<li>频繁查询、条件查询：where</li>
<li>频繁排序：order、group</li>
<li>频繁连接：join</li>
</ol>
</li>
<li>不需要：<ol>
<li>上面关键字用不到的字段</li>
<li>字段中存在大量重复数据</li>
<li>表数据太少</li>
<li>经常更新的字段：余额</li>
</ol>
</li>
</ol>
</li>
<li><p>优化方法</p>
<ol>
<li><p>前缀索引优化：使用某个字段中字符串的前几个字符建立索引，从而减小索引字段大小。</p>
<ol>
<li>order by无法使用前缀索引</li>
<li>无法把前缀索引用作覆盖索引</li>
</ol>
</li>
<li><p>覆盖索引优化：将经常查询的关联字段建立联合索引，使得索引中存在这些数据，从而避免回表</p>
</li>
<li><p>主键索引最好是自增的（每次插入的都比当前最大值大）：插入新记录时都是追加操作，不需要重新移动数据；主键长度不要太大，因为二级索引存储的数据是主键值，主键长度小意味着二级索引的B+Tree耗费空间少。</p>
</li>
<li><p>索引最好设置为NOT NULL：</p>
<ol>
<li>索引列存在NULL使优化器做索引选择时更复杂</li>
<li>NULL无意义但会占用物理空间</li>
</ol>
</li>
<li><p>防止索引失效</p>
<ol>
<li>索引失效<ol>
<li>使用左或者左右模糊匹配<ol>
<li>例外：表中没有非索引项，且需要查询的键只包含主键与条件所在的键。由于二级索引树包含所需要查询的全部信息，并且二级索引树记录的东西比聚簇索引树少很多，所以全扫描二级索引树耗费的成本远小于全扫描聚簇索引树，优化器会选择全扫描二级索引树查询数据。（虽然也是全扫描，但是因为全扫描的是二级索引树，所以也算作索引没有失效？）</li>
</ol>
</li>
<li>对索引列做了计算、函数、类型转换等操作(如果操作是用在输入参数上，则仍可以用索引扫描)<ol>
<li>如，字符串转int，’10000’、’010000’、’10000e’都会转换成10000，这种情况下判断索引失效。</li>
</ol>
</li>
<li>联合索引没有遵循最左匹配原则</li>
<li>WHERE子句中在OR前的条件列是索引列，而OR后不是</li>
</ol>
</li>
<li>尽量避免全表扫描和全索引扫描</li>
<li>extra字段<ol>
<li>Using filesort：查询语句中包含group by而且无法利用索引完成排序，不得不选择算法排序。</li>
<li>Using temporary：使用临时表保存中间结果，常见于order by与group by</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="3-count-函数"><a href="#3-count-函数" class="headerlink" title="3. count()函数"></a>3. count()函数</h2><ol>
<li>性能排序: count(*) = count(1) &gt; count(主键字段) &gt; count(字段)</li>
<li>count(1)：循环遍历索引（表中有二级索引则遍历二级索引，否则聚簇索引），将读到的记录返回给server层但不读取记录中任何字段的值（1不是任何字段），server层每读到一条记录count+1。</li>
<li>count(*)：等于count(0)，实际上与count(1)一样。</li>
<li>count(主键字段)：如果表里只有主键索引而没有二级索引，InnoDB循环遍历主键索引，将读取到的记录返回给server层并读取主键值，判断是否为NULL，不为NULL则count+1；如果存在二级索引，则会改为遍历二级索引表（遍历成本较聚簇索引低）。</li>
<li>count(字段)：全表扫描，执行效率差。</li>
<li>MyISAM引擎执行count只需要常数时间复杂度，因为每张数据表都有信息记录row_count值；但InnoDB支持事务，多版本并发控制，所以无法只维护一个变量查询。</li>
<li>优化：<ol>
<li>explain关键字，并不会真正查询而是估算</li>
<li>额外维护计数表</li>
</ol>
</li>
</ol>
<h2 id="4-键"><a href="#4-键" class="headerlink" title="4. 键"></a>4. 键</h2><p>超键：在关系中能唯一标识元组的属性集</p>
<p>候选键：不含有多余属性的超键（若从候选键中删除任意属性，就不再能唯一标识）</p>
<p>主键：用户选作元组标识的其中一个候选键。</p>
<p>外键：关系模式中某个属性是其他关系模式的主键，则称为本模式的外键。</p>
<h2 id="5-聚集索引与非聚集索引"><a href="#5-聚集索引与非聚集索引" class="headerlink" title="5. 聚集索引与非聚集索引"></a>5. 聚集索引与非聚集索引</h2><p>聚集索引/聚簇索引：存放的逻辑顺序和列中的顺序一样。一般设置主键索引为聚集索引。</p>
<p>一个表只能有一个主键与聚集索引，因为主键的作用就是将表的数据格式转换为索引的格式放置。</p>
<p>每次数据改变时，必须重新梳理树的结构以维持其正确性，带来不少的性能开销，所以会为查询以外的操作带来副作用。</p>
<p>非聚集索引/常规索引：即为二级索引。每个非聚集索引互相之间不存在关联。</p>
<p>区别：主键索引与二级索引的区别。</p>
<ul>
<li>非聚集索引查询一般需要回表，即第一次按照非聚集索引查询到对应的聚集索引，第二次根据聚集索引去聚集索引树种查询。</li>
<li>聚集索引一张表只能有一个，非聚集索引可以多个。</li>
</ul>
<h2 id="6-索引与主键"><a href="#6-索引与主键" class="headerlink" title="6. 索引与主键"></a>6. 索引与主键</h2><p>区别：</p>
<ol>
<li>主键用于唯一标识每一行，索引用于快速查找特定值的记录。</li>
<li>一个表只能有一个主键，但可以有多个候选索引。</li>
<li>主键列不允许空值，索引允许。</li>
<li>主键是逻辑键，索引是物理键。</li>
</ol>
<h2 id="7-AUTO-INCREMENT"><a href="#7-AUTO-INCREMENT" class="headerlink" title="7. AUTO_INCREMENT"></a>7. AUTO_INCREMENT</h2><p>字段被定义为自增键，表现如下：</p>
<ul>
<li>插入数据时id字段指定为0、null或未指定值，则将该表当前的自增值填到自增字段。</li>
<li>插入数据时id字段指定了具体值，则直接使用。如果指定值大于当前自增值，会将自增值修改为指定值的下一个值。</li>
</ul>
<p>自增值不连续的场景：</p>
<ul>
<li>自增初始值和步长不设置为1：分布式库为了避免主键冲突，一般让一个库自增id奇数，另一个库偶数，导致步长不为1。</li>
<li>自增键出现唯一键冲突，导致插入失败，但是自增值仍然会增加。</li>
<li>事务回滚，自增值不会随之回滚。</li>
<li>批量插入（insert … select）会批量分配自增值，但是这些值并不一定全部用到。</li>
</ul>
<h2 id="8-外键"><a href="#8-外键" class="headerlink" title="8. 外键"></a>8. 外键</h2><p>优点：</p>
<ul>
<li>能保证数据库一致性和完整性。</li>
<li>级联更新方便（更新主键会触发对应的外键更新）</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了复杂性：每次删改都要考虑外键约束。</li>
<li>对分库分表不友好：分库分表时外键无法生效。即对分布式支持不行。</li>
</ul>
<h2 id="9-快照读与锁定读"><a href="#9-快照读与锁定读" class="headerlink" title="9. 快照读与锁定读"></a>9. 快照读与锁定读</h2><p>事务篇与锁篇，一个解决快照读，一个解决锁定读。</p>
<p>快照读（一致性非锁定读）：单纯的SELECT语句，没有 <code>for update</code>、<code>lock in share mode</code>这些关键字。</p>
<ul>
<li>只有在读提交、可重复读隔离级别下，InnoDB才会使用快照读。</li>
<li>适用于对数据一致性要求不是特别高，且追求极致性能的业务场景。</li>
</ul>
<p>当前读（一致性锁定读）：给行记录加X锁或S锁。上面提到的两个例外、增删改语句都是。</p>
<h2 id="10-子查询"><a href="#10-子查询" class="headerlink" title="10. 子查询"></a>10. 子查询</h2><p>尽量转化为join操作。</p>
<p>性能差：结果集是临时表，无法使用索引；产生大量临时表，消耗过多的CPU和IO资源，产生大量的慢查询。</p>
<h1 id="3-事务篇"><a href="#3-事务篇" class="headerlink" title="3. 事务篇"></a>3. 事务篇</h1><p>一个事务是一个原子操作，要么事务中的操作全部执行成功，要么全部执行失败，不允许出现中间状态的数据。</p>
<h2 id="1-★-ACID"><a href="#1-★-ACID" class="headerlink" title="1. ★ ACID"></a>1. ★ ACID</h2><p>一致性是最终目的，原子性、隔离性、持久性都是为了保证一致性。</p>
<ol>
<li>Atomic原子性：一个事务中的所有操作要么全部完成，要么全部不完成。如果事务在执行过程中发生错误，会回滚到事务开始前的状态。通过undo log（回滚日志）来保证。</li>
<li>Consistency一致性：事务在操作前后，数据满足完整性约束，数据库保持一致性状态。通过持久性+原子性+隔离性来保证。</li>
<li>Isolation隔离性：防止多个事务并发执行时由于交叉执行导致数据不一致。通过MVCC（多版本并发控制）或锁机制来保证。</li>
<li>Durability持久性：事务处理结束后，对数据的修改是永久的。通过redo log（重做日志）保证。</li>
</ol>
<h2 id="2-★-并行事务引发的问题"><a href="#2-★-并行事务引发的问题" class="headerlink" title="2. ★ 并行事务引发的问题"></a>2. ★ 并行事务引发的问题</h2><ol>
<li>脏读：一个事务读到了另一个未提交事务修改过的数据，此时如果另一个事务触发回滚，那就读到了过期的数据。</li>
<li>不可重复读：在一个事务内多次读取同一数据，前后两次读到的数据不一样，即多次读取中有其他事务更新了该条数据。</li>
<li>幻读：在一个事务内多次查询某个符合查询条件的记录数量，出现前后两次查询到的记录数量不一样，即在多次查询中有其他事务增删了符合条件的记录。</li>
<li>严重性：脏读 &gt; 不可重复读 &gt; 幻读</li>
</ol>
<h2 id="3-★-隔离级别"><a href="#3-★-隔离级别" class="headerlink" title="3. ★ 隔离级别"></a>3. ★ 隔离级别</h2><p>隔离级别越高，性能效率越低</p>
<ol>
<li>读未提交：一个事务还没提交时，它的变更就能被其他事务看到。不能防止任何问题。</li>
<li>读提交：一个事务提交后，它的变更才能被其他事务看到。能防止脏读。通过在每个语句执行前生成一个Read View实现。</li>
<li>可重复读：一个事务执行过程中看到的数据，跟这个事务启动时看到的数据一致。MySQL InnoDB引擎的默认隔离级别。能防止脏读、不可重复读。通过在启动事务时生成一个Read View实现。</li>
<li>串行化：对记录加上读写锁，多个记录如果对同一条记录发生了读写冲突，后访问的事务必须等待前一个事务执行完成，才能继续操作。能防止三个问题。</li>
</ol>
<p>MYSQL InnoDB默认选择可重复读级别的原因：很大程度上避免了幻读，但并没有完全解决，为了避免性能受太大影响选择可重复读级别。</p>
<ol>
<li>快照读（普通select语句，只需要读取Read View处）：通过MVCC方式解决幻读。事务执行过程中看到的数据跟启动时一致，即使中途有其他事务插入了数据也查询不到。</li>
<li>当前读（select … for update、增删改等语句，需要读取到当前记录最新值）：通过临键锁（记录锁+间隙锁）解决幻读。执行时会上查询范围内的next-key lock，其他事务在锁范围内插入记录时，插入语句会被阻塞。</li>
<li><strong>幻读仍可能发生</strong>：<ol>
<li>其他事务插入并提交记录后，尽管当前事务<strong>看不到该条记录，但是仍然update该条记录</strong>，这样trx_id就会变成当前事务，当前事务也能利用Read View查询到该条记录。</li>
<li>执行快照读select后插入记录，然后执行当前读select for update。</li>
<li>为了避免特殊情况，应该在<strong>事务开启之后马上执行当前读语句</strong>，开启锁。</li>
</ol>
</li>
</ol>
<h2 id="4-隔离级别的实现机制"><a href="#4-隔离级别的实现机制" class="headerlink" title="4. 隔离级别的实现机制"></a>4. 隔离级别的实现机制</h2><ol>
<li>串行化：加读写锁</li>
<li>可重复读：启动事务时生成一个Read View（快照）。</li>
<li>读提交：每个语句执行前生成一个Read View。</li>
</ol>
<h2 id="5-开启事务命令"><a href="#5-开启事务命令" class="headerlink" title="5. 开启事务命令"></a>5. 开启事务命令</h2><ol>
<li>begin/start transaction：在执行该命令后执行增删改查的SQL语句时才真正启动事务。</li>
<li>start transaction with consistent snapshot：立即启动事务。</li>
</ol>
<h2 id="6-Read-View"><a href="#6-Read-View" class="headerlink" title="6. Read View"></a>6. Read View</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<ol>
<li>字段结构：<ol>
<li>m_ids：创建Read View时当前数据库中活跃事务（启动但没提交）的事务id列表。</li>
<li>min_trx_id：m_ids的最小值。</li>
<li>max_trx_id：创建Read View时当前数据库中应该给下一个事务的id值，即全局最大事务id值+1.</li>
<li>creator_trx_id：当前事务id。</li>
</ol>
</li>
<li>聚簇索引记录的隐藏列：<ol>
<li>trx_id：<strong>记录改动该记录的事务id</strong>。</li>
<li>roll_pointer：每次对某条记录改动时，会将旧版本记录写入到undo日志中。该指针指向上一个旧版本记录。</li>
</ol>
</li>
<li>一个事务访问记录时，存在以下几种情况：（trx_id不是访问记录的事务id，而是产生这条记录的事务id）<ol>
<li>trx_id &lt; min_trx_id：该版本的记录是在创建Read View前已提交的事务生成，所以该版本记录对当前事务可见。</li>
<li>trx_id &gt;= max_trx_id：该版本的记录是在创建Read View后才启动的事务生成，所以该版本记录对当前事务不可见。</li>
<li>trx_id在之间：<ol>
<li>trx_id在m_ids里：生成该版本记录的活跃事务没有提交，所以不可见。</li>
<li>trx_id不在m_ids里：已被提交，可见。</li>
</ol>
</li>
<li>如果不可见，需要沿着roll_pointer找到最近一条可见的记录。</li>
</ol>
</li>
<li>这种通过版本链控制并发事务访问同一记录的行为就叫MVCC多版本并发控制。</li>
</ol>
<h1 id="4-锁篇"><a href="#4-锁篇" class="headerlink" title="4. 锁篇"></a>4. 锁篇</h1><h2 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1. 全局锁"></a>1. 全局锁</h2><p>flush tables with read lock</p>
<ol>
<li>作用：阻塞其他线程的增删改数据、更改表结构的操作。</li>
<li>应用场景：全库逻辑备份。</li>
<li>缺点：如果数据库过大，备份耗时过长，会造成业务停滞。</li>
<li>改进：可重复读级的隔离级别可以在备份期间对数据操作。</li>
</ol>
<h2 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2. 表级锁"></a>2. 表级锁</h2><p>表锁和行锁满足读读共享、读写互斥、写写互斥。</p>
<h3 id="1-表锁"><a href="#1-表锁" class="headerlink" title="1. 表锁"></a>1. 表锁</h3><p>lock tables t_xxx read/write</p>
<p>作用：除了限制别的线程读写，也会限制本线程读写。会话退出时自动释放所有表锁。</p>
<h3 id="2-元数据锁MDL"><a href="#2-元数据锁MDL" class="headerlink" title="2. 元数据锁MDL"></a>2. 元数据锁MDL</h3><p>对数据库表进行操作时会自动添加，在事务提交后释放。CRUD操作时加MDL读锁，结构变更操作时加MDL写锁。</p>
<p>缺点：申请MDL锁的操作会形成队列，队列中写锁优先级高于读锁，导致一旦出现MDL写锁等待，会阻塞该表后续所有CRUD操作。</p>
<h3 id="3-意向锁"><a href="#3-意向锁" class="headerlink" title="3. 意向锁"></a>3. 意向锁</h3><ol>
<li>作用：快速判断表里是否有记录被加锁。</li>
<li>应用场景：在使用InnoDB引擎的表里对某些记录加共享/独占锁前，需要先在表级别加上意向共享/独占锁。</li>
<li>说明：意向共享/独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁之间发生冲突。由于在对记录加独占锁前会先加上表级别的意向独占锁，那么后续加独占锁时直接查该表是否有意向独占锁，就可以避免遍历表里的记录查看是否存在独占锁。</li>
</ol>
<h3 id="4-自增锁"><a href="#4-自增锁" class="headerlink" title="4. 自增锁"></a>4. 自增锁</h3><ol>
<li>作用：如果不指定主键，在插入数据时自动给主键赋值递增的数。</li>
<li>应用场景：在插入数据时加一个表级别的自增锁，然后为被AUTO_INCREMENT修饰的字段赋值递增的数，等插入语句执行完后释放锁。保证插入数据时不会有其他事务插入，从而使得主键连续递增。</li>
<li>改进：给AUTO_INCREMENT赋值后立刻释放<ol>
<li>问题：搭配binlog的日志格式是statement一起使用时，在主从复制的场景中会发生数据不一致的问题。线程A创建完表后，线程B创建一个相同结构的表，然后A插入新的数据，B则插入A的表中存在的数据。B插入的数据id会不连续。如果主库发生这种情况，同样的语句拿去从库执行，且从库按照顺序执行语句的话，主从库会发生数据不一致。</li>
<li>解决：binlog_format = 2，在binlog里记录的是主库分配的自增值，拿去从库执行时自增值跟主库一样。</li>
</ol>
</li>
</ol>
<h2 id="3-行级锁"><a href="#3-行级锁" class="headerlink" title="3. 行级锁"></a>3. 行级锁</h2><p>必须要有索引才能实现。</p>
<p>MyISAM不支持。</p>
<p>查询时对记录加锁会成为锁定读。</p>
<p>select语句后添加lock in share mode加共享锁（S锁），添加for update加独占锁（X锁），S型锁间可兼容，其他都不兼容。</p>
<h3 id="1-记录锁"><a href="#1-记录锁" class="headerlink" title="1. 记录锁"></a>1. 记录锁</h3><p>锁住一条记录。</p>
<h3 id="2-间隙锁"><a href="#2-间隙锁" class="headerlink" title="2. 间隙锁"></a>2. 间隙锁</h3><p>只存在于可重复读隔离级别（为了解决幻读），是开区间。</p>
<ol>
<li>作用：锁住一个范围内的记录，解决可重复度级别下的幻读现象。</li>
<li>说明：间隙锁的X锁与S锁都是兼容的，因为间隙锁只是为了防止区间被插入。</li>
</ol>
<h3 id="3-临键锁"><a href="#3-临键锁" class="headerlink" title="3. 临键锁"></a>3. 临键锁</h3><p>记录锁+间隙锁，是左开右闭区间。</p>
<p>如果只使用记录锁或间隙锁就能防止幻读，临键锁就会退化成该种锁。</p>
<p><strong>如果用二级索引进行锁定读查询，除了对二级索引加锁之外，还会对查询到的记录的主键索引项加记录锁。</strong></p>
<ol>
<li>作用：锁定一个范围，并且锁定记录本身，其他事务既不能在范围内插入记录，也不能修改范围内的记录。</li>
<li>说明：因为临键锁包含记录锁，所以X锁与S锁、X锁与X锁之间是不兼容的，但是如果区间一端为无穷，则两个事务可以同时持有这个区间的临键锁，因为无穷不是一个真实的记录。</li>
<li>唯一索引等值查询：如果只使用其中一种锁就能避免幻读，临键锁就会退化成该种锁。<ol>
<li>如果查询的记录存在，在索引树上定位到该条记录后，将该记录的索引中的临键锁退化成记录锁。<ol>
<li>如果其他事务插入等值的索引，因为主键冲突导致无法插入。</li>
<li>加了记录锁导致其他事务无法删除该记录。</li>
</ol>
</li>
<li>如果查询的记录不存在，在索引树找到第一条大于该查询条件的记录后，将该记录的索引中的临键锁退化成间隙锁。<ol>
<li>间隙锁的范围为第一条大于该查询条件的记录与该记录的上一条（开区间）。</li>
<li>因为查询的记录不存在，所以不能对不存在的记录加记录锁，但是需要保证下次相同查询的结果仍然是不存在，所以需要加间隙锁防止插入。</li>
</ol>
</li>
</ol>
</li>
<li>唯一索引范围查询：对每一个扫描到的索引加临键锁，范围为第一条大于该查询条件的记录与该记录的上一条（左开右闭）。<ol>
<li>大于等于的范围查询，因为存在等值查询，所以等值查询的记录存在表中时就会退化成记录锁。</li>
<li>小于或小于等于的范围查询<ol>
<li>条件值的记录不在表中时，扫描到终止范围的查询记录（不满足条件的第一条记录）时，该记录的索引退化成间隙锁。</li>
<li>条件值的记录在表中时，如果是小于的范围查询，扫描到终止范围的查询记录（不满足条件的第一条记录）时，该记录的索引退化成间隙锁。</li>
</ol>
</li>
</ol>
</li>
<li>非唯一索引等值查询：同时对两个索引加锁，但是只对满足查询条件的记录的主键索引加锁。<ol>
<li>查询的记录存在时，扫描到第一个不符合条件的二级索引记录。<ol>
<li>在扫描过程中对扫描到的二级索引记录加临键锁。</li>
<li>第一个不符合条件的二级索引记录退化成间隙锁：避免其他事务插入查询条件相同、主键大于当前查询记录的最大主键的记录，根据2.3的判断规则，如果没有这个间隙锁，是可以成功插入的，从而造成幻读。</li>
<li>在符合查询条件的记录的主键索引上加记录锁。</li>
</ol>
</li>
<li>查询的记录不存在时，扫描到第一个不符合条件的二级索引记录。<ol>
<li>该二级索引退化成间隙锁，范围为相邻两条记录组成的条件存在的区间（开区间）。如果没法扫描到第一个不符合条件的记录，即扫描到了表末尾，则不会退化。</li>
<li>不存在满足查询条件的记录，所以不会对主键索引加锁。</li>
<li>当其他事务需要插入记录时，需要考虑插入记录的主键值，以及插入位置的下一条记录是否有间隙锁，从而判断是否插入成功。</li>
</ol>
</li>
<li>由于索引不唯一，所以在边界插入时，要判断两个索引的大小关系，来决定是否能插入。</li>
</ol>
</li>
<li>非唯一索引范围查询：<strong>不会退化</strong></li>
<li>不加索引的查询：<strong>扫描时全表扫描，每一条记录的索引上都会加临键锁，相当于锁住全表</strong>。但是，有时候即使加索引，如果优化器优化成了全表扫描，依然会锁住全表。</li>
</ol>
<h3 id="4-插入意向锁"><a href="#4-插入意向锁" class="headerlink" title="4. 插入意向锁"></a>4. 插入意向锁</h3><ol>
<li>作用：判断插入位置是否被其他事务加了间隙锁，如果有则插入操作被阻塞直到拥有间隙锁的事务提交，在此期间生成插入意向锁，表明有事务想在区间内插入新记录，但是处于等待状态（锁状态为等待，只有锁状态为正常才代表事务成功获取到了锁）。</li>
<li>说明：插入意向锁实际并不是意向锁，而是特殊的行级别间隙锁。</li>
<li>与间隙锁的区别：<ol>
<li>插入意向锁只锁住一个点</li>
<li>不能与其他事务的间隙锁共存</li>
</ol>
</li>
</ol>
<h2 id="4-Insert语句加行级锁过程"><a href="#4-Insert语句加行级锁过程" class="headerlink" title="4. Insert语句加行级锁过程"></a>4. Insert语句加行级锁过程</h2><ol>
<li>正常执行不会生成锁结构，靠聚簇索引记录自带的trx_id隐藏列来作为隐式锁保护记录。</li>
<li>隐式锁：当事务需要加锁时，如果该锁不可能发生冲突，InnoDB会跳过加锁环节。为了减少锁的数量，提高系统整体性能。</li>
<li>隐式锁转换成显式锁场景：<ol>
<li>记录之间加有间隙锁。</li>
<li>Insert的记录和已有记录存在唯一键冲突：插入失败，对该条记录上S锁。<ol>
<li>主键重复：<ol>
<li>隔离级别为可重复度：插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加S型记录锁。</li>
</ol>
</li>
<li>唯一二级索引列重复：<ol>
<li>插入新记录的事务会给已存在的二级索引列重复的二级索引记录添加S型临键锁。</li>
</ol>
</li>
<li>场景：两个事务执行相同的insert语句添加重复的二级索引<ol>
<li>事务A先插入，插入成功，对应的唯一二级索引记录被隐式锁保护，但没有实际的锁结构。</li>
<li>事务B插入同样二级索引的记录，试图获取S型临键锁，但事务A并未提交，且该隐式锁会变为显式锁，类型为X型记录锁，所以事务B获取锁遇到锁冲突，被阻塞。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="5-避免死锁"><a href="#5-避免死锁" class="headerlink" title="5. 避免死锁"></a>5. 避免死锁</h2><p>死锁一般的出现原因：间隙锁相容导致不同事物持有同一范围的间隙锁，然后这些事务同时插入记录至该范围内，导致插入意向锁跟间隙锁冲突。</p>
<p>死锁的必要条件：互斥、占有且等待、不可剥夺、循环等待。</p>
<ol>
<li>设置事务等待超时时间，超过时间回滚。</li>
<li>开启主动死锁检测。</li>
</ol>
<h2 id="6-乐观锁"><a href="#6-乐观锁" class="headerlink" title="6. 乐观锁"></a>6. 乐观锁</h2><p>先进行业务操作，最后实际更新数据时检查数据是否被更新过，如果数据在业务操作期间被更新过则回滚业务操作，否则更新数据。</p>
<p>回滚操作十分耗费资源，只适用于读操作远大于写操作，且写操作竞争不激烈时使用。</p>
<h3 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h3><p>如果待写的内存值等于预期值，则更新为新值，否则不操作。</p>
<p>一般CAS操作会自旋。</p>
<p>CAS是由CPU支持的原子操作，其原子性由硬件层面保证。</p>
<p>缺点1：CAS只通过判断值相等来确认是否发生变化，但是在如栈的结构中，栈顶值相等，但数据可能已经发生变化。</p>
<p>解决：引入版本号，每次值发生变化版本号+1，CAS还需要判断版本号是否相等。</p>
<p>缺点2：高并发时CAS需要一直尝试，CPU开销大。</p>
<p>解决：重试一定次数后失败退出；高并发尽量不用CAS乐观锁。</p>
<p>限制：CAS只能保证单个内存值操作的原子性，而原子性不代表线程安全；多个变量无能为力。</p>
<h1 id="5-日志篇"><a href="#5-日志篇" class="headerlink" title="5. 日志篇"></a>5. 日志篇</h1><h2 id="1-日志类型"><a href="#1-日志类型" class="headerlink" title="1. 日志类型"></a>1. 日志类型</h2><ol>
<li>undo log回滚日志：存储引擎层生成的日志，实现事务中的原子性，主要用于事务回滚和MVCC。</li>
<li>redo log重做日志：存储引擎层生成的日志，实现事务的持久性，主要用于掉电等故障恢复。</li>
<li>binlog归档日志：Server层生成的日志，主要用于数据备份和主从复制。</li>
</ol>
<h2 id="2-Undo-log"><a href="#2-Undo-log" class="headerlink" title="2. Undo log"></a>2. Undo log</h2><ol>
<li><p>作用：</p>
<ol>
<li>回滚：MySQL会在执行每条语句时隐式开启事务，执行完毕自动提交。如果事务在执行过程中提交之前，MySQL崩溃，或者不打算提交了，就可以利用undo log进行回滚。</li>
<li>MVCC</li>
</ol>
</li>
<li><p>记录中的结构：一条记录的每次更新操作产生的undo log格式都有一个roll_pointer指针和trx_id事务id，通过指针将undo log串成版本链。</p>
</li>
<li><p>事务回滚工作方式：</p>
<ol>
<li>插入一条记录时，记录其主键值，回滚时查找主键值对应的记录删除。</li>
<li>删除一条记录时，记录该记录的内容，回滚时将这些内容组成的记录插入。</li>
<li>更新一条记录时，记录被更新的列旧值，回滚时再更新为旧值。</li>
<li>回滚：扫描日志，找出所有已开始但没有提交的事务。针对这些事务，使用undo log回滚。</li>
</ol>
</li>
<li><p>应用：MVCC（ReadView + undo log）：</p>
<ol>
<li>事务通过对比Read View里的字段与trx_id的字段，如果不满足可见行，就顺着undo log的版本链向上找到满足可见性的记录。</li>
</ol>
</li>
</ol>
<h2 id="3-Buffer-Pool"><a href="#3-Buffer-Pool" class="headerlink" title="3. Buffer Pool"></a>3. Buffer Pool</h2><ol>
<li>作用：<ol>
<li>读取数据时如果数据在Buffer Pool中，客户端直接读取其中的数据。</li>
<li>修改数据时如果数据在Buffer Pool中，直接修改Buffer Pool中数据所在的页，然后设置为脏页。</li>
</ol>
</li>
<li>结构：MySQL启动时，InnoDB会为Buffer Pool申请一片连续的内存空间，按照默认16KB大小划分出一个个页，称为缓存页。<ol>
<li>Undo页：开启事务后InnoDB层更新记录前要记录undo log，undo log写入Buffer Pool中的Undo页面。</li>
</ol>
</li>
<li>跟操作系统类似，查询一条记录是将整个页面加载到Buffer Pool中。</li>
</ol>
<h2 id="4-Redo-log"><a href="#4-Redo-log" class="headerlink" title="4. Redo log"></a>4. Redo log</h2><p>Buffer Pool是基于内存的，可能由于断电导致数据丢失问题。</p>
<ol>
<li><p>WAL技术：更新记录时InnoDB引擎先更新内存，然后将对该页的修改以redo log的形式记录下来，更新完毕；后续在适当的时候，后台线程将缓存在Buffer Pool的脏页刷新到磁盘。</p>
</li>
<li><p>实现方式：Redo log记录的是：对X表空间中Y数据页Z偏移量的位置做了A更新。事务提交时只需要先持久化Redo log到磁盘，系统崩溃时因为Redo log已持久化，所以可以根据Redo log的内容恢复数据。</p>
</li>
<li><p>修改Buffer Pool中的Undo页面也会记录对应的Redo log。</p>
</li>
<li><p>redo log也需要先写入redo log buffer中，后续再写到Page Cache、持久化到磁盘。</p>
</li>
<li><p>重做：扫描日志，找出所有已提交的事务。针对这些事务，使用redo log重做。</p>
</li>
<li><p>好处：</p>
<ol>
<li>实现事务的持久性，让MySQL有crash-safe的能力。</li>
<li>将写操作从随机写变成顺序写，效率更高。写入redo log是追加操作，是顺序写；写入数据需要先寻找数据位置，是随机写。</li>
</ol>
</li>
<li><p>刷盘时机：</p>
<ol>
<li><p>MySQL正常关闭。</p>
</li>
<li><p>redo log buffer记录写入量大于该buffer内存空间一半。</p>
</li>
<li><p>每隔1s。后台线程将redo log buffer写入page cache后调用fsync刷盘。</p>
</li>
<li><p>事务提交时。</p>
</li>
<li><p>innodb_flush_log_at_trx_commit</p>
<ol>
<li>0：事务提交时不主动写入磁盘</li>
<li>1：事务提交时直接持久化到磁盘</li>
<li>2：事务提交时写入redo log文件（写入文件系统的Page Cache）</li>
<li>数据安全性：1 &gt; 2 &gt; 0</li>
<li>写入性能：0 &gt; 2 &gt; 1</li>
</ol>
</li>
</ol>
</li>
<li><p>写满：</p>
<ol>
<li>重做日志文件组：由多个redo log文件组成，以循环写的方式工作在多个文件间切换，类似于RingBuffer。write post表示redo log当前记录写到的位置，check point表示当前要擦除的位置。</li>
<li>如果write post追上了check point，代表redo log文件已满，MySQL会被阻塞，停下来将Buffer Log中的脏页刷新到磁盘中，并标记redo log中哪些记录可以被擦除，然后擦除这些记录腾出空间，check point向后移动。</li>
</ol>
</li>
</ol>
<h2 id="5-binlog"><a href="#5-binlog" class="headerlink" title="5. binlog"></a>5. binlog</h2><ol>
<li><p>作用：MySQL完成一条<strong>更新</strong>操作后，Server层生成一条binlog，等之后事务提交，会将该事务执行过程中产生的所有binlog写入binlog文件。binlog文件不会记录查询类的操作。</p>
</li>
<li><p><strong>为什么有binlog还要redo log</strong>：server层和存储引擎层是解耦的。MySQL最初自带的引擎是MyISAM，但是它没有crash-safe能力，binlog只能用来归档。InnoDB作为插件形式引入MySQL，自带redo log实现crash-safe能力。</p>
</li>
<li><p>格式：逻辑日志</p>
<ol>
<li>STATEMENT（默认）：记录逻辑操作，即SQL语句。有动态函数问题（uuid、now），主库执行结果与从库并不一致。</li>
<li>ROW：记录行数据最终被修改成什么样。每行数据变化的结果都会被记录（如果批量update，每一更新的行都会记录一条），导致binlog文件过大。</li>
<li>MIXED：判断语句是否可能引起数据不一致，选用STATEMENT或ROW模式。</li>
</ol>
</li>
<li><p>主从复制：记录MySQL上所有变化并以二进制形式保存在磁盘上（binlog），复制时将binlog中的数据从主库传输到从库。</p>
<ol>
<li><p>异步：主库上执行事务操作的线程不会等待复制binlog的线程同步完成。</p>
</li>
<li><p>过程：</p>
<ol>
<li>主库收到请求，先写入binlog再提交事务，更新存储引擎中的数据，之后返回给客户端操作成功的响应。</li>
<li>从库创建一个专门的I/O线程，连接主库的log dump线程来接收binlog日志，再将binlog信息写入relay log的中继日志里，返回给主库复制成功的响应。</li>
<li>从库创建一个回访binlog的线程，去读relay log中继日志，然后回放binlog更新存储引擎中的数据。</li>
</ol>
</li>
<li><p>复制之后，可以写数据只写主库，读数据只读从库，写数据不影响读请求执行。</p>
</li>
<li><p>模型：</p>
<ol>
<li>同步复制：主库提交事务的线程要等到所有从库的复制成功响应，之后才返回客户端结果。性能差，要等所有从库复制完；可用性差，任何一个从库出问题都会影响业务。</li>
<li>异步复制：不等待就返回结果。一旦主库宕机，数据会发生丢失。</li>
<li>半同步复制：只需要一部分复制成功就返回结果。</li>
</ol>
</li>
</ol>
</li>
<li><p>刷盘：binlog先写到Server层中的binlog cache（每个线程一个），在事务提交时再写到binlog文件中（page cache，之后通过fsync持久化到磁盘）。一个事务的binlog不能被拆开。由sync_binlog控制刷盘时机：</p>
<ol>
<li>0：每次提交事务只write不fsync，持久化交由操作系统决定。</li>
<li>1：每次提交事务都会write然后fsync。</li>
<li>N：累计N个事务后fsync。</li>
</ol>
</li>
</ol>
<h2 id="6-redo-log-amp-binlog"><a href="#6-redo-log-amp-binlog" class="headerlink" title="6. redo log &amp; binlog"></a>6. redo log &amp; binlog</h2><ol>
<li>适用对象：<ol>
<li>binlog：Server层实现，数据库层面，所有存储引擎都能用。</li>
<li>redo log：InnoDB引擎作为存储引擎层实现，事务层面。</li>
</ol>
</li>
<li>文件格式：<ol>
<li>binlog：逻辑日志<ol>
<li>STATEMENT（默认）：记录逻辑操作，即SQL语句。有动态函数问题（uuid、now），主库执行结果与从库并不一致。</li>
<li>ROW：记录行数据最终被修改成什么样。每行数据变化的结果都会被记录（如果批量update，每一更新的行都会记录一条），导致binlog文件过大。</li>
<li>MIXED：根据情况选用STATEMENT与ROW模式</li>
</ol>
</li>
<li>redo log：物理日志<ol>
<li>记录在某个数据页进行了什么修改，即在X表空间中Y数据页Z偏移量的位置做了A更新。</li>
</ol>
</li>
</ol>
</li>
<li>写入方式：<ol>
<li>binlog：追加写，写满了就创建新文件而不会覆盖。</li>
<li>redo log：循环写，会覆盖。</li>
</ol>
</li>
<li>用途：<ol>
<li>binlog：备份恢复、主从复制。</li>
<li>redo log：故障恢复</li>
</ol>
</li>
</ol>
<h2 id="7-小结：update语句的执行过程"><a href="#7-小结：update语句的执行过程" class="headerlink" title="7. 小结：update语句的执行过程"></a>7. 小结：update语句的执行过程</h2><p>UPDATE t_user SET name = ‘xx’ WHERE id = 1</p>
<ol>
<li>cache：执行器调用存储引擎接口，通过主键索引树获取id=1记录<ol>
<li>如果该行所在的数据页在buffer pool中，直接返回给执行器。</li>
<li>否则从磁盘读到buffer pool中再返回记录。</li>
</ol>
</li>
<li>检查更新：执行器得到聚簇索引记录，看更新前后是否一样，一样则不再进行后续更新，否则将更新前后的记录都当作参数传给InnoDB层</li>
<li>undo log：开启事务，InnoDB层更新记录前先记录undo log，写入Buffer Pool中的Undo页面，在内存修改该Undo页面后记录对应的redo log。</li>
<li>redo log：InnoDB层开始更新记录，先更新内存，然后将记录写入redo log里。一条记录更新完毕</li>
<li>binlog：一条更新语句执行完成后，开始记录该语句对应的binlog。</li>
<li>两阶段提交。</li>
</ol>
<h2 id="8-两阶段提交"><a href="#8-两阶段提交" class="headerlink" title="8. 两阶段提交"></a>8. 两阶段提交</h2><ol>
<li>原因：在binlog和redo log刷盘的中间MySQl宕机，造成其中一个刷盘成功而另一个没有，会造成主从架构中主从库数据不一致。</li>
<li>两阶段：准备阶段与提交阶段。</li>
<li>简单概括：redo log准备写，然后确认bin log已提交后自己再提交。</li>
<li>具体过程：使用内部XA事务，由binlog作为协调者，存储引擎作为参与者。<ol>
<li>prepare：将XID（内部XA事务ID）写入到redo log，将redo log对应的事务状态设置为prepare，然后将redo log持久化。</li>
<li>commit：将XID写入binlog，然后将binlog持久化。调用引擎的提交事务接口，将redo log状态设置为commit，该状态不需要持久化到此案，只需要write到文件系统中的page cache。</li>
</ol>
</li>
<li>异常重启情况：MySQL重启后按顺序扫描redo log文件，如果碰到处于prepare状态的redo log，就拿着XID去binlog查看是否存在<ol>
<li>如果binlog中没有，说明redo log完成刷盘但binlog没有，回滚事务。</li>
<li>如果binlog中有，说明两个log都已完成刷盘，提交事务。</li>
</ol>
</li>
<li>redo log可以在事务没提交前持久化到磁盘，但是binlog必须在事务提交后才能持久化到磁盘。</li>
<li>问题：<ol>
<li>磁盘I/O次数高：每个事务提交都会进行两次刷盘(fsync)。<ol>
<li>sync_binlog = 1表示每次提交事务都会将binlog cache持久化到磁盘。</li>
<li>innodb_flush_log_at_trx_commit = 1表示每次提交事务都将redo log buffer持久化到磁盘。</li>
</ol>
</li>
<li>锁竞争激烈：只能保证单事务两个日志内容一致，但不能保证多事务两者提交顺序一致，所以还需要加一个锁保证提交的原子性。</li>
</ol>
</li>
</ol>
<h2 id="9-组提交"><a href="#9-组提交" class="headerlink" title="9. 组提交"></a>9. 组提交</h2><p>多个事务提交时将多个binlog刷盘操作合并成一个。prepare阶段不变，将commit阶段拆分成三个过程。</p>
<ol>
<li>commit：<ol>
<li>flush：多个事务按进入顺序将binlog从cache写入文件。用于支撑redo log的组提交。</li>
<li>sync：对binlog文件fsync。用于支持binlog的组提交。</li>
<li>commit：各个事务按顺序InnoDB commit。</li>
<li>每个阶段都有一个队列，且有锁进行保护。第一个进入队列的事务成为leader，领导所在队列所有事务并负责整队操作，完成后通知队内其他事务操作结束。锁的粒度减小到队列，使得多个阶段可以并发执行。</li>
</ol>
</li>
<li>MySQL5.7及以上有redo log组提交，在prepare阶段不再让事务各自执行redo log刷盘操作，而是推迟到flush阶段之中binlog写入文件前，由leader一次性将同组的redo log刷盘。</li>
</ol>
<h2 id="10-优化MySQL的磁盘I-O"><a href="#10-优化MySQL的磁盘I-O" class="headerlink" title="10. 优化MySQL的磁盘I/O"></a>10. 优化MySQL的磁盘I/O</h2><ol>
<li>组提交两个参数，延迟binlog刷盘时机<ol>
<li>binlog_group_commit_sync_delay = N表示等待Nms后，直接调用fsync将binlog持久化。</li>
<li>binlog_group_commit_sync_no_delay_count=N表示如果队列中事务数达到N，就忽略delay直接刷盘。</li>
</ol>
</li>
<li>sync_binlog=N，表示每次提交事务都write，但累计N个才刷盘，但是主机掉电会丢失N个事务的binlog日志。</li>
<li>innodb_flush_log_at_trx_commit=2，表示每次事务提交都只将redo log buffer中的log写到文件中，同样有主机掉电的风险。</li>
</ol>
<h1 id="6-内存篇"><a href="#6-内存篇" class="headerlink" title="6. 内存篇"></a>6. 内存篇</h1><h2 id="1-Buffer-Pool"><a href="#1-Buffer-Pool" class="headerlink" title="1. Buffer Pool"></a>1. Buffer Pool</h2><ol>
<li>默认配置为128MB，按页划分，每页大小默认16KB。在MySQL启动时，InnoDB会为Buffer Pool申请一片连续的内存空间并划分页，此时这些页都是空闲的，随着程序运行才有磁盘上的页被缓存。所以，MySQL刚启动时使用的虚拟内存很大，但是物理内存却很小，因为只有当这些虚拟内存被访问时，操作系统才会触发缺页中断，将虚拟地址与物理地址建立映射关系。</li>
<li>缓存内容：数据页、索引页、插入缓存页、undo页、自适应哈希索引、锁信息。</li>
<li>Buffer Pool为每一个缓存页创建了一个控制块，信息包括缓存页的表空间、页号、缓存页地址、链表节点等。控制块放在Buffer Pool最前面，之后有一块碎片空间（剩余的空间不足以分配一对控制块和缓存页），然后是缓存页。<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></li>
<li>内存管理：<ol>
<li>空闲页：将空闲缓存页的控制块作为链表节点连接，成为Free链表。Free链表有一个头节点，包含链表的头节点地址、尾节点地址以及链表中节点数量等信息。</li>
<li>脏页：Flush链表。</li>
<li>提高缓存命中率：young-old LRU算法+进入young区域条件判断。</li>
<li>脏页刷新：<ol>
<li>redo log日志满</li>
<li>Buffer Pool空间不足时需要淘汰一部分数据页，如果淘汰到脏页</li>
<li>MySQL认为空闲时后台线程定期将适量脏页刷新</li>
<li>MySQL正常关闭前刷新所有脏页</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="7-查漏补缺"><a href="#7-查漏补缺" class="headerlink" title="7. 查漏补缺"></a>7. 查漏补缺</h1><h2 id="1-分库分表"><a href="#1-分库分表" class="headerlink" title="1. 分库分表"></a>1. 分库分表</h2><p>原因：</p>
<ul>
<li>单库太大：数据库里的表太多，所在服务器磁盘空间装不下，且IO次数多CPU繁忙。</li>
<li>单表太大：一张表字段太多、数据太多。每次需要加载、查询大量数据。</li>
</ul>
<p>场景：</p>
<ul>
<li>单表数据达到千万级，数据库读写速度缓慢。</li>
<li>数据库中的数据占用空间大，备份时间长。</li>
<li>应用并发量大。</li>
</ul>
<p>常用算法：哈希、范围、地理位置、以上混合。</p>
<h3 id="2-主从架构"><a href="#2-主从架构" class="headerlink" title="2. 主从架构"></a>2. 主从架构</h3><p>主库读写，从库只负责读，从库与主库同步更新数据。</p>
<p>问题：</p>
<ul>
<li>写操作拓展困难，因为需要保证多个主库与主从一致性。</li>
<li>复制延时。</li>
<li>表变大，缓存命中率下降，导致查询性能降低。</li>
</ul>
<h3 id="3-分表"><a href="#3-分表" class="headerlink" title="3. 分表"></a>3. 分表</h3><p>垂直分表：拆分字段。一般把不常用的、数据较大、长度较长的字段拆分。</p>
<p>水平分表：按照某一字段值进行分割（哈希等）。这些表还在同一个库中，库级别的数据表操作还是有IO瓶颈，而且随着数据增加还需要再切分，所以不建议使用。</p>
<h3 id="4-分库"><a href="#4-分库" class="headerlink" title="4. 分库"></a>4. 分库</h3><p>垂直分库：垂直分表后，如将不常用的字段拆分表放在单独数据库中。不同数据库放在不同服务器上。</p>
<p>水平分库：将单张表的数据切分到多个服务器上。能有效缓解单机和单库性能瓶颈压力，突破IO、连接数、硬件资源等的瓶颈，但是切分麻烦。</p>
<h3 id="5-分库分表的问题"><a href="#5-分库分表的问题" class="headerlink" title="5. 分库分表的问题"></a>5. 分库分表的问题</h3><ul>
<li>联合查询困难：两个相关联的表可能在不同数据库、服务器中。</li>
<li>需要支持分布式事务。需要自己编程支持，代码麻烦。</li>
<li>跨库join困难：无法join不同分库的表，导致可能需要多次查询、拷贝。</li>
<li>结果合并麻烦。</li>
<li>事务问题。</li>
</ul>

      </div>
      <div class="post-tags-categories">
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>aoba moka</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2022/11/23/学习笔记-MySQL/" target="_blank" title="学习笔记-MySQL">https://aobamoka.github.io/2022/11/23/学习笔记-MySQL/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">



  
  <div class="post-nav-prev post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
    </div>
    <a href="/2022/12/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-labuladong%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/" class="post-nav-link">
      <div class="title">
        <i class="fas fa-angle-left"></i> 上一篇:
        <div class="title-text">学习笔记-labuladong计算机技术</div>
      </div>
      
      <!-- <div class="content">
        1. linux文件系统文件用途
/bin /sbin：存储可执行的二进制文件，如cp、chmod、ifconfig等命
      </div> -->
    </a>
  </div>



  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" src="" alt="">
    </div>
    <a href="/2022/11/10/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">学习笔记-计算机网络</div>
      </div>
      <!-- <div class="content">
        1. 基础篇1. OSI七层模型
物理层：在物理网络中传输数据帧。集线器。
数据链路层：数据的封帧和差错检测。交换机。

      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-container"></div>

    
  </div>

<!-- comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  <aside id='l_side'>
  
    
      <section class="widget side_blogger">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img src='/medias/test.png'/>
        </a>
      
    
    
      <div class='text'>
        
          <h2>摩卡</h2>
        
        
          <p>不太会说话</p>

        
        
          <p><span id="jinrishici-sentence">摩卡's blog</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
  </div>
</section>

    
  
  
  

  <div class="layout_sticky">    
    
      
<section class="widget side_toc">
  
  <header>
    
      <i style="color: " class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name' style="color: ">本文目录</span>
    
  </header>


  <div class='content'>
    <div class="toc-main">
      <div class="toc-content">
        <!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">1. 基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">1. 关系型数据库与非关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">1. 关系型数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93NoSQL"><span class="toc-text">2. 非关系型数据库NoSQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AF%94%E8%BE%83"><span class="toc-text">3. 比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SQL%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">2. SQL数据完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">1. 实体完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%9F%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">2. 域完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%95%E7%94%A8%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">3. 引用完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">4. 用户定义的完整性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-MYSQL%E6%9E%B6%E6%9E%84"><span class="toc-text">3. MYSQL架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">4. 表空间文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A1%8C"><span class="toc-text">1. 行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%B5"><span class="toc-text">2. 页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%BA"><span class="toc-text">3. 区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%AE%B5"><span class="toc-text">4. 段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">5. 行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Compact"><span class="toc-text">1. Compact</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-text">6. 三大范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="toc-text">1. 第一范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="toc-text">2. 第二范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-text">3. 第三范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-BCNF"><span class="toc-text">4. BCNF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-InnoDB%E4%B8%8EMyISAM"><span class="toc-text">7. InnoDB与MyISAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96"><span class="toc-text">8. 数据库结构优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BC%98%E5%8C%96"><span class="toc-text">9. 高并发优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%B8%B8%E6%A0%87%E4%B8%8E%E8%A7%86%E5%9B%BE"><span class="toc-text">10. 游标与视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-LSM%E6%A0%91"><span class="toc-text">11. LSM树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-text">2. 具体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5"><span class="toc-text">3. 插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9B%B4%E6%96%B0"><span class="toc-text">4. 更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4"><span class="toc-text">5. 删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9F%A5%E6%89%BE"><span class="toc-text">6. 查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%90%88%E5%B9%B6"><span class="toc-text">7. 合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-STCS-Size-Tiered-Compaction-Strategy"><span class="toc-text">1. STCS Size-Tiered-Compaction-Strategy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-LCS-Leveled-Compaction-Strategy"><span class="toc-text">2. LCS Leveled-Compaction-Strategy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-MVCC%E5%9C%A8LSM%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">8. MVCC在LSM树的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%B7%B3%E8%A1%A8skiplist"><span class="toc-text">12. 跳表skiplist</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B1%82%E6%95%B0"><span class="toc-text">1. 层数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE"><span class="toc-text">2. 查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5-1"><span class="toc-text">3. 插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4"><span class="toc-text">4. 删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%AF%94%E8%BE%83"><span class="toc-text">5. 比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E7%AF%87"><span class="toc-text">2. 索引篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-InnoDB"><span class="toc-text">1. InnoDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95"><span class="toc-text">2. 索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-count-%E5%87%BD%E6%95%B0"><span class="toc-text">3. count()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%94%AE"><span class="toc-text">4. 键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-text">5. 聚集索引与非聚集索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%B8%BB%E9%94%AE"><span class="toc-text">6. 索引与主键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-AUTO-INCREMENT"><span class="toc-text">7. AUTO_INCREMENT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%A4%96%E9%94%AE"><span class="toc-text">8. 外键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-text">9. 快照读与锁定读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">10. 子查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%AF%87"><span class="toc-text">3. 事务篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E2%98%85-ACID"><span class="toc-text">1. ★ ACID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E2%98%85-%E5%B9%B6%E8%A1%8C%E4%BA%8B%E5%8A%A1%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">2. ★ 并行事务引发的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E2%98%85-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">3. ★ 隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">4. 隔离级别的实现机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E5%91%BD%E4%BB%A4"><span class="toc-text">5. 开启事务命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Read-View"><span class="toc-text">6. Read View</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%94%81%E7%AF%87"><span class="toc-text">4. 锁篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">1. 全局锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-text">2. 表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A1%A8%E9%94%81"><span class="toc-text">1. 表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81MDL"><span class="toc-text">2. 元数据锁MDL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">3. 意向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%87%AA%E5%A2%9E%E9%94%81"><span class="toc-text">4. 自增锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-text">3. 行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%B0%E5%BD%95%E9%94%81"><span class="toc-text">1. 记录锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-text">2. 间隙锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%B4%E9%94%AE%E9%94%81"><span class="toc-text">3. 临键锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">4. 插入意向锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Insert%E8%AF%AD%E5%8F%A5%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-text">4. Insert语句加行级锁过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">5. 避免死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">6. 乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CAS"><span class="toc-text">1. CAS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%97%A5%E5%BF%97%E7%AF%87"><span class="toc-text">5. 日志篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 日志类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Undo-log"><span class="toc-text">2. Undo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Buffer-Pool"><span class="toc-text">3. Buffer Pool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Redo-log"><span class="toc-text">4. Redo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-binlog"><span class="toc-text">5. binlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-redo-log-amp-binlog"><span class="toc-text">6. redo log &amp; binlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%B0%8F%E7%BB%93%EF%BC%9Aupdate%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">7. 小结：update语句的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">8. 两阶段提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%BB%84%E6%8F%90%E4%BA%A4"><span class="toc-text">9. 组提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BC%98%E5%8C%96MySQL%E7%9A%84%E7%A3%81%E7%9B%98I-O"><span class="toc-text">10. 优化MySQL的磁盘I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E7%AF%87"><span class="toc-text">6. 内存篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Buffer-Pool"><span class="toc-text">1. Buffer Pool</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA"><span class="toc-text">7. 查漏补缺</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-text">1. 分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="toc-text">2. 主从架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E8%A1%A8"><span class="toc-text">3. 分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E5%BA%93"><span class="toc-text">4. 分库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">5. 分库分表的问题</span></a></li></ol></li></ol></li></ol> -->
        <div class="toc"></div>
      </div>
    </div>
  </div>
</section>
<!-- 手机端目录按钮 -->
<div id="toc-mobile-btn">
  <i class="fas fa-list-ul" aria-hidden="true"></i>
</div>

      
  <section class="widget side_recent_post">
    
  <header>
    
      <a style="color: " href='/tags/'><i class="fas fa-book fa-fw" aria-hidden="true"></i><span class='name'>最新文章</span></a>
    
  </header>


    <div class='content'>
      
      <!-- hash算法 -->
      
      <div class="aside-list">
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/27/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E8%B7%B3%E8%A1%A8/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic2.zhimg.com/80/v2-e22aaad20d20634f506f57fff0fcbc17_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-e22aaad20d20634f506f57fff0fcbc17_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-27</span>
                
              </div>
              <a class="post-title" href="/2023/03/27/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E8%B7%B3%E8%A1%A8/">项目学习-跳表</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/23/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-1/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-23</span>
                
              </div>
              <a class="post-title" href="/2023/03/23/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab2-1/">项目学习-CMU-15-445-Lab2-1</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/23/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-3/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-5f7cb7e900b9dcf5354c3d4d2c5cc3c2_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-5f7cb7e900b9dcf5354c3d4d2c5cc3c2_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-23</span>
                
              </div>
              <a class="post-title" href="/2023/03/23/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-3/">项目学习-CMU-15-445-Lab1-3</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Raft%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic2.zhimg.com/80/v2-e22aaad20d20634f506f57fff0fcbc17_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-e22aaad20d20634f506f57fff0fcbc17_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-20</span>
                
              </div>
              <a class="post-title" href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-Raft%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/">项目学习-Raft一致性协议</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-2/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-63bbdb5b76b8d349ad35ff4281efbd37_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">03-20</span>
                
              </div>
              <a class="post-title" href="/2023/03/20/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-CMU-15-445-Lab1-2/">项目学习-CMU-15-445-Lab1-2</a>
            </div>
          </div>
        
      </div>
    </div>
  </section>

    
  </div>
</aside>

  <!-- 图片放大 Wrap images with fancybox support -->
  <script src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || 'rgba(66, 185, 133, 0.8)';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          
            <!-- 不蒜子统计 -->
            <!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
      <i class="fas fa-eye" aria-hidden="true"></i>本站总访问量：<span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
      <i class="fas fa-users" aria-hidden="true"></i>本站访客数：<span id="busuanzi_value_site_uv"></span> 人
</span>

          
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark">
  <div class="dark-content">
    <i class="fas fa-moon" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-moon" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    

    <!-- 图片放大 -->
    
      <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    
      <script type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<!-- <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -70,
    // headingsOffset: -($(window).height() * 0.4 - 45),
    headingsOffset: -($(window).height() * 0.4 - 70),
    // positionFixedSelector: '.toc-main',
    // positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    orderedList: true,
    collapseDepth: 20,
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 150) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('side_toc')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  /* .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  } */
</style>
 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 渲染远程json加载的图片标签(getPhotoOnline)里的内容 -->
<script>
  function loadPhotoOnlineJS() {
    if ($(".post-detail").find(".getJsonPhoto-api").length == 0) {
      return;
    } 
    loadScript('/js/getPhotoOnline/index.js');
  };
  $(function () {
    loadPhotoOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getPhotoJson == "undefined") {
      loadPhotoOnlineJS();
    }
  })
</script>

<!-- 渲染远程json加载的site-card标签(getSiteOnline)里的内容 -->
<script>
  function loadSiteOnlineJS() {
    if ($(".post-detail").find(".getJsonSite-api").length == 0) {
      return;
    } 
    loadScript('/js/getSiteOnline/index.js');
  };
  $(function () {
    loadSiteOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getSiteJson == "undefined") {
      loadSiteOnlineJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
    <script type="text/javascript">
  var utteranceCommon = {};

  function check_utterance() {
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    if (isDark) {
      utteranceCommon.Theme = 'github-dark';
    } else {
      utteranceCommon.Theme = 'github-light';
    }

    return document.getElementById("gitment-container");
  }
  comment_el = '#gitment-container';
  load_utterance = function () {
    if ($(comment_el).length) {
      // 匿名函数，防止污染全局变量
      const HEAD = check_utterance();

      var utterances = document.createElement('script');
      utterances.type = 'text/javascript';
      utterances.async = true;
      utterances.setAttribute('issue-term', 'pathname')
      utterances.setAttribute('theme', utteranceCommon.Theme)
      utterances.setAttribute('repo', '')
      utterances.crossorigin = 'anonymous';
      utterances.src = 'https://utteranc.es/client.js';
      // content 是要插入评论的地方
      document.getElementById('gitment-container').appendChild(utterances);

    }
  }

  function dark_utterance() {
    const HEAD = check_utterance();
    if (!HEAD) return;
    const message = {
      type: 'set-theme',
      theme: utteranceCommon.Theme
    };
    const utteranceIframe = document.querySelector('iframe');
    utteranceIframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }

  $(document).ready(load_utterance);
  document.addEventListener('pjax:complete', function () {
    load_utterance();
  });

  $('.dark').click(function () {
    setTimeout(() => {
      dark_utterance();
    });
  })

</script>

<style>
  .utterances {
    max-width: inherit !important;
  }
</style>
  


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


<!-- 轮播图标签 -->
<script>
  var bambooSwiperTag = {};
  function load_swiper() {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    loadCSS("https://unpkg.com/swiper@6/swiper-bundle.min.css")
    loadScript("https://unpkg.com/swiper@6/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    bambooSwiperTag.swiper = new Swiper('.post-swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      autoplay: true ? {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false,
      } : false,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
      on:{
        init: function(){
          swiperAnimateCache(this); //隐藏动画元素 
          swiperAnimate(this); //初始化完成开始动画
        }, 
        slideChangeTransitionEnd: function(){ 
          swiperAnimate(this); //每个slide切换结束时也运行当前slide动画
          //this.slides.eq(this.activeIndex).find('.ani').removeClass('ani'); 动画只展现一次，去除ani类名
        } 
      }
    });
  }

  document.addEventListener('pjax:complete', function () {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    if (typeof bambooSwiperTag.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>
    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  </body>
</html>