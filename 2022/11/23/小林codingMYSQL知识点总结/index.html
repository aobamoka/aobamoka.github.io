<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="referrer" content="no-referrer">
    <meta name="theme-color" content="#333333">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="google" content="notranslate">
    <meta name="format-detection" content="telephone=no">
    <meta name="keyword"  content="">
    <meta name="description" content="">
    <title>小林codingMYSQL知识点总结 - 青叶摩卡的博客</title>
    <base href="/">
    <link rel="preconnect" href="//cdn.bootcss.com">
    <link rel="manifest" href="/manifest.json">
    <link rel="shortcut icon" href="/icons/icon-72x72.png">
    <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/atom-one-light.min.css" rel="stylesheet">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.10/styles/atom-one-dark.min.css" rel="stylesheet" media="screen and (prefers-color-scheme: dark)">
    <!-- UIkit CSS -->
    <link href="https://cdn.bootcss.com/uikit/3.2.0/css/uikit.min.css" rel="stylesheet">
    <!-- UIkit JS -->
    <script src="https://cdn.bootcss.com/uikit/3.2.0/js/uikit.min.js" async></script>
    <script src="https://cdn.bootcss.com/uikit/3.2.0/js/uikit-icons.min.js" async></script>
    
<link rel="stylesheet" href="/styles/cold-stone.css">

    <noscript>
      <p class="text-center">你的浏览器还没开启 Javascript 功能！</p>
    </noscript>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="aobamoka" type="application/atom+xml">
</head>

  <body>
    

    <header class="header" uk-sticky="top: 100; animation: uk-animation-slide-top; bottom: #sticky-on-scroll-up">
  <nav class="wrapper header-content">
    <div class="nav-overlay uk-navbar-left">
      <h1 class="title nav-list-item uk-logo" data-link="/">
        
        <a href="/" data-link="/">aobamoka</a>
        
      </h1>

      <ul class="nav-list">
        
        <li class="nav-list-item" data-link="/categories/">
          <a class="nav-list-link" href="/categories">CATEGORIES</a>
        </li>
        
        
        <li class="nav-list-item" data-link="/about/">
          <a class="nav-list-link" href="/about/">ABOUT</a>
        </li>
        
        <li class="nav-list-item" data-link="/rss/">
          <a class="nav-list-link" href="/atom.xml">RSS</a>
        </li>
        
      </ul>
    </div>

    
      <div class="uk-navbar-right translate-x">
        <a class="uk-navbar-toggle" href="#modal-full" uk-search-icon uk-toggle></a>
      </div>
    
  </nav>
</header>

<div id="modal-full" class="uk-modal-full uk-modal" uk-modal>
  <div class="uk-modal-dialog uk-flex uk-flex-center uk-flex-middle" uk-height-viewport>
    <button class="uk-modal-close-full" type="button" uk-close></button>
    <form class="uk-search uk-search-large search-form" action="//google.com/search" method="get" accept-charset="UTF-8"
      target="_blank">
      <input class="uk-search-input search-form-input" type="search" name="q" placeholder="Search"
        autofocus autocomplete="false">
      <input type="hidden" name="sitesearch" value="http://example.com">
    </form>
  </div>
</div>


    <main class="main wrapper"><article class="article slide-in-right uk-article">
  <section class="article-header">
    <h1 class="article-title uk-article-title">
      小林codingMYSQL知识点总结
    </h1>
    <p class="article-meta uk-article-meta">
      <span class="meta-info">
        <span>
          Last Update&#58;<time class="post-time"
            datetime="2022-11-26">2022-11-26</time>
        </span>
        <span>Reading Time&#58; 21 min</span>
        <span class="hide" id="busuanzi_container_page_pv">Readed&#58; <span
            id="busuanzi_value_page_pv"></span></span>
      </span>
    </p>
  </section>
  <section class="article-content"><h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p>大三上的数据库课，而且讲的很浅，感觉没记下些啥，可能很基础的也会记上来。。。</p>
<h2 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h2><ol>
<li>MYSQL架构分为Server层和存储引擎层。存储引擎层只负责数据的存储和提取，其他所有功能都在Server层。InnoDB是MYSQL默认的存储引擎。</li>
<li>MYSQL基于TCP传输。</li>
<li>执行流程：<ol>
<li>连接器：通过TCP握手连接MYSQL服务。</li>
<li>查询缓存：查询Server层的k-v缓存（SQL查询语句-查询结果）。由于命中率很低且每更新数据库就需要清空，从MYSQL 8.0开始不用这个阶段。</li>
<li>解析SQL：解析器进行词法分析和语法分析<ol>
<li>词法分析：识别关键词，构建SQL语法树。</li>
<li>语法分析：根据语法规则判断输入的SQL语句是否符合语法。</li>
</ol>
</li>
<li>执行SQL：<ol>
<li>预处理阶段：预处理器检查SQL查询语句中的表或字段是否存在；将select *中的*展开为表上所有列。</li>
<li>优化阶段：优化器将SQL查询语句的执行方案确定下来。比如再表里有多个索引时，优化器基于查询成本决定选择哪个索引。</li>
<li>执行阶段：执行器和存储引擎交互（以记录为单位）<ol>
<li>主键索引查询：id = 1：查询条件用到了主键索引，而且是等值查询，同时主键id唯一。执行器将条件交给存储殷勤，让存储引擎查询记录，存储引擎将结果发回给执行器，执行器判断记录是否符合查询条件，如果符合发送给客户端，否则跳过，直到找不到或者返回-1表示已查询完。</li>
<li>全表扫描：name = ‘xxx’：优化器选择访问类型为all。存储引擎从表中第一条记录读起，执行器判断是否符合条件，如果是则发给客户，否则跳过，直到存储引擎把表中所有记录读完并返回读取完毕。</li>
<li>索引下推：age &gt; 20 and reward = 100000，且对age和reward建立了联合索引：执行器调用接口定位到满足查询条件的第一条二级索引记录(age &gt; 20)；存储器在定位到二级索引后先不执行回表操作，而是先判断reward列条件是否成立，如果不成立直接跳过该索引，成立则回表；执行器再判断其他条件是否成立并决定发给客户端，然后继续向存储引擎索要下一条记录。即将部分条件交给存储引擎直接判断。</li>
</ol>
</li>
</ol>
</li>
<li>总体流程：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="MYSQL执行流程"></li>
</ol>
</li>
</ol>
<h2 id="2-索引篇"><a href="#2-索引篇" class="headerlink" title="2. 索引篇"></a>2. 索引篇</h2><ol>
<li><p>InnoDB：</p>
<ol>
<li><p>创建表的索引选择(聚簇索引)：只能有一</p>
<ol>
<li>如果有主键，默认用主键作为聚簇索引的索引键</li>
<li>如果没有主键，选择第一个不包含NULL值的唯一列作为聚簇索引的索引键</li>
<li>如果都没有，InnoDB自动生成一个隐式自增id列作为聚簇索引的索引键</li>
</ol>
</li>
<li><p>创建的主键索引和二级索引默认使用B+Tree索引</p>
<ol>
<li>B+Tree是一种多叉树，叶子节点存放数据，非叶子节点存放索引，每个节点里的数据按主键顺序存放，每个叶子节点都指向下一个叶子节点，形成一个链表。</li>
<li>二级索引：二级索引的叶子节点中存放的是主键，所以在二级索引查询到后主键值后，还需要根据主键去主键索引的B+Tree再查询一次，称为“回表”；如果查询的数据就在二级索引的叶子节点中（比如主键），就不用再查，称为“覆盖索引”。</li>
<li>B+Tree的优势<ol>
<li>B Tree：B树叶子节点也会存储数据，所以数据量相同的情况下，B+Tree能存放更多索引，导致比B树更“矮胖”，磁盘I/O次数更少；B+ Tree的叶子节点使用了双链表连接，适合范围查询。</li>
<li>二叉树：二叉树每个节点的子节点只能是两个，因此平均检索次数比B+ Tree更多。</li>
<li>Hash：哈希表不适合做范围查询</li>
<li>此外，B Tree与二叉树在增删节点时变形麻烦。</li>
</ol>
</li>
</ol>
</li>
<li><p>数据存储形式</p>
<ol>
<li>数据按照数据页为单位进行读写，默认大小16KB。由文件头、页头、最大最小记录、用户记录、空闲空间、页目录、文件尾七个部分组成。<ol>
<li>File Header文件头中有两个指针分别指向上一页与下一页</li>
<li>页中记录按照主键顺序组成单向链表，为提高检索效率，将所有数据分组（每组记录数有限制），每个组中最后一条记录为组内最大记录，在该记录的头信息中存储该组记录数，页目录存储每组组内最大记录的地址偏移量，称为槽。通过槽查找记录时可以使用二分法。</li>
</ol>
</li>
<li>InnoDB里的B+ Tree每个节点都是一个数据页</li>
</ol>
</li>
</ol>
</li>
<li><p>索引</p>
<ol>
<li><p>索引分类</p>
<ol>
<li><p>按数据结构分类：</p>
<ol>
<li>B+Tree索引</li>
<li>HASH索引</li>
<li>Full-Text索引：通过关键字匹配的方式进行全文过滤<ol>
<li>想对词语进行全文索引，它的长度必须满足在一个区间内（配置文件指定）。</li>
<li>自然语言的全文索引：计算每一个文档对象和查询的相关度，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索。为了避免搜索语气词、助词这些没有意义的词。</li>
<li>在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性。</li>
<li>比like%快，但是精度比它低。</li>
</ol>
</li>
</ol>
</li>
<li><p>按物理存储分类：</p>
<ol>
<li>主键索引</li>
<li>二级索引</li>
</ol>
</li>
<li><p>按字段特性分类：</p>
<ol>
<li>主键索引：一张表最多只有一个，索引列的值不允许有空值</li>
<li>唯一索引：一张表可以有多个，索引列的值必须唯一，允许有空值</li>
<li>普通索引</li>
<li>前缀索引：对字符类型字段的前几个字符建立索引，可以建立在字段类型为char、varchar、binary、varbinary的列上</li>
</ol>
</li>
<li><p>按字段个数分类；</p>
<ol>
<li>单列索引</li>
<li>联合索引：建立在多列上的索引。B+Tree先按照其中一列进行排序，相同时再按另一列排序。存在最左匹配原则，即按照最左优先的方式进行索引的匹配（以(a, b)建立联合索引，不能只查找where b = x）。<ol>
<li>如 select * from table where a &gt; 1 and b = 2。联合索引先按照a字段的值排序，所以搜索时可以定位到符合a &gt; 1的第一条记录，然后会沿链表向后扫描直到结束，但是在符合a &gt; 1的记录中b是无序的，所以只能逐条判断b = 2是否成立。因此，这条语句只有a字段使用了联合索引进行索引查询，而b字段没用到。</li>
<li>如果改成a &gt;= 1，则当a = 1时可以通过b = 2条件减少二级索引范围，当a &gt; 1时再逐条扫描所以这条语句a和b字段都用到了联合索引。</li>
<li>如果改成name like ‘j%’，则当name = j时可以通过b = 2条件检索二级索引范围，当name更长时则需要逐条扫描，所以name和b都用到了联合索引。</li>
<li>索引下推优化：可以在联合索引遍历过程中，先对联合索引包含的字段做判断，直接过滤掉不满足条件的记录，减少回表次数。</li>
<li>索引区分度：某个字段不同值的个数除以表的总行数。<ol>
<li>建立联合索引时，越靠前的字段被用于索引过滤的概率越高。如果索引区分度小且字段分布均匀，那么无论搜索哪个值都不能去掉很多数据。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>索引的适用场合：</p>
<ol>
<li>需要：<ol>
<li>字段唯一性限制：身份证</li>
<li>经常用于WHERE</li>
<li>经常用于GROUP BY和ORDER BY：无须再做一次排序</li>
</ol>
</li>
<li>不需要：<ol>
<li>上面三个关键字用不到的字段</li>
<li>字段中存在大量重复数据</li>
<li>表数据太少</li>
<li>经常更新的字段：余额</li>
</ol>
</li>
</ol>
</li>
<li><p>优化方法</p>
<ol>
<li>前缀索引优化：使用某个字段中字符串的前几个字符建立索引，从而减小索引字段大小。<ol>
<li>order by无法使用前缀索引</li>
<li>无法把前缀索引用作覆盖索引</li>
</ol>
</li>
<li>覆盖索引优化：将经常查询的关联字段建立联合索引，使得索引中存在这些数据，从而避免回表</li>
<li>主键索引最好是自增的（每次插入的都比当前最大值大）：插入新记录时都是追加操作，不需要重新移动数据；主键长度不要太大，因为二级索引存储的数据是主键值，主键长度小意味着二级索引的B+Tree耗费空间少。</li>
<li>索引最好设置为NOT NULL：<ol>
<li>索引列存在NULL使优化器做索引选择时更复杂</li>
<li>NULL无意义但会占用物理空间</li>
</ol>
</li>
<li>防止索引失效<ol>
<li>索引失效<ol>
<li>使用左或者左右模糊匹配<ol>
<li>例外：表中没有非索引项，且需要查询的键只包含主键与条件所在的键。由于二级索引树包含所需要查询的全部信息，并且二级索引树记录的东西比聚簇索引树少很多，所以全扫描二级索引树耗费的成本远小于全扫描聚簇索引树，优化器会选择全扫描二级索引树查询数据。（虽然也是全扫描，但是因为全扫描的是二级索引树，所以也算作索引没有失效？）</li>
</ol>
</li>
<li>对索引列做了计算、函数、类型转换等操作(如果操作是用在输入参数上，则仍可以用索引扫描)</li>
<li>联合索引没有遵循最左匹配原则</li>
<li>WHERE子句中在OR前的条件列是索引列，而OR后不是</li>
</ol>
</li>
<li>尽量避免全表扫描和全索引扫描</li>
<li>extra字段<ol>
<li>Using filesort：查询语句中包含group by而且无法利用索引完成排序，不得不选择算法排序。</li>
<li>Using temporary：使用临时表保存中间结果，常见于order by与group by</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>count()函数</p>
<ol>
<li>性能排序: count(*) = count(1) &gt; count(主键字段) &gt; count(字段)</li>
<li>count(1)：循环遍历索引（表中有二级索引则遍历二级索引，否则聚簇索引），将读到的记录返回给server层但不读取记录中任何字段的值（1不是任何字段），server层每读到一条记录count+1。</li>
<li>count(*)：等于count(0)，实际上与count(1)一样。</li>
<li>count(主键字段)：如果表里只有主键索引而没有二级索引，InnoDB循环遍历主键索引，将读取到的记录返回给server层并读取主键值，判断是否为NULL，不为NULL则count+1；如果存在二级索引，则会改为遍历二级索引表（遍历成本较聚簇索引低）。</li>
<li>count(字段)：全表扫描，执行效率差。</li>
<li>MyISAM引擎执行count只需要常数时间复杂度，因为每张数据表都有信息记录row_count值；但InnoDB支持事务，多版本并发控制，所以无法只维护一个变量查询。</li>
<li>优化：<ol>
<li>explain关键字，并不会真正查询而是估算</li>
<li>额外维护计数表</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="3-事务篇"><a href="#3-事务篇" class="headerlink" title="3. 事务篇"></a>3. 事务篇</h2><ol>
<li>特点ACID<ol>
<li>原子性：一个事务中的所有操作要么全部完成，要么全部不完成。如果事务在执行过程中发生错误，会回滚到十五开始前的状态。通过undo log（回滚日志）来保证。</li>
<li>一致性：事务在操作前后，数据满足完整性约束，数据库保持一致性状态。通过持久性+原子性+隔离性来保证。</li>
<li>隔离性：防止多个事务并发执行时由于交叉执行导致数据不一致。通过MVCC（多版本并发控制）或锁机制来保证。</li>
<li>持久性：事务处理结束后，对数据的修改是永久的。通过redo log（重做日志）保证。</li>
</ol>
</li>
<li>并行事务引发的问题：<ol>
<li>脏读：一个事务读到了另一个未提交事务修改过的数据，此时如果另一个事务触发回滚，那就读到了过期的数据。</li>
<li>不可重复读：在一个事务内多次读取同一数据，前后两次读到的数据不一样，即多次读取中有其他事务更新了该条数据。</li>
<li>幻读：在一个事务内多次查询某个符合查询条件的记录数量，出现前后两次查询到的记录数量不一样，即在多次查询中有其他事务增删了符合条件的记录。</li>
<li>严重性：脏读 &gt; 不可重复读 &gt; 幻读</li>
</ol>
</li>
<li>隔离级别：隔离级别越高，性能效率越低<ol>
<li>读未提交：一个事务还没提交时，它的变更就能被其他事务看到。不能防止任何问题。</li>
<li>读提交：一个事务提交后，它的变更才能被其他事务看到。能防止脏读。</li>
<li>可重复读：一个事务执行过程中看到的数据，跟这个事务启动时看到的数据一致。MySQL InnoDB引擎的默认隔离级别。能防止脏读、不可重复读。</li>
<li>串行化：对记录加上读写锁，多个记录如果对同一条记录发生了读写冲突，后访问的事务必须等待前一个事务执行完成，才能继续操作。能防止三个问题。</li>
</ol>
</li>
<li>MYSQL InnoDB默认选择可重复读级别的原因：很大程度上避免了幻读，但并没有完全解决，为了避免性能受太大影响选择可重复读级别。<ol>
<li>快照读（普通select语句，只需要读取Read View处）：通过MVCC方式解决幻读。事务执行过程中看到的数据跟启动时一致，即使中途有其他事务插入了数据也查询不到。</li>
<li>当前读（select … for update、增删改等语句，需要读取到当前记录最新值）：通过临键锁（记录锁+间隙锁）解决幻读。执行时会上查询范围内的next-key lock，其他事务在锁范围内插入记录时，插入语句会被阻塞。</li>
<li>幻读仍可能发生：<ol>
<li>其他事务插入并提交记录后，尽管当前事务看不到该条记录，但是仍然update该条记录，这样trx_id就会变成当前事务，当前事务也能利用Read View查询到该条记录。</li>
<li>执行快照读select后插入记录，然后执行当前读select for update。</li>
<li>为了避免特殊情况，应该在事务开启之后马上执行当前读语句，开启锁。</li>
</ol>
</li>
</ol>
</li>
<li>实现机制：<ol>
<li>串行化：加读写锁</li>
<li>可重复读：启动事务时生成一个Read View（快照）。</li>
<li>读提交：每个语句执行前生成一个Read View。</li>
</ol>
</li>
<li>开启事务命令：<ol>
<li>begin/start transaction：在执行该命令后执行增删改查的SQL语句时才真正启动事务。</li>
<li>start transaction with consistent snapshot：立即启动事务。</li>
</ol>
</li>
<li>Read View<ol>
<li>字段结构：<ol>
<li>m_ids：创建Read View时当前数据库中活跃事务（启动但没提交）的事务id列表。</li>
<li>min_trx_id：m_ids的最小值。</li>
<li>max_trx_id：创建Read View时当前数据库中应该给下一个事务的id值，即全局最大事务id值+1.</li>
<li>creator_trx_id：当前事务id。</li>
</ol>
</li>
<li>聚簇索引记录的隐藏列：<ol>
<li>trx_id：记录改动该记录的事务id。</li>
<li>roll_pointer：每次对某条记录改动时，会将旧版本记录写入到undo日志中。该指针指向上一个旧版本记录。</li>
</ol>
</li>
<li>一个事务访问记录时，存在以下几种情况：<ol>
<li>trx_id &lt; min_trx_id：该版本的记录是在创建Read View前已提交的事务生成，所以该版本记录对当前事务可见。</li>
<li>trx_id &gt;= max_trx_id：该版本的记录是在创建Read View后才启动的事务生成，所以该版本记录对当前事务不可见。</li>
<li>trx_id在之间：<ol>
<li>trx_id在m_ids里：生成该版本记录的活跃事务没有提交，所以不可见。</li>
<li>trx_id不在m_ids里：已被提交，可见。</li>
</ol>
</li>
<li>如果不可见，需要沿着roll_pointer找到最近一条可见的记录。</li>
</ol>
</li>
<li>这种通过版本链控制并发事务访问同一记录的行为就叫MVCC多版本并发控制。</li>
</ol>
</li>
</ol>
<h2 id="4-锁篇"><a href="#4-锁篇" class="headerlink" title="4. 锁篇"></a>4. 锁篇</h2><ol>
<li>锁分类<ol>
<li>全局锁：flush tables with read lock。<ol>
<li>作用：阻塞其他线程的增删改数据、更改表结构的操作。</li>
<li>应用场景：全库逻辑备份。</li>
<li>缺点：如果数据库过大，备份耗时过长，会造成业务停滞。</li>
<li>改进：可重复读级的隔离级别可以在备份期间对数据操作。</li>
</ol>
</li>
<li>表级锁：表锁和行锁满足读读共享、读写互斥、写写互斥。<ol>
<li>表锁：lock tables t_xxx read/write<ol>
<li>作用：除了限制别的线程读写，也会限制本线程读写。会话退出时自动释放所有表锁。</li>
</ol>
</li>
<li>元数据锁MDL：对数据库表进行操作时会自动添加，在事务提交后释放。CRUD操作时加MDL读锁，结构变更操作时加MDL写锁。<ol>
<li>缺点：申请MDL锁的操作会形成队列，队列中写锁优先级高于读锁，导致一旦出现MDL写锁等待，会阻塞该表后续所有CRUD操作。</li>
</ol>
</li>
<li>意向锁：<ol>
<li>作用：快速判断表里是否有记录被加锁。</li>
<li>应用场景：在使用InnoDB引擎的表里对某些记录加共享/独占锁前，需要先在表级别加上意向共享/独占锁。</li>
<li>说明：意向共享/独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，智慧和共享表锁和独占表锁之间发生冲突。由于在对记录加独占锁前会先加上表级别的意向独占锁，那么后续加独占锁时直接查该表是否有意向独占锁，就可以避免遍历表里的记录查看是否存在独占锁。</li>
</ol>
</li>
<li>AUTO-INC锁：<ol>
<li>作用：如果不指定主键，在插入数据时自动给主键赋值递增的数。</li>
<li>应用场景：在插入数据时加一个表级别的AUTO-INC锁，然后为被AUTO_INCREMENT修饰的字段赋值递增的数，等插入语句执行完后释放锁。保证插入数据时不会有其他事务插入，从而使得主键连续递增。</li>
<li>改进：给AUTO_INCREMENT赋值后立刻释放<ol>
<li>问题：搭配binlog的日志格式是statement一起使用时，在主从复制的场景中会发生数据不一致的问题。线程A创建完表后，线程B创建一个相同结构的表，然后A插入新的数据，B则插入A的表中存在的数据。B插入的数据id会不连续。如果主库发生这种情况，同样的语句拿去从库执行，且从库按照顺序执行语句的话，主从库会发生数据不一致。</li>
<li>解决：binlog_format = 2，在binlog里记录的是主库分配的自增值，拿去从库执行时自增值跟主库一样。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>行级锁：MyISAM不支持。查询时对记录枷锁会成为锁定读。select语句后添加lock in share mode加共享锁（S锁），添加for update加独占锁（X锁），S型锁间可兼容，其他都不兼容。<ol>
<li>记录锁：<ol>
<li>作用：锁住一条记录。</li>
</ol>
</li>
<li>间隙锁：只存在于可重复读隔离级别<ol>
<li>作用：锁住一个范围内的记录，解决可重复度级别下的幻读现象。</li>
<li>说明：间隙锁的X锁与S锁都是兼容的，因为间隙锁是为了防止插入幻影记录。</li>
</ol>
</li>
<li>临键锁：记录锁+间隙锁<ol>
<li>作用：锁定一个范围，并且锁定记录本身，其他事务既不能在范围内插入记录，也不能修改范围内的记录。</li>
<li>唯一索引等值查询：如果只使用其中一种锁就能避免幻读，临键锁就会退化成该种锁。<ol>
<li>如果查询的记录存在，在索引树上定位到该条记录后，将该记录的索引中的临键锁退化成记录锁。<ol>
<li>如果其他事务插入等值的索引，因为主键冲突导致无法插入。</li>
<li>加了记录锁导致其他事务无法删除该记录。</li>
</ol>
</li>
<li>如果查询的记录不存在，在索引树找到第一条大于该查询条件的记录后，将该记录的索引中的临键锁退化成间隙锁。<ol>
<li>间隙锁的范围为第一条大于该查询条件的记录与该记录的上一条（开区间）。</li>
<li>因为查询的记录不存在，所以不能对不存在的记录加记录锁。</li>
</ol>
</li>
</ol>
</li>
<li>唯一索引范围查询：对每一个扫描到的索引加临键锁，范围为第一条大于该查询条件的记录与该记录的上一条（左开右闭）。<ol>
<li>大于等于的范围查询，因为存在等值查询，所以等值查询的记录存在表中时就会退化成记录锁。</li>
<li>小于或小于等于的范围查询<ol>
<li>条件值的记录不在表中时，扫描到终止范围的查询记录（不满足条件的第一条记录）时，该记录的索引退化成间隙锁。</li>
<li>条件值的记录在表中时，如果是小于的范围查询，扫描到终止范围的查询记录（不满足条件的第一条记录）时，该记录的索引退化成间隙锁。</li>
</ol>
</li>
</ol>
</li>
<li>非唯一索引等值查询：同时对两个索引加锁，但是只对满足查询条件的记录的主键索引加锁。<ol>
<li>查询的记录存在时，扫描到第一个不符合条件的二级索引记录。<ol>
<li>在扫描过程中对扫描到的二级索引记录加临键锁。</li>
<li>第一个不符合条件的二级索引记录退化成间隙锁：避免其他事务插入查询条件相同、主键大于当前查询记录的最大主键的记录，根据2.3的判断规则，如果没有这个间隙锁，是可以成功插入的，从而造成幻读。</li>
<li>在符合查询条件的记录的主键索引上加记录锁。</li>
</ol>
</li>
<li>查询的记录不存在时，扫描到第一个不符合条件的二级索引记录。<ol>
<li>该二级索引退化成间隙锁，范围为相邻两条记录组成的条件存在的区间（开区间）。</li>
<li>不存在满足查询条件的记录，所以不会对主键索引加锁。</li>
<li>当其他事务需要插入记录时，需要考虑插入记录的主键值，以及插入位置的下一条记录是否有间隙锁，从而判断是否插入成功。</li>
</ol>
</li>
</ol>
</li>
<li>非唯一索引范围查询：不会退化</li>
<li>不加索引的查询：扫描时全表扫描，每一条记录的索引上都会加临键锁，相当于锁住全表</li>
</ol>
</li>
<li>插入意向锁：<ol>
<li>作用：判断插入位置是否被其他事务加了间隙锁，如果有则插入操作被阻塞直到拥有间隙锁的事务提交，在此期间生成插入意向锁，表明有事务想在区间内插入新记录，但是处于等待状态（锁状态为等待，只有锁状态为正常才代表事务成功获取到了锁）。</li>
<li>说明：插入意向锁实际并不是意向锁，而是特殊的行级别间隙锁。相比间隙锁，插入意向锁只锁住一个点，且两个事务不能同时分别拥有一个区间的间隙锁与该间隙区间内的插入意向锁。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</section>
</article>

<section class="prev-next card slide-in-right">
	
		<a class="link-disabled prev link">&larr; Not More</a>
	
	
		<a href="/2022/11/10/小林coding计网知识点总结/" class="link next" title="小林coding计网知识点总结">
			<span class="hover-underline-animation">小林coding计网知识点总结 &rarr;</span>
		</a>
	
</section>


<section class="article-toc">
  <div class="card uk-margin-remove-bottom">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MYSQL"><span class="toc-text">MYSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">1. 基础篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E7%AF%87"><span class="toc-text">2. 索引篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%AF%87"><span class="toc-text">3. 事务篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%94%81%E7%AF%87"><span class="toc-text">4. 锁篇</span></a></li></ol></li></ol>
  </div>
</section>

<section class="article slide-in-right">
  <div class="loader" id="loader">
    <svg viewBox="0 0 50 50">
      <circle class="ring" cx="25" cy="25" r="20"></circle>
      <circle class="ball" cx="25" cy="5" r="3.5"></circle>
    </svg>
  </div>

  <div class="comment" id="utteranc"></div>
  <noscript>Please activate JavaScript for normal use of comments</noscript>
</section>

<a class="card back-to-top" id="backTop">&UpArrow;</a>
</main>

    

    <script>
	window.COLD_STONE = {
		root: "/",
		author: "aoba moka" || '',
		gaid: "xxxxxxxxxxxxxx" || '',
		repo: "xrr2016/blog" || '',
	}
</script>




	<script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad()</script>


<script src="/scripts/busuanzi.js" referrerpolicy="origin"></script>

<script src="/scripts/cold-stone.js"></script>



  <script src="//www.googletagmanager.com/gtag/js?id=xxxxxxxxxxxxxx"></script>

  <script>
	window.dataLayer = window.dataLayer || []
	function gtag() {
		dataLayer.push(arguments)
	}
	gtag('js', new Date())
	gtag('config', window.COLD_STONE.gaid)
  </script>


  </body>
</html>
