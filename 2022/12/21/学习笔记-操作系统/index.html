<!DOCTYPE html>
<html>
  <!-- meta/link... -->
  



<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <!-- Global site tag (gtag.js) - Google Analytics -->


  <title>学习笔记-操作系统 | 摩卡&#39;s blog</title>

  <link rel="icon" type="image/x-icon, image/vnd.microsoft.icon" href="/icons/icon.ico">
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_1911880_c1nvbyezg17.css">
  <link href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
  <link href="/js/swiper/swiper@5.4.1.min.css" rel="stylesheet">
  
  
  
  
<link rel="stylesheet" href="/css/animate.min.css">

  
<link rel="stylesheet" href="/css/style.css">

  
  
    <link href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css" rel="stylesheet">
  
  
    
<link rel="stylesheet" href="/js/shareJs/share.min.css">

  
  <style>
        @media (max-width: 992px) {
            #waifu {
                display: none;
            }
        }
    </style>
    <script defer src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

    
    
    <!-- 依赖于jquery和vue -->
    
        <script src="https://unpkg.com/jquery@3.5.1/dist/jquery.min.js"></script>
    

    
        <script src="https://unpkg.com/vue@2.6.11/dist/vue.min.js"></script>
    

    <!-- import link -->
    
        
            
        
            
        
    
    <!-- import script -->
    
        
            
        
            
        
    

<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="摩卡's blog" type="application/atom+xml">
</head>

  
  <!-- 预加载动画 -->
  <!-- 页面预加载动画 -->

  
    <div class="preloader_2" id="loader">
  <div class="loader"></div>
</div>

  
<script>
  var endLoading = function () {
    document.body.style.overflow = 'auto';
    document.getElementById('loader').classList.add("loading");
  }
  window.addEventListener('DOMContentLoaded',endLoading);
</script>

  <body>
    <!-- 判断是否为暗黑风格 -->
    <!-- 判断是否为黑夜模式 -->
<script>
  let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');

  if (isDark) {
    $(document.body).addClass('darkModel');
  }
</script>

    <!-- 需要在上面加载的js -->
    <script>
  function loadScript(src, cb) {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }

  //https://github.com/filamentgroup/loadCSS
  var loadCSS = function (src) {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  };

</script> 

<!-- 轮播图所需要的js -->
<script src="/js/swiper/swiper.min.js"></script>
<script src="/js/swiper/vue-awesome-swiper.js"></script>
<script src="/js/swiper/swiper.animate1.0.3.min.js"></script>

<script type="text/javascript">
  Vue.use(window.VueAwesomeSwiper)
</script>


  <script src="/js/vue-typed-js/index.js"></script>


<!-- 首页的公告滚动插件的js需要重新加载 -->
<script src="/js/vue-seamless-scroll/index.js"></script>

<!-- 打字机效果js -->
<script src="https://unpkg.com/typed.js@2.0.11"></script>


    <div id="safearea">
      <main class="main" id="pjax-container">
        <!-- 头部导航 -->
        
<header class="header  " 
  id="navHeader"
  style="position: fixed;
  left: 0; top: 0; z-index: 10;width: 100%;"
>
  <div class="header-content">
    <div class="bars">
      <div id="appDrawer" class="sidebar-image">
  <div class="drawer-box-icon">
    <i class="fas fa-bars" aria-hidden="true" @click="showDialogDrawer"></i>
  </div>
  
  <transition name="fade">
    <div class="drawer-box_mask" v-cloak style="display: none;" v-show="visible" @click.self="cancelDialogDrawer">
    </div>
  </transition>
  <div class="drawer-box" :class="{'active': visible}">
    <div class="drawer-box-head bg-color">
      <img class="drawer-box-head_logo lazyload placeholder" src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
      <h3 class="drawer-box-head_title">摩卡&#39;s blog</h3>
      <h5 class="drawer-box-head_desc">随便写写，记录下都看了些啥</h5>
    </div>
    
    <div class="drawer-box-content">
      <ul class="drawer-box-content_menu">
        
        
          <li class="drawer-box-content_item">
            <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo">
              <i class="fas fa-github" aria-hidden="true"></i>
              <span>Github</span>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>

<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appDrawer',
    data: {
      visible: false,
      top: 0,
      openArr: [],
    },
    computed: {
    },
    mounted() {
    },
    methods: {
      isOpen(index) {
        if (this.openArr.includes(index)) {
          return true;
        } else {
          return false;
        }
      },
      openOrCloseMenu(curIndex) {
        const index = this.openArr.indexOf(curIndex);
        if (index !== -1) {
          this.openArr.splice(index, 1);
        } else {
          this.openArr.push(curIndex);
        }
      },
      showDialogDrawer() {
        this.visible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'width: 100%; height: 100%;overflow: hidden;';
      },
      cancelDialogDrawer() {
        this.visible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      }
    },
    created() {}
  })
</script>

    </div>
    <div class="blog-title" id="author-avatar">
      
        <div class="avatar">
          <img src="/medias/logo.png" class="lazyload placeholder" data-srcset="/medias/logo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="logo">
        </div>
      
      <a href="/" class="logo">摩卡&#39;s blog</a>
    </div>
    <nav class="navbar">
      <ul class="menu">
        
      </ul>
      
      
        <div id="appSearch">
  <div class="search"  @click="showDialog()"><i class="fas fa-search" aria-hidden="true"></i></div>
  <transition name="fade">
    <div class="message-box_wrapper" style="display: none;" v-cloak v-show="dialogVisible" @click.self="cancelDialogVisible()">
      <div class="message-box animated bounceInDown">
        <h2>
          <span>
            <i class="fas fa-search" aria-hidden="true"></i>
            <span class="title">本地搜索</span>
          </span>
          <i class="fas fa-times close" pointer style="float:right;" aria-hidden="true" @click.self="cancelDialogVisible()"></i>
        </h2>
        <form class="site-search-form">
          <input type="text"
            placeholder="请输入关键字"
            id="local-search-input" 
            @click="getSearchFile()"
            class="st-search-input"
            v-model="searchInput"
          />
        </form>
        <div class="result-wrapper">
          <div id="local-search-result" class="local-search-result-cls"></div>
        </div>
      </div>
    </div>
  </transition>
</div>
<script src="/js/local_search.js"></script>
<script>
  var body = document.body || document.documentElement || window;
  var vm = new Vue({
    el: '#appSearch',
    data: {
      dialogVisible: false,
      searchInput: '',
      top: 0,
    },
    computed: {
    },
    mounted() {
      window.addEventListener('pjax:complete', () => {
        this.cancelDialogVisible();
      })
    },
    methods: {
      showDialog() {
        this.dialogVisible = true;
        // 防止页面滚动，只能让弹框滚动
        this.top = $(document).scrollTop()
        body.style.cssText = 'overflow: hidden;';
      },
      getSearchFile() {
        if (!this.searchInput) {
          getSearchFile("/search.xml");
        }
      },
      cancelDialogVisible() {
        this.dialogVisible = false;
        body.removeAttribute('style');
        $(document).scrollTop(this.top)
      },
    },
    created() {}
  })
</script>
<!-- 解决刷新页面闪烁问题，可以在元素上添加display: none, 或者用vue.extend方法，详情：https://blog.csdn.net/qq_31393401/article/details/81017912 -->
<!-- 下面是搜索基本写法 -->
<!-- <script type="text/javascript" id="local.search.active">
  var inputArea = document.querySelector("#local-search-input");
  inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
  inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script> -->

      

    </nav>
  </div>
  
    <a target="_blank" rel="noopener" href="https://github.com/yuang01/hexo-theme-bamboo" class="github-corner color-primary" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  
  
    <div id="he-plugin-simple"></div>
    <script>
      WIDGET = {
        CONFIG: {
          "modules": "012",
          "background": 5,
          "tmpColor": "4A4A4A",
          "tmpSize": 16,
          "cityColor": "4A4A4A",
          "citySize": 16,
          "aqiSize": 16,
          "weatherIconSize": 24,
          "alertIconSize": 18,
          "padding": "10px 10px 10px 10px",
          "shadow": "1",
          "language": "auto",
          "borderRadius": 5,
          "fixed": "false",
          "vertical": "middle",
          "horizontal": "center",
          "key": "2784dd3fcb1e4f0f9a9b579bf69641f2"
        }
      }
    </script>
    <script defer src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script> 
    
</header>
        <!-- 内容区域 -->
        
 <!-- prismjs 代码高亮 -->
 


<div class="bg-dark-floor" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -1;"></div>


  <!-- 文章详情页顶部图片和标题 -->




<div class="post-detail-header" id="thumbnail_canvas" style="background-repeat: no-repeat; background-size: cover; 
  background-position: center center;position: relative;background-image:url('https://pica.zhimg.com/80/v2-61f99f8dcf899f54cad2a1aa28b21e44_1440w.webp')">
  <div class="post-detail-header-mask"></div>
  <canvas id="header_canvas"style="position:absolute;bottom:0;pointer-events:none;"></canvas>
  
  <div class="post-detail-header_info-box">
    <div class="title-box">
      <span class="title">
        学习笔记-操作系统
      </span>
    </div>
    
    
      
        <span class="post-detail-header_date">
          <i class="fas fa-calendar"></i> 发表于：2022-12-21 |
        </span>
      

      
        <span class="post-detail-header_categories">
          <i class="iconfont iconbookmark1"></i> 分类：
          
            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-detail-header_category">
              学习笔记
            </a>
          
        </span>
      

      
    
  </div>
  
  
    <script src="/js/bubble/bubble.js"></script>
  
</div>





<div class="post-detail-content post-row" 
  style="padding-top: 0px;">
  <div class="main-content">
    <article class="post post-detail">
      <div class="post-content">
        <h1 id="1-硬件结构"><a href="#1-硬件结构" class="headerlink" title="1. 硬件结构"></a>1. 硬件结构</h1><h2 id="1-冯诺依曼模型"><a href="#1-冯诺依曼模型" class="headerlink" title="1. 冯诺依曼模型"></a>1. 冯诺依曼模型</h2><p>冯诺依曼模型：运算器、控制器、存储器、输入设备、输出设备。对应于现代计算机的结构：</p>
<ul>
<li>存储器：内存</li>
<li>控制器：南桥，负责IO设备、外部存储设备与BIOS之间的通信；北桥，负责CPU和内存、显卡的数据传送</li>
<li>运算器：CPU</li>
<li>输入设备：键盘</li>
<li>输出设备：显示器、网卡</li>
</ul>
<p>运算器、控制器在中央处理器中，存储器就是常见的内存，输入输出设备是计算机外接设备。存储单元与输入输出设备通过控制总线、数据总线与地址总线与CPU以及其中的控制器、寄存器、逻辑运算单元连接。</p>
<h3 id="1-内存"><a href="#1-内存" class="headerlink" title="1. 内存"></a>1. 内存</h3><p>存储数据基本单位是字节，1字节=8位。</p>
<h3 id="2-中央处理器-CPU"><a href="#2-中央处理器-CPU" class="headerlink" title="2. 中央处理器/CPU"></a>2. 中央处理器/CPU</h3><p>32位CPU一次可以计算4个字节，64位则是8个。32位与64位通常称为位宽。</p>
<p>常用寄存器种类：</p>
<ul>
<li>通用寄存器：存放需要进行运算的数据。</li>
<li>程序计数器：存储CPU要执行下一条指令<strong>所在的内存地址</strong>。</li>
<li>指令寄存器：存放当前正在执行的指令。</li>
</ul>
<h3 id="3-总线"><a href="#3-总线" class="headerlink" title="3. 总线"></a>3. 总线</h3><p>负责通信，分为三种：</p>
<ul>
<li>地址总线：指定CPU将要操作的内存地址。</li>
<li>数据总线：读写内存数据。</li>
<li>控制总线：发送和接收信号。</li>
</ul>
<p>CPU读写内存数据时，先通过<strong>地址总线</strong>指定内存地址，然后通过<strong>控制总线</strong>控制读写命令，最后通过<strong>数据总线</strong>传输数据。</p>
<h3 id="4-输入输出设备"><a href="#4-输入输出设备" class="headerlink" title="4. 输入输出设备"></a>4. 输入输出设备</h3><p>输入设备向计算机输入数据，计算机计算后将结果交给输出设备。</p>
<p>如果输入设备是键盘，按下按键时需要与CPU交互，还需要用到控制总线。</p>
<h2 id="2-位宽"><a href="#2-位宽" class="headerlink" title="2. 位宽"></a>2. 位宽</h2><p>线路位宽：地址总线数目。每条地址总线能表示0或1，总共能表示0~2^n范围内的数据。</p>
<p>CPU位宽：CPU在一个时钟周期内能处理的二进制位数。</p>
<p>CPU位宽=数据总线位宽=CPU内部通用寄存器位宽=机器字长（计算机一次整数运算能处理的二进制数据的位数）</p>
<p>CPU位宽最好不要小于线路位宽。32位CPU最大只能操作4G内存，因此安装再大的内存也没用。</p>
<h2 id="3-指令周期"><a href="#3-指令周期" class="headerlink" title="3. 指令周期"></a>3. 指令周期</h2><p>一条指令通常分为4个阶段，称为四级流水线，或是<strong>指令周期</strong>。</p>
<ol>
<li>Fetch（取得指令）：CPU通过程序计数器读取对应内存地址的指令。<strong>控制器</strong>根据程序计数器的值，操作<strong>地址总线</strong>指定需要访问的指令；<strong>内存</strong>取出指令并通过<strong>数据总线</strong>传输回CPU，控制器将其放在指令寄存器中。程序计数器自增。</li>
<li>Decode（指令译码）：CPU对指令进行解码。由<strong>控制器</strong>进行。</li>
<li>Execution（指令解码）：CPU执行指令。一般由<strong>算术逻辑单元</strong>操作，如果是简单的无条件跳转则是由<strong>控制器</strong>完成。</li>
<li>Store（数据回写）：CPU将计算结果存回寄存器或将寄存器的值存入内存。</li>
</ol>
<p>指令通过功能可划分为5大类：数据传输、运算、跳转、信号（trap引起中断）、闲置。</p>
<p>1GHz的CPU指的是时钟频率1G，1秒产生1G次数的脉冲信号，每一次脉冲信号高低电平转换为一个周期，称为时钟周期。</p>
<p>程序CPU执行时间 = CPU时钟周期数 x 时钟周期时间 = 指令数 x CPI（每条指令平均时钟周期数） x 时钟周期时间</p>
<h2 id="4-64位和32位"><a href="#4-64位和32位" class="headerlink" title="4. 64位和32位"></a>4. 64位和32位</h2><p>64位CPU优势：</p>
<ul>
<li>可以一次计算超过32位的数字。</li>
<li>可以寻址更大的内存空间。</li>
</ul>
<p>硬件的64位与32位指CPU位宽，而软件指的是指令的位宽，也就是指令多少位（操作系统也是一种应用程序）。</p>
<h2 id="5-存储结构"><a href="#5-存储结构" class="headerlink" title="5. 存储结构"></a>5. 存储结构</h2><p>寄存器、CPU Cache（L1、L2、L3）、内存、硬盘。</p>
<p>存储器速度越快，能耗就越高，单位空间也越贵，所以容量一般越小。</p>
<p>每一种存储设备只与它相邻的存储器设备打交道。</p>
<h3 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1. 寄存器"></a>1. 寄存器</h3><p>32位/64位CPU中大多数寄存器可存储4/8个字节，一般要求在半个CPU时钟周期内完成读写。</p>
<h3 id="2-CPU-Cache"><a href="#2-CPU-Cache" class="headerlink" title="2. CPU Cache"></a>2. CPU Cache</h3><p>使用SRAM（Static Random-Access Memory，静态随机存储器）的芯片。“静态”是因为只要有电数据就在，一旦断电数据就丢失。一般分为三层：</p>
<ol>
<li>L1高速缓存：访问速度2~4个时钟周期，大小在几十KB到几百KB不等。每个CPU都有一块L1高速缓存，分为指令缓存和数据缓存。</li>
<li>L2高速缓存：访问速度10~20个时钟周期，大小在几百KB到几MB不等。每个CPU都有一块，比L1离CPU核心更远。</li>
<li>L3高速缓存：访问速度20~60个时钟周期，大小在几MB到几十MB不等。一般多个CPU核心公用，位置更远。</li>
</ol>
<h3 id="3-内存"><a href="#3-内存" class="headerlink" title="3. 内存"></a>3. 内存</h3><p>使用DRAM（Dynamic Random Access Memory，动态随机存取存储器）芯片。“动态”指需要定时刷新电容才能保证数据不丢失。访问速度200~300个时钟周期。</p>
<h3 id="4-SSD-HDD硬盘"><a href="#4-SSD-HDD硬盘" class="headerlink" title="4. SSD/HDD硬盘"></a>4. SSD/HDD硬盘</h3><p>固态硬盘（Solid-state disk）：比内存慢10~1000倍。</p>
<p>机械硬盘（Hard Disk Drive）：比内存慢10w倍左右。</p>
<h2 id="6-Cache映射方式"><a href="#6-Cache映射方式" class="headerlink" title="6. Cache映射方式"></a>6. Cache映射方式</h2><p>CPU Cache由很多个Cache Line（缓存块）组成，Cache Line由Tag + Data Block组成。</p>
<h3 id="1-直接映射"><a href="#1-直接映射" class="headerlink" title="1. 直接映射"></a>1. 直接映射</h3><p>CPU访问内存数据也是以块为单位读取的，称为内存块。直接映射把内存块的地址始终映射在一个CPU缓存块的地址，通过取模运算映射。所以，缓存块大小应与内存块大小保持一致。</p>
<p>有效位Valid bit：标记对应的缓存块数据是否有效。</p>
<p>组标记Tag：记录当前缓存块中存储的数据对应的内存块。</p>
<p>数据Data：存放缓存数据块。</p>
<p>内存地址可分为：Tag + Index + Offset。CPU根据该地址访问Cache的顺序为：</p>
<ol>
<li>先计算该内存在Cache中的索引，也就是Index。</li>
<li>判断有效位，如果无效需要重新加载。</li>
<li>对比Tag组标记，确实是否为需要访问的地址，否则重新加载。</li>
<li>根据Offset偏移量信息读取对应的字。</li>
</ol>
<h3 id="2-全相联映射"><a href="#2-全相联映射" class="headerlink" title="2. 全相联映射"></a>2. 全相联映射</h3><p>每个内存块映射到Cache的任意块中，有空位就放，靠Tag组标记来确认是否为需要的地址。</p>
<h3 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="3. 组相联映射"></a>3. 组相联映射</h3><p>每个内存块映射到Cache固定组的任意块中。内存块与组的映射关系与直接映射相同，而组中使用全相联映射。</p>
<h2 id="7-提升Cache命中率"><a href="#7-提升Cache命中率" class="headerlink" title="7. 提升Cache命中率"></a>7. 提升Cache命中率</h2><h3 id="1-数据缓存"><a href="#1-数据缓存" class="headerlink" title="1. 数据缓存"></a>1. 数据缓存</h3><p>多维数组占用的内存是连续的，尽量按照内存布局顺序访问。</p>
<h3 id="2-指令缓存"><a href="#2-指令缓存" class="headerlink" title="2. 指令缓存"></a>2. 指令缓存</h3><p>CPU有分支预测器，对于条件语句，如果可以预测到接下来执行哪个分支的指令，就提前将其放在指令缓存中。</p>
<p>可以在一段循环中尽量将同一个分支的语句放在一起，比如先排序再遍历条件处理。</p>
<h2 id="8-Cache写入内存"><a href="#8-Cache写入内存" class="headerlink" title="8. Cache写入内存"></a>8. Cache写入内存</h2><p>写直达：将更新的数据同时写入Cache和内存。</p>
<p>写回：只写Cache，并设置为脏。只有脏块被替换时才写内存。</p>
<h2 id="9-缓存一致性问题"><a href="#9-缓存一致性问题" class="headerlink" title="9. 缓存一致性问题"></a>9. 缓存一致性问题</h2><p>多核CPU具有各自的Cache，可能引起一致性问题。</p>
<p>要实现机制同步缓存数据，需要做到：</p>
<ol>
<li><strong>写传播</strong>：某个CPU核心的Cache数据更新时要传播到其他核心的Cache。</li>
<li><strong>事务串行化</strong>：某个CPU核心对数据的操作顺序在其他核心看起来顺序一样。</li>
</ol>
<p>实现机制：</p>
<h3 id="1-总线嗅探"><a href="#1-总线嗅探" class="headerlink" title="1. 总线嗅探"></a>1. 总线嗅探</h3><p>CPU修改后通过总线将事件广播给其他所有核心，每个CPU核心时刻监听总线上的广播事件。</p>
<p>缺点：需要每个CPU核心时刻监听，加重负载；不能保证事务串行化。</p>
<h3 id="2-MESI协议"><a href="#2-MESI协议" class="headerlink" title="2. MESI协议"></a>2. MESI协议</h3><p>Cache Line的四个状态：</p>
<ul>
<li>Modified，已修改。该缓存块的数据已更新，但还没有写到内存。</li>
<li>Exclusive，独占。该缓存块的数据与内存一致，但是只有这一个CPU核心中缓存。</li>
<li>Shared，共享。该缓存块的数据与内存一致，但是有其他CPU核心缓存。</li>
<li>Invalidated，已失效。该缓存块的数据已失效，不可读取。</li>
</ul>
<p>状态转换：</p>
<ul>
<li>已修改：<ul>
<li>本地读：从Cache中取数据，状态不变。</li>
<li>本地写：写入Cache中，状态不变。</li>
<li>远程读：Cache Line中的数据写入内存，状态变成共享。</li>
<li>远程写：Cache Line中的数据写入内存，状态变成已失效。（其他CPU读取后写入新的数据）</li>
</ul>
</li>
<li>独占：<ul>
<li>本地读：从Cache中取数据，状态不变。</li>
<li>本地写：写入Cache中，状态变成已修改。</li>
<li>远程读：状态变成共享。</li>
<li>远程写：状态变成已失效。（为啥独占还会被远程写？？？）</li>
</ul>
</li>
<li>共享：<ul>
<li>本地读：从Cache中取数据，状态不变。</li>
<li>本地写：写入Cache中，状态变成已修改。其他CPU核心共享的Cache Line状态变成已失效。</li>
<li>远程读：状态不变。</li>
<li>远程写：状态变成已失效。</li>
</ul>
</li>
<li>已失效：<ul>
<li>本地读：<ul>
<li>如果其他核心的Cache没有这份数据，本地核心Cache从内存中读取，状态变成独占。</li>
<li>如果其他核心中的Cache有这份数据，且状态为共享或独占，本地核心Cache从内存中读取，这些共享Cache Line状态变成共享。</li>
<li>如果其他核心中的Cache有这份数据，且状态为已修改，则其他核心Cache更新到内存，本地再从内存中读取，这两个Cache Line状态变成共享。</li>
</ul>
</li>
<li>本地写：先本地读，然后在Cache中更新数据，状态变成已修改。其他核心中Cache Line状态变成已失效。</li>
<li>远程写：已失效，所以其他核心操作与其无关。</li>
<li>远程读：已失效，所以其他核心操作与其无关。</li>
</ul>
</li>
</ul>
<h2 id="10-Cache伪共享"><a href="#10-Cache伪共享" class="headerlink" title="10. Cache伪共享"></a>10. Cache伪共享</h2><p>因为多个线程同时读写同一个Cache Line的不同变量时导致CPU Cache失效的现象。</p>
<p>避免的方法：通过对齐机制或字节填充等，让读写的变量不在一个Cache行中。</p>
<ol>
<li>__cacheline_alinged_in_smp宏定义：在多核系统中定义为__cacheline_alinged，Cache Line的大小。可以在结构体中将变量地址设置为Cache Line对齐地址，使不同的变量在不同Cache Line中。</li>
<li>RingBuffer（Java）：在结构前后各填充七个不会被读写的long变量。</li>
</ol>
<h2 id="11-Linux-Windows的线程调度"><a href="#11-Linux-Windows的线程调度" class="headerlink" title="11. Linux/Windows的线程调度"></a>11. Linux/Windows的线程调度</h2><h3 id="1-Linux"><a href="#1-Linux" class="headerlink" title="1. Linux"></a>1. Linux</h3><p>Linux中根据任务的优先级与响应要求分为两种，优先级数值越小优先级越高：</p>
<ul>
<li>实时任务：优先级0~99.</li>
<li>普通任务：优先级100~139.</li>
</ul>
<p>调度类分为三种：</p>
<p>Deadline和Realtime调度类应用于实时任务，其调度策略结合起来有三种。</p>
<ul>
<li>SCHED_DEADLINE：距离当前时间点最近的deadline任务优先调度。</li>
<li>SCHED_FIFO：相同优先级先来先服务，优先级更高可抢占。</li>
<li>SCHED_RR：相同优先级时间片轮转，优先级更高可抢占。</li>
</ul>
<p>Fair调度类应用于普通任务，由CFS调度器管理：</p>
<ul>
<li>SCHED_NORMAL：普通任务调度策略。</li>
<li>SCHED_BATCH：后台任务调度策略，可以适当降低优先级。</li>
<li>SCHED_IDLE：空闲时才跑的任务。</li>
</ul>
<p>Linux中实现了一个基于CFS的调度算法，完全公平调度。</p>
<ul>
<li>为每个任务维护一个虚拟运行时间，当逻辑时钟到来时增加所有正在运行的任务的虚拟时间。</li>
<li>调度时优先选择虚拟运行时间少的任务。</li>
<li>每个任务根据优先级获得权重，权重越大虚拟时间增加越慢，也就更容易获得调度。</li>
</ul>
<p>CFS：完全公平调度策略。试图模拟一个理想的、精确的多任务CPU，希望能将性能平分给所有并行的进程。</p>
<h3 id="2-Windows"><a href="#2-Windows" class="headerlink" title="2. Windows"></a>2. Windows</h3><p>windows调度器根据优先级采用抢占式调度策略，调度线程。</p>
<p>使用32个数字表示优先级。数字越高优先级越高。</p>
<ul>
<li>实时优先级16~31。</li>
<li>可变优先级1~15。</li>
<li>系统优先级0，用于内存页清零线程。</li>
</ul>
<p>创建线程时，在其优先级别上进一步赋予相对优先级：尽量实时、最高、高于一般、一般、低于一般、最低、空闲。</p>
<p>调度时参考：当前线程所在进程额基准优先级，与线程优先级。</p>
<p>可变优先级进入实时优先级，需要获得更高的调度优先级特权。</p>
<p>线程状态：</p>
<ul>
<li>就绪</li>
<li>预备：比就绪更接近运行。</li>
<li>运行</li>
<li>等待：等待系统资源。</li>
<li>过渡：线程已经准备就绪，但是运行它所需的核心栈暂时被分页调度到磁盘上。</li>
<li>终止</li>
<li>已初始化：刚创建</li>
</ul>
<p>调度机制：</p>
<ul>
<li>为每一个优先级别维护一个就绪等待队列。</li>
<li>线程运行时获得一个可运行的时间配额。每过一个时钟周期-1。</li>
<li>时间配额用完时调度下一个优先级最高的线程。基于优先级的抢占调度，有比运行线程更高优先级的线程进入等待队列时，可抢占。</li>
<li>运行线程需要等待某一对象时，主动让出CPU进入等待。</li>
<li>为每一个等待对象维护一个等待队列。</li>
<li>线程核心栈完成上下文切换，调度器将调出线程的上下文环境信息压入该线程的核心栈，并将栈指针保存到该线程的核心线程块。</li>
</ul>
<h2 id="12-中断"><a href="#12-中断" class="headerlink" title="12. 中断"></a>12. 中断</h2><p>Linux系统为了解决中断处理程序过长和中断丢失的问题，将中断过程分为两个阶段，分别是上半部和下半部</p>
<ul>
<li>上半部处理快速中断，一般暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。</li>
<li>下半部延迟处理上半部未完成的工作，一般以内核线程的方式运行。</li>
</ul>
<h2 id="13-操作系统的作用"><a href="#13-操作系统的作用" class="headerlink" title="13. 操作系统的作用"></a>13. 操作系统的作用</h2><p>作为应用程序和硬件之间的中间层，控制应用程序应用硬件的权限，并且提供统一机制控制复杂的底层硬件。</p>
<p>引入抽象概念：</p>
<ul>
<li>文件是对IO设备的抽象。</li>
<li>虚拟内存是对内存和磁盘IO的抽象。</li>
<li>进程是对处理器、内存与IO设备的抽象。</li>
</ul>
<h1 id="2-操作系统内核"><a href="#2-操作系统内核" class="headerlink" title="2. 操作系统内核"></a>2. 操作系统内核</h1><p>内核基本功能：</p>
<ul>
<li>进程调度：管理进程线程，决定哪个进程线程使用CPU。</li>
<li>内存管理：管理内存，决定内存分配与回收。</li>
<li>硬件通信：管理硬件设备，为进程与硬件设备之间提供通信能力。</li>
<li>系统调用：提供系统调用，让应用程序支持运行更高权限的服务。</li>
</ul>
<h2 id="1-Linux-1"><a href="#1-Linux-1" class="headerlink" title="1. Linux"></a>1. Linux</h2><p>Linux内核的设计理念：</p>
<ul>
<li>MultiTask多任务：并发/并行</li>
<li>SMP对称多处理：每个CPU地位相等，对资源的使用权限相同。</li>
<li>ELF可执行文件链接格式：Linux中可执行文件的存储格式。<ul>
<li>代码通过编译器编译成汇编代码，通过汇编器变成目标代码，最后通过连接器将多个目标文件以及调用的函数库链接，形成可执行文件。</li>
<li>ELF文件通过装载器装载到内存里，CPU读取指令和数据执行文件。</li>
</ul>
</li>
<li>Monolithic Kernel宏内核：Linux内核是一个完整的可执行程序且拥有最高权限<ul>
<li>微内核：内核只保留最基本的能力，如进程调度、中断等，将一些应用放到用户空间。服务之间隔离，单个服务出现故障不会导致整个操作系统挂掉；由于驱动程序不在内核中，与硬件设备交互需要频繁切换，带来性能损耗。</li>
<li>混合类型内核：宏内核包着一个微内核。</li>
</ul>
</li>
</ul>
<h2 id="2-Windows-1"><a href="#2-Windows-1" class="headerlink" title="2. Windows"></a>2. Windows</h2><p>混合型内核。</p>
<p>可执行文件叫PE可移植执行文件。</p>
<h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><p>程序使用的内存地址叫虚拟内存地址，实际存在硬件里的空间地址叫物理内存地址。进程持有的虚拟地址通过CPU中的内存管理单元MMU映射到物理地址，再通过物理地址访问内存。</p>
<p>虚拟内存的意义/为什么要虚拟内存：</p>
<ul>
<li>结合磁盘和物理内存的优势，为进程提供看起来速度足够快且容量足够大的独立存储。进程都有一样的虚拟内存，但页表不同，因此分配到的物理内存也就不同。</li>
<li>进程间可共享物理内存减少开销，也能简化程序的链接、装载与内存分配过程。</li>
<li>控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li>
</ul>
<h2 id="1-内存分段"><a href="#1-内存分段" class="headerlink" title="1. 内存分段"></a>1. 内存分段</h2><p>不同的段有不同的属性。虚拟地址由段选择因子和段内偏移量两部分组成。</p>
<ul>
<li>段选择因子保存在段寄存器中，有段号，用作段表索引。段表里保存段基地址、段的界限和特权等级。</li>
<li>段内偏移量位于0和段界限之间。段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p>不足：</p>
<ul>
<li>内存碎片：分段管理不会出现内部内存碎片，但是多个段未必能恰好使用所有内存空间，会产生多个不连续的小物理内存，就是外部内存碎片。解决方法是内存交换。</li>
<li>内存交换效率低：外部内存碎片很容易产生，而每一次内存交换都需要把一大段连续的内存数据写到硬盘上，硬盘访问速度比内存慢太多。</li>
</ul>
<h2 id="2-内存分页"><a href="#2-内存分页" class="headerlink" title="2. 内存分页"></a>2. 内存分页</h2><p>将整个虚拟和物理内存空间切成固定大小，叫页。Linux每页4KB。虚拟地址与物理地址间通过页表映射。只有需要时触发缺页中断将页加载到物理内存中。</p>
<p>页与页之间紧密排列，不会有外部碎片。但是即使程序不足一页大小，也至少要分配一页，会产生内部内存碎片。</p>
<p>内存页面换入/换出使得<strong>一次性换入/换出磁盘的只有少数几页，提高了交换效率。</strong></p>
<p>虚拟地址分为页号与页内偏移：</p>
<ul>
<li>根据页号在页表中查询物理页号。</li>
<li>物理页号+偏移量得到物理内存地址。</li>
</ul>
<p>不足：</p>
<ul>
<li>内部内存碎片</li>
<li>页表项太大：多级页表，只在需要时创建多级页表。64位系统有4级目录。</li>
</ul>
<p>TLB：页表项Cache，存储程序最常访问的页。将虚拟地址直接映射到物理地址而不必访问页表。CPU中的内存管理单元完成地址转换与TLB的访问与交互。</p>
<h2 id="3-段页式内存管理"><a href="#3-段页式内存管理" class="headerlink" title="3. 段页式内存管理"></a>3. 段页式内存管理</h2><p>先将程序划分为多个有逻辑意义的段，再将每个段划分为多个页。地质结构由段号、段内页号和页内位移三部分组成。</p>
<p>段页式地址变换到物理地址需要经过三次内存访问：</p>
<ul>
<li>第一次访问段表，得到页表起始地址。</li>
<li>第二次访问页表，得到物理页号。</li>
<li>第三次将物理页号与页内位移结合，得到物理地址。</li>
</ul>
<h2 id="4-Linux虚拟内存布局"><a href="#4-Linux虚拟内存布局" class="headerlink" title="4. Linux虚拟内存布局"></a>4. Linux虚拟内存布局</h2><p>32位Linux系统每个段都是从0地址开始的整个4GB虚拟空间。相当于屏蔽了逻辑地址概念，只用页管理地址，段只用于访问控制和内存保护。内核空间占用最高的1G，用户最多可申请剩下的3G虚拟空间。</p>
<p>64位系统内核空间与用户空间都是128T，中间部分未定义。</p>
<p>32位空间用户内存从低到高分布：</p>
<ul>
<li>程序文件段（.text）:二进制可执行代码。</li>
<li>已初始化数据段（.data）：静态常量。</li>
<li>未初始化数据段（.bss）：未初始化的静态变量。</li>
<li>堆段：动态分配的内存，从低地址向上增长。</li>
<li>文件映射段：动态库、共享内存等，从低地址向上增长。</li>
<li>栈段：局部变量和函数调用的上下文等。栈大小固定。</li>
</ul>
<h2 id="5-动态分配内存"><a href="#5-动态分配内存" class="headerlink" title="5. 动态分配内存"></a>5. 动态分配内存</h2><p>mmap可以在文件映射段动态分配内存，malloc可以在堆段动态分配内存。</p>
<p>操作系统先在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目，指向硬盘上新创建的虚拟页），通过页表条目建立虚拟页和物理页的映射关系。</p>
<p>malloc有两种方式申请内存：具体看C++篇</p>
<ul>
<li>如果用户分配内存小于128KB，通过brk系统调用从堆分配。free释放内存时并不还给操作系统，而是缓存在malloc内存池中。</li>
<li>如果用户分配内存大于128KB，通过mmap系统调用在文件映射区分配。free释放内存时还给操作系统。</li>
</ul>
<p>为什么不全部用mmap：mmap每次释放内存都还给操作系统，所以分配的虚拟地址一定没有映射的物理地址，导致第一次访问一定会触发缺页中断，导致CPU消耗大。</p>
<p>为什么不全部用brk：容易出现内存碎片，导致内存泄漏。</p>
<p>malloc返回给用户态的内存起始地址比堆空间起始地址多了16字节：存储内存块描述信息，如内存块大小等。</p>
<h2 id="6-内存紧张的处理方式"><a href="#6-内存紧张的处理方式" class="headerlink" title="6. 内存紧张的处理方式"></a>6. 内存紧张的处理方式</h2><p>回收内存：</p>
<ul>
<li>后台内存回收（kswapd）：异步回收，物理内存紧张时唤醒kswapd内核线程来回收内存。</li>
<li>直接内存回收（direct reclaim）：同步回收，后台内存回收跟不上进程申请的速度，就会开始直接回收。</li>
<li>OOM（Out Of Memory）机制：直接内存回收后空闲内存仍然无法满足申请。OOM Killer机制根据算法不断选择一个占用物理内存较高的进程杀死，直到释放了足够的内存。可以通过调整oom_score_adj降低程序被杀死的优先级，-1000表示无论如何都不能被杀。</li>
</ul>
<p>可以被回收的内存：</p>
<ul>
<li>文件页：包括内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）。</li>
<li>匿名页：堆、栈数据等。通过Swap机制将不常访问的内存写入磁盘中，再次使用时再从磁盘读取。</li>
</ul>
<p>两种页的回收都是基于LRU算法，维护活跃内存页与不活跃内存页两个双向链表。</p>
<p>调整回收内存的性能影响：</p>
<ul>
<li>调整文件页和匿名页的回收倾向。应该优先回收文件页，因为文件页在磁盘中有备份，如果没有写入甚至可以直接覆盖，而匿名页需要先交换到磁盘进行备份。</li>
<li>尽早触发kswapd内核线程异步回收。</li>
</ul>
<h2 id="7-NUMA架构"><a href="#7-NUMA架构" class="headerlink" title="7. NUMA架构"></a>7. NUMA架构</h2><p>SMP架构：多个CPU处理器地位平等，共享电脑资源。也被称为一致存储访问结构NUMA。</p>
<p>但是随着CPU增多，多个CPU通过一个总线访问内核，总线带宽压力会越来越大，同时每个CPU可用带宽减少。</p>
<p>非一致存储访问结构NUMA：将CPU分组，每一组CPU表示为Node，每个Node有独立的资源（内存、IO），通过互联模块总线QPI通信。</p>
<p>NUMA架构下如果某个Node内存不足，可以在其他Node中寻找空闲内存，并且可以调整这个行为与在本Node回收内存的优先级。</p>
<h2 id="8-申请超出物理内存的虚拟内存"><a href="#8-申请超出物理内存的虚拟内存" class="headerlink" title="8. 申请超出物理内存的虚拟内存"></a>8. 申请超出物理内存的虚拟内存</h2><p>分别在32位、64位机器上申请8GB虚拟内存</p>
<ul>
<li>32位操作系统进程最大只能申请3GB虚拟内存，所以会申请失败。</li>
<li>64位操作系统进程最大可以申请128TB虚拟内存，所以会申请成功，即使物理内存小于8GB（申请的是虚拟内存）。如果物理页框全被分配完时，虚拟内存被访问，要看系统有无Swap分区。<ul>
<li>如果没有，因为物理空间不够，进程会因为内存溢出OOM被系统杀死。</li>
<li>如果有，只要申请的物理内存不高出实际物理内存太多，就能正常运行。</li>
</ul>
</li>
</ul>
<h2 id="9-改进LRU算法"><a href="#9-改进LRU算法" class="headerlink" title="9. 改进LRU算法"></a>9. 改进LRU算法</h2><p>传统LRU算法存在两个问题：</p>
<h3 id="1-预读失效，导致缓存命中率下降"><a href="#1-预读失效，导致缓存命中率下降" class="headerlink" title="1. 预读失效，导致缓存命中率下降"></a>1. 预读失效，导致缓存命中率下降</h3><p>出于空间局部性原理，会选择想要读取的数据块周围的几个数据块都加载到内存。</p>
<p>这些提前加载的页如果都没有被访问，就会白白浪费读取资源，而且将热点数据挤到队列末尾淘汰。</p>
<h4 id="1-Linux的处理方式"><a href="#1-Linux的处理方式" class="headerlink" title="1. Linux的处理方式"></a>1. Linux的处理方式</h4><p>分为活跃LRU链表和非活跃LRU链表，预读页进入非活跃LRU链表的头部，真正访问的页加入活跃LRU链表头部。活跃LRU链表淘汰的页，会被降级，插入到非活跃LRU链表的头部。</p>
<h4 id="2-MySQL的处理方式"><a href="#2-MySQL的处理方式" class="headerlink" title="2. MySQL的处理方式"></a>2. MySQL的处理方式</h4><p>与Linux类似，分为young区域与old区域，默认比例63：37。</p>
<h3 id="2-缓存污染，导致缓存命中率下降"><a href="#2-缓存污染，导致缓存命中率下降" class="headerlink" title="2. 缓存污染，导致缓存命中率下降"></a>2. 缓存污染，导致缓存命中率下降</h3><p>批量读取数据时很多的数据都只会读取一次，但是全部加入活跃LRU链表中，将热点数据全部淘汰。</p>
<h4 id="1-Linux处理方式"><a href="#1-Linux处理方式" class="headerlink" title="1. Linux处理方式"></a>1. Linux处理方式</h4><p>内存页被访问第二次时才升级到活跃LRU链表。</p>
<h4 id="2-MySQL处理方式"><a href="#2-MySQL处理方式" class="headerlink" title="2. MySQL处理方式"></a>2. MySQL处理方式</h4><p>内存页被访问第二次时，如果与上次访问时间超过1秒，就会升级到young区域。</p>
<h2 id="10-虚拟内存管理"><a href="#10-虚拟内存管理" class="headerlink" title="10. 虚拟内存管理"></a>10. 虚拟内存管理</h2><p>64位系统虚拟内存布局与32位系统的差异：</p>
<ol>
<li>用户空间与内核空间存在空洞（高16位既不全为0也不全为1）。</li>
<li>代码段跟数据段之间存在一段不可读写的保护段，防止越界。</li>
<li>用户态虚拟内存空间与内核态虚拟内存空间都占用128T。</li>
</ol>
<p>具体的数据结构组织方式：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d945d22667c4ea56dbd2f19677306a91.png" class="lazyload placeholder" data-srcset="https://img-blog.csdnimg.cn/img_convert/d945d22667c4ea56dbd2f19677306a91.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<p>内核态虚拟内存空间前896M区域是直接映射到物理内存前896M的区域，称为直接映射区。前1M在系统启动时被系统占用。后面存放内核代码段，数据段，BSS段，进程相关的描述符。</p>
<h2 id="11-内存碎片"><a href="#11-内存碎片" class="headerlink" title="11. 内存碎片"></a>11. 内存碎片</h2><p>外部碎片：内存中某些空闲区因为比较小而难以利用上，一般出现在内存动态分配方式中。可以通过紧凑技术解决外部碎片问题，即操作系统不时移动整理进程。但是需要动态重定位寄存器支持，且相对费时。</p>
<p>内部碎片：分配给某些进程的内存区域有些部分没用上，一般出现在固定分配方式中。</p>
<p>分段式分配是按需分配，所以有外部碎片无内部碎片；分页式分配是固定分配，所以有内部碎片无外部碎片。</p>
<h2 id="12、Buddy伙伴机制"><a href="#12、Buddy伙伴机制" class="headerlink" title="12、Buddy伙伴机制"></a>12、Buddy伙伴机制</h2><p>伙伴块定义：</p>
<ol>
<li>大小相同</li>
<li>地址连续</li>
<li>从同一个大块分离出来</li>
<li>用一位二进制数表示其伙伴关系，为1表示其中一块在使用，为0表示都空闲或都在使用。系统每次分配和回收伙伴块时都对其伙伴位与1进行异或。</li>
<li>管理：由链表管理，类似于STL，每个链表节点为2次幂大小的freelist</li>
</ol>
<p>分配：</p>
<ol>
<li><p>查对应的freelist，如果有空闲块就直接摘下分配。</p>
</li>
<li><p>如果没有就向上查找，直到找到空闲块。</p>
</li>
<li><p>不断等分这个空闲块，直到恰好为满足条件的大小，把其他分下来的空闲块挂在相应freelist上。</p>
</li>
<li><p>如果找不到则放弃分配。</p>
</li>
</ol>
<p>释放</p>
<ol>
<li>查对应的freelist，如果没有伙伴块就直接挂上。</li>
<li>如果有则摘下伙伴合并，然后向上查找是否可合并。</li>
<li>直到不能合并或已经合并到最大块。</li>
</ol>
<p>缺点</p>
<ol>
<li>小块阻碍大块合并</li>
<li>按2的幂次分块，有一定浪费</li>
<li>拆分和合并涉及较多链表和位图操作，开销大</li>
</ol>
<h1 id="4-进程管理"><a href="#4-进程管理" class="headerlink" title="4. 进程管理"></a>4. 进程管理</h1><h2 id="1-进程状态"><a href="#1-进程状态" class="headerlink" title="1. 进程状态"></a>1. 进程状态</h2><ul>
<li>创建状态：进程正在被创建。</li>
<li>结束状态：进程正在从系统中消失。</li>
<li>运行状态：进程正在占用CPU。</li>
<li>就绪状态：进程可运行，由于其他进程处于运行状态而暂时停止运行。</li>
<li>阻塞状态：进程正在等待某一事件发生而暂时停止运行。</li>
<li>阻塞挂起状态：进程在外存并在等待某一事件发生。</li>
<li>阻塞就绪状态：进程在外存，但只要进入内存就立刻运行。</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<h2 id="2-进程的控制结构"><a href="#2-进程的控制结构" class="headerlink" title="2. 进程的控制结构"></a>2. 进程的控制结构</h2><p>操作系统用进程控制块PCB描述进程，PCB是进程存在的唯一标识，包含如下信息：</p>
<ul>
<li>进程描述信息，包括进程标识符、用户标识符。</li>
<li>进程控制和管理信息，包括进程状态、优先级。</li>
<li>资源分配清单，有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的I/O设备信息。</li>
<li>CPU相关信息，包括CPU中寄存器的值。</li>
</ul>
<p>一般用链表的方式组织PCB，比如就绪队列、阻塞队列等，方便增删与管理。</p>
<h2 id="3-★-进程-线程的控制与切换"><a href="#3-★-进程-线程的控制与切换" class="headerlink" title="3. ★ 进程/线程的控制与切换"></a>3. ★ 进程/线程的控制与切换</h2><p>一般过程为创建/查找到PCB，（创建时需要初始化并分配资源），修改状态，并插入到就绪/阻塞队列。</p>
<p>终止进程时如果有子进程，需要交给1号进程托管。</p>
<p>进程上下文切换的场景：</p>
<ul>
<li>时间片耗尽</li>
<li>系统资源不足，需要等到资源满足才运行时</li>
<li>sleep主动挂起</li>
<li>优先级更高的进程抢占</li>
<li>硬件中断</li>
</ul>
<p><strong>抢占式调度会抢占CPU</strong></p>
<p>★ 切换步骤：</p>
<ul>
<li>进程：<ul>
<li>切换页目录，使用新的地址空间</li>
<li>切换内核栈和硬件上下文</li>
</ul>
</li>
<li>线程：只有第二步<ul>
<li>具体过程：<ul>
<li>保存CPU上下文：指令指针寄存器、栈顶位置、其他CPU中间状态</li>
<li>触发软中断转到内核态，恢复内核栈寄存器信息</li>
<li>内核调度一个线程，恢复其CPU上下文</li>
<li>转到用户态，开始执行新线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>开销：</p>
<ul>
<li>保存寄存器中的内容</li>
<li>CPU高速缓存、快表失效</li>
<li>调度算法</li>
</ul>
<h2 id="4-★-线程"><a href="#4-★-线程" class="headerlink" title="4. ★ 线程"></a>4. ★ 线程</h2><p>fork与pthread底层实现都是调用同一个内核函数clone，如果复制地址空间则为fork，如果共享地址空间则为pthread。</p>
<p>Linux只在用户层面上区分进程和线程，所以pthread操作函数是库函数而非系统调用。</p>
<p>★ 与进程的区别：</p>
<ul>
<li>进程是资源分配的单位，线程是CPU调度的单位。</li>
<li>进程有完整的资源平台，而线程只独享必不可少的资源。</li>
</ul>
<p>线程减少开销体现在：</p>
<ul>
<li>创建比进程快，因为大部分资源共享，创建时不需要资源管理信息。<ul>
<li>线程共享所在进程的虚拟地址空间，切换时不用切换虚拟地址。</li>
<li>因此，切换线程时TLB和cache也都不会失效。</li>
</ul>
</li>
<li>终止比进程快，因为释放资源少。</li>
<li>同一个进程内的线程切换比进程快，因为他们共享资源多，切换的东西少。</li>
<li>线程间数据交互效率更高，因为不需要经过内核。</li>
</ul>
<p>线程共享资源：</p>
<ul>
<li>代码段、数据段</li>
<li>文件描述符表</li>
<li>信号处理函数</li>
<li>当前工作目录</li>
<li>用户ID和组ID</li>
</ul>
<p>独占资源：记前三点差不多了吧</p>
<ul>
<li>线程id</li>
<li>处理器现场和内核栈指针</li>
<li>独立的用户栈空间</li>
<li>errno</li>
<li>信号屏蔽字</li>
<li>调度优先级</li>
</ul>
<p>优点：</p>
<ul>
<li>提高程序并发</li>
<li>开销小</li>
<li>数据通信、共享方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>库函数支持，不稳定</li>
<li>调试、编写困难，gdb不支持</li>
<li>对信号支持不好</li>
</ul>
<p>线程的实现：</p>
<ul>
<li><p>用户线程：用户空间实现的线程，由用户态的线程库管理。</p>
<ul>
<li>优点：<ul>
<li>进程私有TCB列表，由用户级线程库函数维护，可用于不支持线程技术的操作系统。</li>
<li>线程切换也是由线程库函数完成，速度快。</li>
</ul>
</li>
<li>缺点：<ul>
<li>如果一个线程发起系统调用而阻塞，那进程所包含的用户线程都不能执行。</li>
<li>一个进程中的线程无法互相抢占CPU，因为只有操作系统有这个特权，但操作系统不参与调度用户线程。</li>
<li>时间片只分配给进程，所以线程得到的时间片少。</li>
</ul>
</li>
</ul>
</li>
<li><p>内核线程：内核中实现的线程，由内核管理。</p>
<ul>
<li>优点：<ul>
<li>一个进程中某线程的阻塞不影响其他线程。</li>
<li>多线程的进程获得更多CPU运行时间。</li>
</ul>
</li>
<li>缺点：<ul>
<li>支持内核线程的操作系统中由内核维护TCB、PCB，占用内核空间。</li>
<li>线程创建终止和切换都是通过系统调用进行，系统开销大。</li>
</ul>
</li>
</ul>
</li>
<li><p>轻量级进程LWP：在内核中支持用户线程，每个LWP由一个内核线程支持（CPU资源分配、调度），由内核管理并像普通进程一样被调度，用户线程运行在LWP上。一个LWP可以对应一个或多个用户线程。</p>
</li>
</ul>
<h2 id="5-线程调度"><a href="#5-线程调度" class="headerlink" title="5. 线程调度"></a>5. 线程调度</h2><p>可以根据如何处理时钟中断分为非抢占式调度算法与抢占式调度算法。抢占式调度需要在时间间隔末端发生时钟中断，以便把CPU控制返回给调度程序。</p>
<p>调度原则：</p>
<ul>
<li>CPU利用率：确保CPU始终匆忙，提高CPU利用率。</li>
<li>系统吞吐量：单位时间内CPU完成进程的数量。</li>
<li>周转时间：进程运行+阻塞+等待事件总和。</li>
<li>等待时间：进程处于就绪队列的时间。</li>
<li>响应时间：用户提交到系统第一次产生相应花费的时间。</li>
</ul>
<p>FCFS先来先服务算法、SJF最短作业优先算法、HRRN高响应比优先算法、RR时间片轮转算法、HPF最高优先级算法。</p>
<p>多级反馈队列算法：</p>
<ul>
<li>多个队列，优先级由高到低，优先级越高时间片越短。</li>
<li>如果有新的进程加入优先级高的队列，立刻停止当前正在运行的进程转而运行优先级高的队列。</li>
<li>新进程加入第一级末尾，按FCFS等待调度，如果第一级队列的进程没有运行完，就加入第二级队列的末尾，以此类推。</li>
</ul>
<h2 id="6-★-进程-线程通信方式"><a href="#6-★-进程-线程通信方式" class="headerlink" title="6. ★ 进程/线程通信方式"></a>6. ★ 进程/线程通信方式</h2><p>进程：目的主要是为了交换数据</p>
<ul>
<li>匿名管道：通信数据是无格式的流且大小受限，单向通信，只能用于存在公共祖先关系的进程间通信。</li>
<li>命名管道：提供名称与之关联，不存在亲缘关系的进程只要能访问管道文件，也能相互通信。只读/只写管道不会单独存在，一旦被打开就会阻塞，直到另一个进程打开只写/只读管道。<ul>
<li>管道是半双工的，只有一方写一方读。</li>
<li>速度慢、传输消息少。</li>
<li>不用担心互斥问题。</li>
</ul>
</li>
<li>消息队列：保存在内核中的消息链表。消息不及时；不适合大文件传输，每条消息和队列总长度有上限；通信过程中存在内核态与用户态的数据拷贝开销。<ul>
<li>速度慢、传输消息少。</li>
<li>存在拷贝开销。</li>
</ul>
</li>
<li>共享内存：使一个磁盘文件与存储空间的一个缓冲区相映射。<strong>最快的通信方式</strong>，但多进程竞争同一资源会造成数据错乱。<ul>
<li>速度最快。</li>
<li>需要注意互斥。</li>
</ul>
</li>
<li>信号量：访问互斥与进程同步。<ul>
<li>只用于同步，传递消息需要结合其他机制。</li>
</ul>
</li>
<li>信号：异步通信机制，用于进程和内核间直接交互。简单；携带信息少；满足特定条件时发送。进程有三种方式响应信号：执行默认操作；捕捉；忽略。<ul>
<li>传输消息少。</li>
<li>用户态与内核态切换开销大。</li>
</ul>
</li>
<li>套接字：网络通信，也可以自连接。</li>
</ul>
<p>线程：目的主要是为了互斥/同步</p>
<ul>
<li>锁机制：互斥锁/条件变量/读写锁。</li>
<li>信号量。</li>
<li>volatile内存共享。</li>
</ul>
<h2 id="7-线程冲突问题"><a href="#7-线程冲突问题" class="headerlink" title="7. 线程冲突问题"></a>7. 线程冲突问题</h2><h3 id="1-生产者-消费者问题"><a href="#1-生产者-消费者问题" class="headerlink" title="1. 生产者-消费者问题"></a>1. 生产者-消费者问题</h3><h3 id="2-哲学家就餐问题"><a href="#2-哲学家就餐问题" class="headerlink" title="2. 哲学家就餐问题"></a>2. 哲学家就餐问题</h3><p>设计方案</p>
<ul>
<li>用叉子设置信号量，对某个哲学家必须同时P成功两边的信号量才能用餐，用餐完V。但是如果每个哲学家同时拿起自己左边的叉子，就会死锁。</li>
<li>在P叉子前加个互斥信号量上锁。但是同时只有一个哲学家能动。</li>
<li>在方案一的基础上做改进，奇数编号的哲学家先P左边的叉子，偶数编号的哲学家先P右边的叉子。</li>
<li>信号量表示哲学家，同时用一个数组表示哲学家状态。每位哲学家只有当两个邻居都没有进餐时才能进餐；每位哲学家进餐完毕时唤醒邻居。</li>
</ul>
<h3 id="3-读者-写者问题"><a href="#3-读者-写者问题" class="headerlink" title="3. 读者-写者问题"></a>3. 读者-写者问题</h3><ul>
<li>读者优先：有读者进入就试图P写者，最后一个读者出去时才V写者。</li>
<li>写者优先：有写者进入时P读者访问临界区的锁，保证后续不会有读者进入；写者写数据用另外的锁保证互斥。</li>
<li>公平：在读者优先的基础上，读者/写者进入时先P额外的共同信号量。</li>
</ul>
<h2 id="8-★-死锁"><a href="#8-★-死锁" class="headerlink" title="8. ★ 死锁"></a>8. ★ 死锁</h2><p>死锁的四要素：</p>
<ul>
<li>互斥条件：多个线程不能同时使用同一资源。</li>
<li>持有并等待：线程等待其他资源时不会释放已拥有的资源。</li>
<li>不可剥夺：线程持有资源时不能被其他线程获取。</li>
<li>环路等待：多个线程需求的资源被其他线程所持有，构成环形需求链。</li>
</ul>
<p>处理死锁问题：</p>
<ul>
<li>鸵鸟策略：因为解决死锁问题代价很高，所以不解决。</li>
<li>检测恢复：资源指向进程表示资源已分配给进程，进程指向资源表示进程请求获取资源。从一个结点开始dfs检测是否有环。如何恢复：<ul>
<li>抢占、回滚、杀死进程</li>
</ul>
</li>
</ul>
<p>要避免死锁问题，只要破坏前面的一个条件就行了。最常见且可行的方法是<strong>资源有序分配法</strong>，破坏环路等待条件。</p>
<p>资源有序分配法：将资源编号进行排序，所有线程获取资源必须按照相同的编号顺序获取。</p>
<p>操作系统检测死锁：</p>
<p>检测时机</p>
<ul>
<li>定时检索</li>
<li>进程阻塞时</li>
<li>系统资源利用率下降时</li>
</ul>
<p>检测方法：资源分配图法</p>
<ul>
<li>进程节点申请资源节点，资源-&gt;进程。</li>
<li>进程节点占有资源节点，进程-&gt;资源。</li>
<li>找到没有资源指向其的进程节点，释放其与其关联的边。</li>
<li>将相应资源分配给一个等待该资源的进程，即将其申请边变为占有边。</li>
<li>重复以上步骤，直到最后图中仍有边且不能再简化，此时即存在死锁。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>撤销所有死锁进程</li>
<li>连续撤销死锁进程直到不再存在死锁</li>
<li>连续剥夺资源直到不再存在死锁</li>
</ul>
<h2 id="9-锁"><a href="#9-锁" class="headerlink" title="9. 锁"></a>9. 锁</h2><h3 id="1-互斥锁-自旋锁"><a href="#1-互斥锁-自旋锁" class="headerlink" title="1. 互斥锁/自旋锁"></a>1. 互斥锁/自旋锁</h3><p>互斥锁加锁失败后，线程会释放CPU给其他线程；自旋锁加锁失败后，线程会忙等待，直到拿到锁。</p>
<p>互斥锁加锁失败后，会有两次线程上下文切换的成本：把CPU切给其他线程运行；锁被释放时切给该线程运行。</p>
<p>自旋锁通过CPU提供的CAS函数在用户态完成加锁和解锁，CAS函数使用原子指令，查看锁状态，如果锁空闲则设置为当前线程持有。在单核CPU上需要有抢占式调度器，否则自旋线程永远不会放弃CPU导致死锁。</p>
<p>如果能确定被锁住的代码执行时间短（相对于上下文切换），就用自旋锁而不用互斥锁。</p>
<h3 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="2. 读写锁"></a>2. 读写锁</h3><p>在读多写少的场景有优势，可分为读优先锁和写优先锁：</p>
<ul>
<li>读优先锁：只要有读线程存在，写线程获取写锁就会被阻塞，而后面来的读线程依然可以获取读锁。</li>
<li>写优先锁：如果有写线程有写锁或被阻塞，后来的读线程要被阻塞。</li>
<li>公平：读写线程获取锁前都需要先在公共队列上排队（可通过信号量实现）。</li>
</ul>
<h3 id="3-乐观锁-悲观锁"><a href="#3-乐观锁-悲观锁" class="headerlink" title="3. 乐观锁/悲观锁"></a>3. 乐观锁/悲观锁</h3><p>乐观锁：先修改资源，再验证这段时间内有没有冲突，如果有冲突就放弃操作。使用CAS或版本号控制实现。CAS在硬件层面上保证原子性，由CPU支持。</p>
<p>悲观锁：先上锁再访问共享资源。</p>
<p>乐观锁重试成本很高，所以只有在冲突概率很低且加锁成本很高时才用乐观锁。</p>
<p>乐观锁/CAS应用：<strong>无锁队列</strong></p>
<p>ABA问题：</p>
<ul>
<li>进程P1在共享变量中读到值A。</li>
<li>P2抢占，将A改为B再改回A。</li>
<li>P1抢占，看到A没变，继续执行。（A如果是地址，其内的数据可能已改变）</li>
</ul>
<p>解决：计数/版本号</p>
<h3 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4. 条件变量"></a>4. 条件变量</h3><p>条件变量也是锁，能弥补互斥锁只有锁定和非锁定两种状态的缺点。当条件不满足时，线程揭开相应的互斥锁，等待条件发生变化。一旦某个线程改变了条件变量，就会通知相应的条件变量唤醒数个正被此条件变量阻塞的线程。</p>
<p>互斥锁是线程间互斥的机制，而条件变量是同步的机制。</p>
<h3 id="5-CAS是乐观锁，为什么基于CAS实现的自旋锁是悲观锁？"><a href="#5-CAS是乐观锁，为什么基于CAS实现的自旋锁是悲观锁？" class="headerlink" title="5. CAS是乐观锁，为什么基于CAS实现的自旋锁是悲观锁？"></a>5. CAS是乐观锁，为什么基于CAS实现的自旋锁是悲观锁？</h3><p>自旋锁基于CAS加了while或睡眠操作来实现自旋效果，需要事先拿到锁才能修改数据，所以算悲观锁。</p>
<h2 id="10-线程崩溃与进程崩溃"><a href="#10-线程崩溃与进程崩溃" class="headerlink" title="10. 线程崩溃与进程崩溃"></a>10. 线程崩溃与进程崩溃</h2><p>C/C++中由于非法访问内存导致的线程崩溃会引起进程崩溃。因为进程中线程的地址空间共享，某个线程的非法访问会导致内存的不确定性，进而影响到其他线程，操作系统认为可能导致严重后果。</p>
<p>是通过信号机制引起进程崩溃的。操作系统收到信号后执行相应的信号处理函数。</p>
<p>在Java中因为自定义了相应的信号处理函数，所以线程崩溃不会导致进程崩溃。虚拟机不选择退出，而是内部做了额外处理，恢复了线程执行，且抛出StackoverflowError和NPE。</p>
<h2 id="11-进程通信与线程通信"><a href="#11-进程通信与线程通信" class="headerlink" title="11. 进程通信与线程通信"></a>11. 进程通信与线程通信</h2><p>进程通信：</p>
<ul>
<li>管道：匿名、命名</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享内存</li>
<li>信号</li>
<li>内存映射</li>
<li>Socket：更为通用，可用于不同机器</li>
</ul>
<p>线程通信：主要是为了线程同步，所以没有数据交换的通信机制。</p>
<ul>
<li>Linux<ul>
<li>信号</li>
<li>锁机制</li>
<li>条件变量</li>
<li>信号量</li>
</ul>
</li>
<li>windows<ul>
<li>全局变量</li>
<li>Message消息机制</li>
<li>CEvent对象</li>
</ul>
</li>
</ul>
<h2 id="12-协程"><a href="#12-协程" class="headerlink" title="12. 协程"></a>12. 协程</h2><h3 id="1-产生原因"><a href="#1-产生原因" class="headerlink" title="1. 产生原因"></a>1. 产生原因</h3><p>线程数量非常多，且需要等待IO时，会产生问题。系统线程占用非常多的空间；过多的线程切换会占用大量的系统时间。</p>
<ul>
<li>节省CPU，避免内核级线程的频繁切换造成CPU浪费。</li>
<li>节约内存。</li>
<li>稳定性，避免线程崩溃导致的同一进程内的所有线程崩溃。</li>
<li>开发效率，可方便地将一些耗时IO操作异步化。</li>
</ul>
<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h3><p>是一个函数，可以暂停与恢复执行。其状态与任何线程都无关。</p>
<p>与普通函数的区别：堆上保存状态，调用时在栈上分配空间后，保存一个引用指向堆上的状态。协程暂停时，将当前执行的代码位置记录到堆的状态中，回收栈上的空间。</p>
<p><strong>协作式调度</strong>的<strong>用户态线程。</strong></p>
<p>由开发人员决定协程的栈和上下文切换。</p>
<p>协作式调度：当前线程完全占用CPU时间且不可被抢占，与抢占式调度相对应。抢占式调度执行顺序无法确定，所以同步问题很麻烦，而协程不存在该问题。</p>
<p>协程运行在线程里，分时复用线程，不会增加线程的数量，且只在用户态切换。</p>
<p>协程在IO阻塞时再让出CPU，当IO就绪后主动占用CPU，牺牲任务执行的公平性换取吞吐量。协程能保留上一次调用时的状态。</p>
<p>优点：</p>
<ul>
<li>用户态：无需内核态切换，节省开销</li>
<li>非抢占：无需原子操作锁定与同步，不用担心资源共享的问题</li>
<li>单线程：单线程即可实现高并发</li>
</ul>
<p>缺点：</p>
<ul>
<li>用户态：协程的控制权由用户决定，不安全</li>
<li>非抢占：一个协程被阻塞，则整个线程都被阻塞，所以必须搭配非阻塞IO使用；容易导致饥饿问题</li>
<li>单线程：无法将一个线程的多个协程分摊到多核CPU</li>
</ul>
<h2 id="13-管程"><a href="#13-管程" class="headerlink" title="13. 管程"></a>13. 管程</h2><h3 id="1-提出原因"><a href="#1-提出原因" class="headerlink" title="1. 提出原因"></a>1. 提出原因</h3><p>采用信号量及PV同步机制编写并发程序，对于共享变量与信号量的操作将被分散于各个进程中，存在以下缺点：</p>
<ul>
<li>程序易读性差：判断对一组共享变量/信号量的操作是否正确，需要通读整个系统。</li>
<li>程序不利于修改和维护：任意代码的修改都可能影响全局。</li>
<li>正确性难以保证：并发程序通常很大，复杂系统很难没有逻辑错误。</li>
<li>同步操作不当可能导致死锁。</li>
</ul>
<h3 id="2-定义-1"><a href="#2-定义-1" class="headerlink" title="2. 定义"></a>2. 定义</h3><p>代表共享资源的数据结构和对该共享数据结构实施操作的一组过程，它们组成的资源管理程序。管程中多个子程序形成的多个工作线程互斥访问共享资源，且在一个时间点最多只有一个线程在执行管程的某个子程序。</p>
<p>翻译：定义管程类，封装临界区以及对临界区的操作。</p>
<p>管程有如下特征：</p>
<ul>
<li>模块化：一个管程是一个基本程序单位，可单独编译。</li>
<li>抽象数据类型：管程包含了数据以及对数据操作的方法，类似于类。</li>
<li>信息隐蔽：管程是半透明的，实现的功能在外部不可见。</li>
<li>使用的互斥性：任何时候，管程只能由一个线程使用，互斥性由编译器负责完成。</li>
</ul>
<h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3. 组成"></a>3. 组成</h3><ul>
<li>多个彼此可交互并共用资源的线程</li>
<li>多个与资源使用有关的变量</li>
<li>一个互斥锁</li>
<li>一个用来避免竞态条件的不变量</li>
</ul>
<h3 id="4-工作过程"><a href="#4-工作过程" class="headerlink" title="4. 工作过程"></a>4. 工作过程</h3><p>enter过程：一个进程进入管程前要提出申请。</p>
<p>leave过程：当一个进程离开管程时，如果紧急队列不为空，就必须唤醒其中一个进程。</p>
<p>条件型变量c：指向一个等待该条件的PCB队列的指针。</p>
<p>wait(c)：为进入管程的进程分配某种类型的资源，如果此时这种资源可用则进程使用，否则进程被阻塞，进入紧急队列。</p>
<p>signal(c)：进入管程的进程使用的某种资源要释放，进程会唤醒由于等待这种资源而进入紧急队列的第一个进程。</p>
<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5. 优缺点"></a>5. 优缺点</h3><p>优点：</p>
<ul>
<li>可以以函数库的形式实现，比信号量好控制。</li>
<li>增强模块的独立性。</li>
<li>提高代码的可读性、可维护性。</li>
</ul>
<p>缺点：大多数编程语言没有实现管程。</p>
<h2 id="14-线程回收"><a href="#14-线程回收" class="headerlink" title="14. 线程回收"></a>14. 线程回收</h2><ul>
<li>等待线程结束：pthread_join，主线程调用后等待子线程退出并回收其资源</li>
<li>结束线程：pthread_exit，线程执行后不释放资源而直接结束。子线程执行，结束当前线程并传递返回值，可被pthread_join获得</li>
<li>分离线程：pthread_detach，主线程、子线程均可调用，主线程传入子线程id，子线程传入self，调用后和主线程分离，子线程结束时立刻回收自己资源。</li>
</ul>
<h2 id="15-特殊进程"><a href="#15-特殊进程" class="headerlink" title="15. 特殊进程"></a>15. 特殊进程</h2><h3 id="1-孤儿进程"><a href="#1-孤儿进程" class="headerlink" title="1. 孤儿进程"></a>1. 孤儿进程</h3><p>父进程先退出，子进程还没退出，子进程将成为孤儿进程，被init1号进程收养。</p>
<h3 id="2-僵尸进程"><a href="#2-僵尸进程" class="headerlink" title="2. 僵尸进程"></a>2. 僵尸进程</h3><p>子进程先退出，父进程还没退出，子进程必须等到父进程捕获到子进程的退出状态才真正结束，在这之前子进程成为僵尸进程。</p>
<p>僵尸态的目的是为了维护子进程的信息，以便父进程在以后某个时间获取。</p>
<p>这些僵尸进程将在父进程退出时被1号进程收养，然后被清理。</p>
<p>子进程停止在僵尸态会占据内核资源，需要避免僵尸进程产生或立即结束僵尸态。</p>
<h3 id="3-守护进程"><a href="#3-守护进程" class="headerlink" title="3. 守护进程"></a>3. 守护进程</h3><p><strong>在后台运行、没有控制终端与之相连</strong>的进程，周期性执行某种任务。Linux大部分服务器就是用守护进程的方式实现的，如web服务器进程http。</p>
<p>特殊的孤儿进程。</p>
<p>创建方式：</p>
<ol>
<li>让程序在后台运行：调用fork，然后父进程退出</li>
<li>摆脱父进程的控制终端、登录会话和进程组：调用setsid创建新对话期，使自己成为新的会话组长和进程组长。</li>
<li>禁止进程重新打开控制终端：再通过fork创建新的子进程，然后调用fork的进程退出。</li>
<li>关闭不需要的文件描述符：先获得最高文件描述符值，然后递减遍历，关闭所有文件描述符。</li>
<li>将当前目录更改为根目录。</li>
<li>进程从父进程继承了文件创建屏蔽字，可能修改守护进程创建的文件存取权限，所以unmask(0)清文件创建屏蔽字。</li>
<li>处理SIGCHLD信号，使得子进程结束时不会产生僵尸进程。</li>
</ol>
<h2 id="16-避免僵尸进程"><a href="#16-避免僵尸进程" class="headerlink" title="16. 避免僵尸进程"></a>16. 避免僵尸进程</h2><ul>
<li>signal(SIGCHLD, ISG_IGN)通知内核对子进程的结束不关心，由内核回收</li>
<li>waitpid传递WNOHANG使父进程不阻塞立即返回</li>
<li>如果父进程很忙，可用signal注册信号处理函数，在其中调用waitpid等待子进程退出</li>
<li>调用两次fork，子进程退出后孙进程由1号进程收养</li>
</ul>
<h2 id="17-子进程对父进程的继承"><a href="#17-子进程对父进程的继承" class="headerlink" title="17. 子进程对父进程的继承"></a>17. 子进程对父进程的继承</h2><p>继承：</p>
<p>进程的资格、环境、堆栈、内存、进程组号</p>
<p>独有：</p>
<p>进程号、父进程号、资源使用</p>
<h2 id="18-进程组与会话、作业"><a href="#18-进程组与会话、作业" class="headerlink" title="18. 进程组与会话、作业"></a>18. 进程组与会话、作业</h2><p>进程组：多个进程的集合，其中有一个组长，其进程PID等于进程组的PGID。只要组中有一个进程存在，该组就存在。</p>
<p>会话：一个或多个进程组的集合，可以有一个控制终端。在xshell或WinSCP中打开一个窗口就是新建一个会话。</p>
<p>前后台作业：可以由多个进程组成。只能运行一个前台作业，因为在前台新起一个作业时，shell就被提到后台，就没法再继续接受指令解析运行。</p>
<p>作业与进程的区别：如果作业中某个进程创建了子进程，该子进程不属于该作业。</p>
<h2 id="19-进程的终止"><a href="#19-进程的终止" class="headerlink" title="19. 进程的终止"></a>19. 进程的终止</h2><ol>
<li>main函数自然返回</li>
<li>C函数库中的exit</li>
<li>系统调用中的_exit（对比exit少了调用终止处理程序与清除IO缓冲两步，直接返回内核）</li>
<li>abort函数，异常程序终止，同时发送SIGABRT信号给调用进程</li>
<li>接受能导致进程终止的信号，如ctrlc、SIGINT</li>
</ol>
<h2 id="20-不可重入函数"><a href="#20-不可重入函数" class="headerlink" title="20. 不可重入函数"></a>20. 不可重入函数</h2><p>不同任务调用该函数时可能修改其他任务调用这个函数的数据。</p>
<p>特点：</p>
<ul>
<li>使用了静态数据结构。</li>
<li>操作了堆（malloc/free）</li>
<li>调用了标准IO函数。</li>
</ul>
<h2 id="21-线程的分离态"><a href="#21-线程的分离态" class="headerlink" title="21. 线程的分离态"></a>21. 线程的分离态</h2><p>在pthread_create创建线程后马上调用pthread_detach将线程设置为分离态，这样它运行结束后会自己终止线程并释放系统资源。</p>
<p>如果有线程运行非常快，可能在pthread_create返回前终止，并将线程号和系统资源移交给其他线程，从而导致pthread_create返回错误的线程号。</p>
<p>解决方法是使用同步措施，如在被创建的线程里调用pthread_cond_timedwait函数，让线程等待足够的时间直到pthread_create返回。</p>
<h2 id="22-多线程与多进程的比较"><a href="#22-多线程与多进程的比较" class="headerlink" title="22. 多线程与多进程的比较"></a>22. 多线程与多进程的比较</h2><p>多进程：</p>
<p>优点：</p>
<ul>
<li>进程相互独立，不影响主程序稳定性</li>
<li>可通过增加CPU扩充性能</li>
<li>尽量减少线程加锁解锁的影响</li>
<li>进程分配的时间与空间资源多</li>
</ul>
<p>缺点：</p>
<ul>
<li>逻辑控制复杂，需要与主程序交互</li>
<li>需要跨进程边界，不适合大数据传送，适合小数据传送、密集运算</li>
<li>进程通信、调度开销大</li>
</ul>
<p>多线程：</p>
<p>优点：</p>
<ul>
<li>无需跨进程边界</li>
<li>程序逻辑和控制方式简单</li>
<li>线程可直接共享内存和变量等</li>
<li>消耗总资源占优</li>
</ul>
<p>缺点：</p>
<ul>
<li>线程与主程序共用地址空间</li>
<li>线程同步与锁机制麻烦</li>
<li>一个线程崩溃影响同一进程下的所有线程</li>
<li>增加CPU数目能提升的总性能有限</li>
</ul>
<h2 id="23-用户态和内核态的切换"><a href="#23-用户态和内核态的切换" class="headerlink" title="23. 用户态和内核态的切换"></a>23. 用户态和内核态的切换</h2><p>分态的目的：保护操作系统安全，防止某些关键信息被修改。</p>
<p>切换场景：系统调用；异常；中断。本质上都是一样的步骤。</p>
<p>切换过程/开销：</p>
<ul>
<li>从当前进程描述符中取出内核栈信息。</li>
<li>用内核栈将当前进程的段信息、栈信息、状态保存，同时完成用户栈到内核栈的切换。</li>
<li>将中断向量检索得到的中断处理程序的段、代码起始位置装入寄存器，开始执行中断处理程序。这样就转到内核态的程序执行了。</li>
</ul>
<p>内核态回用户态：iret</p>
<ul>
<li>将压栈的用户态信息弹出，加载到对应位置。</li>
<li>切换成用户态，从上次中断处开始执行。</li>
</ul>
<h2 id="24-RingBuffer"><a href="#24-RingBuffer" class="headerlink" title="24. RingBuffer"></a>24. RingBuffer</h2><p>Linux内核kfifo实现方式为RingBuffer，即环形缓冲区。</p>
<p>通过镜像指示位来判断读写索引相同时是满还是空。（大小设置为2的幂时，下标最高位就能当指示位，不需要额外指示位）</p>
<p>多线程/进程对同一个环形缓冲区读写时，需要加锁，但只有一个读线程/进程和一个写线程/进程时，不用加锁。</p>
<p><img src="https://pic2.zhimg.com/80/v2-22cba7a9b8ff0746184d752a63621981_720w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-22cba7a9b8ff0746184d752a63621981_720w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<h2 id="25-信号"><a href="#25-信号" class="headerlink" title="25. 信号"></a>25. 信号</h2><p>信号由操作系统发送给进程。</p>
<p>信号识别与信号处理函数写在进程源代码中。</p>
<h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><p>操作系统发来信号，进程保存信号。</p>
<ul>
<li>如果信号被阻塞，先保存。</li>
<li>如果信号不阻塞，在合适的时机递达信号。</li>
<li>递达信号后，进程可：<ul>
<li>执行默认信号处理函数。</li>
<li>忽略信号。</li>
<li>执行自定义信号处理函数。</li>
</ul>
</li>
</ul>
<h3 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h3><p>操作系统向进程控制块中的信号位图写入。</p>
<p>判断信号是否阻塞，同样也有一个对应的位图。</p>
<h2 id="26、作业和进程"><a href="#26、作业和进程" class="headerlink" title="26、作业和进程"></a>26、作业和进程</h2><p>区别：</p>
<ul>
<li>作业是用户向计算机提交任务的任务实体，进程是完成用户任务的执行实体</li>
<li>一个作业由一个或多个进程组成</li>
<li>作业概念主要用于批处理系统，分时系统中不存在这个概念</li>
</ul>
<h2 id="27、管道"><a href="#27、管道" class="headerlink" title="27、管道"></a>27、管道</h2><p>对管道进行操作与对应结果</p>
<ul>
<li>读管道<ul>
<li>管道中有数据：读出所有数据</li>
<li>管道中无数据<ul>
<li>管道写端未关闭：阻塞等待</li>
<li>管道写端关闭：返回0</li>
</ul>
</li>
</ul>
</li>
<li>写管道<ul>
<li>管道读端关闭：进程异常终止</li>
<li>管道读端未关闭<ul>
<li>管道已满：阻塞等待</li>
<li>管道未满：写入数据，返回实际写入的字节数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="28、惊群现象"><a href="#28、惊群现象" class="headerlink" title="28、惊群现象"></a>28、惊群现象</h2><p>惊群现象：多个线程等待同一资源时，只要有一个资源到来，所有线程都来竞争资源。</p>
<p>后果：无效调度、上下文频繁切换，影响系统性能；为确保只有一个线程得到资源，需要加锁，产生额外开销。<br>典型：socket accept，多个用户线程监听同一个端口。<br>解决：</p>
<ol>
<li>Linux2.6前：监听同一个socket的线程挂在一个等待队列上，请求到来时唤醒所有子线程，使用锁解决。</li>
<li>后：引入标记位。<ol>
<li>进程加入等待队列时，如果有标记位，被添加到队列尾部，否则到队列首部。</li>
<li>wake唤醒第一个有标记的进程后停止。</li>
</ol>
</li>
</ol>
<h1 id="5-调度算法"><a href="#5-调度算法" class="headerlink" title="5. 调度算法"></a>5. 调度算法</h1><h2 id="1-进程调度算法"><a href="#1-进程调度算法" class="headerlink" title="1. 进程调度算法"></a>1. 进程调度算法</h2><ul>
<li>先来先服务</li>
<li>最短作业优先/最短剩余时间优先（抢占式版）</li>
<li>高响应比优先：优先权=（等待时间+要求服务时间）/ 要求服务时间</li>
<li>时间片轮转</li>
<li>最高优先级</li>
<li>多级反馈队列</li>
</ul>
<h2 id="2-内存页面置换算法"><a href="#2-内存页面置换算法" class="headerlink" title="2. 内存页面置换算法"></a>2. 内存页面置换算法</h2><ul>
<li>最佳页面置换算法：置换在未来最长时间不访问，但是因为程序访问页面是动态的，无法预知所以无法实现。用于衡量算法效率，算法效率越接近该算法，说明越高效。</li>
<li>先进先出置换算法</li>
<li>最近最久未使用LRU</li>
<li>时钟页面置换：FIFO改进版，页面保存在环形链表中，指针指向的页访问位为1则清除访问位，为0则淘汰页。</li>
<li>改进时钟页面置换：考虑到如果页面没有被修改，就不需要写回，因此增加了修改位。优先淘汰未被修改的，在修改状态相同时优先淘汰未被访问的。</li>
<li>最不常用LFU：访问次数最少的页。会存在过去时间访问次数很高，但是近期不访问的页。改进：定期减少访问次数，比如在时钟中断时将访问次数除以2。</li>
</ul>
<p>belady异常：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象 。FIFO不考虑使用频率。</p>
<h2 id="3-磁盘调度算法"><a href="#3-磁盘调度算法" class="headerlink" title="3. 磁盘调度算法"></a>3. 磁盘调度算法</h2><ul>
<li>先来先服务</li>
<li>最短寻道时间优先：贪心，但可能存在饥饿问题。</li>
<li>扫描算法：一次只往一个方向扫描，直到到达最大/最小磁盘号再折返（最小是0而不是序列最小）。</li>
<li>循环扫描：按照特定方向扫描，扫描一遍后返回时直接复位而不处理任何请求。即只响应一个方向的请求。</li>
<li>LOOK：扫描算法的优化：移动到最远的请求（该方向上没有其他请求）就折返。</li>
<li>C-LOOK：循环扫描的优化。</li>
</ul>
<h2 id="4-动态分区分配算法"><a href="#4-动态分区分配算法" class="headerlink" title="4. 动态分区分配算法"></a>4. 动态分区分配算法</h2><p>找到一块适宜大小的内存，将用户程序装入其中</p>
<ul>
<li>首次适应算法：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。<ul>
<li>算法开销小</li>
<li>但是会使内存低地址部分产生很多碎片。</li>
</ul>
</li>
<li>最佳适应算法：空闲分区容量按次序递增，然后首次适应算法，保证大进程到来时有连续的大片空间。<ul>
<li>会产生很多难以利用的小碎片。</li>
<li>算法开销大，每次回收需要重新排序。</li>
</ul>
</li>
<li>最坏适应算法：空闲分区容量按次序递减，然后首次适应算法。解决最佳适应算法的碎片问题。<ul>
<li>但是无法满足可能的大进程需求。</li>
<li>算法开销大，每次回收需要重新排序。</li>
</ul>
</li>
<li>邻近适应算法：每次查找都从上次结束的位置，然后首次适应算法。</li>
</ul>
<h1 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6. 文件系统"></a>6. 文件系统</h1><p>磁盘划分分区，每个分区有一个独立的文件系统。</p>
<p>磁盘0号扇区为主引导记录MBR，MBR结尾是分区表，给出每个分区的起始结束地址。</p>
<p>计算机被引导时，BIOS读入并执行MBR，MDRB确定活动分区，读入其第一个块，称为引导块，并执行。引导块中的程序将装载该分区中的操作系统。</p>
<p>有两种数据结构可以代表一个文件：</p>
<ul>
<li><strong>索引节点inode</strong>：记录文件的元信息，如inode编号、文件大小、访问权限、创建修改时间、数组在磁盘的位置等。索引节点是文件的唯一标识。</li>
<li><strong>目录项dentry</strong>：记录文件的名字、索引节点指针以及其他与目录项的层级关联关系。目录项是由内核维护的，缓存在内存。</li>
</ul>
<p>一个索引节点可以对应一个或多个目录项。目录项相当于是文件在内存中的缓存。</p>
<p>磁盘读写的最小单位是扇区，最小512B，文件系统将多个扇区组成一个逻辑块，每次读写最小单位是逻辑块，Linux中为4KB。</p>
<p>磁盘格式化时会分成三个存储区域：</p>
<ul>
<li>超级块，存储文件的详细信息，如块个数、块大小、空闲块等。文件系统挂载时进入内存。</li>
<li>索引节点区，存储索引节点。文件被访问时进入内存。</li>
<li>数据块区，存储文件或目录数据。</li>
</ul>
<h2 id="1-虚拟文件系统VFS"><a href="#1-虚拟文件系统VFS" class="headerlink" title="1. 虚拟文件系统VFS"></a>1. 虚拟文件系统VFS</h2><p>大概分为三类，首先要挂载到某个目录才能正常使用：</p>
<ul>
<li>磁盘文件系统</li>
<li>内存文件系统</li>
<li>网络文件系统，用来访问其他计算机主机数据的文件系统。</li>
</ul>
<p>操作系统为每个进程维护一个打开文件表，文件表里每一项代表文件描述符，其中维护文件的状态和信息：</p>
<ul>
<li>文件指针：上次读写位置</li>
<li>文件打开计数器：可能有多个进程打开同一文件。计数为0时系统关闭文件，删除该条目。</li>
<li>文件磁盘位置</li>
<li>访问权限</li>
</ul>
<h2 id="2-文件存储"><a href="#2-文件存储" class="headerlink" title="2. 文件存储"></a>2. 文件存储</h2><ul>
<li>顺序分配<ul>
<li>访问磁盘1次。</li>
<li>优点：存取速度快，可随机访问</li>
<li>缺点：要求连续存储空间，会产生外部碎片，不方便动态扩充。</li>
</ul>
</li>
<li>链表分配<ul>
<li>访问磁盘n（文件占用的数据块个数）次。</li>
<li>优点：无外部碎片，动态扩充方便。</li>
<li>缺点：只能顺序访问，查找效率低，指针也要占额外空间。</li>
</ul>
</li>
<li>索引分配<ul>
<li>m级须访问m + 1次。</li>
<li>优点：可随机访问，易于增删</li>
<li>缺点：索引表占额外空间，索引表的查找策略影响文件系统效率。</li>
</ul>
</li>
</ul>
<h3 id="1-连续空间存放"><a href="#1-连续空间存放" class="headerlink" title="1. 连续空间存放"></a>1. 连续空间存放</h3><p>文件存放在连续的物理空间中，文件头指定起始块位置和长度。读写效率很高，但文件长度不易扩展，有磁盘空间碎片。</p>
<h3 id="2-非连续空间存放"><a href="#2-非连续空间存放" class="headerlink" title="2. 非连续空间存放"></a>2. 非连续空间存放</h3><h4 id="1-链表式"><a href="#1-链表式" class="headerlink" title="1. 链表式"></a>1. 链表式</h4><p>隐式链表：文件头包含首尾两块的位置，每个数据块中留出指针空间，存放下一块的位置。</p>
<p>缺点：无法直接访问某数据块，且指针占用空间。如果链表指针丢失，会导致文件数据丢失。指针占用使得每个磁盘块存储字节数不是2的整数次幂，降低运行效率。</p>
<p>显式链接：把用于链接文件各数据块的指针显式存放在一张链接表中，每个表项粗放链接指针指向下一个数据块号。称为文件分配表FAT。</p>
<p>缺点：整张表都要存放在内存中，读写速度快，但也因此不适用于大磁盘。</p>
<h4 id="2-索引式"><a href="#2-索引式" class="headerlink" title="2. 索引式"></a>2. 索引式</h4><p>为每个文件创建一个索引数据块，存放指向文件每个数据块的指针列表，文件头包含指向索引数据块的指针。</p>
<p>优点：文件修改方便、没有碎片问题、支持顺序读写和随机读写。</p>
<p>缺点：文件过小时，索引数据块浪费空间；文件过大，以至于一个索引块放不下所有指针。</p>
<h4 id="3-链式索引块"><a href="#3-链式索引块" class="headerlink" title="3. 链式索引块"></a>3. 链式索引块</h4><p>在索引数据块中留出一个存放下一个索引数据块的指针。</p>
<p>缺点：与链表一样，指针损坏导致无法读取后面数据。</p>
<h4 id="4-多级索引块"><a href="#4-多级索引块" class="headerlink" title="4. 多级索引块"></a>4. 多级索引块</h4><p>索引嵌套</p>
<h3 id="3-Unix文件实现方式"><a href="#3-Unix文件实现方式" class="headerlink" title="3. Unix文件实现方式"></a>3. Unix文件实现方式</h3><p>用于Linux Ext 2/3 文件系统中</p>
<p>根据文件大小存放方式变化：</p>
<ul>
<li>如果存放文件所需数据块小于10块，直接查找。</li>
<li>如果存放文件所需数据块大于10块，采用一级间接索引。</li>
<li>如果上面都不够放，采用二级间接索引。</li>
<li>如果上面都不够放，采用三级间接索引。</li>
</ul>
<p>Inode文件头包含13个指针：</p>
<ul>
<li>10个指向数据块</li>
<li>第11个指向索引块</li>
<li>第12个指向二级索引块</li>
<li>第13个指向三级索引块</li>
</ul>
<h2 id="3-空闲空间管理"><a href="#3-空闲空间管理" class="headerlink" title="3. 空闲空间管理"></a>3. 空闲空间管理</h2><h3 id="1-空闲表法"><a href="#1-空闲表法" class="headerlink" title="1. 空闲表法"></a>1. 空闲表法</h3><p>为所有连续空闲空间建立一张表，维护第一个空闲块号与空闲块个数。请求时顺序搜索直到找到第一个合适的空闲区与。</p>
<p>缺点：有大量小的空闲区时效率很低。</p>
<h3 id="2-空闲链表法"><a href="#2-空闲链表法" class="headerlink" title="2. 空闲链表法"></a>2. 空闲链表法</h3><p>每个空闲块有指针指向下一块。请求时从头部取空闲空间。</p>
<p>缺点：不能随机访问，在链上增加/移动空闲块时要做很多I/O操作，指针消耗空间。</p>
<h3 id="3-位图法"><a href="#3-位图法" class="headerlink" title="3. 位图法"></a>3. 位图法</h3><p>用二进制的一位表示一个块的使用情况。Linux用这种方法管理。</p>
<h2 id="4-文件系统结构"><a href="#4-文件系统结构" class="headerlink" title="4. 文件系统结构"></a>4. 文件系统结构</h2><p>Linux Ext2文件系统由1个引导块和后面的多个块组组成。</p>
<p>最前面的第一个块是引导块，在系统启动时用于启动引导。</p>
<p>块组内容如下：</p>
<ul>
<li>超级块：文件系统重要信息，如inode总个数、块总个数等。</li>
<li>块组描述符：文件系统中各个块组的状态。每个块组都包含了所有块组的组描述符信息。</li>
<li>数据位图和inode位图：表示对应数据块/inode是否空闲。</li>
<li>inode列表：块组中所有inode。</li>
<li>数据块：文件的有用数据。</li>
</ul>
<p>超级块和块组描述符都是全局信息，因为：</p>
<ul>
<li>作为冗余副本，在系统崩溃破坏这两个结构时进行恢复。</li>
<li>使文件和管理数据尽可能接近，减少磁头寻道和旋转。</li>
</ul>
<h2 id="5-目录的存储"><a href="#5-目录的存储" class="headerlink" title="5. 目录的存储"></a>5. 目录的存储</h2><p>普通文件块中保存的是文件数据，目录文件块中保存的是目录中的文件信息。</p>
<p>ext文件系统用哈希表保存文件inode号、文件类型与文件名</p>
<h2 id="6-★-链接"><a href="#6-★-链接" class="headerlink" title="6. ★ 链接"></a>6. ★ 链接</h2><h3 id="1-硬链接"><a href="#1-硬链接" class="headerlink" title="1. 硬链接"></a>1. 硬链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>源文件与目标文件inode号相同，inode中链接数+1。</p>
<p>删除文件时也会减少链接数。链接数为0时，表明没有文件指向该inode，系统回收inode号与对应的block区域。</p>
<p>目录下.与..两个目录项等同于当前目录与父目录的硬链接，所以任何一个目录的硬链接总数总等于子目录总数+2。</p>
<p>inode无法跨越文件系统，所以硬链接同样无法跨越文件系统。只有删除文件的所有硬链接及源文件时，系统才会彻底删除文件。</p>
<h3 id="2-软链接"><a href="#2-软链接" class="headerlink" title="2. 软链接"></a>2. 软链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 源文件 目标文件</span><br></pre></td></tr></table></figure>
<p>重新创建一个inode号不同的文件，目标文件内容是源文件的路径，读取时自动导向源文件。所以可以跨文件系统。</p>
<p>目标文件被删除后链接文件仍然存在，只是指向的文件找不到。</p>
<h3 id="3、inode作用"><a href="#3、inode作用" class="headerlink" title="3、inode作用"></a>3、inode作用</h3><ul>
<li>文件名包含特殊字符无法删除时，可直接删除inode节点</li>
<li>移动、重命名文件夹只需改变文件名，不需改变inode号</li>
<li>打开文件系统后，系统只以inode号识别文件，可以在不关闭软件的情况下更新。新版文件以相同文件名生成新inode号，下次运行时文件名自动指向新版文件，旧版文件inode被回收</li>
</ul>
<h2 id="7-文件I-O"><a href="#7-文件I-O" class="headerlink" title="7. 文件I/O"></a>7. 文件I/O</h2><p>I/O分为两个过程：</p>
<ol>
<li>数据准备（从硬件拷贝到内核空间）</li>
<li>数据从内核空间拷贝到用户进程缓冲区</li>
</ol>
<p>缓冲与非缓冲I/O（是否利用<strong>标准库</strong>的缓存）</p>
<ul>
<li>缓冲I/O利用标准库缓存实现文件的加速访问，标准库再通过系统调用访问文件。</li>
<li>非缓冲I/O直接通过系统调用访问文件。</li>
</ul>
<p>直接与非直接I/O（是否利用<strong>操作系统</strong>的缓存）</p>
<ul>
<li>直接I/O直接经过文件系统访问磁盘。</li>
<li>非直接I/O利用内核缓存与用户程序交互，内核决定什么时候写回。<ul>
<li>调用write后内核缓存数据太多</li>
<li>主动调用fsync</li>
<li>内存十分紧张</li>
<li>数据缓存超过某个时间</li>
</ul>
</li>
</ul>
<p>阻塞与非阻塞I/O</p>
<ul>
<li>阻塞I/O：调用read后线程在过程1、2都一直阻塞，直到完成过程2。</li>
<li>非阻塞I/O：在数据未准备好时立刻返回，应用程序不断轮询内核直到过程1完成，最后一次获得数据的read需要等待过程2。</li>
</ul>
<p>I/O多路复用（select、poll）：通过I/O事件分发，当内核数据准备好后再以事件通知应用程序操作。当前线程阻塞，CPU切换其他线程执行任务，等内核发现有事件到来通知当前线程，遍历socket找到有数据到来的socket，并等待过程2。</p>
<p>优势在于，用户可以在一个线程内同时处理多个socket的IO请求。</p>
<p>阻塞、非阻塞、多路复用都是同步I/O，因为在过程2都需要等待。</p>
<p>异步I/O是过程1、2都不需要等待，应用程序调用read后继续运行，后续直接接到内核拷贝完成的通知，处理数据。</p>
<h2 id="8-Page-Cache"><a href="#8-Page-Cache" class="headerlink" title="8. Page Cache"></a>8. Page Cache</h2><p>write与read实际上都是与内核的Page Cache进行交互。</p>
<p>Linux上供用户可访问的内存分为两个类型：</p>
<ul>
<li>File-backed pages（Page Cache）：文件备份页，对应于磁盘上的若干数据块。<ul>
<li>内存回收代价较低。一方面，其通常对应一个文件的若干顺序块，可以通过顺序I/O的方式落盘；另一方面，因为其对应某个文件的缓存，如果没有写操作甚至不需要回盘。</li>
</ul>
</li>
<li>Anonymous pages：匿名页，进程的运行时内存空间（方法栈、局部变量表等）。<ul>
<li>内存回收代价较高：匿名页通常随机地写入持久化交换设备；为了确保数据不丢失，swap时必须持久化到磁盘。</li>
</ul>
</li>
</ul>
<p>SwapCached也是Page Cache：当匿名页先被交换到磁盘上再加载回内存中时，磁盘还有该匿名页的备份，所以它也可以认为是File-backed pages。</p>
<h3 id="1-Page-Cache与Buffer-Cache"><a href="#1-Page-Cache与Buffer-Cache" class="headerlink" title="1. Page Cache与Buffer Cache"></a>1. Page Cache与Buffer Cache</h3><ul>
<li>Page Cache缓存文件的页数据，页是逻辑上的概念，因此其与<strong>文件系统</strong>同级。在有文件系统的情况下对文件操作，数据缓存到Page Cache。<ul>
<li>Page Cache主要是为了给读文件操作提供缓冲。</li>
</ul>
</li>
<li>Buffer Cache缓存块设备的块数据，块是物理上的概念，因此其与<strong>块驱动设备</strong>同级。直接对磁盘读写，数据缓存到Buffer Cache。<ul>
<li>Buffer Cache主要是为了给写磁盘操作提供缓冲。</li>
</ul>
</li>
</ul>
<p>Linux 2.4版本内核后，如果一个文件的页加载到了Page Cache，那么Buffer Cache只需要维护块指向页的指针，两块缓存<strong>近似融合</strong>。</p>
<h3 id="2-优劣"><a href="#2-优劣" class="headerlink" title="2. 优劣"></a>2. 优劣</h3><p>优势：</p>
<ol>
<li>加快数据访问。</li>
<li>减少I/O次数，提高系统磁盘I/O吞吐量。（缓存、预读）</li>
</ol>
<p>劣势：</p>
<ol>
<li>占用额外物理内存。</li>
<li>对应用层没有提供很好管理的API。</li>
<li>在某些场景下比Direct I/O多一次磁盘读写。</li>
</ol>
<h2 id="9-文件系统性能"><a href="#9-文件系统性能" class="headerlink" title="9. 文件系统性能"></a>9. 文件系统性能</h2><ul>
<li>高速缓存：块高速缓存block cache或缓冲区高速缓存buffer cache</li>
<li>块提前读：读某个块时将其之后的几个块也读入缓存。只适合顺序读取的文件。</li>
<li>减少磁盘臂运动：可能顺序访问的块放一个柱面上。</li>
<li>磁盘碎片整理：移动文件让它们相邻。</li>
</ul>
<h1 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7. 设备管理"></a>7. 设备管理</h1><h2 id="1-设备控制器"><a href="#1-设备控制器" class="headerlink" title="1. 设备控制器"></a>1. 设备控制器</h2><p>CPU通过设备控制器来管理设备，设备控制器是为了屏蔽不同设备之间的差异。</p>
<p>设备控制器里有芯片，可执行自己的逻辑，也有自己的寄存器与CPU通信。</p>
<p>控制器有三类寄存器：</p>
<ul>
<li>数据寄存器，CPU向设备写入需要传输的数据。</li>
<li>命令寄存器：CPU发送命令告诉设备要进行什么操作，任务完成后会将状态寄存器里的状态标记为完成。</li>
<li>状态寄存器：告诉CPU现在已经在工作或者工作已完成。只有工作已完成CPU才能发送下一个字符和命令。</li>
</ul>
<p>输入输出设备分为两大类：</p>
<ul>
<li>块设备，将数据存储在固定大小的块中，每个块有自己的地址，如硬盘、USB。<ul>
<li>通常传输数据量很大，所以控制器设立了一个可读写的数据缓冲区。缓冲区屯够一部分时才让CPU读写数据，减少频繁操作。</li>
</ul>
</li>
<li>字符设备，以字符为单位发送或接收一个字符流，不可寻址也没有寻道操作，如鼠标。</li>
</ul>
<p>CPU用两种方式与控制寄存器和数据缓冲区通信：</p>
<ul>
<li>端口I/O，每个控制寄存器分配一个I/O端口，可通过特殊的汇编指令操作这些寄存器。</li>
<li>内存映射I/O，将所有控制寄存器映射到内存空间中。</li>
</ul>
<h2 id="2-I-O控制方式"><a href="#2-I-O控制方式" class="headerlink" title="2. I/O控制方式"></a>2. I/O控制方式</h2><h3 id="1-轮询等待"><a href="#1-轮询等待" class="headerlink" title="1. 轮询等待"></a>1. 轮询等待</h3><p>CPU一直查询寄存器状态直到标记完成。</p>
<h3 id="2-中断"><a href="#2-中断" class="headerlink" title="2. 中断"></a>2. 中断</h3><p>设备完成任务后触发中断到中断控制器，中断控制器再通知CPU暂停当前任务处理。硬中断就是硬件触发的。</p>
<h3 id="3-DMA"><a href="#3-DMA" class="headerlink" title="3. DMA"></a>3. DMA</h3><p>要求有DMA控制器的硬件支持。工作方式如下：</p>
<ul>
<li>CPU对DMA控制器下发指令，指示读取多少数据以及放在内存哪个地方。</li>
<li>DMA控制器向磁盘控制器发出指令，通知其从磁盘读数据到缓冲区，磁盘控制器将缓冲区数据传输给内存。</li>
<li>磁盘控制器传输完成后，在总线上发送确认成功的信号给DMA控制器。</li>
<li>DMA控制器收到信号后，通过中断通知CPU指令完成，CPU直接使用数据。</li>
</ul>
<p>在传送开始和结束仍需要CPU干预。</p>
<h2 id="3-设备驱动程序"><a href="#3-设备驱动程序" class="headerlink" title="3. 设备驱动程序"></a>3. 设备驱动程序</h2><p>为了屏蔽设备控制器的差异。属于操作系统的一部分，提供统一接口给操作系统。</p>
<p>设备驱动程序处理设备产生的中断，根据设备驱动初始化时注册的中断处理程序进行处理。</p>
<h2 id="4-通用块层"><a href="#4-通用块层" class="headerlink" title="4. 通用块层"></a>4. 通用块层</h2><p>减少不同块设备的差异带来的影响。</p>
<p>通用块层的功能：</p>
<ul>
<li>向上为文件系统和应用程序提供访问块设备的标准接口，向下把不同的磁盘设备抽象为统一的块设备，在内核层面提供框架管理驱动程序。</li>
<li>给文件系统和应用程序的I/O请求排队并调度。</li>
</ul>
<p>Linux内存支持5种I/O调度算法：</p>
<ul>
<li>没有调度（常出现在虚拟机，交由物理机系统负责调度）</li>
<li>先入先出</li>
<li>完全公平：按时间片均匀分布</li>
<li>优先级</li>
<li>最终期限：DDL，读写队列分开，适宜压力较大的场景，如数据库。</li>
</ul>
<h2 id="5-存储系统I-O软件分层"><a href="#5-存储系统I-O软件分层" class="headerlink" title="5. 存储系统I/O软件分层"></a>5. 存储系统I/O软件分层</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.png" class="lazyload placeholder" data-srcset="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>
<p>文件系统层：向上为应用程序提供标准文件访问接口，向下通过通用块层存储和管理磁盘设备。</p>
<p>通用块层：调度I/O请求，选择其中一个发送给设备层。</p>
<p>设备层：包括硬件设备、设备控制器和驱动程序，负责最终物理设备的I/O操作。</p>
<p>提高I/O效率的措施：</p>
<ul>
<li>提高文件访问效率：使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，减少对块设备的直接调用。</li>
<li>提高块设备访问效率：缓冲区。</li>
</ul>
<h2 id="6-总体流程"><a href="#6-总体流程" class="headerlink" title="6. 总体流程"></a>6. 总体流程</h2><p>以键盘为例：</p>
<ul>
<li>输入字符后，键盘控制器产生扫描码数据，缓存在键盘控制器的寄存器中，并向CPU发送中断请求。</li>
<li>操作系统保存被中断进程的上下文，调用键盘的中断处理程序。</li>
<li>中断处理函数从寄存器缓冲区中读取扫描码，翻译成对应的字符。如果是显示字符，就翻译成ASCII码。</li>
<li>把ASCII码放入读缓冲区队列，显示设备的驱动程序定时从队列中读取数据放到写缓冲区队列，写入到显示设备的控制器的寄存器的数据缓冲区中，最后显示在屏幕上。</li>
<li>显示出结果后恢复被中断程序的上下文。</li>
</ul>
<h2 id="7-中断与异常"><a href="#7-中断与异常" class="headerlink" title="7. 中断与异常"></a>7. 中断与异常</h2><p>相同点：</p>
<ul>
<li>最终都由CPU发给内核处理</li>
<li>处理程序流程设计上相似</li>
</ul>
<p>不同点：</p>
<ul>
<li>中断由设备产生，异常由CPU产生</li>
<li>处理程序不同</li>
<li>中断不是时钟同步的，可以随时到来；异常是时钟同步的</li>
<li>处理中断时处于中断上下文，处理异常时处于异常上下文</li>
</ul>
<h1 id="8-网络系统"><a href="#8-网络系统" class="headerlink" title="8. 网络系统"></a>8. 网络系统</h1><h2 id="1-零拷贝"><a href="#1-零拷贝" class="headerlink" title="1. 零拷贝"></a>1. 零拷贝</h2><h3 id="1-DMA技术"><a href="#1-DMA技术" class="headerlink" title="1. DMA技术"></a>1. DMA技术</h3><p>Direct Memory Access直接内存访问技术。即在进行I/O设备和内存的数据传输时，数据搬运工作全部交给DMA控制器，CPU只在开始告知传输数据以及在结束时将数据从内核拷贝到用户空间。</p>
<h3 id="2-传统文件传输"><a href="#2-传统文件传输" class="headerlink" title="2. 传统文件传输"></a>2. 传统文件传输</h3><p>服务端提供文件传输功能时，先将磁盘上的文件read读出来，再write通过网络协议发送给客户端。</p>
<p>期间共发生4次用户态与内核态的上下文切换，read与write两次系统调用。每次都从用户态切换到内核态，等内核态完成任务后切回用户态。</p>
<p>发生4次数据拷贝，1次DMA控制器从磁盘到内核，1次CPU从内核缓冲区到用户缓冲区，1次CPU从用户缓冲区到内核socket缓冲区，1次DMA控制器从内核socket缓冲区到网卡缓冲区。</p>
<h3 id="3-优化文件传输"><a href="#3-优化文件传输" class="headerlink" title="3. 优化文件传输"></a>3. 优化文件传输</h3><h4 id="1-用户态与内核态上下文切换次数"><a href="#1-用户态与内核态上下文切换次数" class="headerlink" title="1. 用户态与内核态上下文切换次数"></a>1. 用户态与内核态上下文切换次数</h4><p>上下文切换是因为用户空间没有权限操作硬件，要减少系统调用的次数。</p>
<h4 id="2-数据拷贝次数"><a href="#2-数据拷贝次数" class="headerlink" title="2. 数据拷贝次数"></a>2. 数据拷贝次数</h4><p>如果不对数据再加工，数据实际上不用搬运到用户空间。</p>
<h3 id="4-零拷贝"><a href="#4-零拷贝" class="headerlink" title="4. 零拷贝"></a>4. 零拷贝</h3><h4 id="1-mmap-write"><a href="#1-mmap-write" class="headerlink" title="1. mmap + write"></a>1. mmap + write</h4><p>用mmap替换read，直接把内核缓冲区的数据映射到用户空间，可以减少一次read数据拷贝。但是系统调用还是2次，所以还是需要4次上下文切换。</p>
<h4 id="2-sendfile"><a href="#2-sendfile" class="headerlink" title="2. sendfile"></a>2. sendfile</h4><p>替换read + write，可以直接把内核缓冲区的数据拷贝到内核中的socket缓冲区。只有1次系统调用，2次上下文切换，3次数据拷贝（内核缓冲区到内核socket缓冲区还要一次）。</p>
<h4 id="3-sendfile-SG-DMA（网卡支持）"><a href="#3-sendfile-SG-DMA（网卡支持）" class="headerlink" title="3. sendfile + SG-DMA（网卡支持）"></a>3. sendfile + SG-DMA（网卡支持）</h4><p>数据拷贝到内核缓冲区后，缓冲区描述符和数据长度传到socket缓冲区，网卡的SG-DMA控制器可以直接将内核缓冲区数据拷贝到网卡缓冲区。只有1次系统调用，2次数据拷贝。</p>
<h4 id="4-零拷贝技术"><a href="#4-零拷贝技术" class="headerlink" title="4. 零拷贝技术"></a>4. 零拷贝技术</h4><p>3中的方式全程通过DMA传输，没有CPU搬运数据。只需要1次系统调用，2次上下文切换与2次数据拷贝，且都由DMA进行。</p>
<h3 id="5-大文件传输"><a href="#5-大文件传输" class="headerlink" title="5. 大文件传输"></a>5. 大文件传输</h3><h4 id="1-PageCache"><a href="#1-PageCache" class="headerlink" title="1. PageCache"></a>1. PageCache</h4><p>内核缓冲区实际上就是PageCache，通过缓存最近被访问的数据与预读，提高读写磁盘性能。</p>
<p>但是在传输GB级别的大文件时，PageCache会被迅速占满，而很多部分一般只会读取一次，会白白浪费DMA多做一次数据拷贝，所以不应使用零拷贝技术。</p>
<h4 id="2-大文件传输"><a href="#2-大文件传输" class="headerlink" title="2. 大文件传输"></a>2. 大文件传输</h4><p>高并发场景下，使用异步I/O + 直接I/O替代零拷贝技术。</p>
<p>由于直接I/O绕过了PageCache（发起中断信号后CPU直接将数据从磁盘控制器缓冲区拷贝到用户缓冲区），会无法享受优化：</p>
<ul>
<li>I/O调度算法缓存请求并合并，从而减少磁盘的寻址操作。</li>
<li>内核预读I/O请求。</li>
</ul>
<h2 id="2-I-O多路复用"><a href="#2-I-O多路复用" class="headerlink" title="2. I/O多路复用"></a>2. I/O多路复用</h2><h3 id="1-基本Socket模型"><a href="#1-基本Socket模型" class="headerlink" title="1. 基本Socket模型"></a>1. 基本Socket模型</h3><p>服务端：</p>
<ul>
<li>调用socket()创建网络协议IPv4，传输协议TCP的Socket。</li>
<li>调用bind()绑定一个IP地址和端口。</li>
<li>调用listen()监听。</li>
<li>调用accept()从内核获取客户端的连接，如果没有连接则会阻塞。（accept并不是接收连接，而只是从已经建立好的连接中选择一个）</li>
</ul>
<p>客户端：</p>
<ul>
<li>调用socket()创建Socket。</li>
<li>调用connect()指明服务端IP地址和端口号发起三次握手连接。</li>
</ul>
<p>服务器内核为每个Socket维护两个队列：</p>
<ul>
<li>TCP半连接队列，还没完成三次握手，服务端处于syn_rcvd状态。</li>
<li>TCP全连接队列，完成了三次握手，服务端处于established状态。</li>
</ul>
<p>监听的Socket与用来传数据的已连接Socket不是同一个。</p>
<h3 id="2-Socket结构"><a href="#2-Socket结构" class="headerlink" title="2. Socket结构"></a>2. Socket结构</h3><p>Socket也是文件，其inode中有发送队列和接收队列，保存sk_buff用链表穿起来。sk_buff在各个层表示不同，在应用层叫data，TCP层叫segment，IP层叫packet，数据链路层叫frame。</p>
<p>为了方便不同层之间传递数据且不发生拷贝，调整data的指针：</p>
<ul>
<li>接收报文时，通过协议栈层层往上传送数据包，通过增加data的值逐步剥离协议首部。</li>
<li>发送报文时，创建sk_buff结构体并为头部预留足够空间，向下层协议传递时通过减少data的值来增加协议首部。</li>
</ul>
<h3 id="3-多进程模型"><a href="#3-多进程模型" class="headerlink" title="3. 多进程模型"></a>3. 多进程模型</h3><p>父进程只需要关心监听Socket，子进程只需要关心已连接Socket。</p>
<p>客户端数量过多时，产生进程会占据一定的系统资源，且进程上下文切换消耗很大，影响性能。</p>
<h3 id="4-多线程模型"><a href="#4-多线程模型" class="headerlink" title="4. 多线程模型"></a>4. 多线程模型</h3><p>可通过线程池避免线程的频繁创建和销毁。已连接Socket放进一个队列里，线程池中的线程从队列中取出Socket进行处理。</p>
<h3 id="5-I-O多路复用"><a href="#5-I-O多路复用" class="headerlink" title="5. I/O多路复用"></a>5. I/O多路复用</h3><p>将进程处理每个请求的事件时间控制在1ms内，1s内就可以处理上千个请求，从时间拉长看，多个请求复用了一个进程。</p>
<h4 id="1-select-poll"><a href="#1-select-poll" class="headerlink" title="1. select/poll"></a>1. select/poll</h4><p>select：</p>
<ul>
<li>已连接的Socket放到一个文件描述符集合中，调用select函数将其拷贝到内核，让内核遍历检查是否有网络事件发生。</li>
<li>如果检测到，标记Socket为可读或可写，然后将整个文件描述符集合拷贝回用户态。</li>
<li>用户态还需要遍历一遍找到可读或可写的Socket再处理。</li>
<li>使用定长BitsMap表示文件描述符集合，只能监听0~1023文件描述符</li>
</ul>
<p>poll：用动态数组、链表形式组织，不受select文件描述符个数限制，但还是受系统文件描述符限制。</p>
<h4 id="2-epoll"><a href="#2-epoll" class="headerlink" title="2. epoll"></a>2. epoll</h4><p>步骤：</p>
<ul>
<li>epoll_create()创建一个epoll对象</li>
<li>epoll_ctl()将需要监听的socket添加到对象中</li>
<li>epoll_wait()等待数据。<ul>
<li>可通过timeout参数空值是否阻塞。-1表示永远等待，0表示不等待直接返回，其他表示在超时事件内如果没有事件发生，返回0。</li>
</ul>
</li>
</ul>
<p>对前面两个函数的改进</p>
<ul>
<li>在内核中使用红黑树跟踪进程所有待检测字的文件描述字，而不需要每次拷贝。每次只需要传入一个待检测的socket。</li>
<li>使用事件驱动机制，维护一个链表记录就绪事件。如果某个socket有事件发生，内核通过回调函数将其加入就绪事件列表，用户调用epoll_wait()时只返回有事件发生的文件描述符个数。</li>
</ul>
<p>为什么不用哈希表？</p>
<ul>
<li>哈希表需要提前预留内存。</li>
<li>哈希表扩容时，该次epoll_ctl响应时间可能远长于其他epoll_ctl，性能不稳定。</li>
</ul>
<p>epoll没有使用共享内存，而是在epoll_wait()中将数据从内核空间拷贝到用户空间。</p>
<p>epoll支持边缘触发ET和水平触发LT两种事件触发模式。</p>
<p>ET：当被监控的Socket描述符上有可读事件发生时，服务器端只从epoll_wait苏醒一次。因此程序要保证一次性将内核缓冲区的数据读完。</p>
<p>一般会循环从文件描述符中读取，如果文件描述符是阻塞的，没有数据读写时进程会阻塞在读写函数，所以ET一般与<strong>非阻塞I/O</strong>搭配使用。</p>
<p>LT：当被监控的Socket描述符上有可读事件发生时，服务器端不断从epoll_wait中苏醒，直到内核缓冲区数据被读完。</p>
<p>多路复用API返回的事件并不一定可读写，所以多路复用最好都搭配<strong>非阻塞I/O</strong>。</p>
<h4 id="3-取舍"><a href="#3-取舍" class="headerlink" title="3. 取舍"></a>3. 取舍</h4><p>所有fd都是活跃连接，且fd少时，线性结构效率比红黑树高，且返回时线性结构约等于就绪队列，所以用select/poll效率更高。</p>
<h2 id="3-高性能网络模式"><a href="#3-高性能网络模式" class="headerlink" title="3. 高性能网络模式"></a>3. 高性能网络模式</h2><h3 id="1-Reactor模式"><a href="#1-Reactor模式" class="headerlink" title="1. Reactor模式"></a>1. Reactor模式</h3><p>对I/O多路复用进行了封装。收到事件后，根据时间类型分配给某个线程。</p>
<p>由Reactor和处理资源池两个核心部分组成。</p>
<ul>
<li>Reactor负责监听和分发事件，有连接事件、读写事件。</li>
<li>处理资源池负责处理事件，如read-&gt;业务逻辑-&gt;send。</li>
</ul>
<p>Reactor可以是一个，也可以是多个；处理资源池的线程也是如此。</p>
<h4 id="1-单Reactor单线程"><a href="#1-单Reactor单线程" class="headerlink" title="1. 单Reactor单线程"></a>1. 单Reactor单线程</h4><p>C语言一般是单进程，而Java语言一般是单线程，因为Java程序跑在Java虚拟机上，虚拟机中有很多线程。</p>
<p>具体方案：</p>
<ul>
<li>Reactor通过多路复用接口监听事件，收到事件后按类型分发。</li>
<li>如果是连接建立事件，交给Acceptor对象处理。Acceptor通过accept方法获取连接，创建一个Handler对象处理后续的响应事件。</li>
<li>如果不是连接建立事件，交由当前连接对应的Handler对象响应。Handler对象通过read-&gt;业务逻辑-&gt;send流程完成完整的业务流程。</li>
<li>全部工作在一个进程内完成。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只有一个进程，无法利用多核CPU性能。</li>
<li>Handler对象处理业务时整个进程无法处理其他连接事件。</li>
</ul>
<p>只适用于业务处理快速的场景，而不适用于计算密集型场景。</p>
<h4 id="2-单Reactor多线程"><a href="#2-单Reactor多线程" class="headerlink" title="2. 单Reactor多线程"></a>2. 单Reactor多线程</h4><p>具体方案：</p>
<ul>
<li>分发步骤与1相同。</li>
<li>Handler对象只负责数据的接受和发送，通过read读取到数据后发给子线程的Processor对象处理业务。</li>
<li>Processor对象处理完后将结果发给主线程中的Handler对象。</li>
<li>Handler对象通过send方法将响应结果发给client。</li>
</ul>
<p>能够充分利用多核CPU性能。</p>
<p>缺点：一个Reactor对象承担所有事件的监听和响应，且只在主线程中运行。面对瞬间高并发场景易成为性能瓶颈。</p>
<h4 id="3-多Reactor多线程"><a href="#3-多Reactor多线程" class="headerlink" title="3. 多Reactor多线程"></a>3. 多Reactor多线程</h4><p>具体方案：</p>
<ul>
<li>主线程的MainReactor对象通过多路复用接口监听连接建立事件，收到事件后通过Acceptor对象的accept获取连接，将新连接分配给某个子线程。</li>
<li>子线程的SubReactor接收分配的连接，加入多路复用接口继续监听，并创建一个Handler处理连接的响应事件。</li>
<li>如果有新的事件发生，SubReactor调用当前连接对应的Handler响应。</li>
<li>Handler对象完成read-&gt;业务流程-&gt;send。</li>
</ul>
<p>优点：</p>
<ul>
<li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责后续业务处理。</li>
<li>主线程和子线程交互简单，主线程只需要将连接发给子线程，子线程直接将处理结果发给客户端。</li>
</ul>
<h3 id="2-Proactor"><a href="#2-Proactor" class="headerlink" title="2. Proactor"></a>2. Proactor</h3><p>异步网络模式，采用了aio_read异步I/O技术。</p>
<ul>
<li>Reactor是非阻塞同步网络模式，感知就绪可读写事件。每次感知到有事件发生，需要应用程序主动调用read方法完成数据读取。</li>
<li>Proactor是异步网络模式，感知已完成读写事件。操作系统读取完数据后主动通知应用程序。</li>
</ul>
<p>工作流程：</p>
<ul>
<li>Proactor initiator创建Proactor和Handler对象，将其通过Asynchronous Operation Processor注册到内核。（应用进程）</li>
<li>Handler负责<strong>业务处理</strong>。（应用进程）</li>
<li>Asynchronous Operation Processor负责<strong>处理注册请求与I/O操作</strong>，完成I/O操作后<strong>通知</strong>Proactor。（内核进程）</li>
<li>Proactor根据不同事件类型<strong>回调</strong>不同的Handler处理业务。（内核进程）</li>
</ul>
<p>Linux的异步I/O不完善，aio系列函数只是在用户空间模拟出的异步，且仅支持基于本地文件的aio异步操作，网络编程中的socket不支持。所以基于Linux的高性能网络程序都是用Reactor方案。</p>
<h2 id="4-一致性哈希"><a href="#4-一致性哈希" class="headerlink" title="4. 一致性哈希"></a>4. 一致性哈希</h2><p>负载均衡算法。一个分布式KV缓存系统，某个key应该到哪个或者哪些节点上获得，应该是确定的。</p>
<p>如果使用传统哈希算法，节点数量发生变化（扩容或缩容时）必须迁移改变了映射关系的数据，最坏情况下所有数据都要迁移。</p>
<p>一致性哈希对2^32进行取模运算，将结果组织成一个圆环，称为哈希环。</p>
<p>两步哈希：</p>
<ul>
<li>对存储节点哈希运算。</li>
<li>存储或访问数据时对数据哈希。</li>
<li>数据映射的结果值顺时针方向第一个节点就是存储该数据的节点。</li>
</ul>
<p>增加或移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点。</p>
<p>对节点分布不均匀问题的改进：把一个真实节点多复制几个副本作为虚拟节点，映射到哈希环上。</p>
<h2 id="5、socket函数"><a href="#5、socket函数" class="headerlink" title="5、socket函数"></a>5、socket函数</h2><p>socket函数：socket是一种特殊的文件，socket函数就是对其进行的操作。</p>
<h3 id="1、socket"><a href="#1、socket" class="headerlink" title="1、socket"></a>1、socket</h3><p><code>int socket(int domain, int type, int protocol);</code></p>
<ol>
<li>domain：协议族。AF_INET、AF_INET6。用于本机通信的为AF_UNIX。</li>
<li>type：socket类型。SOCK_STREAM、SOCK_DGRAM。</li>
<li>protocol：指定协议。IPPROTO_TCP、IPPROTO_UDP。</li>
<li>返回值：<ol>
<li>非负：成功，代表文件描述符</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
<h3 id="2、bind"><a href="#2、bind" class="headerlink" title="2、bind"></a>2、bind</h3><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
<ol>
<li><p>sockfd：创建的socket描述字。</p>
</li>
<li><p>addr：指向绑定给sockfd的协议地址，储存了地址类型、IP地址和端口号。</p>
</li>
<li><p>addrlen：地址长度。</p>
</li>
<li><p>返回值：</p>
<ol>
<li>0：成功</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
<h3 id="3、listen"><a href="#3、listen" class="headerlink" title="3、listen"></a>3、listen</h3><p><code>int listen(int sockfd, int backlog); </code></p>
<ol>
<li><p>sockfd：要监听的socket描述字。</p>
</li>
<li><p>backlog：全连接队列长度。</p>
</li>
<li><p>listen将socket变为被动类型，等待客户连接请求。</p>
</li>
<li><p>返回值：</p>
<ol>
<li>0：成功</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
<h3 id="4、connect"><a href="#4、connect" class="headerlink" title="4、connect"></a>4、connect</h3><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); </code></p>
<ol>
<li>sockfd：客户端的socket描述字。</li>
<li>addr：服务器的socket地址。</li>
<li>addrlen：socket地址长度。</li>
<li>返回值：<ol>
<li>0：成功</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
<h3 id="5、accept"><a href="#5、accept" class="headerlink" title="5、accept"></a>5、accept</h3><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></p>
<ol>
<li>sockfd：服务器的socket描述字。</li>
<li>addr：返回客户端的协议地址。</li>
<li>addrlen：客户端协议地址的长度。</li>
<li>返回值：<ol>
<li>非负：成功，代表已连接套接字</li>
<li>-1：出错</li>
</ol>
</li>
</ol>
<h3 id="6、send"><a href="#6、send" class="headerlink" title="6、send"></a>6、send</h3><p><code>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</code></p>
<ol>
<li>sockfd：发送端套接字。</li>
<li>buf：存放要发送数据的缓冲区。</li>
<li>len：要发送的字节数。</li>
<li>flags：参数。</li>
<li>返回值：<ol>
<li>非负：成功拷贝至发送缓冲区的字节数</li>
<li>-1：出错并置错误号errno（len大于缓冲区长度、拷贝时出错、网络断开）</li>
</ol>
</li>
</ol>
<h3 id="7、recv"><a href="#7、recv" class="headerlink" title="7、recv"></a>7、recv</h3><p><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</code></p>
<ol>
<li>返回值：<ol>
<li>非负：成功拷贝的字节数</li>
<li>-1：出错并置错误号errno（拷贝时出错、网络断开）</li>
</ol>
</li>
</ol>
<h1 id="9-杂七杂八的"><a href="#9-杂七杂八的" class="headerlink" title="9. 杂七杂八的"></a>9. 杂七杂八的</h1><h2 id="1-ASCII、Unicode和UTF-8编码"><a href="#1-ASCII、Unicode和UTF-8编码" class="headerlink" title="1. ASCII、Unicode和UTF-8编码"></a>1. ASCII、Unicode和UTF-8编码</h2><h3 id="1-ASCII"><a href="#1-ASCII" class="headerlink" title="1. ASCII"></a>1. ASCII</h3><p>只有127个字符，表示英文字母大小写、数字和一些符号，但是表示其他语言不够。一个字节表示一个字符。</p>
<h3 id="2-Unicode"><a href="#2-Unicode" class="headerlink" title="2. Unicode"></a>2. Unicode</h3><p>为了统一各个国家的编码格式，通常两个字节表示一个字符。</p>
<h3 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3. UTF-8"></a>3. UTF-8</h3><p>为了解决Unicode在编译全英文文本时，使用的空间比ASCII码多一倍的问题。UTF-8将Unicode字符按数字大小编码为1-6字节，英文字符编码为1字节，常用汉字编码为3字节。</p>
<h3 id="4-联系"><a href="#4-联系" class="headerlink" title="4. 联系"></a>4. 联系</h3><p>计算机内存中统一使用Unicode编码，保存到硬盘或传输时转换为UTF-8编码。</p>
<p>记事本编辑时，文件读取的UTF-8字符转换为Unicode字符到内存里，编辑完成后，保存时再转回UTF-8保存到文件。</p>
<p>浏览网页时，服务器把动态生成的Unicode内容转换为UTF-8再传输到浏览器。</p>
<h2 id="2-库函数与系统调用"><a href="#2-库函数与系统调用" class="headerlink" title="2. 库函数与系统调用"></a>2. 库函数与系统调用</h2><p>系统调用：操作系统提供给用户程序的程序接口，用于执行某些服务。</p>
<p>库函数：语言或应用程序的一部分，大部分封装了系统调用。</p>
<p>区别：</p>
<ul>
<li>移植性：系统调用依赖于内核，不保证移植性；库函数平台移植性好</li>
<li>执行区域：系统调用在内核空间执行；库函数在用户空间</li>
<li>开销：系统调用需要切换，开销大；库函数属于过程调用，开销小（仅对于没有封装系统调用的库函数）</li>
<li>应用场景：<ul>
<li>跟内核与操作系统特性相关联的服务，由系统调用提供。</li>
<li>具有共同特性的功能（如读写），由库函数提供。</li>
</ul>
</li>
</ul>
<h2 id="3-高并发服务器方案"><a href="#3-高并发服务器方案" class="headerlink" title="3. 高并发服务器方案"></a>3. 高并发服务器方案</h2><ul>
<li>应用程序与静态资源分离，将静态资源（图片、视频、js、css等）单独保存到专门的静态资源服务器</li>
<li>客户端缓存</li>
<li>反向代理与负载均衡：请求先经过反向代理服务器，它可以直接返回结果，也可以根据后端服务器的负载，将请求交给其中一台处理。感觉前三点Nginx都能做到。</li>
<li>集群和分布式。集群指所有服务器都有相同的功能，起分流作用；分布式将不同的业务放到不同服务器中，请求一个业务可能需要使用多台服务器，加快处理速度。它们的作用都是将原属于一台服务器的压力分散到多台，同时加快请求速度</li>
</ul>

      </div>
      <div class="post-tags-categories">
        
      </div>
      
        <div class="copyright">
  <ul class="post-copyright">
    <li class="post-copyright-author">
    <strong>作者:  </strong>aoba moka</a>
    </li>
    <li class="post-copyright-link">
    <strong>文章链接:  </strong>
    <a href="/2022/12/21/学习笔记-操作系统/" target="_blank" title="学习笔记-操作系统">https://aobamoka.github.io/2022/12/21/学习笔记-操作系统/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明:   </strong>
      本网站所有文章除特别声明外,均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
      许可协议。转载请注明出处!
    </li>
  </ul>
<div>
      
    </article>
    <!-- 上一篇文章和下一篇文章 -->
    
      <!-- 文章详情页的上一页和下一页 -->
<div class="post-nav">



  
  <div class="post-nav-prev post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" class="lazyload placeholder" data-srcset="https://picx.zhimg.com/80/v2-9c50d3af0bc62a0e8b6e89e24c769317_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
    </div>
    <a href="/2023/01/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C++/" class="post-nav-link">
      <div class="title">
        <i class="fas fa-angle-left"></i> 上一篇:
        <div class="title-text">学习笔记-C++</div>
      </div>
      
      <!-- <div class="content">
        C和C++区别
面向过程&amp;面向对象：C++有类和对象，支持模板，有STL。
动态内存管理：malloc&amp;
      </div> -->
    </a>
  </div>



  
  <div class="post-nav-next post-nav-item">
    <div class="post-nav-img" style="background-size: cover; 
      background-position: center center;">
      <img class="lazyload lazyload placeholder" src="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" class="lazyload placeholder" data-srcset="https://pic4.zhimg.com/80/v2-e434e3a2888fb4efb1844845b8791d1f_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" src="" alt="">
    </div>
    <a href="/2022/12/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-labuladong%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/" class="post-nav-link">
      <div class="title">
        下一篇: <i class="fas fa-angle-right"></i>
        <div class="title-text">学习笔记-labuladong计算机技术</div>
      </div>
      <!-- <div class="content">
        1. linux文件系统文件用途
/bin /sbin：存储可执行的二进制文件，如cp、chmod、ifconfig等命
      </div> -->
    </a>
  </div>

</div>

    
    

    <!-- 打赏 -->
    

    <!-- 分享 -->
    
      <!-- https://github.com/overtrue/share.js -->
<!-- 文章详情页的分享 -->
<div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>

<script src="/js/shareJs/social-share.min.js"></script>
</script>

<style>
  .social-share {
    margin: 20px 0;
  }
</style>


    
    
    <!-- 评论 -->
    <!-- 评论 -->

  <div id="myComment">
    
      <div id="gitment-container"></div>

    
  </div>

<!-- comment script in themes\hexo-theme-bamboo\layout\_partial\scripts\index.ejs -->


  </div>

  <!-- 目录 -->
  <aside id='l_side'>
  
    
      <section class="widget side_blogger">
  <div class='content'>
    
      
        <a class='avatar flat-box rectangle' href='/about/'>
          <img src='/medias/test.png'/>
        </a>
      
    
    
      <div class='text'>
        
          <h2>摩卡</h2>
        
        
          <p>不太会说话</p>

        
        
          <p><span id="jinrishici-sentence">摩卡's blog</span></p>
          <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
        
      </div>
    
    
  </div>
</section>

    
  
  
  

  <div class="layout_sticky">    
    
      
<section class="widget side_toc">
  
  <header>
    
      <i style="color: " class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name' style="color: ">本文目录</span>
    
  </header>


  <div class='content'>
    <div class="toc-main">
      <div class="toc-content">
        <!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">1. 硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. 冯诺依曼模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98"><span class="toc-text">1. 内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8-CPU"><span class="toc-text">2. 中央处理器&#x2F;CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BA%BF"><span class="toc-text">3. 总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="toc-text">4. 输入输出设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%8D%E5%AE%BD"><span class="toc-text">2. 位宽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-text">3. 指令周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-64%E4%BD%8D%E5%92%8C32%E4%BD%8D"><span class="toc-text">4. 64位和32位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">5. 存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">1. 寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CPU-Cache"><span class="toc-text">2. CPU Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98"><span class="toc-text">3. 内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-SSD-HDD%E7%A1%AC%E7%9B%98"><span class="toc-text">4. SSD&#x2F;HDD硬盘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Cache%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-text">6. Cache映射方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="toc-text">1. 直接映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-text">2. 全相联映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="toc-text">3. 组相联映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8F%90%E5%8D%87Cache%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="toc-text">7. 提升Cache命中率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98"><span class="toc-text">1. 数据缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%87%E4%BB%A4%E7%BC%93%E5%AD%98"><span class="toc-text">2. 指令缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Cache%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98"><span class="toc-text">8. Cache写入内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">9. 缓存一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%BB%E7%BA%BF%E5%97%85%E6%8E%A2"><span class="toc-text">1. 总线嗅探</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MESI%E5%8D%8F%E8%AE%AE"><span class="toc-text">2. MESI协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Cache%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-text">10. Cache伪共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Linux-Windows%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">11. Linux&#x2F;Windows的线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Linux"><span class="toc-text">1. Linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Windows"><span class="toc-text">2. Windows</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E4%B8%AD%E6%96%AD"><span class="toc-text">12. 中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">13. 操作系统的作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-text">2. 操作系统内核</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux-1"><span class="toc-text">1. Linux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Windows-1"><span class="toc-text">2. Windows</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">3. 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-text">1. 内存分段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="toc-text">2. 内存分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">3. 段页式内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">4. Linux虚拟内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text">5. 动态分配内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E7%B4%A7%E5%BC%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">6. 内存紧张的处理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-NUMA%E6%9E%B6%E6%9E%84"><span class="toc-text">7. NUMA架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%94%B3%E8%AF%B7%E8%B6%85%E5%87%BA%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">8. 申请超出物理内存的虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%94%B9%E8%BF%9BLRU%E7%AE%97%E6%B3%95"><span class="toc-text">9. 改进LRU算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%EF%BC%8C%E5%AF%BC%E8%87%B4%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87%E4%B8%8B%E9%99%8D"><span class="toc-text">1. 预读失效，导致缓存命中率下降</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Linux%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">1. Linux的处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MySQL%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">2. MySQL的处理方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%EF%BC%8C%E5%AF%BC%E8%87%B4%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87%E4%B8%8B%E9%99%8D"><span class="toc-text">2. 缓存污染，导致缓存命中率下降</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Linux%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">1. Linux处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MySQL%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">2. MySQL处理方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">10. 虚拟内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-text">11. 内存碎片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81Buddy%E4%BC%99%E4%BC%B4%E6%9C%BA%E5%88%B6"><span class="toc-text">12、Buddy伙伴机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">4. 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">1. 进程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text">2. 进程的控制结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E2%98%85-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%88%87%E6%8D%A2"><span class="toc-text">3. ★ 进程&#x2F;线程的控制与切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E2%98%85-%E7%BA%BF%E7%A8%8B"><span class="toc-text">4. ★ 线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">5. 线程调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E2%98%85-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">6. ★ 进程&#x2F;线程通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-text">7. 线程冲突问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">1. 生产者-消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">2. 哲学家就餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">3. 读者-写者问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E2%98%85-%E6%AD%BB%E9%94%81"><span class="toc-text">8. ★ 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%94%81"><span class="toc-text">9. 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%92%E6%96%A5%E9%94%81-%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">1. 互斥锁&#x2F;自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">2. 读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">3. 乐观锁&#x2F;悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">4. 条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-CAS%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8ECAS%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%9F"><span class="toc-text">5. CAS是乐观锁，为什么基于CAS实现的自旋锁是悲观锁？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83"><span class="toc-text">10. 线程崩溃与进程崩溃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">11. 进程通信与线程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%8D%8F%E7%A8%8B"><span class="toc-text">12. 协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-text">1. 产生原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89"><span class="toc-text">2. 定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E7%AE%A1%E7%A8%8B"><span class="toc-text">13. 管程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8F%90%E5%87%BA%E5%8E%9F%E5%9B%A0"><span class="toc-text">1. 提出原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">2. 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E6%88%90"><span class="toc-text">3. 组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">4. 工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">5. 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6"><span class="toc-text">14. 线程回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B"><span class="toc-text">15. 特殊进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-text">1. 孤儿进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-text">2. 僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">3. 守护进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-text">16. 避免僵尸进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%AF%B9%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">17. 子进程对父进程的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E8%BF%9B%E7%A8%8B%E7%BB%84%E4%B8%8E%E4%BC%9A%E8%AF%9D%E3%80%81%E4%BD%9C%E4%B8%9A"><span class="toc-text">18. 进程组与会话、作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-text">19. 进程的终止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-text">20. 不可重入函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%A6%BB%E6%80%81"><span class="toc-text">21. 线程的分离态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">22. 多线程与多进程的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-text">23. 用户态和内核态的切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-RingBuffer"><span class="toc-text">24. RingBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E4%BF%A1%E5%8F%B7"><span class="toc-text">25. 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%81%E7%A8%8B"><span class="toc-text">1. 流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%AC%E8%B4%A8"><span class="toc-text">2. 本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E3%80%81%E4%BD%9C%E4%B8%9A%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">26、作业和进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E3%80%81%E7%AE%A1%E9%81%93"><span class="toc-text">27、管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E3%80%81%E6%83%8A%E7%BE%A4%E7%8E%B0%E8%B1%A1"><span class="toc-text">28、惊群现象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">5. 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">1. 进程调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">2. 内存页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">3. 磁盘调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">4. 动态分区分配算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">6. 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FVFS"><span class="toc-text">1. 虚拟文件系统VFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-text">2. 文件存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE"><span class="toc-text">1. 连续空间存放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE"><span class="toc-text">2. 非连续空间存放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%93%BE%E8%A1%A8%E5%BC%8F"><span class="toc-text">1. 链表式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E5%BC%8F"><span class="toc-text">2. 索引式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%9D%97"><span class="toc-text">3. 链式索引块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%9D%97"><span class="toc-text">4. 多级索引块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Unix%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">3. Unix文件实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">3. 空闲空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-text">1. 空闲表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-text">2. 空闲链表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%8D%E5%9B%BE%E6%B3%95"><span class="toc-text">3. 位图法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-text">4. 文件系统结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">5. 目录的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E2%98%85-%E9%93%BE%E6%8E%A5"><span class="toc-text">6. ★ 链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-text">1. 硬链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-text">2. 软链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81inode%E4%BD%9C%E7%94%A8"><span class="toc-text">3、inode作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%96%87%E4%BB%B6I-O"><span class="toc-text">7. 文件I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Page-Cache"><span class="toc-text">8. Page Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Page-Cache%E4%B8%8EBuffer-Cache"><span class="toc-text">1. Page Cache与Buffer Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E5%8A%A3"><span class="toc-text">2. 优劣</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD"><span class="toc-text">9. 文件系统性能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-text">7. 设备管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">1. 设备控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">2. I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BD%AE%E8%AF%A2%E7%AD%89%E5%BE%85"><span class="toc-text">1. 轮询等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD"><span class="toc-text">2. 中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DMA"><span class="toc-text">3. DMA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">3. 设备驱动程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%80%9A%E7%94%A8%E5%9D%97%E5%B1%82"><span class="toc-text">4. 通用块层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI-O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82"><span class="toc-text">5. 存储系统I&#x2F;O软件分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-text">6. 总体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-text">7. 中断与异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">8. 网络系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-text">1. 零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-DMA%E6%8A%80%E6%9C%AF"><span class="toc-text">1. DMA技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-text">2. 传统文件传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%98%E5%8C%96%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-text">3. 优化文件传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%AC%A1%E6%95%B0"><span class="toc-text">1. 用户态与内核态上下文切换次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E6%AC%A1%E6%95%B0"><span class="toc-text">2. 数据拷贝次数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-text">4. 零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mmap-write"><span class="toc-text">1. mmap + write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sendfile"><span class="toc-text">2. sendfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-sendfile-SG-DMA%EF%BC%88%E7%BD%91%E5%8D%A1%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-text">3. sendfile + SG-DMA（网卡支持）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF"><span class="toc-text">4. 零拷贝技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-text">5. 大文件传输</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-PageCache"><span class="toc-text">1. PageCache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-text">2. 大文件传输</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">2. I&#x2F;O多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%ACSocket%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. 基本Socket模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Socket%E7%BB%93%E6%9E%84"><span class="toc-text">2. Socket结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">3. 多进程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">4. 多线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">5. I&#x2F;O多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-select-poll"><span class="toc-text">1. select&#x2F;poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-epoll"><span class="toc-text">2. epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%96%E8%88%8D"><span class="toc-text">3. 取舍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">3. 高性能网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Reactor%E6%A8%A1%E5%BC%8F"><span class="toc-text">1. Reactor模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">1. 单Reactor单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">2. 单Reactor多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%9AReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">3. 多Reactor多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Proactor"><span class="toc-text">2. Proactor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-text">4. 一致性哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81socket%E5%87%BD%E6%95%B0"><span class="toc-text">5、socket函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81socket"><span class="toc-text">1、socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81bind"><span class="toc-text">2、bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81listen"><span class="toc-text">3、listen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81connect"><span class="toc-text">4、connect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81accept"><span class="toc-text">5、accept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81send"><span class="toc-text">6、send</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81recv"><span class="toc-text">7、recv</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84"><span class="toc-text">9. 杂七杂八的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ASCII%E3%80%81Unicode%E5%92%8CUTF-8%E7%BC%96%E7%A0%81"><span class="toc-text">1. ASCII、Unicode和UTF-8编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ASCII"><span class="toc-text">1. ASCII</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Unicode"><span class="toc-text">2. Unicode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-UTF-8"><span class="toc-text">3. UTF-8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%81%94%E7%B3%BB"><span class="toc-text">4. 联系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">2. 库函数与系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E6%A1%88"><span class="toc-text">3. 高并发服务器方案</span></a></li></ol></li></ol> -->
        <div class="toc"></div>
      </div>
    </div>
  </div>
</section>
<!-- 手机端目录按钮 -->
<div id="toc-mobile-btn">
  <i class="fas fa-list-ul" aria-hidden="true"></i>
</div>

      
  <section class="widget side_recent_post">
    
  <header>
    
      <a style="color: " href='/tags/'><i class="fas fa-book fa-fw" aria-hidden="true"></i><span class='name'>最新文章</span></a>
    
  </header>


    <div class='content'>
      
      <!-- hash算法 -->
      
      <div class="aside-list">
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/09/02/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic2.zhimg.com/80/v2-29e78b52051ce542adf6d786d61fbd19_1440w.webp" class="lazyload placeholder" data-srcset="https://pic2.zhimg.com/80/v2-29e78b52051ce542adf6d786d61fbd19_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">09-02</span>
                
              </div>
              <a class="post-title" href="/2023/09/02/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E4%B8%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">经验分享-如何在阿里云ECS上部署自己的应用程序</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/08/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tomcat-Servlet/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">08-13</span>
                
              </div>
              <a class="post-title" href="/2023/08/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tomcat-Servlet/">学习笔记-Tomcat&amp;Servlet</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/08/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Spring/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">08-13</span>
                
              </div>
              <a class="post-title" href="/2023/08/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Spring/">学习笔记-Spring</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/08/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-e5c15010b8ba4608a1974403a02a2da0_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">08-13</span>
                
              </div>
              <a class="post-title" href="/2023/08/13/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">学习笔记-Java基础知识</a>
            </div>
          </div>
        
          <div class="aside-list-item">
            
            
            

            <div class="post-img-box">
              <a href="/2023/08/11/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8ERaft%E7%9A%84kv%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-img " style="background-size: cover; 
                background-position: center center;">
                <img class="lazyload lazyload placeholder" style="width:100%;height:100%;object-fit:cover;" data-src="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" class="lazyload placeholder" data-srcset="https://pic3.zhimg.com/80/v2-7cfc909ebe8d83683909846edd6b5232_1440w.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="">
              </a>
            </div>
            <div class="post-date-title">
              <div>
                
                  <span class="post-date">08-11</span>
                
              </div>
              <a class="post-title" href="/2023/08/11/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8ERaft%E7%9A%84kv%E6%95%B0%E6%8D%AE%E5%BA%93/">项目学习-基于Raft的kv数据库</a>
            </div>
          </div>
        
      </div>
    </div>
  </section>

    
  </div>
</aside>

  <!-- 图片放大 Wrap images with fancybox support -->
  <script src="/js/wrapImage.js"></script>
</div>

<!-- 文章详情页背景图 -->
<div id="appBgSwiper" style="position: fixed;left: 0;top: 0;width: 100%;height: 100%;z-index: -2;"
	:style="{'background-color': bgColor ? bgColor : 'transparent'}">
	<transition-group tag="ul" :name="names">
		<li v-for='(image,index) in img' :key='index' v-show="index === mark" class="bg-swiper-box">
			<img :src="image" class="bg-swiper-img no-lazy">
		</li>
	</transition-group>
</div>
<script>
	var vm = new Vue({
		el: '#appBgSwiper',
		data: {
			names: '' || 'fade' || 'fade', // translate-fade fade
			mark: 0,
			img: [],
			bgColor: '',
			time: null
		},
		methods: {   //添加方法
			change(i, m) {
				if (i > m) {
					// this.names = 'fade';
				} else if (i < m) {
					// this.names = 'fade';
				} else {
					return;
				}
				this.mark = i;
			},
			prev() {
				// this.names = 'fade';
				this.mark--;
				if (this.mark === -1) {
					this.mark = 3;
					return
				}
			},
			next() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			autoPlay() {
				// this.names = 'fade';
				this.mark++;
				if (this.mark === this.img.length) {
					this.mark = 0;
					return
				}
			},
			play() {
				let bgImgDelay = '' || '180000'
				let delay = parseInt(bgImgDelay) || 180000;
				this.time = setInterval(this.autoPlay, delay);
			},
			enter() {
				clearInterval(this.time);
			},
			leave() {
				this.play();
			}
		},
		created() {
			this.play()
		},
		beforeDestroy() {
			clearInterval(this.time);
		},
		mounted() {
			let prop = '' || '';
			let isImg = prop.includes('.bmp') || prop.includes('.jpg') || prop.includes('.png') || prop.includes('.tif') || prop.includes('.gif') || prop.includes('.pcx') || prop.includes('.tga') || prop.includes('.exif') || prop.includes('.fpx') || prop.includes('.psd') || prop.includes('.cdr') || prop.includes('.pcd') || prop.includes('.dxf') || prop.includes('.ufo') || prop.includes('.eps') || prop.includes('.ai') || prop.includes('.raw') || prop.includes('.WMF') || prop.includes('.webp') || prop.includes('.jpeg') || prop.includes('http://') || prop.includes('https://')
			if (isImg) {
				let img = prop.split(',');
				let configRoot = '/'
				let arrImg = [];
				img.forEach(el => {
					var Expression = /http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/;
					var objExp = new RegExp(Expression);

					if (objExp.test(el)) {
						// http or https
						arrImg.push(el);
					} else {
						// 非http or https开头
						// 本地文件
						let firstStr = el.charAt(0);
						if (firstStr == '/') {
							el = el.substr(1); // 删除第一个字符 '/',因为 configRoot最后一个字符为 /
						}
						el = configRoot + el;
						arrImg.push(el);
					}
				})
				this.img = arrImg;
			} else {
				this.bgColor = prop;
			}
		}
	})
</script>

<style>
	.bg-swiper-box {
		position: absolute;
		display: block;
		width: 100%;
		height: 100%;
	}

	.bg-swiper-img {
		object-fit: cover;
		width: 100%;
		height: 100%;
	}
</style>




  <script>
  function loadMermaid() {
    if (document.getElementsByClassName('mermaid').length) {
      if (window.mermaidJsLoad) mermaid.init()
      else {
        loadScript('https://unpkg.com/mermaid/dist/mermaid.min.js').then(() => {
          window.mermaidJsLoad = true
          mermaid.initialize({
            theme: 'default',
          })
          if ('true') {
            mermaid.init();
          }
        })
      }
    }
  };
  document.addEventListener("DOMContentLoaded", function () {
    loadMermaid();
  })

  document.addEventListener('pjax:complete', function () {
    loadMermaid();
  })
  
</script>


      </main>
    </div>

    <!-- 页脚 -->
    
  
  
    <!-- 底部鱼儿跳动效果，依赖于jquery-->
<div id="j-fish-skip" style=" position: relative;height: 153px;width: auto;"></div>
<script>
  var RENDERER = {
    POINT_INTERVAL: 5,
    FISH_COUNT: 3,
    MAX_INTERVAL_COUNT: 50,
    INIT_HEIGHT_RATE: .5,
    THRESHOLD: 50,
    FISH_COLOR: '',
    init: function () {
      this.setFishColor(); this.setParameters(), this.reconstructMethods(), this.setup(), this.bindEvent(), this.render()
    },
    setFishColor: function () {
      let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
      if (isDark) {
        this.FISH_COLOR = '#222'; // 暗黑色，有时间把这整成一个变量
      } else {
        this.FISH_COLOR = '' || 'rgba(66, 185, 133, 0.8)';
      }
    },
    setParameters: function () {
      this.$window = $(window), this.$container = $("#j-fish-skip"), this.$canvas = $("<canvas />"), this.context = this.$canvas.appendTo(this.$container).get(0).getContext("2d"), this.points = [], this.fishes = [], this.watchIds = []
    },
    createSurfacePoints: function () {
      var t = Math.round(this.width / this.POINT_INTERVAL);
      this.pointInterval = this.width / (t - 1), this.points.push(new SURFACE_POINT(this, 0));
      for (var i = 1; i < t; i++) {
        var e = new SURFACE_POINT(this, i * this.pointInterval),
          h = this.points[i - 1];
        e.setPreviousPoint(h), h.setNextPoint(e), this.points.push(e)
      }
    },
    reconstructMethods: function () {
      this.watchWindowSize = this.watchWindowSize.bind(this), this.jdugeToStopResize = this.jdugeToStopResize.bind(this), this.startEpicenter = this.startEpicenter.bind(this), this.moveEpicenter = this.moveEpicenter.bind(this), this.reverseVertical = this.reverseVertical.bind(this), this.render = this.render.bind(this)
    },
    setup: function () {
      this.points.length = 0, this.fishes.length = 0, this.watchIds.length = 0, this.intervalCount = this.MAX_INTERVAL_COUNT, this.width = this.$container.width(), this.height = this.$container.height(), this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500, this.$canvas.attr({
        width: this.width,
        height: this.height
      }), this.reverse = !1, this.fishes.push(new FISH(this)), this.createSurfacePoints()
    },
    watchWindowSize: function () {
      this.clearTimer(), this.tmpWidth = this.$window.width(), this.tmpHeight = this.$window.height(), this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL))
    },
    clearTimer: function () {
      for (; this.watchIds.length > 0;) clearTimeout(this.watchIds.pop())
    },
    jdugeToStopResize: function () {
      var t = this.$window.width(),
        i = this.$window.height(),
        e = t == this.tmpWidth && i == this.tmpHeight;
      this.tmpWidth = t, this.tmpHeight = i, e && this.setup()
    },
    bindEvent: function () {
      this.$window.on("resize", this.watchWindowSize), this.$container.on("mouseenter", this.startEpicenter), this.$container.on("mousemove", this.moveEpicenter)
    },
    getAxis: function (t) {
      var i = this.$container.offset();
      return {
        x: t.clientX - i.left + this.$window.scrollLeft(),
        y: t.clientY - i.top + this.$window.scrollTop()
      }
    },
    startEpicenter: function (t) {
      this.axis = this.getAxis(t)
    },
    moveEpicenter: function (t) {
      var i = this.getAxis(t);
      this.axis || (this.axis = i), this.generateEpicenter(i.x, i.y, i.y - this.axis.y), this.axis = i
    },
    generateEpicenter: function (t, i, e) {
      if (!(i < this.height / 2 - this.THRESHOLD || i > this.height / 2 + this.THRESHOLD)) {
        var h = Math.round(t / this.pointInterval);
        h < 0 || h >= this.points.length || this.points[h].interfere(i, e)
      }
    },
    reverseVertical: function () {
      this.reverse = !this.reverse;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].reverseVertical()
    },
    controlStatus: function () {
      for (var t = 0, i = this.points.length; t < i; t++) this.points[t].updateSelf();
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].updateNeighbors();
      this.fishes.length < this.fishCount && 0 == --this.intervalCount && (this.intervalCount = this.MAX_INTERVAL_COUNT, this.fishes.push(new FISH(this)))
    },
    render: function () {
      requestAnimationFrame(this.render), this.controlStatus(), this.context.clearRect(0, 0, this.width, this.height), this.context.fillStyle = this.FISH_COLOR;
      for (var t = 0, i = this.fishes.length; t < i; t++) this.fishes[t].render(this.context);
      this.context.save(), this.context.globalCompositeOperation = "xor", this.context.beginPath(), this.context.moveTo(0, this.reverse ? 0 : this.height);
      for (t = 0, i = this.points.length; t < i; t++) this.points[t].render(this.context);
      this.context.lineTo(this.width, this.reverse ? 0 : this.height), this.context.closePath(), this.context.fill(), this.context.restore()
    }
  },
  SURFACE_POINT = function (t, i) {
    this.renderer = t, this.x = i, this.init()
  };
  SURFACE_POINT.prototype = {
    SPRING_CONSTANT: .03,
    SPRING_FRICTION: .9,
    WAVE_SPREAD: .3,
    ACCELARATION_RATE: .01,
    init: function () {
      this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE, this.height = this.initHeight, this.fy = 0, this.force = {
        previous: 0,
        next: 0
      }
    },
    setPreviousPoint: function (t) {
      this.previous = t
    },
    setNextPoint: function (t) {
      this.next = t
    },
    interfere: function (t, i) {
      this.fy = this.renderer.height * this.ACCELARATION_RATE * (this.renderer.height - this.height - t >= 0 ? -1 : 1) * Math.abs(i)
    },
    updateSelf: function () {
      this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height), this.fy *= this.SPRING_FRICTION, this.height += this.fy
    },
    updateNeighbors: function () {
      this.previous && (this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height)), this.next && (this.force.next = this.WAVE_SPREAD * (this.height - this.next.height))
    },
    render: function (t) {
      this.previous && (this.previous.height += this.force.previous, this.previous.fy += this.force.previous), this.next && (this.next.height += this.force.next, this.next.fy += this.force.next), t.lineTo(this.x, this.renderer.height - this.height)
    }
  };
  var FISH = function (t) {
    this.renderer = t, this.init()
  };
  FISH.prototype = {
    GRAVITY: .4,
    init: function () {
      this.direction = Math.random() < .5, this.x = this.direction ? this.renderer.width + this.renderer.THRESHOLD : -this.renderer.THRESHOLD, this.previousY = this.y, this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1), this.renderer.reverse ? (this.y = this.getRandomValue(1 * this.renderer.height / 10, 4 * this.renderer.height / 10), this.vy = this.getRandomValue(2, 5), this.ay = this.getRandomValue(.05, .2)) : (this.y = this.getRandomValue(6 * this.renderer.height / 10, 9 * this.renderer.height / 10), this.vy = this.getRandomValue(-5, -2), this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1, this.theta = 0, this.phi = 0
    },
    getRandomValue: function (t, i) {
      return t + (i - t) * Math.random()
    },
    reverseVertical: function () {
      this.isOut = !this.isOut, this.ay *= -1
    },
    controlStatus: function (t) {
      this.previousY = this.y, this.x += this.vx, this.y += this.vy, this.vy += this.ay, this.renderer.reverse ? this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy -= this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(.05, .2)), this.isOut = !1) : this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE ? (this.vy += this.GRAVITY, this.isOut = !0) : (this.isOut && (this.ay = this.getRandomValue(-.2, -.05)), this.isOut = !1), this.isOut || (this.theta += Math.PI / 20, this.theta %= 2 * Math.PI, this.phi += Math.PI / 30, this.phi %= 2 * Math.PI), this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY), (this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD) && this.init()
    },
    render: function (t) {
      t.save(), t.translate(this.x, this.y), t.rotate(Math.PI + Math.atan2(this.vy, this.vx)), t.scale(1, this.direction ? 1 : -1), t.beginPath(), t.moveTo(-30, 0), t.bezierCurveTo(-20, 15, 15, 10, 40, 0), t.bezierCurveTo(15, -10, -20, -15, -30, 0), t.fill(), t.save(), t.translate(40, 0), t.scale(.9 + .2 * Math.sin(this.theta), 1), t.beginPath(), t.moveTo(0, 0), t.quadraticCurveTo(5, 10, 20, 8), t.quadraticCurveTo(12, 5, 10, 0), t.quadraticCurveTo(12, -5, 20, -8), t.quadraticCurveTo(5, -10, 0, 0), t.fill(), t.restore(), t.save(), t.translate(-3, 0), t.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)), t.beginPath(), this.renderer.reverse ? (t.moveTo(5, 0), t.bezierCurveTo(10, 10, 10, 30, 0, 40), t.bezierCurveTo(-12, 25, -8, 10, 0, 0)) : (t.moveTo(-5, 0), t.bezierCurveTo(-10, -10, -10, -30, 0, -40), t.bezierCurveTo(12, -25, 8, -10, 0, 0)), t.closePath(), t.fill(), t.restore(), t.restore(), this.controlStatus(t)
    }
  }, $(function () {
    RENDERER.init()
    $('.dark').click(function () {
      setTimeout(() => {
        RENDERER.setFishColor();
        RENDERER.context.fill();
      });
    })
  });
</script>
  
  <div class="footer bg-color">
    <div class="footer-main">
      
        
          <div class="link">
            
          </div>
        
      
        
          <div class="footer-copyright">
            <p>Copyright © 2019 - 2020 <a target="_blank" rel="noopener" href="https://github.com/yuang01">yuang01</a> | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/yuang01/theme">Bamboo</a> </p>

          </div>
        
      
        
          
            <!-- 不蒜子统计 -->
            <!-- 不蒜子统计 -->
<span id="busuanzi_container_site_pv">
      <i class="fas fa-eye" aria-hidden="true"></i>本站总访问量：<span id="busuanzi_value_site_pv"></span> 次
</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv" style='display:none'>
      <i class="fas fa-users" aria-hidden="true"></i>本站访客数：<span id="busuanzi_value_site_uv"></span> 人
</span>

          
        
      
        
          <div class="footer-custom">
            
          </div>
        
      
    </div>
  </div>



    <!-- 渲染暗黑按钮 -->
    
      <div class="dark">
  <div class="dark-content">
    <i class="fas fa-moon" aria-hidden="true"></i>
    <!-- <span>关灯</span> -->
  </div>
  
</div>

<script>
  $(function() {
    let isDark = JSON.parse(localStorage.getItem('dark'))  || JSON.parse('false');
    if (isDark) {
      $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
    }
    $('.dark').click(function() {
      if ($(document.body).is('.darkModel')) {
        $(document.body).removeClass('darkModel');
        localStorage.setItem('dark', false);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-moon" aria-hidden="true"></i>
          </div>
          `
        );
      } else {
        $(document.body).addClass('darkModel');
        localStorage.setItem('dark', true);
        $(".dark-content").replaceWith(
          `
          <div class='dark-content'>
            <i class="fas fa-lightbulb" aria-hidden="true"></i>
          </div>
          `
        );
      }
    })
  })
</script>
    
    <!-- 渲染回到顶部按钮 -->
    
      <div class="goTop top-btn-color" pointer>
  <i class="fas fa-arrow-up" aria-hidden="true"></i>
</div>
<script src="/js/goTop.js"></script>

    
    <!-- 渲染左下角音乐播放器 -->
    

    <!-- 图片放大 -->
    
      <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js"></script>
    

    <!-- 百度解析 -->
    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <!-- 背景彩带 -->
    
      <script type="text/javascript" size="100" alpha='0.4' zIndex="-1" src="/js/ribbon.min.js"></script>
    

    <script src="/js/utils/index.js"></script>
    <script src="/js/app.js"></script>
    
    <!-- 文章目录所需js -->
<!-- <link href="/js/tocbot/tocbot.css" rel="stylesheet">
<script src="/js/tocbot/tocbot.min.js"></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">

<script>
  var headerEl = 'h2, h3, h4',  //headers 
    content = '.post-detail',//文章容器
    idArr = {};  //标题数组以确定是否增加索引id
  //add #id
  var option = {
    // Where to render the table of contents.
    tocSelector: '.toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: content,
    // Which headings to grab inside of the contentSelector element.
    headingSelector: headerEl,
    scrollSmooth: true,
    scrollSmoothOffset: -70,
    // headingsOffset: -($(window).height() * 0.4 - 45),
    headingsOffset: -($(window).height() * 0.4 - 70),
    // positionFixedSelector: '.toc-main',
    // positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    activeLinkClass: 'is-active-link',
    orderedList: true,
    collapseDepth: 20,
    // onClick: function (e) {},
  }
  if ($('.toc').length > 0) {

    $(content).children(headerEl).each(function () {
      //去除空格以及多余标点
      var headerId = $(this).text().replace(/[\s|\~|`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\_|\+|\=|\||\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\<|\.|\>|\/|\?|\：|\，|\。]/g, '');

      headerId = headerId.toLowerCase();
      if (idArr[headerId]) {
        //id已经存在
        $(this).attr('id', headerId + '-' + idArr[headerId]);
        idArr[headerId]++;
      }
      else {
        //id未存在
        idArr[headerId] = 1;
        $(this).attr('id', headerId);
      }
    });

    document.addEventListener("DOMContentLoaded", function () {
      tocbot.init(option);
      mobileTocClick();
    });

  }

  window.tocScrollFn = function () {
    return bamboo.throttle(function () {
      findHeadPosition();
    }, 100)()
  }
  window.addEventListener('scroll', tocScrollFn);

  const findHeadPosition = function (top) {
    if ($('.toc-list').length <= 0) {
      return false;
    }
    setTimeout(() => {  // or DOMContentLoaded 
      autoScrollToc();
    }, 0);
  }

  const autoScrollToc = function () {
    const $activeItem = document.querySelector('.is-active-link');
    const $cardToc = document.querySelector('.toc-content');
    const activePosition = $activeItem.getBoundingClientRect().top
    const sidebarScrollTop = $cardToc.scrollTop
    if (activePosition > (document.documentElement.clientHeight - 100)) {
      $cardToc.scrollTop = sidebarScrollTop + 150
    }
    if (activePosition < 150) {
      $cardToc.scrollTop = sidebarScrollTop - 150
    }
  }

  document.addEventListener('pjax:send', function () {
    if ($('.toc').length) {
      tocbot.destroy();
    }
  });

  document.addEventListener('pjax:complete', function () {
    if ($('.toc').length) {
      tocbot.init(option);
      mobileTocClick();
    }
  });
  
  // 手机端toc按钮点击出现目录
  const mobileTocClick = function () {
    const $cardTocLayout = document.getElementsByClassName('side_toc')[0];
    const $cardToc = $cardTocLayout.getElementsByClassName('toc-content')[0];
    let right = '45px';
    if (window.innerWidth >= 551 && window.innerWidth <= 992) {
      right = '100px'
    }
    const mobileToc = {
      open: () => {
        $cardTocLayout.style.cssText = 'animation: toc-open .3s; opacity: 1; right: ' + right
      },

      close: () => {
        $cardTocLayout.style.animation = 'toc-close .2s'
        setTimeout(() => {
          $cardTocLayout.style.cssText = "opacity:''; animation: ''; right: ''"
        }, 100)
      }
    }
    document.getElementById('toc-mobile-btn').addEventListener('click', () => {
      if (window.getComputedStyle($cardTocLayout).getPropertyValue('opacity') === '0') mobileToc.open()
      else mobileToc.close()
    })

    $cardToc.addEventListener('click', (e) => {
      if (window.innerWidth < 992) { // 小于992px的时候
        mobileToc.close()
      }
    })
  }
</script>

<style>
  /* .is-position-fixed {
    position: sticky !important;
    top: 74px;
  }

  .toc-main ul {
    counter-reset: show-list;
  }

  .toc-main ul li::before {
    content: counter(item)".";
    display: block;
    position: absolute;
    left: 12px;
    top: 0;
  } */
</style>
 

<!-- 设置导航背景 -->
<script>
  let setHeaderClass = () => {
    const nav = $('#navHeader');
    const navTop = nav.outerHeight();
    const winTop = $(window).scrollTop();
    if(winTop > navTop) {
      nav.addClass('header-bg-color');
    }
    else {
      nav.removeClass('header-bg-color');
    }
  };

  let scrollCollect = () => {
    return bamboo.throttle(function (e) {
      setHeaderClass();
    }, 200)()
  }

  let initHeaderBg = () => {
    setHeaderClass();
  }

  setHeaderClass();
  window.addEventListener('scroll', scrollCollect);

  document.addEventListener('pjax:send', function () {
    window.removeEventListener('scroll', scrollCollect)
  })
  document.addEventListener('pjax:complete', function () {
    window.addEventListener('scroll', scrollCollect);
    setHeaderClass();
  })
</script> 

<!-- 渲染issues标签里的内容 -->
<script>
  function loadIssuesJS() {
    if ($(".post-detail").find(".issues-api").length == 0) {
      return;
    } 
    loadScript('/js/issues/index.js');
  };
  $(function () {
    loadIssuesJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof IssuesAPI == "undefined") {
      loadIssuesJS();
    }
  })
</script>

<!-- 渲染远程json加载的图片标签(getPhotoOnline)里的内容 -->
<script>
  function loadPhotoOnlineJS() {
    if ($(".post-detail").find(".getJsonPhoto-api").length == 0) {
      return;
    } 
    loadScript('/js/getPhotoOnline/index.js');
  };
  $(function () {
    loadPhotoOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getPhotoJson == "undefined") {
      loadPhotoOnlineJS();
    }
  })
</script>

<!-- 渲染远程json加载的site-card标签(getSiteOnline)里的内容 -->
<script>
  function loadSiteOnlineJS() {
    if ($(".post-detail").find(".getJsonSite-api").length == 0) {
      return;
    } 
    loadScript('/js/getSiteOnline/index.js');
  };
  $(function () {
    loadSiteOnlineJS();
  });
  document.addEventListener('pjax:complete', function () {
    if (typeof getSiteJson == "undefined") {
      loadSiteOnlineJS();
    }
  })
</script>

<!-- 输入框打字特效 -->
<!-- 输入框打字特效 -->

  <script src="/js/activate-power-mode.js"></script>
  <script>
    POWERMODE.colorful = true;  // 打开随机颜色特效
    POWERMODE.shake = false;    // 关闭输入框抖动
    document.body.addEventListener('input', POWERMODE);//监听打字事件
  </script>


<!-- markdown代码一键复制功能 -->

  <link rel="stylesheet" href="https://unpkg.com/v-plugs-ayu/lib/ayu.css">
  <script src="https://unpkg.com/v-plugs-ayu/lib/ayu.umd.min.js"></script>
  <script src="/js/clipboard/clipboard.min.js"></script>
  <div id="appCopy">
  </div>
  <script data-pjax>
    var vm = new Vue({
      el: '#appCopy',
      data: {
      },
      computed: {
      },
      mounted() {
        const that = this;
        var copy = '复制';
        /* code */
        var initCopyCode = function () {
          var copyHtml = '';
          copyHtml += '<button class="btn-copy" data-clipboard-snippet="" style="position:absolute;top:0;right:0;z-index:1;">';
          copyHtml += '<i class="fas fa-copy"></i><span>' + copy + '</span>';
          copyHtml += '</button>';
          $(".post-detail pre").not('.gutter pre').wrap("<div class='codeBox' style='position:relative;width:100%;'></div>")
          $(".post-detail pre").not('.gutter pre').before(copyHtml);
          new ClipboardJS('.btn-copy', {
            target: function (trigger) {
              return trigger.nextElementSibling;
            }
          });
        }
        initCopyCode();
        $('.btn-copy').unbind('click').bind('click', function () {
          doSomething();
        })
        $(document).unbind('keypress').bind('keypress', function (e) {
          if (e.ctrlKey && e.keyCode == 67) {
            doSomething();
          }
        })

        function doSomething() {
          that.$notify({
            title: "成功",
            content: "代码已复制，请遵守相关授权协议。",
            type: 'success'
          })
        }
      },
      methods: {
      },
      created() { }
    })
  </script>
  

<!-- 图片懒加载 -->
<script defer src="https://unpkg.com/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>


<!-- 卡片滚动动画 -->
   

<!-- 评论所需js -->

  
    <script type="text/javascript">
  var utteranceCommon = {};

  function check_utterance() {
    let isDark = JSON.parse(localStorage.getItem('dark')) || JSON.parse('false');
    if (isDark) {
      utteranceCommon.Theme = 'github-dark';
    } else {
      utteranceCommon.Theme = 'github-light';
    }

    return document.getElementById("gitment-container");
  }
  comment_el = '#gitment-container';
  load_utterance = function () {
    if ($(comment_el).length) {
      // 匿名函数，防止污染全局变量
      const HEAD = check_utterance();

      var utterances = document.createElement('script');
      utterances.type = 'text/javascript';
      utterances.async = true;
      utterances.setAttribute('issue-term', 'pathname')
      utterances.setAttribute('theme', utteranceCommon.Theme)
      utterances.setAttribute('repo', '')
      utterances.crossorigin = 'anonymous';
      utterances.src = 'https://utteranc.es/client.js';
      // content 是要插入评论的地方
      document.getElementById('gitment-container').appendChild(utterances);

    }
  }

  function dark_utterance() {
    const HEAD = check_utterance();
    if (!HEAD) return;
    const message = {
      type: 'set-theme',
      theme: utteranceCommon.Theme
    };
    const utteranceIframe = document.querySelector('iframe');
    utteranceIframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }

  $(document).ready(load_utterance);
  document.addEventListener('pjax:complete', function () {
    load_utterance();
  });

  $('.dark').click(function () {
    setTimeout(() => {
      dark_utterance();
    });
  })

</script>

<style>
  .utterances {
    max-width: inherit !important;
  }
</style>
  


<!-- 鼠标点击特效 -->
<!-- 爱心点击 -->

  
    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 999; pointer-events: none;" ></canvas>
    <script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script src="/js/cursor/explosion.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" data-pjax></script>


<!-- 轮播图标签 -->
<script>
  var bambooSwiperTag = {};
  function load_swiper() {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    loadCSS("https://unpkg.com/swiper@6/swiper-bundle.min.css")
    loadScript("https://unpkg.com/swiper@6/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    bambooSwiperTag.swiper = new Swiper('.post-swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      autoplay: true ? {
        delay: 3000,
        stopOnLastSlide: false,
        disableOnInteraction: false,
      } : false,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
      on:{
        init: function(){
          swiperAnimateCache(this); //隐藏动画元素 
          swiperAnimate(this); //初始化完成开始动画
        }, 
        slideChangeTransitionEnd: function(){ 
          swiperAnimate(this); //每个slide切换结束时也运行当前slide动画
          //this.slides.eq(this.activeIndex).find('.ani').removeClass('ani'); 动画只展现一次，去除ani类名
        } 
      }
    });
  }

  document.addEventListener('pjax:complete', function () {
    if (!document.querySelectorAll(".post-swiper-container")[0]) return;
    if (typeof bambooSwiperTag.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>
    <!-- pjax -->
    

<!-- pjax -->


  <script src="/js/pjax@0.2.8/index.js"></script>
  
    <!-- 样式位于：source/css/_third-party/pjaxanimate.styl -->

<div class="pjax-animate">
  
    <div class="loading-circle"><div id="loader-circle"></div></div>
    <script>
      window.ShowLoading = function() {
        $(".loading-circle").css("display", "block");
      };
      window.HideLoading = function() {
        $(".loading-circle").css("display", "none");
      }
    </script>
  
	<script>
    document.addEventListener('pjax:complete', function () {
      window.HideLoading();
    })
    document.addEventListener('pjax:send', function () {
      window.ShowLoading();
    })
    document.addEventListener('pjax:error', function () {
      window.HideLoading();
    })
	</script>
</div>

  

  <script>
    var pjax = new Pjax({
      elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([no-pjax])',   // 拦截正常带链接的 a 标签
      selectors: ["#pjax-container","title"],                                   // 根据实际需要确认重载区域
      cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
      timeout: 5000
    });

    document.addEventListener('pjax:send', function (e) {

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');

    })
    
    document.addEventListener('pjax:complete', function () {
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
    });

    document.addEventListener('pjax:error', function (e) {
      window.location.href = e.triggerElement.href;
    })
    
    // 刷新不从顶部开始
    document.addEventListener("DOMContentLoaded", function () {
      history.scrollRestoration = 'auto';
    })
  </script>



  </body>
</html>